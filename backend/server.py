from fastapi import FastAPI, APIRouter, HTTPException, Depends, status, Body, UploadFile, File
from fastapi.responses import Response, StreamingResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
import asyncio
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import uuid
from datetime import datetime, timezone, timedelta, date
import jwt
import json
import hashlib
import re
import bcrypt
import time
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER, TA_LEFT
import base64
from io import BytesIO as IOBytesIO
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment
from io import BytesIO
import base64
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
import resend
import firebase_admin
from firebase_admin import credentials, messaging
import qrcode
from pwa_manifest import pwa_router
from io import BytesIO
import base64

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection avec configuration SSL pour production
mongo_url = os.environ['MONGO_URL']

# Configuration SSL/TLS pour MongoDB Atlas et production
# tlsAllowInvalidCertificates=true peut Ãªtre nÃ©cessaire pour certains environnements
if 'mongodb+srv' in mongo_url or 'ssl=true' in mongo_url.lower():
    # Pour MongoDB Atlas, s'assurer que les paramÃ¨tres SSL sont corrects
    if '?' in mongo_url:
        # Ajouter/forcer les paramÃ¨tres SSL si nÃ©cessaire
        if 'ssl=' not in mongo_url.lower() and 'tls=' not in mongo_url.lower():
            mongo_url += '&tls=true&tlsAllowInvalidCertificates=false'
    else:
        mongo_url += '?tls=true&tlsAllowInvalidCertificates=false'

client = AsyncIOMotorClient(
    mongo_url,
    serverSelectionTimeoutMS=30000,  # 30 secondes pour sÃ©lection serveur (distance Oregon-Virginie)
    connectTimeoutMS=30000,          # 30 secondes pour connexion initiale
    socketTimeoutMS=60000,           # 60 secondes pour opÃ©rations (documents avec photos base64)
    maxPoolSize=50,                  # Pool de connexions pour rÃ©utilisation
    minPoolSize=10,                  # Connexions permanentes
    maxIdleTimeMS=45000,             # Garder connexions inactives 45s
    retryWrites=True,                # Retry automatique en cas d'Ã©chec
    retryReads=True                  # Retry automatique en lecture
)

# Extraire le nom de la base de donnÃ©es depuis MONGO_URL ou utiliser un dÃ©faut
db_name = os.environ.get('DB_NAME', 'profiremanager')
db = client[db_name]

# Create the main app without a prefix
app = FastAPI(title="ProFireManager API", version="2.0")

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")

# ==================== FIREBASE INITIALIZATION ====================

# Initialiser Firebase Admin
firebase_cred_path = ROOT_DIR / 'firebase-credentials.json'
if firebase_cred_path.exists():
    try:
        cred = credentials.Certificate(str(firebase_cred_path))
        firebase_admin.initialize_app(cred)
        print("âœ… Firebase Admin SDK initialized successfully")
    except Exception as e:
        print(f"âš ï¸ Firebase initialization error: {e}")
else:
    print("âš ï¸ Firebase credentials file not found - Push notifications will not work")

# ==================== INITIALIZATION ====================

async def create_database_indexes():
    """CrÃ©er les index MongoDB pour optimiser les performances"""
    try:
        # Index pour les tenants (CRITIQUE - appelÃ© Ã  chaque requÃªte)
        await db.tenants.create_index([("slug", 1)])
        await db.tenants.create_index([("slug", 1), ("actif", 1)])
        
        # Index pour les notifications (CRITIQUE pour la performance)
        await db.notifications.create_index([
            ("tenant_id", 1),
            ("destinataire_id", 1),
            ("statut", 1)
        ])
        await db.notifications.create_index([("date_creation", -1)])
        
        # Index pour les utilisateurs (CRITIQUE - chargement dashboard)
        await db.users.create_index([("tenant_id", 1)])
        await db.users.create_index([("tenant_id", 1), ("email", 1)])
        await db.users.create_index([("tenant_id", 1), ("statut", 1)])
        
        # Index pour les types de garde (chargement dashboard)
        await db.types_garde.create_index([("tenant_id", 1)])
        
        # Index pour les assignations (planning)
        await db.assignations.create_index([("tenant_id", 1), ("user_id", 1)])
        await db.assignations.create_index([("tenant_id", 1), ("semaine_debut", 1)])
        await db.assignations.create_index([("semaine_debut", 1)])
        
        # Index pour le planning
        await db.planning.create_index([("tenant_id", 1), ("semaine_debut", 1)])
        
        # Index pour les disponibilitÃ©s
        await db.disponibilites.create_index([("tenant_id", 1), ("user_id", 1)])
        await db.disponibilites.create_index([("tenant_id", 1), ("date", 1)])
        
        # Index pour les bÃ¢timents (prÃ©vention)
        await db.batiments.create_index([("tenant_id", 1)])
        await db.batiments.create_index([("tenant_id", 1), ("niveau_risque", 1)])
        
        # Index pour les formations
        await db.formations.create_index([("tenant_id", 1)])
        
        # Index pour prÃ©vention - prÃ©ventionnistes
        await db.batiments.create_index([("tenant_id", 1), ("preventionniste_assigne_id", 1)])
        await db.secteurs_geographiques.create_index([("tenant_id", 1), ("preventionniste_assigne_id", 1)])
        await db.inspections.create_index([("tenant_id", 1), ("preventionniste_id", 1)])
        await db.inspections.create_index([("tenant_id", 1), ("date_inspection", 1)])
        await db.plans_intervention.create_index([("tenant_id", 1), ("created_by", 1)])
        
        # Index pour rapports externes - budgets
        await db.budgets.create_index([("tenant_id", 1), ("annee", 1)])
        await db.immobilisations.create_index([("tenant_id", 1)])
        await db.immobilisations.create_index([("tenant_id", 1), ("type", 1)])
        
        # Index pour dashboard - CRITIQUE pour performance
        await db.assignations.create_index([("tenant_id", 1), ("user_id", 1), ("date", 1)])
        await db.inscriptions_formations.create_index([("tenant_id", 1), ("user_id", 1)])
        await db.inscriptions_formations.create_index([("formation_id", 1)])
        await db.formations.create_index([("tenant_id", 1), ("date_debut", 1)])
        await db.activites.create_index([("tenant_id", 1), ("created_at", -1)])
        await db.activites.create_index([("tenant_id", 1), ("user_id", 1)])
        await db.activites.create_index([("tenant_id", 1), ("type_activite", 1)])
        
        print("âœ… Index MongoDB crÃ©Ã©s avec succÃ¨s (optimisations complÃ¨tes)")
    except Exception as e:
        print(f"âš ï¸ Erreur crÃ©ation index: {e}")

async def initialize_multi_tenant():
    """Initialize super admin and default tenant on first run"""
    # CrÃ©er les index MongoDB pour les performances
    await create_database_indexes()
    
    # 1. CrÃ©er le super admin s'il n'existe pas
    super_admin_exists = await db.super_admins.find_one({"email": SUPER_ADMIN_EMAIL})
    
    if not super_admin_exists:
        super_admin = SuperAdmin(
            email=SUPER_ADMIN_EMAIL,
            nom="Super Admin",
            mot_de_passe_hash=get_password_hash("230685Juin+")
        )
        await db.super_admins.insert_one(super_admin.dict())
        print(f"âœ… Super admin crÃ©Ã©: {SUPER_ADMIN_EMAIL}")
    
    # 2. CrÃ©er le tenant Shefford s'il n'existe pas
    shefford_exists = await db.tenants.find_one({"slug": "shefford"})
    
    if not shefford_exists:
        shefford_tenant = Tenant(
            slug="shefford",
            nom="Service Incendie de Shefford",
            ville="Shefford",
            province="QC"
        )
        await db.tenants.insert_one(shefford_tenant.dict())
        print(f"âœ… Tenant Shefford crÃ©Ã©: {shefford_tenant.id}")
        
        # 3. Migrer toutes les donnÃ©es existantes vers Shefford
        # Ajouter tenant_id aux collections qui n'en ont pas
        collections_to_migrate = [
            "users", "types_garde", "assignations", "demandes_remplacement",
            "formations", "disponibilites", "sessions_formation", 
            "inscriptions_formation", "demandes_conge", "notifications",
            "notifications_remplacement", "employee_epis", "parametres_remplacements"
        ]
        
        for collection_name in collections_to_migrate:
            collection = db[collection_name]
            # Mise Ã  jour des documents sans tenant_id
            result = await collection.update_many(
                {"tenant_id": {"$exists": False}},
                {"$set": {"tenant_id": shefford_tenant.id}}
            )
            if result.modified_count > 0:
                print(f"âœ… {result.modified_count} documents migrÃ©s dans {collection_name}")

async def initialize_default_grades():
    """Initialise les grades par dÃ©faut pour chaque tenant s'ils n'existent pas"""
    try:
        tenants = await db.tenants.find({}).to_list(1000)
        
        default_grades = [
            {"nom": "Pompier", "niveau_hierarchique": 1},
            {"nom": "Lieutenant", "niveau_hierarchique": 2},
            {"nom": "Capitaine", "niveau_hierarchique": 3},
            {"nom": "Directeur", "niveau_hierarchique": 4}
        ]
        
        for tenant in tenants:
            tenant_id = tenant.get('id')
            if not tenant_id:
                continue
            
            # VÃ©rifier si des grades existent dÃ©jÃ  pour ce tenant
            existing_count = await db.grades.count_documents({"tenant_id": tenant_id})
            
            if existing_count == 0:
                # CrÃ©er les grades par dÃ©faut
                for grade_data in default_grades:
                    grade = Grade(
                        tenant_id=tenant_id,
                        nom=grade_data["nom"],
                        niveau_hierarchique=grade_data["niveau_hierarchique"]
                    )
                    grade_dict = grade.dict()
                    grade_dict["created_at"] = grade.created_at.isoformat()
                    grade_dict["updated_at"] = grade.updated_at.isoformat()
                    await db.grades.insert_one(grade_dict)
                
                print(f"âœ… {len(default_grades)} grades par dÃ©faut crÃ©Ã©s pour le tenant {tenant.get('nom', tenant_id)}")
    except Exception as e:
        print(f"âš ï¸ Erreur lors de l'initialisation des grades: {str(e)}")

@app.on_event("startup")
async def startup_event():
    """Ã‰vÃ©nement de dÃ©marrage de l'application"""
    await initialize_multi_tenant()
    
    # Initialiser les grades par dÃ©faut
    await initialize_default_grades()
    
    # DÃ©marrer le job pÃ©riodique pour vÃ©rifier les timeouts de remplacement
    asyncio.create_task(job_verifier_timeouts_remplacements())
    
    # DÃ©marrer le nettoyage pÃ©riodique des tÃ¢ches SSE expirÃ©es
    asyncio.create_task(cleanup_expired_tasks())

# ==================== SYSTÃˆME DE PROGRESSION TEMPS RÃ‰EL ====================
# Dictionnaire global pour stocker les progressions des attributions auto
attribution_progress_store: Dict[str, Dict[str, Any]] = {}

class AttributionProgress:
    """Classe pour gÃ©rer la progression d'une attribution automatique"""
    
    def __init__(self, task_id: str):
        self.task_id = task_id
        self.start_time = time.time()
        self.current_step = ""
        self.progress_percentage = 0
        self.total_gardes = 0
        self.gardes_traitees = 0
        self.assignations_creees = 0
        self.status = "en_cours"  # en_cours, termine, erreur
        self.error_message = None
        self.expires_at = time.time() + 3600  # Expire aprÃ¨s 1 heure
        
    def update(self, step: str, progress: int, gardes_traitees: int = 0, assignations: int = 0):
        """Met Ã  jour la progression"""
        self.current_step = step
        self.progress_percentage = min(progress, 100)
        self.gardes_traitees = gardes_traitees
        if assignations > 0:
            self.assignations_creees = assignations
        attribution_progress_store[self.task_id] = self.to_dict()
    
    def complete(self, assignations_totales: int):
        """Marque la tÃ¢che comme terminÃ©e"""
        self.status = "termine"
        self.progress_percentage = 100
        self.assignations_creees = assignations_totales
        elapsed_time = time.time() - self.start_time
        self.current_step = f"âœ… TerminÃ© en {elapsed_time:.1f}s - {assignations_totales} assignations crÃ©Ã©es"
        attribution_progress_store[self.task_id] = self.to_dict()
    
    def error(self, message: str):
        """Marque la tÃ¢che en erreur"""
        self.status = "erreur"
        self.error_message = message
        self.current_step = f"âŒ Erreur: {message}"
        attribution_progress_store[self.task_id] = self.to_dict()
    
    def to_dict(self):
        """Convertit en dictionnaire pour JSON"""
        elapsed = time.time() - self.start_time
        return {
            "task_id": self.task_id,
            "status": self.status,
            "current_step": self.current_step,
            "progress_percentage": self.progress_percentage,
            "total_gardes": self.total_gardes,
            "gardes_traitees": self.gardes_traitees,
            "assignations_creees": self.assignations_creees,
            "elapsed_time": f"{elapsed:.1f}s",
            "error_message": self.error_message
        }

async def progress_event_generator(task_id: str):
    """GÃ©nÃ©rateur SSE pour streamer les mises Ã  jour de progression"""
    try:
        # Attendre que la tÃ¢che soit crÃ©Ã©e
        for _ in range(50):  # Attendre max 5 secondes
            if task_id in attribution_progress_store:
                break
            await asyncio.sleep(0.1)
        
        # Streamer les mises Ã  jour
        last_data = None
        while True:
            if task_id in attribution_progress_store:
                current_data = attribution_progress_store[task_id]
                
                # Envoyer seulement si les donnÃ©es ont changÃ©
                if current_data != last_data:
                    yield f"data: {json.dumps(current_data)}\n\n"
                    last_data = current_data.copy()
                
                # Si terminÃ© ou en erreur, arrÃªter le stream
                if current_data.get("status") in ["termine", "erreur"]:
                    break
            
            await asyncio.sleep(0.5)  # Mise Ã  jour toutes les 500ms
            
    except asyncio.CancelledError:
        pass

async def cleanup_expired_tasks():
    """Nettoie pÃ©riodiquement les tÃ¢ches expirÃ©es du store"""
    while True:
        try:
            current_time = time.time()
            expired_keys = []
            
            for task_id, data in list(attribution_progress_store.items()):
                # Supprimer les tÃ¢ches terminÃ©es depuis plus de 5 minutes
                if data.get("status") in ["termine", "erreur"]:
                    # VÃ©rifier si la tÃ¢che est vieille de plus de 5 minutes
                    if "elapsed_time" in data:
                        try:
                            elapsed_seconds = float(data["elapsed_time"].replace("s", ""))
                            task_age = current_time - (data.get("start_time", current_time) - elapsed_seconds)
                            if task_age > 300:  # 5 minutes
                                expired_keys.append(task_id)
                        except:
                            pass
            
            # Supprimer les tÃ¢ches expirÃ©es
            for key in expired_keys:
                del attribution_progress_store[key]
            
            if expired_keys:
                logging.info(f"ğŸ§¹ Nettoyage: {len(expired_keys)} tÃ¢ches expirÃ©es supprimÃ©es")
            
        except Exception as e:
            logging.error(f"Erreur nettoyage tÃ¢ches: {e}")
        
        await asyncio.sleep(300)  # Nettoyer toutes les 5 minutes
    
    # DÃ©marrer le scheduler APScheduler pour les notifications automatiques
    asyncio.create_task(start_notification_scheduler())
    
    print("ğŸš€ ProFireManager API Multi-Tenant dÃ©marrÃ©")

# ==================== SCHEDULER NOTIFICATIONS AUTOMATIQUES ====================

async def start_notification_scheduler():
    """DÃ©marre le scheduler pour les notifications automatiques de planning"""
    scheduler = AsyncIOScheduler()
    
    # CrÃ©er un job qui vÃ©rifie toutes les heures si une notification doit Ãªtre envoyÃ©e
    # On vÃ©rifie Ã  chaque heure au lieu de programmer des jobs dynamiques
    scheduler.add_job(
        job_verifier_notifications_planning,
        CronTrigger(minute=0),  # Toutes les heures Ã  la minute 0
        id='check_planning_notifications',
        replace_existing=True
    )
    
    scheduler.start()
    logging.info("âœ… Scheduler de notifications automatiques dÃ©marrÃ©")

async def job_verifier_notifications_planning():
    """
    Job qui vÃ©rifie si des notifications de planning doivent Ãªtre envoyÃ©es
    S'exÃ©cute toutes les heures
    """
    try:
        now = datetime.now(timezone.utc)
        current_hour = now.hour
        current_day = now.day
        
        logging.info(f"ğŸ” VÃ©rification des notifications planning - Jour {current_day}, Heure {current_hour}h")
        
        # RÃ©cupÃ©rer tous les tenants
        tenants = await db.tenants.find().to_list(None)
        
        for tenant in tenants:
            try:
                # RÃ©cupÃ©rer les paramÃ¨tres de notification de ce tenant
                params = await db.parametres_validation_planning.find_one({"tenant_id": tenant["id"]})
                
                if not params:
                    continue
                
                # VÃ©rifier si notifications automatiques activÃ©es
                if not params.get("envoi_automatique", False):
                    continue
                
                # VÃ©rifier si c'est le bon jour
                jour_envoi = params.get("jour_envoi", 25)
                if current_day != jour_envoi:
                    continue
                
                # VÃ©rifier si c'est la bonne heure
                heure_envoi = params.get("heure_envoi", "17:00")
                heure_cible = int(heure_envoi.split(":")[0])
                
                if current_hour != heure_cible:
                    continue
                
                # VÃ©rifier si dÃ©jÃ  envoyÃ© aujourd'hui
                derniere_notif = params.get("derniere_notification")
                if derniere_notif:
                    derniere_date = datetime.fromisoformat(derniere_notif).date()
                    if derniere_date == now.date():
                        logging.info(f"â­ï¸ Notifications dÃ©jÃ  envoyÃ©es aujourd'hui pour {tenant['nom']}")
                        continue
                
                # C'est le moment d'envoyer !
                logging.info(f"ğŸ“§ Envoi des notifications automatiques pour {tenant['nom']}")
                
                # Calculer la pÃ©riode Ã  notifier
                periode_couverte = params.get("periode_couverte", "mois_suivant")
                
                if periode_couverte == "mois_suivant":
                    # Mois suivant
                    next_month = now + timedelta(days=30)
                    periode_debut = next_month.replace(day=1).strftime("%Y-%m-%d")
                    
                    # Dernier jour du mois suivant
                    if next_month.month == 12:
                        last_day = next_month.replace(year=next_month.year + 1, month=1, day=1) - timedelta(days=1)
                    else:
                        last_day = next_month.replace(month=next_month.month + 1, day=1) - timedelta(days=1)
                    periode_fin = last_day.strftime("%Y-%m-%d")
                else:
                    # Mois en cours
                    periode_debut = now.replace(day=1).strftime("%Y-%m-%d")
                    if now.month == 12:
                        last_day = now.replace(year=now.year + 1, month=1, day=1) - timedelta(days=1)
                    else:
                        last_day = now.replace(month=now.month + 1, day=1) - timedelta(days=1)
                    periode_fin = last_day.strftime("%Y-%m-%d")
                
                # Envoyer les notifications
                await envoyer_notifications_planning_automatique(
                    tenant=tenant,
                    periode_debut=periode_debut,
                    periode_fin=periode_fin
                )
                
                # Mettre Ã  jour la date de derniÃ¨re notification
                await db.parametres_validation_planning.update_one(
                    {"tenant_id": tenant["id"]},
                    {"$set": {"derniere_notification": now.isoformat()}}
                )
                
                logging.info(f"âœ… Notifications envoyÃ©es avec succÃ¨s pour {tenant['nom']}")
                
            except Exception as e:
                logging.error(f"âŒ Erreur envoi notifications pour {tenant.get('nom', 'Unknown')}: {str(e)}", exc_info=True)
        
    except Exception as e:
        logging.error(f"âŒ Erreur dans job_verifier_notifications_planning: {str(e)}", exc_info=True)

async def envoyer_notifications_planning_automatique(tenant: dict, periode_debut: str, periode_fin: str):
    """Envoie les notifications de planning (version automatique sans auth)"""
    try:
        # RÃ©cupÃ©rer les assignations de la pÃ©riode
        assignations = await db.assignations.find({
            "tenant_id": tenant["id"],
            "date": {
                "$gte": periode_debut,
                "$lte": periode_fin
            }
        }).to_list(None)
        
        if not assignations:
            logging.info(f"Aucune assignation trouvÃ©e pour {tenant['nom']} pÃ©riode {periode_debut} - {periode_fin}")
            return
        
        # Grouper par pompier
        gardes_par_pompier = {}
        for assignation in assignations:
            user_id = assignation["user_id"]
            if user_id not in gardes_par_pompier:
                gardes_par_pompier[user_id] = []
            gardes_par_pompier[user_id].append(assignation)
        
        # RÃ©cupÃ©rer infos users et types garde
        users = await db.users.find({"tenant_id": tenant["id"]}).to_list(None)
        types_garde = await db.types_garde.find({"tenant_id": tenant["id"]}).to_list(None)
        
        user_map = {u["id"]: u for u in users}
        type_garde_map = {t["id"]: t for t in types_garde}
        
        # Envoyer email Ã  chaque pompier
        emails_envoyes = 0
        for user_id, gardes in gardes_par_pompier.items():
            user = user_map.get(user_id)
            if not user or not user.get("email"):
                continue
            
            # PrÃ©parer liste des gardes avec dÃ©tails
            gardes_list = []
            for garde in gardes:
                type_g = type_garde_map.get(garde["type_garde_id"], {})
                
                # Trouver collÃ¨gues sur mÃªme garde
                collegues_meme_garde = [
                    a for a in assignations 
                    if a["date"] == garde["date"] 
                    and a["type_garde_id"] == garde["type_garde_id"]
                    and a["user_id"] != user_id
                ]
                
                collegues_noms = []
                for coll in collegues_meme_garde:
                    coll_user = user_map.get(coll["user_id"])
                    if coll_user:
                        collegues_noms.append(f"{coll_user.get('prenom', '')} {coll_user.get('nom', '')}")
                
                gardes_list.append({
                    "date": garde["date"],
                    "type_garde": type_g.get("nom", "Garde"),
                    "collegues": collegues_noms
                })
            
            # Trier par date
            gardes_list.sort(key=lambda x: x["date"])
            
            # Envoyer email
            try:
                send_gardes_notification_email(
                    user_email=user["email"],
                    user_name=f"{user.get('prenom', '')} {user.get('nom', '')}",
                    gardes_list=gardes_list,
                    tenant_slug=tenant["slug"],
                    periode=f"{periode_debut} au {periode_fin}"
                )
                emails_envoyes += 1
            except Exception as e:
                logging.error(f"Erreur envoi email Ã  {user.get('email')}: {str(e)}")
        
        logging.info(f"âœ… {emails_envoyes} emails envoyÃ©s pour {tenant['nom']}")
        
    except Exception as e:
        logging.error(f"Erreur dans envoyer_notifications_planning_automatique: {str(e)}", exc_info=True)
        raise

async def job_verifier_timeouts_remplacements():
    """
    Job pÃ©riodique qui vÃ©rifie les timeouts des demandes de remplacement
    S'exÃ©cute toutes les minutes
    """
    while True:
        try:
            await asyncio.sleep(60)  # Attendre 60 secondes
            await verifier_et_traiter_timeouts()
        except Exception as e:
            logging.error(f"âŒ Erreur dans le job de vÃ©rification des timeouts: {e}", exc_info=True)
            await asyncio.sleep(60)  # Attendre avant de rÃ©essayer mÃªme en cas d'erreur

# JWT and Password configuration
SECRET_KEY = os.environ.get("JWT_SECRET", "your-secret-key-here")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 24 * 60  # 24 hours

# Super Admin credentials
SUPER_ADMIN_EMAIL = "gussdub@icloud.com"
SUPER_ADMIN_PASSWORD_HASH = ""  # Will be set on first run

# Simplified password hashing

# ==================== HELPER FUNCTIONS ====================

# Helper functions
def validate_complex_password(password: str) -> bool:
    """
    Valide qu'un mot de passe respecte les critÃ¨res de complexitÃ© :
    - 8 caractÃ¨res minimum
    - 1 majuscule
    - 1 chiffre  
    - 1 caractÃ¨re spÃ©cial (!@#$%^&*+-?())
    """
    if len(password) < 8:
        return False
    
    has_uppercase = bool(re.search(r'[A-Z]', password))
    has_digit = bool(re.search(r'\d', password))
    has_special = bool(re.search(r'[!@#$%^&*+\-?()]', password))
    
    return has_uppercase and has_digit and has_special


def normalize_string_for_matching(s: str) -> str:
    """
    Normalise une chaÃ®ne pour le matching intelligent :
    - EnlÃ¨ve les accents (Ã© â†’ e, Ã  â†’ a, etc.)
    - Convertit en minuscules
    - Strip les espaces
    
    UtilisÃ© pour matcher des noms/prÃ©noms de faÃ§on flexible dans les imports CSV.
    
    Exemple:
        "SÃ©bastien BERNARD" â†’ "sebastien bernard"
        "Dupont Jean-Pierre" â†’ "dupont jean-pierre"
    """
    import unicodedata
    # Enlever les accents (NFD = dÃ©compose, puis filtre les marques diacritiques)
    s = ''.join(c for c in unicodedata.normalize('NFD', s) 
                if unicodedata.category(c) != 'Mn')
    # Minuscules et strip
    return s.lower().strip()


def create_user_matching_index(users_list: list) -> dict:
    """
    CrÃ©e un index de matching pour recherche rapide d'utilisateurs.
    
    GÃ¨re automatiquement :
    - Ordre normal (PrÃ©nom Nom)
    - Ordre inversÃ© (Nom PrÃ©nom)
    - Normalisation (accents, casse)
    
    Args:
        users_list: Liste d'utilisateurs avec 'prenom' et 'nom'
    
    Returns:
        dict: Index {nom_normalisÃ©: user_object}
        
    Exemple:
        users = [{"prenom": "SÃ©bastien", "nom": "Bernard"}]
        index = create_user_matching_index(users)
        # index["sebastien bernard"] â†’ user
        # index["bernard sebastien"] â†’ user (ordre inversÃ© aussi)
    """
    index = {}
    for user in users_list:
        prenom = user.get('prenom', '').strip()
        nom = user.get('nom', '').strip()
        
        if prenom and nom:
            # Index 1: PrÃ©nom Nom (ordre normal)
            key1 = normalize_string_for_matching(f"{prenom} {nom}")
            index[key1] = user
            
            # Index 2: Nom PrÃ©nom (ordre inversÃ©)
            key2 = normalize_string_for_matching(f"{nom} {prenom}")
            index[key2] = user
    
    return index


def find_user_intelligent(
    search_string: str, 
    users_by_name: dict, 
    users_by_num: dict = None,
    numero_field: str = "numero_employe"
) -> dict:
    """
    Recherche intelligente d'un utilisateur avec matching flexible.
    
    StratÃ©gie de recherche (par ordre de prioritÃ©) :
    1. Par numÃ©ro d'employÃ© (si prÃ©sent entre parenthÃ¨ses et fiable)
    2. Par nom normalisÃ© (ordre normal ou inversÃ©)
    3. Par parsing approfondi (noms composÃ©s)
    
    Args:
        search_string: ChaÃ®ne de recherche (ex: "Bernard SÃ©bastien (981)")
        users_by_name: Index crÃ©Ã© par create_user_matching_index()
        users_by_num: Index optionnel {numero: user}
        numero_field: Nom du champ contenant le numÃ©ro (dÃ©faut: "numero_employe")
    
    Returns:
        dict: User object si trouvÃ©, None sinon
        
    Exemples:
        find_user_intelligent("Bernard SÃ©bastien (981)", index)
        find_user_intelligent("BERNARD Sebastien", index)
        find_user_intelligent("Jean-Pierre Dubois", index)
    """
    if not search_string:
        return None
    
    # Extraire le nom sans le numÃ©ro entre parenthÃ¨ses
    nom_complet = search_string.split("(")[0].strip()
    
    # Tentative 1: Par numÃ©ro d'employÃ©
    if users_by_num and "(" in search_string and ")" in search_string:
        try:
            num = search_string.split("(")[1].split(")")[0].strip()
            if num and num in users_by_num:
                return users_by_num[num]
        except:
            pass
    
    # Tentative 2: Matching flexible par nom normalisÃ©
    if nom_complet:
        normalized = normalize_string_for_matching(nom_complet)
        if normalized in users_by_name:
            return users_by_name[normalized]
    
    # Tentative 3: Parsing approfondi pour noms composÃ©s
    if nom_complet:
        parts = nom_complet.split()
        if len(parts) >= 2:
            # Essayer toutes les combinaisons
            for i in range(len(parts)):
                possible_prenom = " ".join(parts[:i+1])
                possible_nom = " ".join(parts[i+1:])
                
                if possible_nom:
                    # Ordre normal
                    test_key = normalize_string_for_matching(f"{possible_prenom} {possible_nom}")
                    if test_key in users_by_name:
                        return users_by_name[test_key]
                    
                    # Ordre inversÃ©
                    test_key2 = normalize_string_for_matching(f"{possible_nom} {possible_prenom}")
                    if test_key2 in users_by_name:
                        return users_by_name[test_key2]
    
    return None


def send_welcome_email(user_email: str, user_name: str, user_role: str, temp_password: str, tenant_slug: str = ""):
    """
    Envoie un email de bienvenue avec les informations de connexion
    tenant_slug: slug de la caserne pour construire l'URL d'accÃ¨s directe
    """
    try:
        # DÃ©finir les modules selon le rÃ´le
        modules_by_role = {
            'admin': [
                "ğŸ“Š Tableau de bord - Vue d'ensemble et statistiques",
                "ğŸ‘¥ Personnel - Gestion complÃ¨te des pompiers", 
                "ğŸ“… Planning - Attribution automatique et manuelle",
                "ğŸ”„ Remplacements - Validation des demandes",
                "ğŸ“š Formations - Inscription et gestion",
                "ğŸ“ˆ Rapports - Analyses et exports",
                "âš™ï¸ ParamÃ¨tres - Configuration systÃ¨me",
                "ğŸ‘¤ Mon profil - Informations personnelles"
            ],
            'superviseur': [
                "ğŸ“Š Tableau de bord - Vue d'ensemble et statistiques",
                "ğŸ‘¥ Personnel - Consultation des pompiers",
                "ğŸ“… Planning - Gestion et validation", 
                "ğŸ”„ Remplacements - Approbation des demandes",
                "ğŸ“š Formations - Inscription et gestion",
                "ğŸ‘¤ Mon profil - Informations personnelles"
            ],
            'employe': [
                "ğŸ“Š Tableau de bord - Vue d'ensemble personnalisÃ©e",
                "ğŸ“… Planning - Consultation de votre planning",
                "ğŸ”„ Remplacements - Demandes de remplacement",
                "ğŸ“š Formations - Inscription aux formations",
                "ğŸ‘¤ Mon profil - Informations et disponibilitÃ©s"
            ]
        }
        
        role_name = {
            'admin': 'Administrateur',
            'superviseur': 'Superviseur', 
            'employe': 'EmployÃ©'
        }.get(user_role, 'Utilisateur')
        
        user_modules = modules_by_role.get(user_role, modules_by_role['employe'])
        modules_html = ''.join([f'<li style="margin-bottom: 8px;">{module}</li>' for module in user_modules])
        
        subject = f"Bienvenue dans ProFireManager v2.0 - Votre compte {role_name}"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">SystÃ¨me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Votre compte <strong>{role_name}</strong> a Ã©tÃ© crÃ©Ã© avec succÃ¨s dans ProFireManager v2.0, le systÃ¨me de gestion des horaires et remplacements automatisÃ©s pour les services d'incendie du Canada.</p>
                
                <p style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 12px; margin: 15px 0;">
                    ğŸ¢ <strong>Votre caserne :</strong> {tenant_slug.title() if tenant_slug else 'Non spÃ©cifiÃ©e'}
                </p>
                
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #dc2626; margin-top: 0;">ğŸ”‘ Informations de connexion :</h3>
                    <p><strong>Email :</strong> {user_email}</p>
                    <p><strong>Mot de passe temporaire :</strong> {temp_password}</p>
                    <p style="color: #dc2626; font-weight: bold;">âš ï¸ Veuillez modifier votre mot de passe lors de votre premiÃ¨re connexion</p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')}/{tenant_slug}" 
                       style="background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
                        ğŸš’ AccÃ©der Ã  ProFireManager
                    </a>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        ğŸ’¡ Conseil : Ajoutez ce lien Ã  vos favoris pour un accÃ¨s rapide Ã  votre caserne
                    </p>
                </div>
                
                <h3 style="color: #1e293b;">ğŸ“‹ Modules disponibles pour votre rÃ´le ({role_name}) :</h3>
                <ul style="background: #f0fdf4; border-left: 4px solid #10b981; padding: 15px 20px; margin: 15px 0;">
                    {modules_html}
                </ul>
                
                <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #92400e; margin-top: 0;">ğŸ”’ SÃ©curitÃ© de votre compte :</h4>
                    <p style="color: #92400e; font-weight: bold; margin: 10px 0;">
                        âš ï¸ IMPORTANT : Changez votre mot de passe temporaire dÃ¨s maintenant !
                    </p>
                    <p style="color: #78350f; margin: 10px 0;">
                        <strong>ğŸ“ Comment changer votre mot de passe :</strong>
                    </p>
                    <ol style="color: #78350f; margin: 10px 0;">
                        <li>Connectez-vous Ã  ProFireManager avec le mot de passe temporaire ci-dessus</li>
                        <li>Cliquez sur <strong>"Mon Profil"</strong> dans le menu de gauche</li>
                        <li>Descendez en <strong>bas de la page</strong></li>
                        <li>Trouvez la section <strong>"Modifier le mot de passe"</strong></li>
                        <li>Entrez votre nouveau mot de passe (8 caractÃ¨res min, 1 majuscule, 1 chiffre, 1 caractÃ¨re spÃ©cial)</li>
                        <li>Cliquez sur <strong>"Enregistrer"</strong></li>
                    </ol>
                    <p style="color: #78350f; margin: 10px 0;">
                        ğŸ’¡ <strong>Conseils de sÃ©curitÃ© :</strong>
                    </p>
                    <ul style="color: #78350f; margin: 10px 0;">
                        <li>Utilisez un mot de passe unique et complexe</li>
                        <li>Ne partagez jamais vos identifiants</li>
                        <li>DÃ©connectez-vous aprÃ¨s chaque session</li>
                    </ul>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a Ã©tÃ© envoyÃ© automatiquement par ProFireManager v2.0.<br>
                    Si vous avez des questions, contactez votre administrateur systÃ¨me.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - SystÃ¨me de gestion des services d'incendie du Canada<br>
                        DÃ©veloppÃ© pour optimiser la gestion des horaires et remplacements automatisÃ©s
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configurÃ©e - Email non envoyÃ© Ã  {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"âœ… Email de bienvenue envoyÃ© avec succÃ¨s Ã  {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"âš ï¸ Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"âŒ Erreur lors de l'envoi de l'email Ã  {user_email}: {str(e)}")
        return False


def send_temporary_password_email(user_email: str, user_name: str, temp_password: str, tenant_slug: str = ""):
    """
    Envoie un email avec le mot de passe temporaire suite Ã  une rÃ©initialisation par l'administrateur
    """
    try:
        subject = "RÃ©initialisation de votre mot de passe - ProFireManager"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">SystÃ¨me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Suite Ã  votre demande, votre mot de passe a Ã©tÃ© rÃ©initialisÃ© par un administrateur.</p>
                
                <div style="background: #fef3c7; border: 2px solid #fcd34d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #92400e; margin-top: 0;">âš ï¸ IMPORTANT - SÃ©curitÃ© de votre compte</h3>
                    <p style="color: #92400e; font-weight: bold; margin: 10px 0;">
                        Si vous n'avez jamais demandÃ© ce changement, veuillez communiquer avec votre administrateur le plus rapidement possible.
                    </p>
                </div>
                
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #dc2626; margin-top: 0;">ğŸ”‘ Votre nouveau mot de passe temporaire :</h3>
                    <p style="background: white; padding: 12px; border: 2px dashed #dc2626; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; text-align: center;">
                        {temp_password}
                    </p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')}/{tenant_slug}" 
                       style="background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
                        ğŸš’ Se connecter Ã  ProFireManager
                    </a>
                </div>
                
                <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #1e3a8a; margin-top: 0;">ğŸ“ ProcÃ©dure pour changer votre mot de passe :</h4>
                    <ol style="color: #1e3a8a; margin: 10px 0;">
                        <li>Connectez-vous Ã  ProFireManager avec le mot de passe temporaire ci-dessus</li>
                        <li>Cliquez sur <strong>"Mon Profil"</strong> dans le menu de gauche</li>
                        <li>Descendez en <strong>bas de la page</strong></li>
                        <li>Trouvez la section <strong>"Modifier le mot de passe"</strong></li>
                        <li>Entrez votre <strong>mot de passe actuel</strong> (le mot de passe temporaire)</li>
                        <li>Entrez votre <strong>nouveau mot de passe</strong> (8 caractÃ¨res min, 1 majuscule, 1 chiffre, 1 caractÃ¨re spÃ©cial)</li>
                        <li>Confirmez votre nouveau mot de passe</li>
                        <li>Cliquez sur <strong>"Enregistrer les modifications"</strong></li>
                    </ol>
                    <p style="color: #1e3a8a; margin: 10px 0;">
                        ğŸ’¡ <strong>Conseils de sÃ©curitÃ© :</strong>
                    </p>
                    <ul style="color: #1e3a8a; margin: 10px 0;">
                        <li>Utilisez un mot de passe unique et complexe</li>
                        <li>Ne partagez jamais vos identifiants</li>
                        <li>DÃ©connectez-vous aprÃ¨s chaque session</li>
                        <li>Changez votre mot de passe immÃ©diatement</li>
                    </ul>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a Ã©tÃ© envoyÃ© automatiquement par ProFireManager v2.0.<br>
                    Si vous avez des questions, contactez votre administrateur systÃ¨me.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - SystÃ¨me de gestion des services d'incendie du Canada<br>
                        DÃ©veloppÃ© pour optimiser la gestion des horaires et remplacements automatisÃ©s
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configurÃ©e - Email non envoyÃ© Ã  {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"âœ… Email de rÃ©initialisation envoyÃ© avec succÃ¨s Ã  {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"âš ï¸ Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"âŒ Erreur lors de l'envoi de l'email de rÃ©initialisation Ã  {user_email}: {str(e)}")
        return False


def send_password_reset_email(user_email: str, user_name: str, reset_token: str, tenant_slug: str = ""):
    """
    Envoie un email avec un lien pour rÃ©initialiser le mot de passe
    """
    try:
        frontend_url = os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')
        reset_link = f"{frontend_url}/{tenant_slug}/reset-password?token={reset_token}"
        
        subject = "RÃ©initialisation de votre mot de passe - ProFireManager"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">SystÃ¨me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Nous avons reÃ§u une demande de rÃ©initialisation de mot de passe pour votre compte ProFireManager.</p>
                
                <div style="background: #fef3c7; border: 2px solid #fcd34d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #92400e; margin-top: 0;">âš ï¸ IMPORTANT - SÃ©curitÃ©</h3>
                    <p style="color: #92400e; font-weight: bold; margin: 10px 0;">
                        Si vous n'avez pas demandÃ© cette rÃ©initialisation, ignorez cet email. Votre mot de passe actuel reste inchangÃ©.
                    </p>
                    <p style="color: #78350f; margin: 10px 0;">
                        Ce lien est valide pendant <strong>1 heure</strong> seulement.
                    </p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{reset_link}" 
                       style="background: #dc2626; color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block; font-size: 16px;">
                        ğŸ” RÃ©initialiser mon mot de passe
                    </a>
                </div>
                
                <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                    <p style="color: #1e3a8a; margin: 0; font-size: 14px;">
                        ğŸ’¡ <strong>Le lien ne fonctionne pas?</strong><br>
                        Copiez et collez cette adresse dans votre navigateur :<br>
                        <span style="font-family: 'Courier New', monospace; font-size: 12px; word-break: break-all;">{reset_link}</span>
                    </p>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a Ã©tÃ© envoyÃ© automatiquement par ProFireManager v2.0.<br>
                    Pour des questions de sÃ©curitÃ©, contactez votre administrateur.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - SystÃ¨me de gestion des services d'incendie du Canada
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configurÃ©e - Email non envoyÃ© Ã  {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"âœ… Email de rÃ©initialisation de mot de passe envoyÃ© avec succÃ¨s Ã  {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"âš ï¸ Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"âŒ Erreur lors de l'envoi de l'email de rÃ©initialisation Ã  {user_email}: {str(e)}")
        return False
        

def send_super_admin_welcome_email(user_email: str, user_name: str, temp_password: str):
    """
    Envoie un email de bienvenue Ã  un nouveau super admin
    """
    try:
        frontend_url = os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')
        admin_url = f"{frontend_url}/admin"
        
        subject = "Bienvenue en tant que Super Admin - ProFireManager"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">SystÃ¨me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Votre compte <strong>Super Administrateur</strong> a Ã©tÃ© crÃ©Ã© avec succÃ¨s dans ProFireManager v2.0.</p>
                
                <div style="background: #fef3c7; border: 2px solid #fcd34d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #92400e; margin-top: 0;">ğŸ‘‘ PrivilÃ¨ges de Super Admin</h3>
                    <p style="color: #92400e; margin: 10px 0;">
                        En tant que Super Admin, vous avez accÃ¨s Ã :
                    </p>
                    <ul style="color: #78350f; margin: 10px 0;">
                        <li><strong>Tous les tenants/casernes</strong> de la plateforme</li>
                        <li><strong>Interface d'administration</strong> globale</li>
                        <li><strong>Gestion des autres super admins</strong></li>
                        <li><strong>CrÃ©ation et configuration</strong> des tenants</li>
                        <li><strong>Statistiques</strong> multi-tenant</li>
                    </ul>
                </div>
                
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #dc2626; margin-top: 0;">ğŸ”‘ Informations de connexion :</h3>
                    <p><strong>Email :</strong> {user_email}</p>
                    <p><strong>Mot de passe temporaire :</strong> {temp_password}</p>
                    <p style="color: #dc2626; font-weight: bold;">âš ï¸ Veuillez modifier votre mot de passe lors de votre premiÃ¨re connexion</p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{admin_url}" 
                       style="background: #dc2626; color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block; font-size: 16px;">
                        ğŸ‘‘ AccÃ©der Ã  l'interface Super Admin
                    </a>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        ğŸ’¡ Ajoutez ce lien Ã  vos favoris pour un accÃ¨s rapide
                    </p>
                </div>
                
                <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #1e40af; margin-top: 0;">ğŸ“‹ FonctionnalitÃ©s disponibles :</h4>
                    <ul style="color: #1e40af; margin: 0;">
                        <li>Gestion multi-tenant (crÃ©ation, Ã©dition, suppression)</li>
                        <li>Statistiques globales de la plateforme</li>
                        <li>Gestion des super administrateurs</li>
                        <li>Configuration des tenants</li>
                        <li>Surveillance des performances</li>
                    </ul>
                </div>
                
                <div style="background: #fee2e2; border: 2px solid #dc2626; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #991b1b; margin-top: 0;">ğŸ”’ IMPORTANT - SÃ©curitÃ© :</h4>
                    <p style="color: #991b1b; font-weight: bold; margin: 10px 0;">
                        âš ï¸ Changez votre mot de passe temporaire IMMÃ‰DIATEMENT !
                    </p>
                    <p style="color: #7f1d1d; margin: 10px 0;">
                        En tant que Super Admin, vous avez un accÃ¨s complet au systÃ¨me. Utilisez des mots de passe forts et ne partagez jamais vos identifiants.
                    </p>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a Ã©tÃ© envoyÃ© automatiquement par ProFireManager v2.0.<br>
                    Si vous n'avez pas demandÃ© ce compte, contactez immÃ©diatement l'administrateur systÃ¨me.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - SystÃ¨me de gestion des services d'incendie du Canada
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configurÃ©e - Email non envoyÃ© Ã  {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"âœ… Email de bienvenue super admin envoyÃ© avec succÃ¨s Ã  {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"âš ï¸ Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"âŒ Erreur lors de l'envoi de l'email super admin Ã  {user_email}: {str(e)}")
        return False


def send_gardes_notification_email(user_email: str, user_name: str, gardes_list: list, tenant_slug: str, periode: str):
    """
    Envoie un email dÃ©taillÃ© avec les gardes assignÃ©es pour le mois
    
    Args:
        user_email: Email du pompier
        user_name: Nom complet du pompier
        gardes_list: Liste des gardes [{date, type_garde, horaire, collegues}]
        tenant_slug: Slug de la caserne
        periode: PÃ©riode concernÃ©e (ex: "janvier 2025")
    """
    resend_api_key = os.environ.get('RESEND_API_KEY')
    
    if not resend_api_key:
        print(f"[WARNING] RESEND_API_KEY non configurÃ©e - Email NON envoyÃ© Ã  {user_email}")
        return False
    
    try:
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        subject = f"Vos gardes assignÃ©es - {periode}"
        
        # Construction de la liste des gardes en HTML
        gardes_html = ''
        for garde in gardes_list:
            collegues_str = ', '.join(garde.get('collegues', [])) if garde.get('collegues') else 'Non spÃ©cifiÃ©s'
            
            gardes_html += f"""
                <div style="background: #f8fafc; border-left: 4px solid #3b82f6; padding: 15px; margin: 15px 0; border-radius: 4px;">
                    <h4 style="color: #1e293b; margin: 0 0 10px 0;">
                        ğŸ“… {garde['jour']} {garde['date']}
                    </h4>
                    <p style="margin: 5px 0; color: #475569;">
                        <strong>{garde['type_garde']}</strong> ({garde['horaire']})
                    </p>
                    <p style="margin: 5px 0; color: #64748b; font-size: 0.9rem;">
                        ğŸ‘¥ Avec: {collegues_str}
                    </p>
                    <p style="margin: 5px 0; color: #64748b; font-size: 0.9rem;">
                        ğŸ“ Lieu: Caserne {tenant_slug.title()}
                    </p>
                </div>
            """
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="color: white; margin: 0; font-size: 24px;">ğŸš’ ProFireManager</h1>
                <p style="color: #fecaca; margin: 10px 0 0 0;">Planning validÃ©</p>
            </div>
            
            <div style="background: white; padding: 30px; border: 1px solid #e2e8f0; border-top: none; border-radius: 0 0 10px 10px;">
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Voici vos gardes assignÃ©es pour <strong>{periode}</strong>.</p>
                
                <p style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 12px; margin: 15px 0;">
                    ğŸ¢ <strong>Caserne:</strong> {tenant_slug.title()}
                </p>
                
                <h3 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px;">
                    ğŸ“‹ Vos gardes
                </h3>
                
                {gardes_html}
                
                <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #92400e; margin-top: 0;">ğŸ“¢ Important :</h4>
                    <ul style="color: #78350f; margin: 10px 0;">
                        <li>Ce planning a Ã©tÃ© validÃ© par votre administrateur</li>
                        <li>Des ajustements peuvent encore survenir en cas de remplacements</li>
                        <li>Consultez rÃ©guliÃ¨rement le planning en ligne pour les mises Ã  jour</li>
                        <li>En cas d'absence, signalez-le immÃ©diatement via l'application</li>
                    </ul>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')}/{tenant_slug}" 
                       style="background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
                        ğŸš’ Consulter le planning
                    </a>
                </div>
                
                <div style="border-top: 2px solid #e2e8f0; margin-top: 30px; padding-top: 20px; text-align: center; color: #64748b; font-size: 0.875rem;">
                    <p>ProFireManager v2.0 - Gestion des horaires et remplacements</p>
                    <p>Services d'incendie du Canada</p>
                    <p style="margin-top: 10px;">
                        Cet email a Ã©tÃ© envoyÃ© automatiquement. Ne pas rÃ©pondre.
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        params = {
            "from": f"ProFireManager <{sender_email}>",
            "to": [user_email],
            "subject": subject,
            "html": html_content
        }
        
        response = resend.Emails.send(params)
        print(f"âœ… Email de gardes envoyÃ© avec succÃ¨s Ã  {user_email} via Resend (ID: {response.get('id', 'N/A')})")
        return True
            
    except Exception as e:
        print(f"âŒ Erreur lors de l'envoi de l'email de gardes Ã  {user_email}: {str(e)}")
        return False

# ==================== HELPERS PDF PERSONNALISÃ‰S ====================

def create_pdf_header_elements(tenant, styles):
    """
    CrÃ©e les Ã©lÃ©ments de header personnalisÃ©s pour les PDFs
    Retourne une liste d'Ã©lÃ©ments Ã  ajouter au document
    """
    elements = []
    
    # Logo (si prÃ©sent)
    if hasattr(tenant, 'logo_url') and tenant.logo_url:
        try:
            if tenant.logo_url.startswith('data:image/'):
                # Extraire les donnÃ©es base64
                header, encoded = tenant.logo_url.split(',', 1)
                logo_data = base64.b64decode(encoded)
                logo_buffer = IOBytesIO(logo_data)
                
                # Utiliser PIL pour obtenir les dimensions de l'image
                from PIL import Image as PILImage
                pil_image = PILImage.open(logo_buffer)
                img_width, img_height = pil_image.size
                
                # Calculer la hauteur proportionnelle pour une largeur de 1.5 inch
                target_width = 1.5 * inch
                aspect_ratio = img_height / img_width
                target_height = target_width * aspect_ratio
                
                # RÃ©initialiser le buffer pour ReportLab
                logo_buffer.seek(0)
                
                # Ajouter le logo avec largeur et hauteur explicites
                logo = Image(logo_buffer, width=target_width, height=target_height)
                logo.hAlign = 'LEFT'
                elements.append(logo)
                elements.append(Spacer(1, 0.1 * inch))
        except Exception as e:
            print(f"Erreur chargement logo PDF: {e}")
    
    # Nom du service
    nom_service = tenant.nom_service if hasattr(tenant, 'nom_service') and tenant.nom_service else tenant.nom
    
    header_style = ParagraphStyle(
        'ServiceHeader',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=10,
        alignment=TA_CENTER
    )
    
    elements.append(Paragraph(nom_service, header_style))
    elements.append(Spacer(1, 0.2 * inch))
    
    return elements

def create_pdf_footer_text(tenant):
    """
    CrÃ©e le texte du footer pour les PDFs
    """
    footer_parts = []
    
    # Toujours afficher ProFireManager (sauf si explicitement dÃ©sactivÃ©)
    if not hasattr(tenant, 'afficher_profiremanager') or tenant.afficher_profiremanager:
        footer_parts.append("GÃ©nÃ©rÃ© par ProFireManager â€¢ www.profiremanager.com")
    
    return " | ".join(footer_parts) if footer_parts else ""

# Classe CustomDocTemplate avec branding automatique
from reportlab.platypus import BaseDocTemplate, PageTemplate, Frame
from reportlab.pdfgen import canvas as pdf_canvas

class BrandedDocTemplate(SimpleDocTemplate):
    """
    Template de document PDF personnalisÃ© avec branding tenant automatique
    HÃ©rite de SimpleDocTemplate pour la simplicitÃ©
    """
    def __init__(self, filename, tenant=None, **kwargs):
        self.tenant = tenant
        # Appeler le constructeur de SimpleDocTemplate
        SimpleDocTemplate.__init__(self, filename, **kwargs)



def create_branded_pdf(tenant, pagesize=A4, **kwargs):
    """
    Fonction helper pour crÃ©er un PDF brandÃ© avec logo et footer
    
    Args:
        tenant: L'objet tenant
        pagesize: Taille de la page (A4, letter, etc.)
        **kwargs: Arguments additionnels pour SimpleDocTemplate
        
    Returns:
        tuple: (buffer, doc, elements_with_header)
        - buffer: BytesIO object
        - doc: SimpleDocTemplate instance avec branding
        - elements_with_header: Liste avec logo et header dÃ©jÃ  ajoutÃ©s
    """
    from io import BytesIO
    from reportlab.lib.styles import getSampleStyleSheet
    
    buffer = BytesIO()
    
    # Utiliser les marges par dÃ©faut si non spÃ©cifiÃ©es
    if 'topMargin' not in kwargs:
        kwargs['topMargin'] = 0.75 * inch
    if 'bottomMargin' not in kwargs:
        kwargs['bottomMargin'] = 0.75 * inch
    
    # Utiliser SimpleDocTemplate directement pour la simplicitÃ©
    doc = SimpleDocTemplate(buffer, pagesize=pagesize, **kwargs)
    styles = getSampleStyleSheet()
    
    # CrÃ©er les Ã©lÃ©ments de base avec logo et header
    elements = create_pdf_header_elements(tenant, styles)
    
    # Ajouter le footer Ã  la fin du document
    footer_text = create_pdf_footer_text(tenant)
    if footer_text:
        from reportlab.platypus import Paragraph
        from reportlab.lib.enums import TA_CENTER
        from reportlab.lib.styles import ParagraphStyle
        
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            alignment=TA_CENTER,
            spaceAfter=0
        )
        # Note: Le footer sera ajoutÃ© Ã  la fin du document par l'appelant si nÃ©cessaire
    
    return buffer, doc, elements


def get_modern_pdf_styles(styles):
    """
    Retourne les styles modernes standardisÃ©s pour tous les PDFs
    BasÃ© sur le design du rapport d'inspection (Ronde de sÃ©curitÃ©)
    """
    title_style = ParagraphStyle(
        'ModernTitle',
        parent=styles['Heading1'],
        fontSize=20,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'ModernHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#374151'),
        spaceAfter=12,
        spaceBefore=20
    )
    
    subheading_style = ParagraphStyle(
        'ModernSubheading',
        parent=styles['Normal'],
        fontSize=12,
        textColor=colors.HexColor('#374151'),
        spaceAfter=10,
        alignment=TA_CENTER
    )
    
    return {
        'title': title_style,
        'heading': heading_style,
        'subheading': subheading_style,
        'primary_color': colors.HexColor('#1f2937'),
        'secondary_color': colors.HexColor('#374151'),
        'bg_light': colors.HexColor('#f3f4f6'),
        'success': colors.HexColor('#10b981'),
        'error': colors.HexColor('#ef4444'),
        'grid': colors.HexColor('#e5e7eb'),
        'warning_bg': colors.HexColor('#fef2f2')
    }

# ==================== FIN HELPERS PDF ====================

def get_password_hash(password: str) -> str:
    """
    CrÃ©e un hash bcrypt du mot de passe (sÃ©curisÃ© et standard).
    """
    password_bytes = password.encode('utf-8')
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password_bytes, salt).decode('utf-8')

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    VÃ©rifie un mot de passe contre son hash bcrypt.
    SystÃ¨me simplifiÃ©: UNIQUEMENT bcrypt pour stabilitÃ© maximale.
    
    Retourne True si le mot de passe correspond, False sinon.
    """
    try:
        password_bytes = plain_password.encode('utf-8')
        
        # VÃ©rifier si c'est un hash bcrypt valide
        if not hashed_password or not hashed_password.startswith('$2'):
            logging.error(f"âŒ Hash invalide ou non-bcrypt dÃ©tectÃ©")
            return False
        
        if isinstance(hashed_password, str):
            hash_bytes = hashed_password.encode('utf-8')
        else:
            hash_bytes = hashed_password
        
        result = bcrypt.checkpw(password_bytes, hash_bytes)
        logging.info(f"âœ… VÃ©rification bcrypt: {result}")
        return result
        
    except Exception as e:
        logging.error(f"âŒ Erreur vÃ©rification mot de passe: {e}")
        return False



def send_debogage_notification_email(super_admins_emails: List[str], type_notification: str, titre: str, description: str, priorite: str, created_by: str, item_id: str):
    """
    Envoie un email aux super-admins pour les notifier d'un nouveau bug ou feature request
    
    Args:
        super_admins_emails: Liste des emails des super-admins
        type_notification: "bug" ou "feature"
        titre: Titre du bug/feature
        description: Description
        priorite: PrioritÃ© (critique, haute, moyenne, basse)
        created_by: Nom de la personne qui a crÃ©Ã©
        item_id: ID du bug/feature
    """
    try:
        resend_api_key = os.environ.get('RESEND_API_KEY')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configurÃ©e - Email NON envoyÃ©")
            return
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        # DÃ©terminer le type et l'emoji
        if type_notification == "bug":
            type_label = "ğŸ› Nouveau Bug SignalÃ©"
            color = "#dc2626"  # rouge
        else:
            type_label = "âœ¨ Nouvelle FonctionnalitÃ© DemandÃ©e"
            color = "#2563eb"  # bleu
        
        # DÃ©terminer la couleur de prioritÃ©
        priorite_colors = {
            "critique": "#dc2626",
            "haute": "#f97316",
            "moyenne": "#eab308",
            "basse": "#22c55e"
        }
        priorite_color = priorite_colors.get(priorite, "#6b7280")
        
        # CrÃ©er l'URL de l'interface admin
        admin_url = f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/admin"
        
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
    <div style="max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f8fafc;">
        <!-- Header -->
        <div style="background: linear-gradient(135deg, {color} 0%, {color}dd 100%); padding: 30px; border-radius: 16px 16px 0 0; text-align: center;">
            <h1 style="margin: 0; color: white; font-size: 24px; font-weight: 600;">
                {type_label}
            </h1>
        </div>
        
        <!-- Content -->
        <div style="background-color: white; padding: 30px; border-radius: 0 0 16px 16px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <!-- Titre -->
            <div style="margin-bottom: 20px;">
                <h2 style="margin: 0 0 10px 0; color: #1e293b; font-size: 20px; font-weight: 600;">
                    {titre}
                </h2>
                <div style="display: inline-block; padding: 4px 12px; background-color: {priorite_color}; color: white; border-radius: 12px; font-size: 12px; font-weight: 600; text-transform: uppercase;">
                    PrioritÃ©: {priorite}
                </div>
            </div>
            
            <!-- Description -->
            <div style="background-color: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid {color};">
                <p style="margin: 0; color: #475569; line-height: 1.6;">
                    {description[:200]}{'...' if len(description) > 200 else ''}
                </p>
            </div>
            
            <!-- Info supplÃ©mentaires -->
            <div style="margin-bottom: 25px; padding: 15px; background-color: #eff6ff; border-radius: 8px;">
                <p style="margin: 0 0 8px 0; color: #64748b; font-size: 14px;">
                    <strong>CrÃ©Ã© par:</strong> {created_by}
                </p>
                <p style="margin: 0; color: #64748b; font-size: 14px;">
                    <strong>ID:</strong> {item_id[:8]}...
                </p>
            </div>
            
            <!-- Call to Action -->
            <div style="text-align: center; margin-top: 30px;">
                <a href="{admin_url}" style="display: inline-block; padding: 14px 32px; background: linear-gradient(135deg, {color} 0%, {color}dd 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    Voir dans l'Interface Admin
                </a>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="text-align: center; padding: 20px; color: #94a3b8; font-size: 12px;">
            <p style="margin: 0;">ProFireManager - SystÃ¨me de Gestion de SÃ©curitÃ© Incendie</p>
            <p style="margin: 5px 0 0 0;">Cet email a Ã©tÃ© envoyÃ© automatiquement, merci de ne pas y rÃ©pondre.</p>
        </div>
    </div>
</body>
</html>
"""
        
        # Envoyer l'email Ã  tous les super-admins avec Resend
        for admin_email in super_admins_emails:
            try:
                params = {
                    "from": "ProFireManager <noreply@profiremanager.ca>",
                    "to": [admin_email],
                    "subject": f"{type_label}: {titre}",
                    "html": html_content
                }
                
                response = resend.Emails.send(params)
                print(f"[INFO] Email de notification envoyÃ© Ã  {admin_email} via Resend (ID: {response.get('id', 'N/A')})")
            except Exception as e:
                print(f"[ERROR] Erreur lors de l'envoi de l'email Ã  {admin_email}: {e}")
                
    except Exception as e:
        print(f"[ERROR] Erreur gÃ©nÃ©rale lors de l'envoi des emails de dÃ©bogage: {e}")

security = HTTPBearer()

# Define Models
# ==================== MULTI-TENANT MODELS ====================

class Tenant(BaseModel):
    """ModÃ¨le pour une caserne (tenant)"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    slug: str  # URL slug (shefford, bromont, etc.)
    nom: str  # Nom complet de la caserne
    adresse: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    telephone: str = ""
    email_contact: str = ""
    actif: bool = True
    date_creation: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    parametres: Dict[str, Any] = {}
    # Personnalisation
    logo_url: str = ""  # URL ou base64 du logo
    nom_service: str = ""  # Nom complet du service (ex: "Service Incendie de Ville-X")
    afficher_profiremanager: bool = True  # Afficher le branding ProFireManager

class TenantCreate(BaseModel):
    slug: str
    nom: str
    adresse: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    telephone: str = ""
    email_contact: str = ""
    date_creation: Optional[str] = None  # Date optionnelle

class SuperAdmin(BaseModel):
    """Super administrateur gÃ©rant toutes les casernes"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    email: str
    nom: str = "Super Admin"
    mot_de_passe_hash: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SuperAdminLogin(BaseModel):
    email: str
    mot_de_passe: str

# ==================== USER MODELS ====================

class User(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str  # ID de la caserne
    nom: str
    prenom: str
    email: str
    telephone: str = ""
    adresse: str = ""  # Adresse du pompier
    contact_urgence: str = ""
    grade: str  # Capitaine, Directeur, Pompier, Lieutenant
    fonction_superieur: bool = False  # Pour pompiers pouvant agir comme lieutenant
    type_emploi: str  # temps_plein, temps_partiel
    heures_max_semaine: int = 40  # Heures max par semaine (pour temps partiel)
    role: str  # admin, superviseur, employe
    statut: str = "Actif"  # Actif, Inactif
    numero_employe: str = ""
    date_embauche: str = ""
    taux_horaire: float = 0.0  # Taux horaire en $/h
    heures_internes: float = 0.0  # Heures de garde internes (travail physique)
    heures_externes: float = 0.0  # Heures de garde externes (astreinte Ã  domicile)
    formations: List[str] = []  # Liste des UUIDs de formations suivies (pour module Formation)
    competences: List[str] = []  # Liste des UUIDs de compÃ©tences acquises/certifiÃ©es (pour auto-attribution)
    accepte_gardes_externes: bool = True  # Accepte d'Ãªtre assignÃ© aux gardes externes
    est_preventionniste: bool = False  # DÃ©signÃ© comme prÃ©ventionniste (module PrÃ©vention)
    mot_de_passe_hash: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class UserCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    nom: str
    prenom: str
    email: str
    telephone: str = ""
    adresse: str = ""
    contact_urgence: str = ""
    grade: str = "Pompier"
    fonction_superieur: bool = False
    type_emploi: str = "temps_plein"
    heures_max_semaine: int = 40
    role: str = "employe"
    numero_employe: str = ""
    date_embauche: str = ""
    taux_horaire: float = 0.0
    formations: List[str] = []  # Liste des formations suivies
    competences: List[str] = []  # Liste des compÃ©tences acquises
    accepte_gardes_externes: bool = True  # Accepte d'Ãªtre assignÃ© aux gardes externes
    est_preventionniste: bool = False  # DÃ©signÃ© comme prÃ©ventionniste
    mot_de_passe: str = "TempPass123!"

class UserUpdate(BaseModel):
    nom: Optional[str] = None
    prenom: Optional[str] = None
    email: Optional[str] = None
    telephone: Optional[str] = None
    adresse: Optional[str] = None
    contact_urgence: Optional[str] = None
    grade: Optional[str] = None
    fonction_superieur: Optional[bool] = None
    type_emploi: Optional[str] = None
    heures_max_semaine: Optional[int] = None
    role: Optional[str] = None
    numero_employe: Optional[str] = None
    date_embauche: Optional[str] = None
    taux_horaire: Optional[float] = None
    formations: Optional[List[str]] = None
    competences: Optional[List[str]] = None
    accepte_gardes_externes: Optional[bool] = None
    est_preventionniste: Optional[bool] = None
    mot_de_passe: Optional[str] = None  # Optionnel pour les mises Ã  jour

class UserLogin(BaseModel):
    email: str
    mot_de_passe: str

class ForgotPasswordRequest(BaseModel):
    email: str

class ResetPasswordRequest(BaseModel):
    token: str
    nouveau_mot_de_passe: str

class PasswordResetToken(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    email: str
    token: str
    expires_at: datetime
    used: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class TypeGarde(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    heure_debut: str
    heure_fin: str
    personnel_requis: int
    duree_heures: int
    couleur: str
    jours_application: List[str] = []  # monday, tuesday, etc.
    officier_obligatoire: bool = False
    competences_requises: List[str] = []  # Liste des formations/compÃ©tences requises pour cette garde
    est_garde_externe: bool = False  # True si c'est une garde externe (astreinte Ã  domicile)
    taux_horaire_externe: Optional[float] = None  # Taux horaire spÃ©cifique pour garde externe
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class TypeGardeCreate(BaseModel):
    nom: str
    heure_debut: str
    heure_fin: str
    personnel_requis: int
    duree_heures: int
    couleur: str
    jours_application: List[str] = []
    officier_obligatoire: bool = False
    competences_requises: List[str] = []
    est_garde_externe: bool = False
    taux_horaire_externe: Optional[float] = None

class Planning(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    semaine_debut: str  # Format: YYYY-MM-DD
    semaine_fin: str
    assignations: Dict[str, Any] = {}  # jour -> type_garde -> assignation
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class PlanningCreate(BaseModel):
    semaine_debut: str
    semaine_fin: str
    assignations: Dict[str, Any] = {}

class Assignation(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    type_garde_id: str
    date: str
    statut: str = "planifie"  # planifie, confirme, remplacement_demande
    assignation_type: str = "auto"  # auto, manuel, manuel_avance
    justification: Optional[Dict[str, Any]] = None  # Justification dÃ©taillÃ©e pour assignations auto
    notes_admin: Optional[str] = None  # Notes manuelles de l'admin
    justification_historique: Optional[List[Dict[str, Any]]] = None  # Historique des justifications

class AssignationCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    user_id: str
    type_garde_id: str
    date: str
    assignation_type: str = "manuel"

class TentativeRemplacement(BaseModel):
    """Historique des tentatives de remplacement"""
    user_id: str
    nom_complet: str
    date_contact: datetime
    statut: str  # contacted, accepted, refused, expired
    date_reponse: Optional[datetime] = None

class DemandeRemplacement(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    demandeur_id: str
    type_garde_id: str
    date: str  # Date de la garde Ã  remplacer (format: YYYY-MM-DD)
    raison: str
    statut: str = "en_attente"  # en_attente, en_cours, accepte, expiree, annulee
    priorite: str = "normal"  # urgent (â‰¤24h), normal (>24h) - calculÃ© automatiquement
    remplacant_id: Optional[str] = None
    tentatives_historique: List[Dict[str, Any]] = []  # Historique des personnes contactÃ©es
    remplacants_contactes_ids: List[str] = []  # IDs des remplaÃ§ants actuellement en attente de rÃ©ponse
    date_prochaine_tentative: Optional[datetime] = None
    nombre_tentatives: int = 0
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DemandeRemplacementCreate(BaseModel):
    type_garde_id: str
    date: str
    raison: str

class Formation(BaseModel):
    """Formation planifiÃ©e avec gestion inscriptions NFPA 1500"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    competence_id: str = ""  # Optionnel pour rÃ©trocompatibilitÃ©
    description: str = ""
    date_debut: str = ""
    date_fin: str = ""
    heure_debut: str = ""
    heure_fin: str = ""
    duree_heures: float = 0
    lieu: str = ""
    instructeur: str = ""
    places_max: int = 20
    places_restantes: int = 20
    statut: str = "planifiee"
    obligatoire: bool = False
    annee: int = 0
    validite_mois: int = 12  # Pour anciennes formations
    user_inscrit: bool = False  # Si l'utilisateur actuel est inscrit
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class FormationCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    competence_id: str
    description: str = ""
    date_debut: str
    date_fin: str
    heure_debut: str
    heure_fin: str
    duree_heures: float
    lieu: str = ""
    instructeur: str = ""
    places_max: int
    obligatoire: bool = False
    annee: int

class FormationUpdate(BaseModel):
    nom: Optional[str] = None
    competence_id: Optional[str] = None
    description: Optional[str] = None
    date_debut: Optional[str] = None
    date_fin: Optional[str] = None
    heure_debut: Optional[str] = None
    heure_fin: Optional[str] = None
    duree_heures: Optional[float] = None
    lieu: Optional[str] = None
    instructeur: Optional[str] = None
    places_max: Optional[int] = None
    obligatoire: Optional[bool] = None
    statut: Optional[str] = None

class InscriptionFormation(BaseModel):
    """Inscription d'un pompier Ã  une formation"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    formation_id: str
    user_id: str
    date_inscription: str
    statut: str = "inscrit"  # inscrit, en_attente, present, absent, complete
    heures_creditees: float = 0.0
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InscriptionFormationCreate(BaseModel):
    tenant_id: Optional[str] = None
    formation_id: str
    user_id: str

class InscriptionFormationUpdate(BaseModel):
    statut: Optional[str] = None
    heures_creditees: Optional[float] = None
    notes: Optional[str] = None

class Competence(BaseModel):
    """CompÃ©tence avec exigences NFPA 1500"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    description: str = ""
    heures_requises_annuelles: float = 0.0
    obligatoire: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CompetenceCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    description: str = ""
    heures_requises_annuelles: float = 0.0
    obligatoire: bool = False

class CompetenceUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    heures_requises_annuelles: Optional[float] = None
    obligatoire: Optional[bool] = None

class Grade(BaseModel):
    """Grade hiÃ©rarchique pour les pompiers"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    niveau_hierarchique: int  # 1 = niveau le plus bas, 10 = niveau le plus haut
    est_officier: bool = False  # True si ce grade est considÃ©rÃ© comme un officier
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class GradeCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    niveau_hierarchique: int
    est_officier: bool = False

class GradeUpdate(BaseModel):
    nom: Optional[str] = None
    niveau_hierarchique: Optional[int] = None
    est_officier: Optional[bool] = None

class ParametresFormations(BaseModel):
    """ParamÃ¨tres globaux formations pour NFPA 1500"""
    tenant_id: str
    heures_minimales_annuelles: float = 100.0
    pourcentage_presence_minimum: float = 80.0
    delai_notification_liste_attente: int = 7  # jours
    email_notifications_actif: bool = True
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ValidationCompetence(BaseModel):
    """Validation manuelle d'une compÃ©tence pour un employÃ©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    competence_id: str
    justification: str
    date_validation: str  # Date au format ISO
    validee_par: str  # ID de l'administrateur qui a validÃ©
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ValidationCompetenceCreate(BaseModel):
    user_id: str
    competence_id: str
    justification: str
    date_validation: str

# Alias pour compatibilitÃ© avec anciennes routes
SessionFormation = Formation
SessionFormationCreate = FormationCreate

class Disponibilite(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    date: str  # Date exacte YYYY-MM-DD
    type_garde_id: Optional[str] = None  # SpÃ©cifier pour quel type de garde
    heure_debut: str
    heure_fin: str
    statut: str = "disponible"  # disponible, indisponible, preference
    origine: str = "manuelle"  # manuelle, montreal_7_24, quebec_10_14, personnalisee
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DisponibiliteCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    user_id: str
    date: str  # Date exacte YYYY-MM-DD
    type_garde_id: Optional[str] = None
    heure_debut: str
    heure_fin: str
    statut: str = "disponible"
    origine: str = "manuelle"  # manuelle, montreal_7_24, quebec_10_14, personnalisee

class IndisponibiliteGenerate(BaseModel):
    user_id: str
    horaire_type: str  # "montreal" ou "quebec"
    equipe: str  # "Rouge", "Jaune", "Bleu", "Vert"
    date_debut: str  # Date de dÃ©but (YYYY-MM-DD)
    date_fin: str  # Date de fin (YYYY-MM-DD)
    date_jour_1: Optional[str] = None  # Pour Quebec 10/14, date du Jour 1 du cycle (YYYY-MM-DD)
    conserver_manuelles: bool = True  # Conserver les modifications manuelles lors de la rÃ©gÃ©nÃ©ration

class DisponibiliteReinitialiser(BaseModel):
    user_id: str
    periode: str  # "semaine", "mois", "annee", "personnalisee"
    mode: str  # "tout" ou "generees_seulement"
    type_entree: str = "les_deux"  # "disponibilites", "indisponibilites", "les_deux"
    date_debut: Optional[str] = None  # Pour pÃ©riode personnalisÃ©e (YYYY-MM-DD)
    date_fin: Optional[str] = None  # Pour pÃ©riode personnalisÃ©e (YYYY-MM-DD)

class ConflictResolution(BaseModel):
    """Historique des rÃ©solutions de conflits disponibilitÃ©/indisponibilitÃ©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str  # Utilisateur qui a crÃ©Ã© et rÃ©solu le conflit
    affected_user_id: str  # Utilisateur dont les dispos/indispos sont affectÃ©es
    action: str  # "supprimer_conflits", "creer_quand_meme", "annuler"
    type_created: str  # "disponibilite" ou "indisponibilite"
    conflicts_deleted: List[Dict[str, Any]] = []  # Liste des Ã©lÃ©ments supprimÃ©s
    created_item: Optional[Dict[str, Any]] = None  # L'Ã©lÃ©ment crÃ©Ã©
    resolved_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ConflictDetail(BaseModel):
    """DÃ©tails d'un conflit dÃ©tectÃ©"""
    conflict_id: str
    conflict_type: str  # "disponibilite" ou "indisponibilite"
    date: str
    heure_debut: str
    heure_fin: str
    type_garde_id: Optional[str] = None
    type_garde_nom: Optional[str] = None
    statut: str
    overlap_start: str  # DÃ©but du chevauchement
    overlap_end: str  # Fin du chevauchement

class DeviceToken(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    device_token: str
    platform: str  # "ios" ou "android"
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DeviceTokenRegister(BaseModel):
    user_id: str
    device_token: str
    platform: str

class PushNotificationSend(BaseModel):
    user_ids: List[str]
    title: str
    body: str
    data: Optional[dict] = None

class Statistiques(BaseModel):
    personnel_actif: int
    gardes_cette_semaine: int
    formations_planifiees: int
    taux_couverture: float
    heures_travaillees: int
    remplacements_effectues: int

# ==================== GESTION DES ACTIFS MODELS ====================

class LocalisationGPS(BaseModel):
    lat: float
    lng: float

class Vehicule(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Nom/Identifiant du vÃ©hicule (ex: "391", "Autopompe 1")
    type_vehicule: Optional[str] = None  # ex: Autopompe, Citerne, Pick-up, Ã‰chelle
    marque: Optional[str] = None
    modele: Optional[str] = None
    annee: Optional[int] = None
    kilometrage: Optional[float] = None
    vin: Optional[str] = None  # NumÃ©ro d'identification du vÃ©hicule
    statut: str = "actif"  # actif, maintenance, retraite
    date_mise_service: Optional[str] = None  # Date format YYYY-MM-DD
    modele_inventaire_id: Optional[str] = None  # ModÃ¨le d'inventaire assignÃ©
    photos: List[str] = []  # URLs ou base64 des photos
    documents: List[Dict[str, str]] = []  # [{nom: "doc.pdf", url: "..."}]
    notes: Optional[str] = None
    # Inspection SAAQ
    derniere_inspection_id: Optional[str] = None
    derniere_inspection_date: Optional[str] = None
    # QR Code
    qr_code: Optional[str] = None  # QR code en base64
    qr_code_url: Optional[str] = None  # URL encodÃ©e dans le QR code
    # Fiche de vie (audit trail)
    logs: List[Dict[str, Any]] = []  # Historique complet des actions
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class VehiculeCreate(BaseModel):
    nom: str
    type_vehicule: Optional[str] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    annee: Optional[int] = None
    kilometrage: Optional[float] = None
    vin: Optional[str] = None
    statut: str = "actif"
    date_mise_service: Optional[str] = None
    photos: List[str] = []
    documents: List[Dict[str, str]] = []
    notes: Optional[str] = None

class VehiculeUpdate(BaseModel):
    nom: Optional[str] = None
    type_vehicule: Optional[str] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    annee: Optional[int] = None
    kilometrage: Optional[float] = None
    vin: Optional[str] = None
    statut: Optional[str] = None
    date_mise_service: Optional[str] = None
    modele_inventaire_id: Optional[str] = None
    photos: Optional[List[str]] = None
    documents: Optional[List[Dict[str, str]]] = None
    notes: Optional[str] = None

class BorneIncendie(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Nom de la borne (ex: "Allen", "Borne Wallace")
    type_borne: str  # "seche" ou "fontaine"
    localisation_gps: Optional[LocalisationGPS] = None
    adresse: Optional[str] = None
    transversale: Optional[str] = None  # Chemin transversal
    municipalite: Optional[str] = None
    debit: Optional[str] = None  # DÃ©bit en GPM ou autre
    statut: str = "operationnelle"  # operationnelle, hors_service, a_verifier
    date_derniere_inspection: Optional[str] = None  # Date format YYYY-MM-DD
    lien_maps: Optional[str] = None  # Lien Google Maps
    photos: List[str] = []  # URLs ou base64 des photos
    schemas: List[str] = []  # SchÃ©mas techniques
    notes_importantes: Optional[str] = None
    # QR Code
    qr_code: Optional[str] = None  # QR code en base64
    qr_code_url: Optional[str] = None  # URL encodÃ©e dans le QR code
    # Fiche de vie (audit trail)
    logs: List[Dict[str, Any]] = []  # Historique complet des actions
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BorneIncendieCreate(BaseModel):
    nom: str
    type_borne: str  # "seche" ou "fontaine"
    localisation_gps: Optional[LocalisationGPS] = None
    adresse: Optional[str] = None
    transversale: Optional[str] = None
    municipalite: Optional[str] = None
    debit: Optional[str] = None
    statut: str = "operationnelle"
    date_derniere_inspection: Optional[str] = None
    lien_maps: Optional[str] = None
    photos: List[str] = []
    schemas: List[str] = []
    notes_importantes: Optional[str] = None

class BorneIncendieUpdate(BaseModel):
    nom: Optional[str] = None
    type_borne: Optional[str] = None
    localisation_gps: Optional[LocalisationGPS] = None
    adresse: Optional[str] = None
    transversale: Optional[str] = None
    municipalite: Optional[str] = None
    debit: Optional[str] = None
    statut: Optional[str] = None
    date_derniere_inspection: Optional[str] = None
    lien_maps: Optional[str] = None
    photos: Optional[List[str]] = None
    schemas: Optional[List[str]] = None
    notes_importantes: Optional[str] = None

# ==================== INVENTAIRES VÃ‰HICULES MODELS ====================

class ItemInventaire(BaseModel):
    """Un item dans une section d'inventaire"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str  # Ex: "Masque bleu chirurgical"
    type_item: str = "checkbox"  # checkbox, text, number
    obligatoire: bool = False
    ordre: int = 0  # Pour l'affichage

class SectionInventaire(BaseModel):
    """Une section dans un modÃ¨le d'inventaire"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str  # Ex: "Cabine"
    description: Optional[str] = None
    photos_reference: List[str] = []  # Photos du compartiment pour guider
    items: List[ItemInventaire] = []
    ordre: int = 0

class ModeleInventaire(BaseModel):
    """Template d'inventaire pour un type de vÃ©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Inventaire Autopompe 391"
    description: Optional[str] = None
    type_vehicule: Optional[str] = None  # Pour filtrer
    sections: List[SectionInventaire] = []
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ModeleInventaireCreate(BaseModel):
    nom: str
    description: Optional[str] = None
    type_vehicule: Optional[str] = None
    sections: List[SectionInventaire] = []

class ModeleInventaireUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    type_vehicule: Optional[str] = None
    sections: Optional[List[SectionInventaire]] = None

class ResultatItemInspection(BaseModel):
    """RÃ©sultat pour un item lors d'une inspection"""
    item_id: str
    section_id: str
    statut: str  # "present", "absent", "non_applicable"
    notes: Optional[str] = None
    photo_url: Optional[str] = None  # Photo de l'item si problÃ¨me

class InspectionInventaire(BaseModel):
    """Inspection d'inventaire d'un vÃ©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    vehicule_id: str
    modele_inventaire_id: str
    inspecteur_id: str  # User qui fait l'inspection
    inspecteur_nom: Optional[str] = None
    date_inspection: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    statut: str = "en_cours"  # en_cours, complete
    resultats: List[ResultatItemInspection] = []
    notes_generales: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    completed_at: Optional[datetime] = None

class InspectionInventaireCreate(BaseModel):
    vehicule_id: str
    modele_inventaire_id: str
    inspecteur_id: str

class InspectionInventaireUpdate(BaseModel):
    statut: Optional[str] = None
    resultats: Optional[List[ResultatItemInspection]] = None
    notes_generales: Optional[str] = None

# Helper functions

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), tenant_slug: str = None):
    """
    Authentifie l'utilisateur et vÃ©rifie qu'il appartient au tenant
    tenant_slug est optionnel pour compatibilitÃ© avec les routes qui ne l'utilisent pas encore
    """
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        tenant_id: str = payload.get("tenant_id")  # Tenant ID stockÃ© dans le token
        
        if user_id is None:
            raise HTTPException(status_code=401, detail="Token invalide")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token invalide")
    
    user = await db.users.find_one({"id": user_id})
    if user is None:
        raise HTTPException(status_code=401, detail="Utilisateur non trouvÃ©")
    
    # VÃ©rifier que l'utilisateur appartient au tenant si tenant_slug est fourni
    if tenant_slug:
        tenant = await get_tenant_from_slug(tenant_slug)
        if user.get("tenant_id") != tenant.id:
            raise HTTPException(status_code=403, detail="AccÃ¨s interdit Ã  cette caserne")
    
    return User(**user)

async def trouver_opportunites_regroupement(
    date_str: str,
    types_garde: list,
    existing_assignations: list,
    duree_max: int,
    tenant_id: str
):
    """
    Trouve les opportunitÃ©s de regroupement de gardes pour une date donnÃ©e
    
    Returns:
        List de tuples (type_garde_1, type_garde_2_or_None, date_2_or_None) reprÃ©sentant les regroupements possibles
    """
    opportunites = []
    date_obj = datetime.strptime(date_str, "%Y-%m-%d")
    date_suivante_str = (date_obj + timedelta(days=1)).strftime("%Y-%m-%d")
    
    # 1. MÃŠME JOURNÃ‰E: Chercher des gardes qui peuvent se regrouper dans la mÃªme journÃ©e
    gardes_date = [tg for tg in types_garde]
    
    for i, tg1 in enumerate(gardes_date):
        # Chercher dans les gardes suivantes
        for tg2 in gardes_date[i+1:]:
            duree_totale = tg1.get("duree_heures", 8) + tg2.get("duree_heures", 8)
            
            if duree_totale <= duree_max:
                # VÃ©rifier qu'elles ne sont pas dÃ©jÃ  assignÃ©es
                assignations_tg1 = [a for a in existing_assignations 
                                   if a["date"] == date_str and a["type_garde_id"] == tg1["id"]]
                assignations_tg2 = [a for a in existing_assignations 
                                   if a["date"] == date_str and a["type_garde_id"] == tg2["id"]]
                
                places_tg1 = tg1.get("nombre_pompiers_requis", 1) - len(assignations_tg1)
                places_tg2 = tg2.get("nombre_pompiers_requis", 1) - len(assignations_tg2)
                
                if places_tg1 > 0 and places_tg2 > 0:
                    # OpportunitÃ© de regroupement mÃªme journÃ©e
                    opportunites.append({
                        "type": "meme_journee",
                        "garde1": tg1,
                        "garde2": tg2,
                        "date1": date_str,
                        "date2": date_str,
                        "duree_totale": duree_totale
                    })
    
    # 2. JOURS CONSÃ‰CUTIFS: Chercher des gardes sur jour J et J+1
    for tg1 in types_garde:
        for tg2 in types_garde:
            duree_totale = tg1.get("duree_heures", 8) + tg2.get("duree_heures", 8)
            
            if duree_totale <= duree_max:
                # VÃ©rifier qu'elles ne sont pas dÃ©jÃ  assignÃ©es
                assignations_tg1 = [a for a in existing_assignations 
                                   if a["date"] == date_str and a["type_garde_id"] == tg1["id"]]
                assignations_tg2 = [a for a in existing_assignations 
                                   if a["date"] == date_suivante_str and a["type_garde_id"] == tg2["id"]]
                
                places_tg1 = tg1.get("nombre_pompiers_requis", 1) - len(assignations_tg1)
                places_tg2 = tg2.get("nombre_pompiers_requis", 1) - len(assignations_tg2)
                
                if places_tg1 > 0 and places_tg2 > 0:
                    # OpportunitÃ© de regroupement jours consÃ©cutifs
                    opportunites.append({
                        "type": "jours_consecutifs",
                        "garde1": tg1,
                        "garde2": tg2,
                        "date1": date_str,
                        "date2": date_suivante_str,
                        "duree_totale": duree_totale
                    })
    
    return opportunites

async def calculer_heures_employe_periode(user_id: str, tenant_id: str, date_reference: str, periode: str, jours_personnalises: int = 7):
    """
    Calcule les heures travaillÃ©es par un employÃ© sur une pÃ©riode donnÃ©e
    
    Args:
        user_id: ID de l'employÃ©
        tenant_id: ID du tenant
        date_reference: Date de rÃ©fÃ©rence (format YYYY-MM-DD)
        periode: Type de pÃ©riode ("semaine", "mois", "personnalise")
        jours_personnalises: Nombre de jours si pÃ©riode personnalisÃ©e
    
    Returns:
        Nombre d'heures travaillÃ©es sur la pÃ©riode
    """
    date_ref = datetime.strptime(date_reference, "%Y-%m-%d")
    
    # Calculer date_debut et date_fin selon la pÃ©riode
    if periode == "semaine":
        # Du lundi au dimanche de la semaine en cours
        date_debut = date_ref - timedelta(days=date_ref.weekday())
        date_fin = date_debut + timedelta(days=6)
    elif periode == "mois":
        # Du 1er au dernier jour du mois
        date_debut = date_ref.replace(day=1)
        # Dernier jour du mois
        if date_ref.month == 12:
            date_fin = date_ref.replace(day=31)
        else:
            date_fin = (date_ref.replace(month=date_ref.month + 1, day=1) - timedelta(days=1))
    else:  # personnalise
        # X jours glissants avant la date de rÃ©fÃ©rence
        date_debut = date_ref - timedelta(days=jours_personnalises - 1)
        date_fin = date_ref
    
    date_debut_str = date_debut.strftime("%Y-%m-%d")
    date_fin_str = date_fin.strftime("%Y-%m-%d")
    
    # RÃ©cupÃ©rer toutes les assignations de l'employÃ© sur cette pÃ©riode
    assignations = await db.assignations.find({
        "user_id": user_id,
        "tenant_id": tenant_id,
        "date": {
            "$gte": date_debut_str,
            "$lte": date_fin_str
        }
    }).to_list(1000)
    
    # Calculer le total des heures
    total_heures = 0
    for assignation in assignations:
        # RÃ©cupÃ©rer le type de garde pour obtenir la durÃ©e
        type_garde = await db.types_garde.find_one({"id": assignation["type_garde_id"]})
        if type_garde:
            total_heures += type_garde.get("duree_heures", 8)
    
    return total_heures

# Root route
@api_router.get("/")
async def root():
    return {"message": "ProFireManager API v2.0 - Multi-Tenant", "status": "running"}


# ==================== DÃ‰BOGAGE MODELS ====================

class CommentaireDebogage(BaseModel):
    user_id: str
    user_name: str
    texte: str
    date: datetime

class HistoriqueStatut(BaseModel):
    ancien_statut: str
    nouveau_statut: str
    user_id: str
    user_name: str
    date: datetime

class BugReport(BaseModel):
    id: str
    titre: str
    description: str
    module: str  # Planning, Mes DisponibilitÃ©s, Personnel, etc.
    priorite: str  # critique, haute, moyenne, basse
    etapes_reproduction: str
    resultat_attendu: str
    resultat_observe: str
    navigateur: Optional[str] = None
    os: Optional[str] = None
    role_utilisateur: Optional[str] = None
    console_logs: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []  # URLs des images
    statut: str = "nouveau"  # nouveau, en_cours, test, resolu, ferme
    commentaires: Optional[List[dict]] = []
    historique_statuts: Optional[List[dict]] = []
    created_by: str
    created_by_name: str
    created_at: datetime
    updated_at: datetime
    tenant_slug: Optional[str] = None  # Si bug liÃ© Ã  un tenant spÃ©cifique

class BugReportCreate(BaseModel):
    titre: str
    description: str
    module: str
    priorite: str
    etapes_reproduction: str
    resultat_attendu: str
    resultat_observe: str
    navigateur: Optional[str] = None
    os: Optional[str] = None
    role_utilisateur: Optional[str] = None
    console_logs: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []
    tenant_slug: Optional[str] = None

class FeatureRequest(BaseModel):
    id: str
    titre: str
    description: str
    probleme_a_resoudre: str
    solution_proposee: str
    alternatives: Optional[str] = None
    module: str
    priorite: str
    utilisateurs_concernes: List[str] = []  # admin, superviseur, employe, tous
    cas_usage: str
    dependances: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []
    statut: str = "nouveau"
    commentaires: Optional[List[dict]] = []
    historique_statuts: Optional[List[dict]] = []
    created_by: str
    created_by_name: str
    created_at: datetime
    updated_at: datetime

class FeatureRequestCreate(BaseModel):
    titre: str
    description: str
    probleme_a_resoudre: str
    solution_proposee: str
    alternatives: Optional[str] = None
    module: str
    priorite: str
    utilisateurs_concernes: List[str] = []
    cas_usage: str
    dependances: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []

class CommentaireDeDebogageCreate(BaseModel):
    texte: str

class ChangementStatut(BaseModel):
    nouveau_statut: str

# ==================== SUPER ADMIN DEPENDENCIES ====================

async def get_super_admin(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Authentifie et retourne le super admin"""
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        admin_id: str = payload.get("sub")
        role: str = payload.get("role")
        
        if role != "super_admin":
            raise HTTPException(status_code=403, detail="AccÃ¨s super admin requis")
            
        admin = await db.super_admins.find_one({"id": admin_id})
        if not admin:
            raise HTTPException(status_code=401, detail="Super admin non trouvÃ©")
        return SuperAdmin(**admin)
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token invalide")

# ==================== SUPER ADMIN ROUTES ====================
# Note: Super Admin routes MUST be defined before tenant routes to avoid conflicts

@api_router.post("/admin/auth/login")
async def super_admin_login(login: SuperAdminLogin):
    """Authentification du super admin avec migration automatique SHA256 -> bcrypt"""
    try:
        logging.info(f"ğŸ”‘ Tentative de connexion Super Admin: {login.email}")
        
        admin_data = await db.super_admins.find_one({"email": login.email})
        
        if not admin_data:
            logging.warning(f"âŒ Super Admin non trouvÃ©: {login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"âœ… Super Admin trouvÃ©: {admin_data.get('nom')} (id: {admin_data.get('id')})")
        
        current_hash = admin_data.get("mot_de_passe_hash", "")
        hash_type = "bcrypt" if current_hash.startswith('$2') else "SHA256"
        logging.info(f"ğŸ” Type de hash dÃ©tectÃ©: {hash_type}")
        
        if not verify_password(login.mot_de_passe, current_hash):
            logging.warning(f"âŒ Mot de passe incorrect pour Super Admin {login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"âœ… Mot de passe vÃ©rifiÃ© avec succÃ¨s pour Super Admin {login.email}")
        
        admin = SuperAdmin(**admin_data)
        access_token = create_access_token(data={"sub": admin.id, "role": "super_admin"})
        
        logging.info(f"âœ… Token JWT crÃ©Ã© pour Super Admin {login.email}")
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "admin": {
                "id": admin.id,
                "email": admin.email,
                "nom": admin.nom
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur inattendue lors du login Super Admin pour {login.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

@api_router.get("/admin/auth/me")
async def get_super_admin_me(admin: SuperAdmin = Depends(get_super_admin)):
    """RÃ©cupÃ¨re les informations du super admin authentifiÃ©"""
    return {
        "id": admin.id,
        "email": admin.email,
        "nom": admin.nom,
        "role": "super_admin"
    }

@api_router.get("/admin/tenants")
async def list_tenants(admin: SuperAdmin = Depends(get_super_admin)):
    """Liste toutes les casernes (actives et inactives) avec compteur de personnel"""
    # RÃ©cupÃ©rer TOUTES les casernes (pas de filtre) pour que le Super Admin puisse tout voir
    tenants_data = await db.tenants.find({}).to_list(100)
    
    # Ajouter le compteur d'employÃ©s pour chaque tenant
    tenants_with_counts = []
    for tenant_data in tenants_data:
        # Supprimer _id (ObjectId non sÃ©rialisable)
        if '_id' in tenant_data:
            del tenant_data['_id']
        
        # Compter le nombre d'employÃ©s
        nombre_employes = await db.users.count_documents({"tenant_id": tenant_data['id']})
        tenant_data['nombre_employes'] = nombre_employes
        
        # Normaliser le statut actif (gÃ©rer les deux champs actif et is_active)
        # Pour compatibilitÃ© avec anciennes et nouvelles donnÃ©es
        if 'is_active' not in tenant_data and 'actif' in tenant_data:
            tenant_data['is_active'] = tenant_data['actif']
        elif 'is_active' in tenant_data and 'actif' not in tenant_data:
            tenant_data['actif'] = tenant_data['is_active']
        
        tenants_with_counts.append(tenant_data)
    
    return tenants_with_counts

@api_router.get("/admin/stats")
async def get_global_stats(admin: SuperAdmin = Depends(get_super_admin)):
    """Statistiques globales avec calcul des revenus mensuels"""
    # RÃ©cupÃ©rer tous les tenants pour gÃ©rer les deux champs actif et is_active
    tous_tenants = await db.tenants.find({}).to_list(100)
    
    total_casernes_actives = 0
    total_casernes_inactives = 0
    tenants_actifs = []
    
    # Analyser chaque tenant pour dÃ©terminer son statut
    for tenant in tous_tenants:
        # Un tenant est actif si actif=True OU is_active=True
        is_active = tenant.get('actif', False) or tenant.get('is_active', False)
        
        if is_active:
            total_casernes_actives += 1
            tenants_actifs.append(tenant)
        else:
            total_casernes_inactives += 1
    
    # Calculer les revenus mensuels
    revenus_mensuels = 0
    total_pompiers = 0
    details_revenus = []
    
    for tenant in tenants_actifs:
        # Exclure la caserne "dÃ©monstration" du calcul des revenus (compte dÃ©mo client)
        tenant_slug = tenant.get('slug', '').lower()
        tenant_nom = tenant.get('nom', '').lower()
        
        is_demo = 'demonstration' in tenant_slug or 'demonstration' in tenant_nom or 'demo' in tenant_slug
        
        # Compter les pompiers de cette caserne
        user_count = await db.users.count_documents({"tenant_id": tenant["id"]})
        
        # Ajouter au total uniquement si ce n'est pas une caserne de dÃ©mo
        if not is_demo:
            total_pompiers += user_count
        
        # DÃ©terminer le prix par pompier selon le palier
        if user_count <= 30:
            prix_par_pompier = 12
        elif user_count <= 50:
            prix_par_pompier = 20
        else:
            prix_par_pompier = 27
        
        # Calculer le revenu pour cette caserne (0 si dÃ©mo)
        revenu_caserne = 0 if is_demo else (user_count * prix_par_pompier)
        revenus_mensuels += revenu_caserne
        
        details_revenus.append({
            "caserne": tenant["nom"],
            "pompiers": user_count,
            "prix_par_pompier": prix_par_pompier if not is_demo else 0,
            "revenu_mensuel": revenu_caserne,
            "is_demo": is_demo
        })
    
    return {
        "casernes_actives": total_casernes_actives,
        "casernes_inactives": total_casernes_inactives,
        "total_pompiers": total_pompiers,
        "revenus_mensuels": revenus_mensuels,
        "details_par_caserne": details_revenus
    }

@api_router.get("/admin/tenants/by-slug/{tenant_slug}")
async def get_tenant_by_slug(tenant_slug: str):
    """RÃ©cupÃ©rer un tenant par son slug (pour rÃ©cupÃ©rer les paramÃ¨tres)"""
    tenant = await db.tenants.find_one({"slug": tenant_slug})
    if not tenant:
        raise HTTPException(status_code=404, detail="Tenant non trouvÃ©")
    
    return clean_mongo_doc(tenant)

@api_router.post("/admin/tenants")
async def create_tenant(tenant_create: TenantCreate, admin: SuperAdmin = Depends(get_super_admin)):
    """CrÃ©er une nouvelle caserne"""
    # VÃ©rifier que le slug est unique
    existing = await db.tenants.find_one({"slug": tenant_create.slug})
    if existing:
        raise HTTPException(status_code=400, detail="Ce slug est dÃ©jÃ  utilisÃ©")
    
    # CrÃ©er le tenant avec date personnalisÃ©e si fournie
    tenant_data = tenant_create.dict()
    if tenant_data.get('date_creation'):
        # Convertir la date string en datetime
        from datetime import datetime as dt
        tenant_data['date_creation'] = dt.fromisoformat(tenant_data['date_creation']).replace(tzinfo=timezone.utc)
    else:
        tenant_data['date_creation'] = datetime.now(timezone.utc)
    
    tenant = Tenant(**tenant_data)
    await db.tenants.insert_one(tenant.dict())
    
    return {"message": f"Caserne '{tenant.nom}' crÃ©Ã©e avec succÃ¨s", "tenant": tenant}

@api_router.put("/admin/tenants/{tenant_id}")
async def update_tenant(
    tenant_id: str, 
    tenant_update: dict,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Modifier une caserne"""
    update_data = tenant_update.copy()
    
    # Supprimer les champs calculÃ©s qui ne doivent pas Ãªtre sauvegardÃ©s
    if 'nombre_employes' in update_data:
        del update_data['nombre_employes']
    if '_id' in update_data:
        del update_data['_id']
    
    # GÃ©rer la date_creation si modifiÃ©e
    if update_data.get('date_creation') and isinstance(update_data['date_creation'], str):
        from datetime import datetime as dt
        update_data['date_creation'] = dt.fromisoformat(update_data['date_creation']).replace(tzinfo=timezone.utc)
    
    result = await db.tenants.update_one(
        {"id": tenant_id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Caserne non trouvÃ©e")
    
    return {"message": "Caserne mise Ã  jour avec succÃ¨s"}

@api_router.post("/admin/tenants/{tenant_id}/create-admin")
async def create_tenant_admin(tenant_id: str, user_data: dict, admin: SuperAdmin = Depends(get_super_admin)):
    """CrÃ©er un administrateur pour une caserne"""
    # VÃ©rifier que la caserne existe
    tenant = await db.tenants.find_one({"id": tenant_id})
    if not tenant:
        raise HTTPException(status_code=404, detail="Caserne non trouvÃ©e")
    
    # VÃ©rifier que l'email n'existe pas dÃ©jÃ 
    existing_user = await db.users.find_one({"email": user_data["email"]})
    if existing_user:
        raise HTTPException(status_code=400, detail="Un utilisateur avec cet email existe dÃ©jÃ ")
    
    # CrÃ©er l'utilisateur administrateur
    new_user = User(
        id=str(uuid.uuid4()),
        tenant_id=tenant_id,
        email=user_data["email"],
        prenom=user_data["prenom"],
        nom=user_data["nom"],
        mot_de_passe_hash=get_password_hash(user_data["mot_de_passe"]),
        role="admin",
        grade="Directeur",
        type_emploi="temps_plein",
        statut="Actif",
        numero_employe="ADMIN-" + str(uuid.uuid4())[:8].upper(),
        date_embauche=datetime.now(timezone.utc).strftime("%Y-%m-%d")
    )
    
    await db.users.insert_one(new_user.dict())
    
    # Envoyer l'email de bienvenue (sans bloquer si Ã§a Ã©choue)
    try:
        send_welcome_email(
            user_email=new_user.email,
            user_name=f"{new_user.prenom} {new_user.nom}",
            user_role=new_user.role,
            temp_password=user_data["mot_de_passe"],
            tenant_slug=tenant['slug']
        )
    except Exception as e:
        print(f"âš ï¸ Erreur envoi email de bienvenue: {e}")
        # Continue mÃªme si l'email Ã©choue
    
    return {
        "message": "Administrateur crÃ©Ã© avec succÃ¨s",
        "user": {
            "id": new_user.id,
            "email": new_user.email,
            "nom": new_user.nom,
            "prenom": new_user.prenom,
            "role": new_user.role
        }
    }

@api_router.get("/admin/tenants/{tenant_id}/deletion-impact")
async def get_deletion_impact(tenant_id: str, admin: SuperAdmin = Depends(get_super_admin)):
    """Obtenir l'impact de la suppression d'une caserne (nombre de donnÃ©es affectÃ©es)"""
    tenant = await db.tenants.find_one({"id": tenant_id})
    if not tenant:
        raise HTTPException(status_code=404, detail="Caserne non trouvÃ©e")
    
    # Compter toutes les donnÃ©es qui seront supprimÃ©es
    users_count = await db.users.count_documents({"tenant_id": tenant_id})
    assignations_count = await db.assignations.count_documents({"tenant_id": tenant_id})
    formations_count = await db.formations.count_documents({"tenant_id": tenant_id})
    epi_count = await db.epi_employes.count_documents({"tenant_id": tenant_id})
    gardes_count = await db.types_garde.count_documents({"tenant_id": tenant_id})
    disponibilites_count = await db.disponibilites.count_documents({"tenant_id": tenant_id})
    conges_count = await db.demandes_conge.count_documents({"tenant_id": tenant_id})
    
    return {
        "tenant": {
            "id": tenant["id"],
            "nom": tenant["nom"],
            "slug": tenant["slug"]
        },
        "impact": {
            "utilisateurs": users_count,
            "assignations": assignations_count,
            "formations": formations_count,
            "epi": epi_count,
            "gardes": gardes_count,
            "disponibilites": disponibilites_count,
            "conges": conges_count
        }
    }

@api_router.delete("/admin/tenants/{tenant_id}")
async def delete_tenant_permanently(tenant_id: str, admin: SuperAdmin = Depends(get_super_admin)):
    """Supprimer dÃ©finitivement une caserne et toutes ses donnÃ©es"""
    tenant = await db.tenants.find_one({"id": tenant_id})
    if not tenant:
        raise HTTPException(status_code=404, detail="Caserne non trouvÃ©e")
    
    # Supprimer toutes les donnÃ©es associÃ©es
    users_result = await db.users.delete_many({"tenant_id": tenant_id})
    await db.assignations.delete_many({"tenant_id": tenant_id})
    await db.formations.delete_many({"tenant_id": tenant_id})
    await db.epi_employes.delete_many({"tenant_id": tenant_id})
    await db.types_garde.delete_many({"tenant_id": tenant_id})
    await db.disponibilites.delete_many({"tenant_id": tenant_id})
    await db.demandes_conge.delete_many({"tenant_id": tenant_id})
    await db.demandes_remplacement.delete_many({"tenant_id": tenant_id})
    await db.notifications.delete_many({"tenant_id": tenant_id})
    await db.parametres.delete_many({"tenant_id": tenant_id})
    await db.sessions_formation.delete_many({"tenant_id": tenant_id})
    
    # Supprimer le tenant
    await db.tenants.delete_one({"id": tenant_id})
    
    return {
        "message": f"Caserne '{tenant['nom']}' et toutes ses donnÃ©es ont Ã©tÃ© supprimÃ©es dÃ©finitivement",
        "deleted": {
            "tenant": tenant["nom"],
            "users": users_result.deleted_count
        }
    }

# ==================== TENANT-SPECIFIC ROUTES ====================
# Note: Tenant routes are defined after Super Admin routes to avoid conflicts

# Route de compatibilitÃ© (OLD - sans tenant dans URL)
@api_router.post("/auth/login")
async def login_legacy(user_login: UserLogin):
    """Login legacy - redirige automatiquement vers le tenant de l'utilisateur avec migration automatique SHA256 -> bcrypt"""
    try:
        logging.info(f"ğŸ”‘ Tentative de connexion legacy pour {user_login.email}")
        
        user_data = await db.users.find_one({"email": user_login.email})
        
        if not user_data:
            logging.warning(f"âŒ Utilisateur non trouvÃ© (legacy): {user_login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"âœ… Utilisateur trouvÃ© (legacy): {user_data.get('nom')} {user_data.get('prenom')} (id: {user_data.get('id')})")
        
        current_hash = user_data.get("mot_de_passe_hash", "")
        hash_type = "bcrypt" if current_hash.startswith('$2') else "SHA256"
        logging.info(f"ğŸ” Type de hash dÃ©tectÃ©: {hash_type}")
        
        if not verify_password(user_login.mot_de_passe, current_hash):
            logging.warning(f"âŒ Mot de passe incorrect (legacy) pour {user_login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"âœ… Mot de passe vÃ©rifiÃ© avec succÃ¨s (legacy) pour {user_login.email}")
        
        user = User(**user_data)
        tenant_data = await db.tenants.find_one({"id": user.tenant_id})
        
        if not tenant_data:
            logging.error(f"âŒ Tenant non trouvÃ© pour l'utilisateur {user_login.email}")
            raise HTTPException(status_code=404, detail="Caserne non trouvÃ©e")
        
        tenant = Tenant(**tenant_data)
        access_token = create_access_token(data={
            "sub": user.id,
            "tenant_id": tenant.id,
            "tenant_slug": tenant.slug
        })
        
        logging.info(f"âœ… Token JWT crÃ©Ã© (legacy) pour {user_login.email}")
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "tenant": {
                "id": tenant.id,
                "slug": tenant.slug,
                "nom": tenant.nom,
                "parametres": tenant.parametres  # Inclure les paramÃ¨tres du tenant
            },
            "user": {
                "id": user.id,
                "nom": user.nom,
                "prenom": user.prenom,
                "email": user.email,
                "role": user.role,
                "grade": user.grade,
                "type_emploi": user.type_emploi
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur inattendue lors du login legacy pour {user_login.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

@api_router.get("/{tenant_slug}/auth/me")
async def get_current_user_info(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant (optionnel ici car dÃ©jÃ  validÃ© dans le token)
    tenant = await get_tenant_from_slug(tenant_slug)
    
    return {
        "id": current_user.id,
        "tenant_id": current_user.tenant_id,
        "nom": current_user.nom,
        "prenom": current_user.prenom,
        "email": current_user.email,
        "role": current_user.role,
        "grade": current_user.grade,
        "type_emploi": current_user.type_emploi,
        "formations": current_user.formations
    }


# ==================== DÃ‰BOGAGE ROUTES (BUGS & FEATURES) ====================

@api_router.get("/admin/bugs")
async def list_bugs(
    statut: Optional[str] = None,
    priorite: Optional[str] = None,
    module: Optional[str] = None,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Liste tous les bugs avec filtres optionnels"""
    query = {}
    if statut:
        query["statut"] = statut
    if priorite:
        query["priorite"] = priorite
    if module:
        query["module"] = module
    
    bugs = await db.bugs.find(query).sort("created_at", -1).to_list(1000)
    return [clean_mongo_doc(bug) for bug in bugs]

@api_router.post("/admin/bugs")
async def create_bug(
    bug_data: BugReportCreate,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """CrÃ©er un nouveau bug report"""
    bug_dict = bug_data.dict()
    bug_dict["id"] = str(uuid.uuid4())
    bug_dict["statut"] = "nouveau"
    bug_dict["commentaires"] = []
    bug_dict["historique_statuts"] = []
    bug_dict["created_by"] = admin.id
    bug_dict["created_by_name"] = admin.nom
    bug_dict["created_at"] = datetime.now(timezone.utc)
    bug_dict["updated_at"] = datetime.now(timezone.utc)
    
    await db.bugs.insert_one(bug_dict)
    
    # Envoyer email aux super-admins (sauf le crÃ©ateur)
    try:
        super_admins = await db.super_admins.find().to_list(100)
        # Exclure l'email du crÃ©ateur
        super_admins_emails = [sa["email"] for sa in super_admins if sa["id"] != admin.id]
        
        if super_admins_emails:  # Envoyer seulement s'il y a d'autres super-admins
            send_debogage_notification_email(
                super_admins_emails=super_admins_emails,
                type_notification="bug",
                titre=bug_data.titre,
                description=bug_data.description,
                priorite=bug_data.priorite,
                created_by=bug_dict["created_by_name"],
                item_id=bug_dict["id"]
            )
    except Exception as e:
        print(f"[ERROR] Erreur envoi email notification bug: {e}")
    
    return clean_mongo_doc(bug_dict)

@api_router.get("/admin/bugs/{bug_id}")
async def get_bug(
    bug_id: str,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """RÃ©cupÃ©rer un bug spÃ©cifique"""
    bug = await db.bugs.find_one({"id": bug_id})
    if not bug:
        raise HTTPException(status_code=404, detail="Bug non trouvÃ©")
    return clean_mongo_doc(bug)

@api_router.put("/admin/bugs/{bug_id}/statut")
async def update_bug_statut(
    bug_id: str,
    statut_data: ChangementStatut,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Changer le statut d'un bug"""
    bug = await db.bugs.find_one({"id": bug_id})
    if not bug:
        raise HTTPException(status_code=404, detail="Bug non trouvÃ©")
    
    # Ajouter Ã  l'historique
    historique = bug.get("historique_statuts", [])
    historique.append({
        "ancien_statut": bug["statut"],
        "nouveau_statut": statut_data.nouveau_statut,
        "user_id": admin.id,
        "user_name": admin.nom,
        "date_changement": datetime.now(timezone.utc).isoformat()
    })
    
    await db.bugs.update_one(
        {"id": bug_id},
        {
            "$set": {
                "statut": statut_data.nouveau_statut,
                "historique_statuts": historique,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    # Envoyer email pour TOUT changement de statut (sauf le crÃ©ateur)
    try:
        super_admins = await db.super_admins.find().to_list(100)
        super_admins_emails = [sa["email"] for sa in super_admins if sa["id"] != admin.id]
        
        if super_admins_emails:
            # Message selon le statut
            status_labels = {
                "nouveau": "ğŸ†• Nouveau",
                "en_cours": "âš™ï¸ En cours",
                "test": "ğŸ§ª En test",
                "resolu": "âœ… RÃ©solu",
                "ferme": "ğŸ”’ FermÃ©"
            }
            status_label = status_labels.get(statut_data.nouveau_statut, statut_data.nouveau_statut)
            
            send_debogage_notification_email(
                super_admins_emails=super_admins_emails,
                type_notification="bug_status",
                titre=f"{status_label}: {bug['titre']}",
                description=f"Le statut a Ã©tÃ© changÃ© de '{bug['statut']}' Ã  '{statut_data.nouveau_statut}' par {admin.nom}",
                priorite=bug["priorite"],
                created_by=bug["created_by_name"],
                item_id=bug_id
            )
    except Exception as e:
        print(f"[ERROR] Erreur envoi email changement statut bug: {e}")
    
    updated_bug = await db.bugs.find_one({"id": bug_id})
    return clean_mongo_doc(updated_bug)

@api_router.post("/admin/bugs/{bug_id}/commentaires")
async def add_bug_comment(
    bug_id: str,
    comment_data: CommentaireDeDebogageCreate,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Ajouter un commentaire Ã  un bug"""
    bug = await db.bugs.find_one({"id": bug_id})
    if not bug:
        raise HTTPException(status_code=404, detail="Bug non trouvÃ©")
    
    commentaires = bug.get("commentaires", [])
    commentaires.append({
        "user_id": admin.id,
        "user_name": admin.nom,
        "texte": comment_data.texte,
        "date": datetime.now(timezone.utc).isoformat()
    })
    
    await db.bugs.update_one(
        {"id": bug_id},
        {
            "$set": {
                "commentaires": commentaires,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    # Envoyer email aux super-admins (sauf le crÃ©ateur du commentaire)
    try:
        super_admins = await db.super_admins.find().to_list(100)
        super_admins_emails = [sa["email"] for sa in super_admins if sa["id"] != admin.id]
        
        if super_admins_emails:
            send_debogage_notification_email(
                super_admins_emails=super_admins_emails,
                type_notification="bug_comment",
                titre=f"ğŸ’¬ Nouveau commentaire sur: {bug['titre']}",
                description=comment_data.texte,
                priorite=bug.get("priorite", "moyenne"),
                created_by=admin.nom,
                item_id=bug_id
            )
    except Exception as e:
        print(f"[ERROR] Erreur envoi email commentaire bug: {e}")
    
    updated_bug = await db.bugs.find_one({"id": bug_id})
    return clean_mongo_doc(updated_bug)

@api_router.put("/admin/bugs/{bug_id}")
async def update_bug(
    bug_id: str,
    bug_update: BugReportCreate,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Modifier un bug existant"""
    bug = await db.bugs.find_one({"id": bug_id})
    if not bug:
        raise HTTPException(status_code=404, detail="Bug non trouvÃ©")
    
    await db.bugs.update_one(
        {"id": bug_id},
        {
            "$set": {
                "titre": bug_update.titre,
                "description": bug_update.description,
                "module": bug_update.module,
                "priorite": bug_update.priorite,
                "etapes_reproduction": bug_update.etapes_reproduction,
                "resultat_attendu": bug_update.resultat_attendu,
                "resultat_observe": bug_update.resultat_observe,
                "navigateur": bug_update.navigateur,
                "os": bug_update.os,
                "role_utilisateur": bug_update.role_utilisateur,
                "console_logs": bug_update.console_logs,
                "infos_supplementaires": bug_update.infos_supplementaires,
                "images": bug_update.images,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    return {"message": "Bug modifiÃ© avec succÃ¨s"}

# ==================== FEATURE REQUESTS ROUTES ====================

@api_router.get("/admin/features")
async def list_features(
    statut: Optional[str] = None,
    priorite: Optional[str] = None,
    module: Optional[str] = None,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Liste toutes les feature requests avec filtres optionnels"""
    query = {}
    if statut:
        query["statut"] = statut
    if priorite:
        query["priorite"] = priorite
    if module:
        query["module"] = module
    
    features = await db.feature_requests.find(query).sort("created_at", -1).to_list(1000)
    return [clean_mongo_doc(feature) for feature in features]

@api_router.post("/admin/features")
async def create_feature(
    feature_data: FeatureRequestCreate,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """CrÃ©er une nouvelle feature request"""
    feature_dict = feature_data.dict()
    feature_dict["id"] = str(uuid.uuid4())
    feature_dict["statut"] = "nouveau"
    feature_dict["commentaires"] = []
    feature_dict["historique_statuts"] = []
    feature_dict["created_by"] = admin.id
    feature_dict["created_by_name"] = admin.nom
    feature_dict["created_at"] = datetime.now(timezone.utc)
    feature_dict["updated_at"] = datetime.now(timezone.utc)
    
    await db.feature_requests.insert_one(feature_dict)
    
    # Envoyer email aux super-admins (sauf le crÃ©ateur)
    try:
        super_admins = await db.super_admins.find().to_list(100)
        # Exclure l'email du crÃ©ateur
        super_admins_emails = [sa["email"] for sa in super_admins if sa["id"] != admin.id]
        
        if super_admins_emails:  # Envoyer seulement s'il y a d'autres super-admins
            send_debogage_notification_email(
                super_admins_emails=super_admins_emails,
                type_notification="feature",
                titre=feature_data.titre,
                description=feature_data.description,
                priorite=feature_data.priorite,
                created_by=feature_dict["created_by_name"],
                item_id=feature_dict["id"]
            )
    except Exception as e:
        print(f"[ERROR] Erreur envoi email notification feature: {e}")
    
    return clean_mongo_doc(feature_dict)

@api_router.get("/admin/features/{feature_id}")
async def get_feature(
    feature_id: str,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """RÃ©cupÃ©rer une feature request spÃ©cifique"""
    feature = await db.feature_requests.find_one({"id": feature_id})
    if not feature:
        raise HTTPException(status_code=404, detail="Feature request non trouvÃ©e")
    return clean_mongo_doc(feature)

@api_router.put("/admin/features/{feature_id}/statut")
async def update_feature_statut(
    feature_id: str,
    statut_data: ChangementStatut,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Changer le statut d'une feature request"""
    feature = await db.feature_requests.find_one({"id": feature_id})
    if not feature:
        raise HTTPException(status_code=404, detail="Feature request non trouvÃ©e")
    
    # Ajouter Ã  l'historique
    historique = feature.get("historique_statuts", [])
    historique.append({
        "ancien_statut": feature["statut"],
        "nouveau_statut": statut_data.nouveau_statut,
        "user_id": admin.id,
        "user_name": admin.nom,
        "date_changement": datetime.now(timezone.utc).isoformat()
    })
    
    await db.feature_requests.update_one(
        {"id": feature_id},
        {
            "$set": {
                "statut": statut_data.nouveau_statut,
                "historique_statuts": historique,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    # Envoyer email pour changement de statut (sauf le crÃ©ateur)
    try:
        super_admins = await db.super_admins.find().to_list(100)
        super_admins_emails = [sa["email"] for sa in super_admins if sa["id"] != admin.id]
        
        if super_admins_emails:
            status_labels = {
                "nouveau": "ğŸ†• Nouveau",
                "en_cours": "âš™ï¸ En cours",
                "test": "ğŸ§ª En test",
                "resolu": "âœ… RÃ©solu",
                "ferme": "ğŸ”’ FermÃ©"
            }
            status_label = status_labels.get(statut_data.nouveau_statut, statut_data.nouveau_statut)
            
            send_debogage_notification_email(
                super_admins_emails=super_admins_emails,
                type_notification="feature_status",
                titre=f"{status_label}: {feature['titre']}",
                description=f"Le statut a Ã©tÃ© changÃ© de '{feature['statut']}' Ã  '{statut_data.nouveau_statut}' par {admin.nom}",
                priorite=feature.get("priorite", "moyenne"),
                created_by=feature["created_by_name"],
                item_id=feature_id
            )
    except Exception as e:
        print(f"[ERROR] Erreur envoi email changement statut feature: {e}")
    
    updated_feature = await db.feature_requests.find_one({"id": feature_id})
    return clean_mongo_doc(updated_feature)

@api_router.post("/admin/features/{feature_id}/commentaires")
async def add_feature_comment(
    feature_id: str,
    comment_data: CommentaireDeDebogageCreate,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Ajouter un commentaire Ã  une feature request"""
    feature = await db.feature_requests.find_one({"id": feature_id})
    if not feature:
        raise HTTPException(status_code=404, detail="Feature request non trouvÃ©e")
    
    commentaires = feature.get("commentaires", [])
    commentaires.append({
        "user_id": admin.id,
        "user_name": admin.nom,
        "texte": comment_data.texte,
        "date": datetime.now(timezone.utc).isoformat()
    })
    
    await db.feature_requests.update_one(
        {"id": feature_id},
        {
            "$set": {
                "commentaires": commentaires,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    # Envoyer email aux super-admins (sauf le crÃ©ateur du commentaire)
    try:
        super_admins = await db.super_admins.find().to_list(100)
        super_admins_emails = [sa["email"] for sa in super_admins if sa["id"] != admin.id]
        
        if super_admins_emails:
            send_debogage_notification_email(
                super_admins_emails=super_admins_emails,
                type_notification="feature_comment",
                titre=f"ğŸ’¬ Nouveau commentaire sur: {feature['titre']}",
                description=comment_data.texte,
                priorite=feature.get("priorite", "moyenne"),
                created_by=admin.nom,
                item_id=feature_id
            )
    except Exception as e:
        print(f"[ERROR] Erreur envoi email commentaire feature: {e}")
    
    updated_feature = await db.feature_requests.find_one({"id": feature_id})
    return clean_mongo_doc(updated_feature)


# Endpoint pour supprimer un bug
@api_router.delete("/admin/bugs/{bug_id}")
async def delete_bug(
    bug_id: str,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Supprimer un bug report"""
    bug = await db.bugs.find_one({"id": bug_id})
    if not bug:
        raise HTTPException(status_code=404, detail="Bug non trouvÃ©")
    
    result = await db.bugs.delete_one({"id": bug_id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=500, detail="Erreur lors de la suppression")
    
    return {"message": "Bug supprimÃ© avec succÃ¨s", "id": bug_id}

# Endpoint pour supprimer une feature request
@api_router.delete("/admin/features/{feature_id}")
async def delete_feature(
    feature_id: str,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Supprimer une feature request"""
    feature = await db.feature_requests.find_one({"id": feature_id})
    if not feature:
        raise HTTPException(status_code=404, detail="Feature request non trouvÃ©e")
    
    result = await db.feature_requests.delete_one({"id": feature_id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=500, detail="Erreur lors de la suppression")
    
    return {"message": "Feature request supprimÃ©e avec succÃ¨s", "id": feature_id}

# Endpoint pour upload d'images (simplifiÃ© - stockage base64 ou URL externe)
@api_router.post("/admin/upload-image")
async def upload_debug_image(
    file: UploadFile,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Upload une image pour un bug/feature (retourne une URL ou base64)"""
    try:
        # Lire le contenu du fichier
        contents = await file.read()
        # Convertir en base64 pour stockage simple
        import base64
        encoded = base64.b64encode(contents).decode('utf-8')
        mime_type = file.content_type or 'image/png'
        data_url = f"data:{mime_type};base64,{encoded}"
        
        return {"url": data_url}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur upload image: {str(e)}")


# ==================== SUPER ADMIN MANAGEMENT ROUTES ====================

@api_router.get("/admin/super-admins")
async def list_super_admins(admin: SuperAdmin = Depends(get_super_admin)):
    """Liste tous les super admins"""
    super_admins = await db.super_admins.find().to_list(1000)
    return [clean_mongo_doc(sa) for sa in super_admins]

@api_router.post("/admin/super-admins")
async def create_super_admin(
    super_admin_data: dict,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """CrÃ©er un nouveau super admin"""
    # Valider les donnÃ©es
    if not all(key in super_admin_data for key in ['email', 'prenom', 'nom', 'mot_de_passe']):
        raise HTTPException(status_code=400, detail="Tous les champs sont obligatoires")
    
    # VÃ©rifier si l'email existe dÃ©jÃ 
    existing = await db.super_admins.find_one({"email": super_admin_data['email']})
    if existing:
        raise HTTPException(status_code=400, detail="Cet email est dÃ©jÃ  utilisÃ©")
    
    # Valider la complexitÃ© du mot de passe
    if not validate_complex_password(super_admin_data['mot_de_passe']):
        raise HTTPException(
            status_code=400,
            detail="Le mot de passe doit contenir au moins 8 caractÃ¨res, une majuscule, un chiffre et un caractÃ¨re spÃ©cial"
        )
    
    # CrÃ©er le super admin
    temp_password = super_admin_data['mot_de_passe']  # Garder le mot de passe temporaire pour l'email
    full_name = f"{super_admin_data['prenom']} {super_admin_data['nom']}"
    new_super_admin = SuperAdmin(
        email=super_admin_data['email'],
        nom=full_name,
        mot_de_passe_hash=get_password_hash(temp_password)
    )
    
    await db.super_admins.insert_one(new_super_admin.dict())
    
    logging.info(f"âœ… Super admin crÃ©Ã©: {new_super_admin.email}")
    
    # Envoyer l'email de bienvenue
    user_name = new_super_admin.nom
    email_sent = send_super_admin_welcome_email(
        new_super_admin.email,
        user_name,
        temp_password
    )
    
    if email_sent:
        logging.info(f"âœ… Email de bienvenue super admin envoyÃ© Ã  {new_super_admin.email}")
    else:
        logging.warning(f"âš ï¸ Email non envoyÃ© Ã  {new_super_admin.email} (Resend non configurÃ© ou erreur)")
    
    return {"message": "Super admin crÃ©Ã© avec succÃ¨s", "id": new_super_admin.id, "email_sent": email_sent}

@api_router.delete("/admin/super-admins/{super_admin_id}")
async def delete_super_admin(
    super_admin_id: str,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Supprimer un super admin"""
    # EmpÃªcher la suppression de soi-mÃªme
    if super_admin_id == admin.id:
        raise HTTPException(status_code=400, detail="Vous ne pouvez pas supprimer votre propre compte")
    
    # VÃ©rifier qu'il reste au moins un autre super admin
    count = await db.super_admins.count_documents({})
    if count <= 1:
        raise HTTPException(status_code=400, detail="Impossible de supprimer le dernier super admin")
    
    # Supprimer
    result = await db.super_admins.delete_one({"id": super_admin_id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Super admin non trouvÃ©")
    
    logging.info(f"âœ… Super admin supprimÃ©: {super_admin_id}")
    
    return {"message": "Super admin supprimÃ© avec succÃ¨s"}

@api_router.put("/admin/super-admins/{super_admin_id}")
async def update_super_admin(
    super_admin_id: str,
    update_data: dict,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Modifier les informations d'un super admin"""
    # VÃ©rifier que le super admin existe
    existing = await db.super_admins.find_one({"id": super_admin_id})
    if not existing:
        raise HTTPException(status_code=404, detail="Super admin non trouvÃ©")
    
    # PrÃ©parer les donnÃ©es Ã  mettre Ã  jour
    update_fields = {}
    if "prenom" in update_data and update_data["prenom"]:
        update_fields["prenom"] = update_data["prenom"]
    if "nom" in update_data and update_data["nom"]:
        update_fields["nom"] = update_data["nom"]
    
    if not update_fields:
        raise HTTPException(status_code=400, detail="Aucune donnÃ©e Ã  mettre Ã  jour")
    
    # Mettre Ã  jour
    await db.super_admins.update_one(
        {"id": super_admin_id},
        {"$set": update_fields}
    )
    
    logging.info(f"âœ… Super admin modifiÃ©: {super_admin_id}")
    
    return {"message": "Super admin modifiÃ© avec succÃ¨s"}

# User management routes
@api_router.post("/{tenant_slug}/users", response_model=User)
async def create_user(tenant_slug: str, user_create: UserCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ‰RIFIER LA LIMITE DU PALIER
    current_count = await db.users.count_documents({"tenant_id": tenant.id})
    
    # DÃ©terminer le palier actuel
    if current_count < 30:
        palier = "Basic (1-30)"
        limite = 30
        prix = "12$"
    elif current_count < 50:
        palier = "Standard (31-50)"
        limite = 50
        prix = "20$"
    else:
        palier = "Premium (51+)"
        limite = None
        prix = "27$"
    
    # Bloquer si la limite du palier est atteinte
    if limite and current_count >= limite:
        # Envoyer email au super admin via Resend
        super_admin_email = "gussdub@icloud.com"
        try:
            resend_api_key = os.environ.get('RESEND_API_KEY')
            if resend_api_key:
                resend.api_key = resend_api_key
                
                params = {
                    "from": os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca'),
                    "to": [super_admin_email],
                    "subject": f'âš ï¸ Limite de palier atteinte - {tenant.nom}',
                    "html": f"""
                    <h2>Alerte - Limite de palier atteinte</h2>
                    <p><strong>Caserne:</strong> {tenant.nom} ({tenant_slug})</p>
                    <p><strong>Palier actuel:</strong> {palier}</p>
                    <p><strong>Personnel actuel:</strong> {current_count}/{limite}</p>
                    <p><strong>Prix actuel:</strong> {prix}/mois</p>
                    <p>L'administrateur a tentÃ© de crÃ©er un {current_count + 1}e pompier mais la limite est atteinte.</p>
                    <p><strong>Action requise:</strong> Contacter le client pour upgrade vers palier supÃ©rieur.</p>
                    """
                }
                resend.Emails.send(params)
        except Exception as e:
            print(f"Erreur envoi email super admin: {str(e)}")
        
        raise HTTPException(
            status_code=403, 
            detail=f"Limite du palier {palier} atteinte ({current_count}/{limite}). Contactez l'administrateur pour upgrader votre forfait."
        )
    
    # Validation du mot de passe complexe
    if not validate_complex_password(user_create.mot_de_passe):
        raise HTTPException(
            status_code=400, 
            detail="Le mot de passe doit contenir au moins 8 caractÃ¨res, une majuscule, un chiffre et un caractÃ¨re spÃ©cial (!@#$%^&*+-?())"
        )
    
    # Check if user already exists DANS CE TENANT
    existing_user = await db.users.find_one({"email": user_create.email, "tenant_id": tenant.id})
    if existing_user:
        raise HTTPException(status_code=400, detail="Cet email est dÃ©jÃ  utilisÃ© dans cette caserne")
    
    user_dict = user_create.dict()
    temp_password = user_dict["mot_de_passe"]  # Sauvegarder pour l'email
    user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
    user_dict["tenant_id"] = tenant.id  # Assigner le tenant
    
    # CORRECTION CRITIQUE: Synchroniser formations vers competences
    # Le frontend utilise "formations" mais l'algorithme cherche dans "competences"
    if "formations" in user_dict:
        user_dict["competences"] = user_dict["formations"]
        logging.info(f"ğŸ”„ [SYNC CREATE] Copie formations â†’ competences: {user_dict['formations']}")
    
    user_obj = User(**user_dict)
    
    await db.users.insert_one(user_obj.dict())
    
    # CrÃ©er une activitÃ©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="personnel_creation",
        description=f"ğŸ‘¤ {current_user.prenom} {current_user.nom} a ajoutÃ© {user_create.prenom} {user_create.nom} ({user_create.grade}) au personnel",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    # Envoyer l'email de bienvenue
    try:
        user_name = f"{user_create.prenom} {user_create.nom}"
        email_sent = send_welcome_email(user_create.email, user_name, user_create.role, temp_password, tenant_slug)
        
        if email_sent:
            print(f"Email de bienvenue envoyÃ© Ã  {user_create.email}")
        else:
            print(f"Ã‰chec envoi email Ã  {user_create.email}")
            
    except Exception as e:
        print(f"Erreur lors de l'envoi de l'email: {str(e)}")
        # Ne pas Ã©chouer la crÃ©ation du compte si l'email Ã©choue
    
    return user_obj

@api_router.post("/{tenant_slug}/users/import-csv")
async def import_users_csv(
    tenant_slug: str,
    users_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse d'utilisateurs/personnel depuis un CSV"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    users = users_data.get("users", [])
    if not users:
        raise HTTPException(status_code=400, detail="Aucun utilisateur Ã  importer")
    
    # VÃ©rifier la limite du palier
    current_count = await db.users.count_documents({"tenant_id": tenant.id})
    total_to_import = len(users)
    
    if current_count < 30:
        limite = 30
        palier = "Basic (1-30)"
    elif current_count < 50:
        limite = 50
        palier = "Standard (31-50)"
    else:
        limite = None
        palier = "Premium (51+)"
    
    if limite and (current_count + total_to_import) > limite:
        raise HTTPException(
            status_code=403,
            detail=f"Import refusÃ©: dÃ©passement du palier {palier}. Vous avez {current_count} utilisateurs, tentative d'import de {total_to_import}. Limite: {limite}."
        )
    
    results = {
        "total": total_to_import,
        "created": 0,
        "updated": 0,
        "errors": [],
        "duplicates": [],
        "password_reset_emails": []
    }
    
    # PrÃ©charger tous les utilisateurs pour matching intelligent
    existing_users_list = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    users_by_email = {u.get("email", "").lower(): u for u in existing_users_list if u.get("email")}
    users_by_name = create_user_matching_index(existing_users_list)
    users_by_num = {u.get("numero_employe"): u for u in existing_users_list if u.get("numero_employe")}
    
    for index, user_data in enumerate(users):
        try:
            # Validation des champs obligatoires
            if not user_data.get("prenom") or not user_data.get("nom") or not user_data.get("email"):
                results["errors"].append({
                    "line": index + 1,
                    "error": "PrÃ©nom, Nom et Email sont requis",
                    "data": user_data
                })
                continue
            
            # VÃ©rifier si l'utilisateur existe dÃ©jÃ  (stratÃ©gie multi-niveaux)
            existing_user = None
            
            # Niveau 1 : Par email (prioritÃ© haute - identifiant unique)
            if user_data.get("email"):
                email_normalized = user_data["email"].lower().strip()
                existing_user = users_by_email.get(email_normalized)
            
            # Niveau 2 : Par numÃ©ro d'employÃ© (si email absent ou pas trouvÃ©)
            if not existing_user and user_data.get("numero_employe"):
                num_employe = user_data["numero_employe"].strip()
                existing_user = users_by_num.get(num_employe)
            
            # Niveau 3 : Par nom complet avec matching intelligent (fallback)
            if not existing_user and user_data.get("prenom") and user_data.get("nom"):
                # Construire la chaÃ®ne de recherche
                search_string = f"{user_data['prenom']} {user_data['nom']}"
                if user_data.get("numero_employe"):
                    search_string += f" ({user_data['numero_employe']})"
                
                existing_user = find_user_intelligent(
                    search_string=search_string,
                    users_by_name=users_by_name,
                    users_by_num=users_by_num,
                    numero_field="numero_employe"
                )
            
            if existing_user:
                results["duplicates"].append({
                    "line": index + 1,
                    "email": user_data["email"],
                    "action": user_data.get("action_doublon", "skip"),
                    "data": user_data
                })
                
                # Si action_doublon = update, mettre Ã  jour
                if user_data.get("action_doublon") == "update":
                    update_data = {
                        "prenom": user_data["prenom"],
                        "nom": user_data["nom"],
                        "numero_employe": user_data.get("numero_employe", ""),
                        "grade": user_data.get("grade", ""),
                        "type_emploi": user_data.get("type_emploi", "temps_plein"),
                        "telephone": user_data.get("telephone", ""),
                        "adresse": user_data.get("adresse", ""),
                        "role": user_data.get("role", "employe"),
                        "accepte_gardes_externes": user_data.get("accepte_gardes_externes", False)
                    }
                    
                    # Champs optionnels
                    if user_data.get("date_embauche"):
                        update_data["date_embauche"] = user_data["date_embauche"]
                    if user_data.get("taux_horaire"):
                        update_data["taux_horaire"] = float(user_data["taux_horaire"])
                    if user_data.get("competences"):
                        update_data["competences"] = user_data["competences"].split(",") if isinstance(user_data["competences"], str) else user_data["competences"]
                    
                    # Contact d'urgence
                    if user_data.get("contact_urgence_nom"):
                        update_data["contact_urgence"] = {
                            "nom": user_data.get("contact_urgence_nom", ""),
                            "telephone": user_data.get("contact_urgence_telephone", ""),
                            "relation": user_data.get("contact_urgence_relation", "")
                        }
                    
                    await db.users.update_one(
                        {"id": existing_user["id"], "tenant_id": tenant.id},
                        {"$set": update_data}
                    )
                    results["updated"] += 1
                else:
                    # skip par dÃ©faut
                    continue
            
            # CrÃ©er l'utilisateur s'il n'existe pas
            if not existing_user:
                # GÃ©nÃ©rer un mot de passe temporaire
                temp_password = f"Temp{str(uuid.uuid4())[:8]}!"
                
                new_user = {
                    "id": str(uuid.uuid4()),
                    "tenant_id": tenant.id,
                    "email": user_data["email"],
                    "prenom": user_data["prenom"],
                    "nom": user_data["nom"],
                    "numero_employe": user_data.get("numero_employe", ""),
                    "grade": user_data.get("grade", ""),
                    "type_emploi": user_data.get("type_emploi", "temps_plein"),
                    "telephone": user_data.get("telephone", ""),
                    "adresse": user_data.get("adresse", ""),
                    "role": user_data.get("role", "employe"),
                    "accepte_gardes_externes": user_data.get("accepte_gardes_externes", False),
                    "mot_de_passe_hash": get_password_hash(temp_password),
                    "heures_internes": 0,
                    "heures_externes": 0,
                    "created_at": datetime.now(timezone.utc).isoformat()
                }
                
                # Champs optionnels
                if user_data.get("date_embauche"):
                    new_user["date_embauche"] = user_data["date_embauche"]
                if user_data.get("taux_horaire"):
                    new_user["taux_horaire"] = float(user_data["taux_horaire"])
                if user_data.get("competences"):
                    new_user["competences"] = user_data["competences"].split(",") if isinstance(user_data["competences"], str) else user_data["competences"]
                
                # Contact d'urgence
                if user_data.get("contact_urgence_nom"):
                    new_user["contact_urgence"] = {
                        "nom": user_data.get("contact_urgence_nom", ""),
                        "telephone": user_data.get("contact_urgence_telephone", ""),
                        "relation": user_data.get("contact_urgence_relation", "")
                    }
                
                await db.users.insert_one(new_user)
                results["created"] += 1
                
                # Envoyer email de rÃ©initialisation de mot de passe
                try:
                    # CrÃ©er un token de rÃ©initialisation
                    reset_token = str(uuid.uuid4())
                    await db.password_resets.insert_one({
                        "email": user_data["email"],
                        "tenant_id": tenant.id,
                        "token": reset_token,
                        "created_at": datetime.now(timezone.utc),
                        "expires_at": datetime.now(timezone.utc) + timedelta(days=7)
                    })
                    
                    # Envoyer l'email (fonction Ã  implÃ©menter selon votre systÃ¨me d'emails)
                    reset_url = f"{os.environ.get('FRONTEND_URL')}/reset-password?token={reset_token}"
                    # send_password_reset_email(user_data["email"], reset_url)
                    
                    results["password_reset_emails"].append({
                        "email": user_data["email"],
                        "reset_url": reset_url
                    })
                except Exception as e:
                    results["errors"].append({
                        "line": index + 1,
                        "error": f"Utilisateur crÃ©Ã© mais email non envoyÃ©: {str(e)}",
                        "data": user_data
                    })
        
        except Exception as e:
            results["errors"].append({
                "line": index + 1,
                "error": str(e),
                "data": user_data
            })
    
    return results



@api_router.get("/{tenant_slug}/users", response_model=List[User])
async def get_users(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # Tous les utilisateurs authentifiÃ©s peuvent voir la liste des users (lecture seule)
    # Les employÃ©s ont besoin de voir les noms dans le Planning
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Filtrer par tenant_id
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    cleaned_users = [clean_mongo_doc(user) for user in users]
    return [User(**user) for user in cleaned_users]

@api_router.get("/{tenant_slug}/users/{user_id}", response_model=User)
async def get_user(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Filtrer par tenant_id ET user_id
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    user = clean_mongo_doc(user)
    return User(**user)

class ProfileUpdate(BaseModel):
    prenom: str
    nom: str
    email: str
    telephone: str = ""
    adresse: str = ""
    contact_urgence: str = ""
    heures_max_semaine: int = 25

@api_router.put("/{tenant_slug}/users/mon-profil", response_model=User)
async def update_mon_profil(
    tenant_slug: str,
    profile_data: ProfileUpdate,
    current_user: User = Depends(get_current_user)
):
    """
    Permet Ã  un utilisateur de modifier son propre profil
    """
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # L'utilisateur peut modifier son propre profil
        # Utiliser exclude_unset=True pour ne mettre Ã  jour que les champs modifiÃ©s
        update_data = profile_data.dict(exclude_unset=True)
        
        if not update_data:
            # Aucune modification
            updated_user = await db.users.find_one({"id": current_user.id, "tenant_id": tenant.id})
            updated_user = clean_mongo_doc(updated_user)
            return User(**updated_user)
        
        result = await db.users.update_one(
            {"id": current_user.id, "tenant_id": tenant.id}, 
            {"$set": update_data}
        )
        
        if result.matched_count == 0:
            raise HTTPException(status_code=404, detail="Profil non trouvÃ©")
        
        # RÃ©cupÃ©rer le profil mis Ã  jour
        updated_user = await db.users.find_one({"id": current_user.id, "tenant_id": tenant.id})
        updated_user = clean_mongo_doc(updated_user)
        return User(**updated_user)
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise Ã  jour profil: {str(e)}")

@api_router.put("/{tenant_slug}/users/{user_id}", response_model=User)
async def update_user(tenant_slug: str, user_id: str, user_update: UserUpdate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Check if user exists dans ce tenant
    existing_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not existing_user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    # PrÃ©parer les donnÃ©es Ã  mettre Ã  jour (seulement les champs fournis)
    update_data = {k: v for k, v in user_update.dict(exclude_unset=True).items() if v is not None}
    
    # CORRECTION CRITIQUE: Synchroniser formations/competences (deux sens!)
    # Certaines parties du frontend envoient "formations", d'autres "competences"
    if "formations" in update_data:
        update_data["competences"] = update_data["formations"]
        logging.info(f"ğŸ”„ [SYNC] Copie formations â†’ competences: {update_data['formations']}")
    elif "competences" in update_data:
        update_data["formations"] = update_data["competences"]
        logging.info(f"ğŸ”„ [SYNC] Copie competences â†’ formations: {update_data['competences']}")
    
    # Gestion du mot de passe
    if "mot_de_passe" in update_data and update_data["mot_de_passe"]:
        update_data["mot_de_passe_hash"] = get_password_hash(update_data.pop("mot_de_passe"))
    elif "mot_de_passe" in update_data:
        update_data.pop("mot_de_passe")
    
    # Mettre Ã  jour uniquement les champs fournis
    result = await db.users.update_one(
        {"id": user_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    updated_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    updated_user = clean_mongo_doc(updated_user)
    
    # CrÃ©er une activitÃ©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="personnel_modification",
        description=f"âœï¸ {current_user.prenom} {current_user.nom} a modifiÃ© le profil de {updated_user['prenom']} {updated_user['nom']}",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return User(**updated_user)

@api_router.delete("/{tenant_slug}/users/{user_id}")
async def delete_user(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Check if user exists dans ce tenant
    existing_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not existing_user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    # Delete user
    result = await db.users.delete_one({"id": user_id, "tenant_id": tenant.id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de supprimer l'utilisateur")
    
    # Also delete related data (filtrÃ© par tenant_id aussi)
    await db.disponibilites.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    await db.assignations.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    await db.demandes_remplacement.delete_many({"demandeur_id": user_id, "tenant_id": tenant.id})
    
    # CrÃ©er une activitÃ©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="personnel_suppression",
        description=f"ğŸ—‘ï¸ {current_user.prenom} {current_user.nom} a supprimÃ© {existing_user['prenom']} {existing_user['nom']} du personnel",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return {"message": "Utilisateur supprimÃ© avec succÃ¨s"}

@api_router.put("/{tenant_slug}/users/{user_id}/password")
async def change_user_password(
    tenant_slug: str,
    user_id: str,
    password_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Changer le mot de passe d'un utilisateur (propre mot de passe ou admin reset)"""
    try:
        logging.info(f"ğŸ”‘ Demande de changement de mot de passe pour l'utilisateur {user_id}")
        
        # VÃ©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer l'utilisateur cible
        user_data = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        if not user_data:
            logging.warning(f"âŒ Utilisateur non trouvÃ© pour changement de mot de passe: {user_id}")
            raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
        
        # Cas 1: Admin qui rÃ©initialise le mot de passe d'un autre utilisateur
        is_admin_reset = current_user.role == "admin" and current_user.id != user_id
        
        # Cas 2: Utilisateur qui change son propre mot de passe
        is_self_change = current_user.id == user_id
        
        if not is_admin_reset and not is_self_change:
            logging.warning(f"âŒ Tentative de changement de mot de passe non autorisÃ©e par {current_user.id} pour {user_id}")
            raise HTTPException(status_code=403, detail="Vous ne pouvez changer que votre propre mot de passe")
        
        # Si c'est un changement personnel, vÃ©rifier l'ancien mot de passe
        if is_self_change and not is_admin_reset:
            if "current_password" not in password_data:
                raise HTTPException(status_code=400, detail="Le mot de passe actuel est requis")
            
            if not verify_password(password_data["current_password"], user_data["mot_de_passe_hash"]):
                logging.warning(f"âŒ Ancien mot de passe incorrect pour {user_id}")
                raise HTTPException(status_code=401, detail="Mot de passe actuel incorrect")
            
            logging.info(f"âœ… Ancien mot de passe vÃ©rifiÃ© pour {user_id}")
            new_password = password_data["new_password"]
        else:
            # Admin reset - pas besoin de l'ancien mot de passe
            logging.info(f"ğŸ‘‘ Reset administrateur du mot de passe pour {user_id} par {current_user.id}")
            new_password = password_data.get("mot_de_passe") or password_data.get("new_password")
            if not new_password:
                raise HTTPException(status_code=400, detail="Le nouveau mot de passe est requis")
        
        # Valider le nouveau mot de passe (8 caractÃ¨res min, 1 majuscule, 1 chiffre, 1 spÃ©cial)
        if len(new_password) < 8:
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins 8 caractÃ¨res")
        if not any(c.isupper() for c in new_password):
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins une majuscule")
        if not any(c.isdigit() for c in new_password):
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins un chiffre")
        if not any(c in '!@#$%^&*+-?()' for c in new_password):
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins un caractÃ¨re spÃ©cial (!@#$%^&*+-?())")
        
        # Hasher et mettre Ã  jour le mot de passe (utilise bcrypt maintenant)
        new_password_hash = get_password_hash(new_password)
        logging.info(f"ğŸ” Nouveau mot de passe hashÃ© avec bcrypt pour {user_id}")
        
        result = await db.users.update_one(
            {"id": user_id, "tenant_id": tenant.id},
            {"$set": {"mot_de_passe_hash": new_password_hash}}
        )
        
        if result.modified_count == 0:
            logging.error(f"âŒ Impossible de mettre Ã  jour le mot de passe pour {user_id}")
            raise HTTPException(status_code=400, detail="Impossible de mettre Ã  jour le mot de passe")
        
        logging.info(f"âœ… Mot de passe changÃ© avec succÃ¨s pour {user_id}")
        
        # Si c'est un admin reset, envoyer un email au utilisateur
        email_sent = False
        if is_admin_reset:
            user_name = f"{user_data.get('prenom', '')} {user_data.get('nom', '')}".strip()
            user_email = user_data.get('email')
            
            if user_email:
                logging.info(f"ğŸ“§ Envoi de l'email de rÃ©initialisation Ã  {user_email}")
                email_sent = send_temporary_password_email(
                    user_email=user_email,
                    user_name=user_name,
                    temp_password=new_password,
                    tenant_slug=tenant_slug
                )
                
                if email_sent:
                    logging.info(f"âœ… Email de rÃ©initialisation envoyÃ© avec succÃ¨s Ã  {user_email}")
                    return {
                        "message": "Mot de passe modifiÃ© avec succÃ¨s",
                        "email_sent": True,
                        "email_address": user_email
                    }
                else:
                    logging.warning(f"âš ï¸ Ã‰chec de l'envoi de l'email Ã  {user_email}")
                    return {
                        "message": "Mot de passe modifiÃ© avec succÃ¨s, mais l'email n'a pas pu Ãªtre envoyÃ©",
                        "email_sent": False,
                        "error": "L'envoi de l'email a Ã©chouÃ©. Veuillez informer l'utilisateur manuellement."
                    }
            else:
                logging.warning(f"âš ï¸ Aucun email trouvÃ© pour l'utilisateur {user_id}")
                return {
                    "message": "Mot de passe modifiÃ© avec succÃ¨s, mais aucun email configurÃ© pour cet utilisateur",
                    "email_sent": False,
                    "error": "Aucune adresse email trouvÃ©e"
                }
        
        return {"message": "Mot de passe modifiÃ© avec succÃ¨s"}
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur inattendue lors du changement de mot de passe pour {user_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

# ==================== PERSONNALISATION (LOGO & BRANDING) ====================

@api_router.get("/{tenant_slug}/public/branding")
async def get_public_branding(tenant_slug: str):
    """RÃ©cupÃ©rer les paramÃ¨tres de branding publics (pas d'authentification requise)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    return {
        "logo_url": tenant.logo_url if hasattr(tenant, 'logo_url') else "",
        "nom_service": tenant.nom_service if hasattr(tenant, 'nom_service') else tenant.nom,
        "afficher_profiremanager": tenant.afficher_profiremanager if hasattr(tenant, 'afficher_profiremanager') else True
    }

@api_router.get("/{tenant_slug}/personnalisation")
async def get_personnalisation(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les paramÃ¨tres de personnalisation du tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    return {
        "logo_url": tenant.logo_url if hasattr(tenant, 'logo_url') else "",
        "nom_service": tenant.nom_service if hasattr(tenant, 'nom_service') else tenant.nom,
        "afficher_profiremanager": tenant.afficher_profiremanager if hasattr(tenant, 'afficher_profiremanager') else True
    }

@api_router.put("/{tenant_slug}/personnalisation")
async def update_personnalisation(
    tenant_slug: str,
    data: dict,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour les paramÃ¨tres de personnalisation (admin uniquement)"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # PrÃ©parer les mises Ã  jour
    update_data = {}
    
    if "logo_url" in data:
        update_data["logo_url"] = data["logo_url"]
    
    if "nom_service" in data:
        update_data["nom_service"] = data["nom_service"]
    
    if "afficher_profiremanager" in data:
        update_data["afficher_profiremanager"] = data["afficher_profiremanager"]
    
    # Mettre Ã  jour dans MongoDB
    if update_data:
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": update_data}
        )
    
    return {
        "message": "Personnalisation mise Ã  jour avec succÃ¨s",
        **update_data
    }

@api_router.post("/{tenant_slug}/personnalisation/upload-logo")
async def upload_logo(
    tenant_slug: str,
    logo_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Upload du logo en base64"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es base64
    if "logo_base64" not in logo_data:
        raise HTTPException(status_code=400, detail="DonnÃ©es logo manquantes")
    
    logo_base64 = logo_data["logo_base64"]
    
    # VÃ©rifier que c'est bien du base64 valide
    if not logo_base64.startswith("data:image/"):
        raise HTTPException(status_code=400, detail="Format d'image invalide")
    
    # Mettre Ã  jour dans MongoDB
    await db.tenants.update_one(
        {"id": tenant.id},
        {"$set": {"logo_url": logo_base64}}
    )
    
    return {
        "message": "Logo uploadÃ© avec succÃ¨s",
        "logo_url": logo_base64
    }

# ==================== FIN PERSONNALISATION ====================

@api_router.put("/{tenant_slug}/users/{user_id}/access", response_model=User)
async def update_user_access(tenant_slug: str, user_id: str, role: str, statut: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Validation des valeurs
    valid_roles = ["admin", "superviseur", "employe"]
    valid_statuts = ["Actif", "Inactif"]
    
    if role not in valid_roles:
        raise HTTPException(status_code=400, detail="RÃ´le invalide")
    if statut not in valid_statuts:
        raise HTTPException(status_code=400, detail="Statut invalide")
    
    # Check if user exists in this tenant
    existing_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not existing_user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    # Update user access
    result = await db.users.update_one(
        {"id": user_id, "tenant_id": tenant.id}, 
        {"$set": {"role": role, "statut": statut}}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de mettre Ã  jour l'accÃ¨s")
    
    updated_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    updated_user = clean_mongo_doc(updated_user)
    return User(**updated_user)

@api_router.delete("/{tenant_slug}/users/{user_id}/revoke")
async def revoke_user_completely(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Check if user exists IN THIS TENANT
    existing_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not existing_user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    # Prevent admin from deleting themselves
    if user_id == current_user.id:
        raise HTTPException(status_code=400, detail="Impossible de supprimer votre propre compte")
    
    # Delete user and all related data (only for this tenant)
    await db.users.delete_one({"id": user_id, "tenant_id": tenant.id})
    await db.disponibilites.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    await db.assignations.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    await db.demandes_remplacement.delete_many({"demandeur_id": user_id, "tenant_id": tenant.id})
    await db.demandes_remplacement.delete_many({"remplacant_id": user_id, "tenant_id": tenant.id})
    
    return {"message": "Utilisateur et toutes ses donnÃ©es ont Ã©tÃ© supprimÃ©s dÃ©finitivement"}

# Types de garde routes
@api_router.post("/{tenant_slug}/types-garde", response_model=TypeGarde)
async def create_type_garde(tenant_slug: str, type_garde: TypeGardeCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    type_garde_dict = type_garde.dict()
    type_garde_dict["tenant_id"] = tenant.id
    
    # CALCUL AUTOMATIQUE de duree_heures Ã  partir de heure_debut et heure_fin
    if type_garde_dict.get("heure_debut") and type_garde_dict.get("heure_fin"):
        try:
            # Parse les heures (format "HH:MM")
            debut = datetime.strptime(type_garde_dict["heure_debut"], "%H:%M")
            fin = datetime.strptime(type_garde_dict["heure_fin"], "%H:%M")
            
            # Calculer la diffÃ©rence en heures
            duree_calculee = (fin - debut).total_seconds() / 3600
            
            # Si heure de fin < heure de dÃ©but, c'est une garde qui traverse minuit
            if duree_calculee < 0:
                duree_calculee += 24
            
            type_garde_dict["duree_heures"] = round(duree_calculee, 2)
            logging.info(f"âœ… [TYPE GARDE] DurÃ©e calculÃ©e: {duree_calculee}h ({type_garde_dict['heure_debut']} â†’ {type_garde_dict['heure_fin']})")
        except Exception as e:
            logging.error(f"âŒ [TYPE GARDE] Erreur calcul durÃ©e: {e}")
            # Fallback sur 8h si erreur
            type_garde_dict["duree_heures"] = 8
    
    type_garde_obj = TypeGarde(**type_garde_dict)
    await db.types_garde.insert_one(type_garde_obj.dict())
    return type_garde_obj

@api_router.get("/{tenant_slug}/types-garde", response_model=List[TypeGarde])
async def get_types_garde(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # OPTIMISATION: Projection explicite + exclusion _id
    types_garde = await db.types_garde.find(
        {"tenant_id": tenant.id},
        {"_id": 0}
    ).to_list(1000)
    cleaned_types = [clean_mongo_doc(type_garde) for type_garde in types_garde]
    return [TypeGarde(**type_garde) for type_garde in cleaned_types]

# Helper function to clean MongoDB documents
def clean_mongo_doc(doc):
    """Remove MongoDB ObjectId and other non-serializable fields"""
    if doc and "_id" in doc:
        doc.pop("_id", None)
    return doc

@api_router.put("/{tenant_slug}/types-garde/{type_garde_id}", response_model=TypeGarde)
async def update_type_garde(tenant_slug: str, type_garde_id: str, type_garde_update: TypeGardeCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Check if type garde exists dans ce tenant
    existing_type = await db.types_garde.find_one({"id": type_garde_id, "tenant_id": tenant.id})
    if not existing_type:
        raise HTTPException(status_code=404, detail="Type de garde non trouvÃ©")
    
    # Update type garde data
    type_dict = type_garde_update.dict()
    type_dict["id"] = type_garde_id
    type_dict["tenant_id"] = tenant.id
    type_dict["created_at"] = existing_type.get("created_at")
    
    # CALCUL AUTOMATIQUE de duree_heures Ã  partir de heure_debut et heure_fin
    if type_dict.get("heure_debut") and type_dict.get("heure_fin"):
        try:
            # Parse les heures (format "HH:MM")
            debut = datetime.strptime(type_dict["heure_debut"], "%H:%M")
            fin = datetime.strptime(type_dict["heure_fin"], "%H:%M")
            
            # Calculer la diffÃ©rence en heures
            duree_calculee = (fin - debut).total_seconds() / 3600
            
            # Si heure de fin < heure de dÃ©but, c'est une garde qui traverse minuit
            if duree_calculee < 0:
                duree_calculee += 24
            
            type_dict["duree_heures"] = round(duree_calculee, 2)
            logging.info(f"âœ… [TYPE GARDE UPDATE] DurÃ©e calculÃ©e: {duree_calculee}h ({type_dict['heure_debut']} â†’ {type_dict['heure_fin']})")
        except Exception as e:
            logging.error(f"âŒ [TYPE GARDE UPDATE] Erreur calcul durÃ©e: {e}")
            # Garder la durÃ©e existante si erreur
            type_dict["duree_heures"] = existing_type.get("duree_heures", 8)
    
    result = await db.types_garde.replace_one({"id": type_garde_id, "tenant_id": tenant.id}, type_dict)
    if result.modified_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de mettre Ã  jour le type de garde")
    
    updated_type = await db.types_garde.find_one({"id": type_garde_id, "tenant_id": tenant.id})
    updated_type = clean_mongo_doc(updated_type)
    return TypeGarde(**updated_type)

@api_router.delete("/{tenant_slug}/types-garde/{type_garde_id}")
async def delete_type_garde(tenant_slug: str, type_garde_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Check if type garde exists
    existing_type = await db.types_garde.find_one({"id": type_garde_id})
    if not existing_type:
        raise HTTPException(status_code=404, detail="Type de garde non trouvÃ©")
    
    # Delete type garde
    result = await db.types_garde.delete_one({"id": type_garde_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de supprimer le type de garde")
    
    # Also delete related assignations
    await db.assignations.delete_many({"type_garde_id": type_garde_id})
    
    return {"message": "Type de garde supprimÃ© avec succÃ¨s"}



# ===== FORMATAGE PLANNING (DEMO UNIQUEMENT) =====

@api_router.delete("/{tenant_slug}/planning/formater-mois")
async def formater_planning_mois(
    tenant_slug: str,
    mois: str,  # Format: YYYY-MM
    current_user: User = Depends(get_current_user)
):
    """
    Formate (vide) le planning d'un mois spÃ©cifique
    UNIQUEMENT pour le tenant demo
    Supprime: assignations, demandes de remplacement
    """
    # 1. VÃ©rifier que c'est le tenant demo
    if tenant_slug != "demo":
        raise HTTPException(status_code=403, detail="Cette fonctionnalitÃ© est rÃ©servÃ©e au tenant demo")
    
    # 2. VÃ©rifier que l'utilisateur est admin
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s rÃ©servÃ© aux administrateurs")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # 3. Valider le format du mois
    try:
        year, month = map(int, mois.split('-'))
        if month < 1 or month > 12:
            raise ValueError()
    except:
        raise HTTPException(status_code=400, detail="Format de mois invalide. Utilisez YYYY-MM")
    
    # 4. Calculer les dates de dÃ©but et fin du mois
    date_debut = datetime(year, month, 1, tzinfo=timezone.utc)
    if month == 12:
        date_fin = datetime(year + 1, 1, 1, tzinfo=timezone.utc) - timedelta(seconds=1)
    else:
        date_fin = datetime(year, month + 1, 1, tzinfo=timezone.utc) - timedelta(seconds=1)
    
    # 5. Supprimer les assignations du mois
    result_assignations = await db.assignations.delete_many({
        "tenant_id": tenant.id,
        "date": {
            "$gte": date_debut.isoformat(),
            "$lte": date_fin.isoformat()
        }
    })
    
    # 6. Supprimer les demandes de remplacement du mois
    result_remplacements = await db.demandes_remplacement.delete_many({
        "tenant_id": tenant.id,
        "date_garde": {
            "$gte": date_debut.isoformat(),
            "$lte": date_fin.isoformat()
        }
    })
    
    return {
        "message": f"Planning formatÃ© avec succÃ¨s pour {mois}",
        "mois": mois,
        "assignations_supprimees": result_assignations.deleted_count,
        "demandes_supprimees": result_remplacements.deleted_count
    }

# ===== EXPORTS PLANNING (doivent Ãªtre AVANT les routes avec paramÃ¨tres dynamiques) =====

@api_router.get("/{tenant_slug}/planning/export-pdf")
async def export_planning_pdf(
    tenant_slug: str, 
    periode: str,
    type: str,
    current_user: User = Depends(get_current_user)
):
    """Export du planning en PDF"""
    try:
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Calculer la pÃ©riode
        if type == 'semaine':
            date_debut = datetime.strptime(periode, '%Y-%m-%d')
            date_fin = date_debut + timedelta(days=6)
        else:  # mois
            year, month = map(int, periode.split('-'))
            date_debut = datetime(year, month, 1)
            if month == 12:
                date_fin = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                date_fin = datetime(year, month + 1, 1) - timedelta(days=1)
        
        # RÃ©cupÃ©rer les donnÃ©es
        assignations_list = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut.strftime('%Y-%m-%d'),
                "$lte": date_fin.strftime('%Y-%m-%d')
            }
        }).to_list(length=None)
        
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        types_map = {t['id']: t for t in types_garde_list}
        users_map = {u['id']: u for u in users_list}
        
        # CrÃ©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(
            tenant,
            pagesize=landscape(letter),
            leftMargin=0.5*inch,
            rightMargin=0.5*inch,
            topMargin=0.75*inch,
            bottomMargin=0.75*inch
        )
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Le logo et le header sont dÃ©jÃ  ajoutÃ©s par create_branded_pdf
        # Pas besoin de les ajouter Ã  nouveau
        
        # Titre principal
        titre = f"PLANIFICATION DES GARDES"
        elements.append(Paragraph(titre, modern_styles['title']))
        
        # Sous-titre avec pÃ©riode
        type_label = "Semaine" if type == "semaine" else "Mois"
        periode_str = f"{type_label} du {date_debut.strftime('%d/%m/%Y')} au {date_fin.strftime('%d/%m/%Y')}"
        elements.append(Paragraph(periode_str, modern_styles['subheading']))
        elements.append(Spacer(1, 0.1*inch))
        
        # Ligne de sÃ©paration
        from reportlab.platypus import HRFlowable
        elements.append(HRFlowable(width="100%", thickness=1, color=modern_styles['grid'], spaceAfter=0.3*inch))
        
        # NOUVEAU FORMAT Ã‰PURÃ‰ - Liste par jour
        jours_fr = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche']
        
        # Style pour les titres de jour (utilisÃ© dans semaine ET mois)
        jour_style = ParagraphStyle(
            'JourStyle',
            parent=styles['Heading2'],
            fontSize=14,
            textColor=modern_styles['secondary_color'],
            spaceAfter=10,
            spaceBefore=15,
            fontName='Helvetica-Bold'
        )
        
        # Style pour les gardes (utilisÃ© dans semaine ET mois)
        garde_style = ParagraphStyle(
            'GardeStyle',
            parent=styles['Normal'],
            fontSize=11,
            leading=16,
            leftIndent=20,
            spaceAfter=8
        )
        
        if type == 'semaine':
            
            # Parcourir les jours
            for i in range(7):
                current_date = date_debut + timedelta(days=i)
                current_date_str = current_date.strftime('%Y-%m-%d')
                current_day = current_date.strftime('%A').lower()
                jour_nom = jours_fr[current_date.weekday()]
                date_formatted = current_date.strftime('%d %B %Y')
                
                # Titre du jour
                elements.append(Paragraph(f"<b>{jour_nom.upper()} {current_date.strftime('%d/%m/%Y')}</b>", jour_style))
                elements.append(Spacer(1, 0.1*inch))
                
                # Trouver les gardes applicables ce jour
                gardes_du_jour = []
                for type_garde in sorted(types_garde_list, key=lambda x: x.get('heure_debut', '')):
                    jours_app = type_garde.get('jours_application', [])
                    
                    # Filtrer par jour applicable
                    if jours_app and current_day not in jours_app:
                        continue
                    
                    # RÃ©cupÃ©rer les assignations
                    assignations_jour = [a for a in assignations_list 
                                        if a['date'] == current_date_str 
                                        and a['type_garde_id'] == type_garde['id']]
                    
                    if assignations_jour or not jours_app:  # Afficher si assignations OU garde gÃ©nÃ©rale
                        noms_complets = []
                        for a in assignations_jour:
                            if a['user_id'] in users_map:
                                user = users_map[a['user_id']]
                                noms_complets.append(f"{user['prenom']} {user['nom']}")
                        
                        garde_nom = type_garde['nom']
                        garde_horaire = f"{type_garde.get('heure_debut', '??:??')} - {type_garde.get('heure_fin', '??:??')}"
                        personnel_requis = type_garde.get('personnel_requis', 1)
                        personnel_assigne = len(noms_complets)
                        
                        # IcÃ´ne de couverture
                        if personnel_assigne == 0:
                            coverage_icon = 'âŒ'
                            coverage_text = 'Vacant'
                        elif personnel_assigne >= personnel_requis:
                            coverage_icon = 'âœ…'
                            coverage_text = 'Complet'
                        else:
                            coverage_icon = 'âš ï¸'
                            coverage_text = 'Partiel'
                        
                        if noms_complets:
                            personnel_str = ", ".join(noms_complets)
                            garde_text = f"<b>{garde_nom}</b> â€¢ {garde_horaire} â€¢ {coverage_icon} {personnel_assigne}/{personnel_requis}<br/>   ğŸ‘¤ {personnel_str}"
                        else:
                            garde_text = f"<b>{garde_nom}</b> â€¢ {garde_horaire} â€¢ {coverage_icon} {personnel_assigne}/{personnel_requis}<br/>   âš ï¸ <i>Aucun employÃ© assignÃ©</i>"
                        
                        elements.append(Paragraph(garde_text, garde_style))
                
                    # Ligne de sÃ©paration
                    if i < 6:  # Pas de ligne aprÃ¨s le dernier jour
                        elements.append(Spacer(1, 0.15*inch))
            
        elif type == 'mois':
            # Mode mois - Afficher semaine par semaine
            current = date_debut
            semaine_num = 1
            
            while current <= date_fin:
                # Titre de semaine
                fin_semaine = min(current + timedelta(days=6), date_fin)
                elements.append(Paragraph(
                    f"<b>SEMAINE {semaine_num} - Du {current.strftime('%d/%m')} au {fin_semaine.strftime('%d/%m/%Y')}</b>",
                    jour_style
                ))
                elements.append(Spacer(1, 0.15*inch))
                
                # Afficher les 7 jours de cette semaine
                for day_offset in range(7):
                    jour_actuel = current + timedelta(days=day_offset)
                    if jour_actuel > date_fin:
                        break
                    
                    date_str = jour_actuel.strftime('%Y-%m-%d')
                    current_day = jour_actuel.strftime('%A').lower()
                    jour_nom = jours_fr[jour_actuel.weekday()]
                    
                    # Titre du jour
                    elements.append(Paragraph(
                        f"<b>{jour_nom} {jour_actuel.strftime('%d/%m')}</b>",
                        garde_style
                    ))
                    
                    # Parcourir les types de garde
                    for type_garde in sorted(types_garde_list, key=lambda x: x.get('heure_debut', '')):
                        jours_app = type_garde.get('jours_application', [])
                        if jours_app and current_day not in jours_app:
                            continue
                        
                        assignations_jour = [a for a in assignations_list 
                                           if a['date'] == date_str 
                                           and a['type_garde_id'] == type_garde['id']]
                        
                        if assignations_jour or not jours_app:  # Afficher aussi les gardes vides
                            noms = [f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}" 
                                   for a in assignations_jour if a['user_id'] in users_map]
                            
                            personnel_requis = type_garde.get('personnel_requis', 1)
                            personnel_assigne = len(noms)
                            
                            # IcÃ´ne de couverture
                            if personnel_assigne == 0:
                                coverage_icon = 'âŒ'
                            elif personnel_assigne >= personnel_requis:
                                coverage_icon = 'âœ…'
                            else:
                                coverage_icon = 'âš ï¸'
                            
                            if noms:
                                personnel_str = ', '.join(noms)
                                garde_text = f"  â€¢ <b>{type_garde['nom']}</b> ({type_garde.get('heure_debut', '??:??')}-{type_garde.get('heure_fin', '??:??')}) {coverage_icon} {personnel_assigne}/{personnel_requis}: {personnel_str}"
                            else:
                                garde_text = f"  â€¢ <b>{type_garde['nom']}</b> ({type_garde.get('heure_debut', '??:??')}-{type_garde.get('heure_fin', '??:??')}) {coverage_icon} Vacant"
                            
                            elements.append(Paragraph(garde_text, styles['Normal']))
                    
                    elements.append(Spacer(1, 0.1*inch))
                
                # Passer Ã  la semaine suivante
                current += timedelta(days=7)
                semaine_num += 1
                
                if current <= date_fin:
                    elements.append(PageBreak())  # Nouvelle page par semaine
        
        # Fonction pour ajouter le footer sur chaque page
        def add_footer(canvas, doc_obj):
            canvas.saveState()
            
            # Ligne de sÃ©paration en haut du footer
            canvas.setStrokeColor(colors.HexColor('#e2e8f0'))
            canvas.setLineWidth(1)
            canvas.line(0.5*inch, 0.5*inch, landscape(letter)[0] - 0.5*inch, 0.5*inch)
            
            # Texte du footer
            canvas.setFont('Helvetica', 9)
            canvas.setFillColor(colors.HexColor('#64748b'))
            footer_text = f"Produit avec ProFireManager v2.0 â€¢ {datetime.now().strftime('%d/%m/%Y Ã  %H:%M')}"
            canvas.drawCentredString(landscape(letter)[0] / 2, 0.35*inch, footer_text)
            
            # NumÃ©ro de page
            canvas.setFont('Helvetica', 8)
            page_num_text = f"Page {doc_obj.page}"
            canvas.drawRightString(landscape(letter)[0] - 0.5*inch, 0.35*inch, page_num_text)
            
            canvas.restoreState()
        
        doc.build(elements, onFirstPage=add_footer, onLaterPages=add_footer)
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename=planning_{type}_{periode}.pdf"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/planning/export-excel")
async def export_planning_excel(
    tenant_slug: str, 
    periode: str,
    type: str,
    current_user: User = Depends(get_current_user)
):
    """Export du planning en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Calculer la pÃ©riode
        if type == 'semaine':
            date_debut = datetime.strptime(periode, '%Y-%m-%d')
            date_fin = date_debut + timedelta(days=6)
        else:
            year, month = map(int, periode.split('-'))
            date_debut = datetime(year, month, 1)
            if month == 12:
                date_fin = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                date_fin = datetime(year, month + 1, 1) - timedelta(days=1)
        
        assignations_list = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut.strftime('%Y-%m-%d'),
                "$lte": date_fin.strftime('%Y-%m-%d')
            }
        }).to_list(length=None)
        
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        types_map = {t['id']: t for t in types_garde_list}
        users_map = {u['id']: u for u in users_list}
        
        wb = Workbook()
        ws = wb.active
        ws.title = f"Planning {type}"
        
        header_fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        center_alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        ws.merge_cells('A1:H1')
        ws['A1'] = f"Planning des Gardes - {type.capitalize()}"
        ws['A1'].font = Font(bold=True, size=16, color="EF4444")
        ws['A1'].alignment = center_alignment
        
        ws.merge_cells('A2:H2')
        ws['A2'] = f"Du {date_debut.strftime('%d/%m/%Y')} au {date_fin.strftime('%d/%m/%Y')}"
        ws['A2'].alignment = center_alignment
        
        row = 4
        if type == 'semaine':
            headers = ['Type de Garde', 'Horaires'] + [(date_debut + timedelta(days=i)).strftime('%a %d/%m') for i in range(7)]
        else:
            headers = ['Date', 'Jour', 'Type de Garde', 'Horaires', 'Personnel', 'Requis', 'AssignÃ©s', 'Statut']
        
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = center_alignment
            cell.border = border
        
        row += 1
        
        if type == 'semaine':
            for type_garde in sorted(types_garde_list, key=lambda x: x.get('heure_debut', '')):
                ws.cell(row=row, column=1, value=type_garde['nom'])
                ws.cell(row=row, column=2, value=f"{type_garde.get('heure_debut', '')} - {type_garde.get('heure_fin', '')}")
                
                for i in range(7):
                    current_date = (date_debut + timedelta(days=i)).strftime('%Y-%m-%d')
                    assignations_jour = [a for a in assignations_list if a['date'] == current_date and a['type_garde_id'] == type_garde['id']]
                    
                    noms = [f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}" 
                           for a in assignations_jour if a['user_id'] in users_map]
                    
                    cell_text = '\n'.join(noms) if noms else 'Vacant'
                    cell = ws.cell(row=row, column=3+i, value=cell_text)
                    cell.alignment = center_alignment
                    cell.border = border
                    
                    if len(noms) >= type_garde.get('personnel_requis', 1):
                        cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
                    elif noms:
                        cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
                    else:
                        cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
                
                row += 1
        else:
            current = date_debut
            while current <= date_fin:
                date_str = current.strftime('%Y-%m-%d')
                jour_fr = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'][current.weekday()]
                
                for type_garde in types_garde_list:
                    assignations_jour = [a for a in assignations_list if a['date'] == date_str and a['type_garde_id'] == type_garde['id']]
                    
                    noms = [f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}" 
                           for a in assignations_jour if a['user_id'] in users_map]
                    
                    personnel_str = ', '.join(noms) if noms else 'Aucun'
                    requis = type_garde.get('personnel_requis', 1)
                    assignes = len(noms)
                    statut = 'Complet' if assignes >= requis else 'Partiel' if noms else 'Vacant'
                    
                    ws.cell(row=row, column=1, value=current.strftime('%d/%m/%Y'))
                    ws.cell(row=row, column=2, value=jour_fr)
                    ws.cell(row=row, column=3, value=type_garde['nom'])
                    ws.cell(row=row, column=4, value=f"{type_garde.get('heure_debut', '')} - {type_garde.get('heure_fin', '')}")
                    ws.cell(row=row, column=5, value=personnel_str)
                    ws.cell(row=row, column=6, value=requis)
                    ws.cell(row=row, column=7, value=assignes)
                    status_cell = ws.cell(row=row, column=8, value=statut)
                    
                    if statut == 'Complet':
                        status_cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
                    elif statut == 'Partiel':
                        status_cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
                    else:
                        status_cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
                    
                    for col in range(1, 9):
                        ws.cell(row=row, column=col).border = border
                        ws.cell(row=row, column=col).alignment = center_alignment
                    
                    row += 1
                
                current += timedelta(days=1)
        
        for col in ws.columns:
            max_length = 0
            column = col[0].column_letter
            for cell in col:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column].width = adjusted_width
        
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename=planning_{type}_{periode}.xlsx"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")

# ===== RAPPORT D'HEURES =====

@api_router.get("/{tenant_slug}/planning/rapport-heures")
async def get_rapport_heures(
    tenant_slug: str,
    date_debut: str,  # Format YYYY-MM-DD
    date_fin: str,    # Format YYYY-MM-DD
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re le rapport d'heures pour tous les employÃ©s sur une pÃ©riode"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin/Superviseur uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer tous les utilisateurs actifs
    users = await db.users.find({
        "tenant_id": tenant.id,
        "statut": "Actif"
    }).to_list(1000)
    
    # RÃ©cupÃ©rer toutes les assignations de la pÃ©riode
    assignations = await db.assignations.find({
        "tenant_id": tenant.id,
        "date": {
            "$gte": date_debut,
            "$lte": date_fin
        }
    }).to_list(10000)
    
    # DÃ‰DUPLICATION: Supprimer les doublons potentiels
    # ClÃ© unique: user_id + type_garde_id + date
    assignations_uniques = {}
    for a in assignations:
        key = f"{a['user_id']}_{a['type_garde_id']}_{a['date']}"
        if key not in assignations_uniques:
            assignations_uniques[key] = a
    
    assignations = list(assignations_uniques.values())
    logging.info(f"ğŸ“Š [RAPPORT] {len(assignations)} assignations uniques pour la pÃ©riode {date_debut} - {date_fin}")
    
    # RÃ©cupÃ©rer les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    # Calculer les heures pour chaque employÃ©
    rapport_data = []
    total_heures_internes = 0
    total_heures_externes = 0
    
    for user in users:
        heures_internes = 0
        heures_externes = 0
        nb_assignations = 0
        
        # Compter les heures de cet utilisateur
        for assignation in assignations:
            if assignation["user_id"] == user["id"]:
                type_garde = types_garde_map.get(assignation["type_garde_id"])
                if type_garde:
                    duree = type_garde.get("duree_heures", 8)
                    nb_assignations += 1
                    if type_garde.get("est_garde_externe", False):
                        heures_externes += duree
                    else:
                        heures_internes += duree
        
        # Log pour utilisateurs avec beaucoup d'heures
        if heures_internes + heures_externes > 150:
            logging.warning(f"âš ï¸ [RAPPORT] {user.get('prenom')} {user.get('nom')}: {nb_assignations} assignations = {heures_internes}h int + {heures_externes}h ext = {heures_internes + heures_externes}h total")
        
        total_heures_internes += heures_internes
        total_heures_externes += heures_externes
        
        rapport_data.append({
            "user_id": user["id"],
            "nom": user.get("nom", ""),
            "prenom": user.get("prenom", ""),
            "nom_complet": f"{user.get('prenom', '')} {user.get('nom', '')}",
            "type_emploi": user.get("type_emploi", "temps_plein"),
            "grade": user.get("grade", ""),
            "heures_internes": heures_internes,
            "heures_externes": heures_externes,
            "total_heures": heures_internes + heures_externes,
            "heures_max_semaine": user.get("heures_max_semaine", 40)
        })
    
    # Trier par nom
    rapport_data.sort(key=lambda x: (x["nom"], x["prenom"]))
    
    # Calculer les statistiques
    nombre_employes = len(users)
    moyenne_heures_internes = total_heures_internes / nombre_employes if nombre_employes > 0 else 0
    moyenne_heures_externes = total_heures_externes / nombre_employes if nombre_employes > 0 else 0
    
    return {
        "periode": {
            "debut": date_debut,
            "fin": date_fin
        },
        "employes": rapport_data,
        "statistiques": {
            "nombre_employes": nombre_employes,
            "total_heures_internes": total_heures_internes,
            "total_heures_externes": total_heures_externes,
            "total_heures_planifiees": total_heures_internes + total_heures_externes,
            "moyenne_heures_internes": round(moyenne_heures_internes, 1),
            "moyenne_heures_externes": round(moyenne_heures_externes, 1)
        }
    }

@api_router.get("/{tenant_slug}/planning/rapport-heures/debug/{user_id}")
async def debug_rapport_heures_user(
    tenant_slug: str,
    user_id: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Endpoint de diagnostic pour comprendre le calcul des heures d'un utilisateur"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer l'utilisateur
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    # RÃ©cupÃ©rer TOUTES les assignations (avec doublons Ã©ventuels)
    assignations_brutes = await db.assignations.find({
        "user_id": user_id,
        "tenant_id": tenant.id,
        "date": {"$gte": date_debut, "$lte": date_fin}
    }, {"_id": 0}).to_list(10000)
    
    # DÃ©duplication
    assignations_uniques = {}
    doublons = []
    for a in assignations_brutes:
        key = f"{a['user_id']}_{a['type_garde_id']}_{a['date']}"
        if key not in assignations_uniques:
            assignations_uniques[key] = a
        else:
            doublons.append(a)
    
    assignations = list(assignations_uniques.values())
    
    # RÃ©cupÃ©rer les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    # Calculer les dÃ©tails
    details = []
    total_heures = 0
    total_heures_calculees = 0
    
    for a in assignations:
        type_garde = types_garde_map.get(a["type_garde_id"])
        if type_garde:
            duree_stored = type_garde.get("duree_heures", None)
            
            # Calculer la durÃ©e rÃ©elle Ã  partir des horaires
            duree_calculee = None
            if type_garde.get("heure_debut") and type_garde.get("heure_fin"):
                try:
                    from datetime import datetime
                    debut = datetime.strptime(type_garde["heure_debut"], "%H:%M")
                    fin = datetime.strptime(type_garde["heure_fin"], "%H:%M")
                    if fin < debut:
                        fin = fin.replace(day=debut.day + 1)
                    delta = (fin - debut).total_seconds() / 3600
                    duree_calculee = round(delta, 2)
                except:
                    duree_calculee = None
            
            # DurÃ©e utilisÃ©e par le code (celle dans le rapport)
            duree_utilisee = duree_stored if duree_stored is not None else 8
            
            total_heures += duree_utilisee
            if duree_calculee:
                total_heures_calculees += duree_calculee
            
            details.append({
                "date": a["date"],
                "type_garde_nom": type_garde.get("nom"),
                "type_garde_id": a["type_garde_id"],
                "heure_debut": type_garde.get("heure_debut"),
                "heure_fin": type_garde.get("heure_fin"),
                "duree_stored_bd": duree_stored,
                "duree_calculee_horaires": duree_calculee,
                "duree_utilisee_rapport": duree_utilisee,
                "est_garde_externe": type_garde.get("est_garde_externe", False)
            })
    
    return {
        "user": {
            "id": user["id"],
            "nom_complet": f"{user.get('prenom')} {user.get('nom')}",
            "email": user.get("email"),
            "heures_max_semaine": user.get("heures_max_semaine", 40)
        },
        "periode": f"{date_debut} au {date_fin}",
        "compteurs": {
            "assignations_brutes": len(assignations_brutes),
            "assignations_uniques": len(assignations),
            "doublons_detectes": len(doublons),
            "total_heures_rapport": total_heures,
            "total_heures_reelles_calculees": total_heures_calculees
        },
        "assignations_details": sorted(details, key=lambda x: x["date"]),
        "doublons": doublons[:10] if doublons else []
    }

@api_router.get("/{tenant_slug}/planning/rapport-assignations-invalides")
async def rapport_assignations_invalides(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Identifie toutes les assignations qui ne respectent pas les jours_application du type de garde"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer toutes les assignations
    assignations = await db.assignations.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(10000)
    
    # RÃ©cupÃ©rer tous les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    # RÃ©cupÃ©rer tous les users
    users = await db.users.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    users_map = {u["id"]: u for u in users}
    
    # Jours de la semaine
    jours_fr_to_en = {
        0: "monday",
        1: "tuesday", 
        2: "wednesday",
        3: "thursday",
        4: "friday",
        5: "saturday",
        6: "sunday"
    }
    
    assignations_invalides = []
    assignations_valides_count = 0
    
    for a in assignations:
        type_garde = types_garde_map.get(a["type_garde_id"])
        if not type_garde:
            continue
        
        jours_application = type_garde.get("jours_application", [])
        
        # Si pas de jours_application, considÃ©rÃ© comme valide pour tous les jours
        if not jours_application or len(jours_application) == 0:
            assignations_valides_count += 1
            continue
        
        # VÃ©rifier le jour de la semaine de cette assignation
        try:
            from datetime import datetime
            date_obj = datetime.strptime(a["date"], "%Y-%m-%d")
            jour_semaine_index = date_obj.weekday()  # 0=lundi, 6=dimanche
            jour_semaine_en = jours_fr_to_en[jour_semaine_index]
            
            # VÃ©rifier si le jour est dans jours_application
            if jour_semaine_en not in jours_application:
                user = users_map.get(a["user_id"], {})
                assignations_invalides.append({
                    "assignation_id": a.get("id"),
                    "date": a["date"],
                    "jour_semaine": jour_semaine_en,
                    "user_nom_complet": f"{user.get('prenom', '')} {user.get('nom', '')}",
                    "user_id": a["user_id"],
                    "type_garde_nom": type_garde.get("nom"),
                    "type_garde_id": a["type_garde_id"],
                    "jours_application_garde": jours_application,
                    "raison": f"Assignation sur {jour_semaine_en} mais garde limitÃ©e Ã  {', '.join(jours_application)}"
                })
            else:
                assignations_valides_count += 1
        except Exception as e:
            logging.error(f"Erreur analyse assignation {a.get('id')}: {str(e)}")
    
    # Grouper par utilisateur
    by_user = {}
    for inv in assignations_invalides:
        user_id = inv["user_id"]
        if user_id not in by_user:
            by_user[user_id] = {
                "user_nom_complet": inv["user_nom_complet"],
                "count": 0,
                "assignations": []
            }
        by_user[user_id]["count"] += 1
        by_user[user_id]["assignations"].append(inv)
    
    return {
        "message": f"TrouvÃ© {len(assignations_invalides)} assignations invalides sur {len(assignations)} totales",
        "statistiques": {
            "total_assignations": len(assignations),
            "assignations_invalides": len(assignations_invalides),
            "assignations_valides": assignations_valides_count,
            "utilisateurs_affectes": len(by_user)
        },
        "par_utilisateur": by_user,
        "toutes_invalides": sorted(assignations_invalides, key=lambda x: (x["date"], x["user_nom_complet"]))
    }

@api_router.post("/{tenant_slug}/planning/supprimer-assignations-invalides")
async def supprimer_assignations_invalides(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Supprime toutes les assignations qui ne respectent pas les jours_application"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # D'abord, rÃ©cupÃ©rer le rapport des invalides
    assignations = await db.assignations.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(10000)
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    jours_fr_to_en = {
        0: "monday", 1: "tuesday", 2: "wednesday", 3: "thursday",
        4: "friday", 5: "saturday", 6: "sunday"
    }
    
    ids_to_delete = []
    
    for a in assignations:
        type_garde = types_garde_map.get(a["type_garde_id"])
        if not type_garde:
            continue
        
        jours_application = type_garde.get("jours_application", [])
        if not jours_application:
            continue
        
        try:
            from datetime import datetime
            date_obj = datetime.strptime(a["date"], "%Y-%m-%d")
            jour_semaine_en = jours_fr_to_en[date_obj.weekday()]
            
            if jour_semaine_en not in jours_application:
                ids_to_delete.append(a["id"])
        except:
            pass
    
    # Supprimer
    if ids_to_delete:
        result = await db.assignations.delete_many({
            "id": {"$in": ids_to_delete},
            "tenant_id": tenant.id
        })
        deleted_count = result.deleted_count
    else:
        deleted_count = 0
    
    return {
        "message": f"SupprimÃ© {deleted_count} assignations invalides",
        "deleted_count": deleted_count,
        "ids_supprimes": ids_to_delete[:50]  # Max 50 pour la rÃ©ponse
    }

@api_router.post("/{tenant_slug}/planning/recalculer-durees-gardes")
async def recalculer_durees_gardes(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Recalcule le champ duree_heures pour tous les types de garde en utilisant heure_debut et heure_fin"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer tous les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    
    corrections = []
    erreurs = []
    
    for tg in types_garde:
        type_id = tg["id"]
        nom = tg.get("nom", "Sans nom")
        heure_debut = tg.get("heure_debut")
        heure_fin = tg.get("heure_fin")
        duree_actuelle = tg.get("duree_heures")
        
        if heure_debut and heure_fin:
            try:
                from datetime import datetime
                debut = datetime.strptime(heure_debut, "%H:%M")
                fin = datetime.strptime(heure_fin, "%H:%M")
                
                # Gestion du cas oÃ¹ la garde traverse minuit
                if fin < debut:
                    fin = fin.replace(day=debut.day + 1)
                
                delta = (fin - debut).total_seconds() / 3600
                duree_calculee = round(delta, 2)
                
                # Mise Ã  jour seulement si diffÃ©rent ou absent
                if duree_actuelle is None or abs(duree_actuelle - duree_calculee) > 0.01:
                    await db.types_garde.update_one(
                        {"id": type_id, "tenant_id": tenant.id},
                        {"$set": {"duree_heures": duree_calculee}}
                    )
                    corrections.append({
                        "type_garde": nom,
                        "horaires": f"{heure_debut} - {heure_fin}",
                        "duree_avant": duree_actuelle,
                        "duree_apres": duree_calculee,
                        "statut": "corrigÃ©"
                    })
                else:
                    corrections.append({
                        "type_garde": nom,
                        "horaires": f"{heure_debut} - {heure_fin}",
                        "duree": duree_actuelle,
                        "statut": "dÃ©jÃ _correct"
                    })
                    
            except Exception as e:
                erreurs.append({
                    "type_garde": nom,
                    "erreur": str(e),
                    "horaires": f"{heure_debut} - {heure_fin}"
                })
        else:
            erreurs.append({
                "type_garde": nom,
                "erreur": "horaires manquants",
                "heure_debut": heure_debut,
                "heure_fin": heure_fin
            })
    
    nb_corriges = len([c for c in corrections if c.get("statut") == "corrigÃ©"])
    nb_deja_ok = len([c for c in corrections if c.get("statut") == "dÃ©jÃ _correct"])
    
    return {
        "message": f"Recalcul terminÃ©: {nb_corriges} corrigÃ©s, {nb_deja_ok} dÃ©jÃ  corrects, {len(erreurs)} erreurs",
        "corrections": corrections,
        "erreurs": erreurs,
        "statistiques": {
            "total_types_garde": len(types_garde),
            "corriges": nb_corriges,
            "deja_corrects": nb_deja_ok,
            "erreurs": len(erreurs)
        }
    }

@api_router.get("/{tenant_slug}/planning/rapport-heures/export-pdf")
async def export_rapport_heures_pdf(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """GÃ©nÃ¨re le PDF du rapport d'heures pour impression"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es du rapport
    rapport_response = await get_rapport_heures(tenant_slug, date_debut, date_fin, current_user)
    
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.platypus import Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    
    # Utiliser la fonction helper pour crÃ©er un PDF brandÃ©
    buffer, doc, elements = create_branded_pdf(tenant, pagesize=A4)
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Titre
    elements.append(Paragraph("Rapport d'Heures", modern_styles['title']))
    
    # PÃ©riode
    debut_dt = datetime.strptime(date_debut, "%Y-%m-%d")
    fin_dt = datetime.strptime(date_fin, "%Y-%m-%d")
    periode_text = f"PÃ©riode: {debut_dt.strftime('%d/%m/%Y')} - {fin_dt.strftime('%d/%m/%Y')}"
    elements.append(Paragraph(periode_text, modern_styles['subheading']))
    
    # Tableau des employÃ©s
    table_data = [
        ['EmployÃ©', 'Type', 'Grade', 'H. Internes', 'H. Externes', 'Total']
    ]
    
    for emp in rapport_response["employes"]:
        type_emploi_abbr = "TP" if emp["type_emploi"] == "temps_partiel" else "TF"
        table_data.append([
            emp["nom_complet"],
            type_emploi_abbr,
            emp["grade"],
            f"{emp['heures_internes']}h",
            f"{emp['heures_externes']}h",
            f"{emp['total_heures']}h"
        ])
    
    table = Table(table_data, colWidths=[2.5*inch, 0.6*inch, 1.2*inch, 1*inch, 1*inch, 0.8*inch])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('FONTSIZE', (0, 1), (-1, -1), 9),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    elements.append(table)
    elements.append(Spacer(1, 0.3*inch))
    
    # Statistiques
    stats = rapport_response["statistiques"]
    stats_text = f"""
    <b>Statistiques Globales</b><br/>
    Nombre d'employÃ©s: {stats['nombre_employes']}<br/>
    Total heures planifiÃ©es: {stats['total_heures_planifiees']}h<br/>
    Moyenne heures internes: {stats['moyenne_heures_internes']}h<br/>
    Moyenne heures externes: {stats['moyenne_heures_externes']}h
    """
    elements.append(Paragraph(stats_text, styles['Normal']))
    
    # Ajouter footer ProFireManager
    elements.append(Spacer(1, 0.5*inch))
    footer_style = ParagraphStyle(
        'Footer',
        parent=styles['Normal'],
        fontSize=8,
        textColor=colors.grey,
        alignment=TA_CENTER
    )
    footer_text = create_pdf_footer_text(tenant)
    if footer_text:
        elements.append(Paragraph(footer_text, footer_style))
    
    doc.build(elements)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=rapport_heures_{date_debut}_{date_fin}.pdf"}
    )

@api_router.get("/{tenant_slug}/planning/rapport-heures/export-excel")
async def export_rapport_heures_excel(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """GÃ©nÃ¨re l'Excel du rapport d'heures"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es du rapport
    rapport_response = await get_rapport_heures(tenant_slug, date_debut, date_fin, current_user)
    
    from openpyxl import Workbook
    from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
    from io import BytesIO
    
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport Heures"
    
    # Styles
    header_fill = PatternFill(start_color="DC2626", end_color="DC2626", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True, size=11)
    border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    center_alignment = Alignment(horizontal="center", vertical="center")
    
    # Titre
    ws.merge_cells('A1:F1')
    title_cell = ws['A1']
    title_cell.value = "Rapport d'Heures"
    title_cell.font = Font(size=16, bold=True, color="DC2626")
    title_cell.alignment = center_alignment
    
    # PÃ©riode
    ws.merge_cells('A2:F2')
    periode_cell = ws['A2']
    debut_dt = datetime.strptime(date_debut, "%Y-%m-%d")
    fin_dt = datetime.strptime(date_fin, "%Y-%m-%d")
    periode_cell.value = f"PÃ©riode: {debut_dt.strftime('%d/%m/%Y')} - {fin_dt.strftime('%d/%m/%Y')}"
    periode_cell.alignment = center_alignment
    
    # En-tÃªtes du tableau
    headers = ['EmployÃ©', 'Type', 'Grade', 'H. Internes', 'H. Externes', 'Total']
    for col, header in enumerate(headers, start=1):
        cell = ws.cell(row=4, column=col)
        cell.value = header
        cell.fill = header_fill
        cell.font = header_font
        cell.border = border
        cell.alignment = center_alignment
    
    # DonnÃ©es
    row = 5
    for emp in rapport_response["employes"]:
        type_emploi_abbr = "TP" if emp["type_emploi"] == "temps_partiel" else "TF"
        ws.cell(row=row, column=1, value=emp["nom_complet"])
        ws.cell(row=row, column=2, value=type_emploi_abbr)
        ws.cell(row=row, column=3, value=emp["grade"])
        ws.cell(row=row, column=4, value=emp["heures_internes"])
        ws.cell(row=row, column=5, value=emp["heures_externes"])
        ws.cell(row=row, column=6, value=emp["total_heures"])
        
        for col in range(1, 7):
            ws.cell(row=row, column=col).border = border
            ws.cell(row=row, column=col).alignment = center_alignment
        
        row += 1
    
    # Statistiques
    stats = rapport_response["statistiques"]
    row += 1
    ws.merge_cells(f'A{row}:F{row}')
    stats_cell = ws.cell(row=row, column=1)
    stats_cell.value = "Statistiques Globales"
    stats_cell.font = Font(bold=True, size=12)
    
    row += 1
    ws.cell(row=row, column=1, value="Nombre d'employÃ©s:")
    ws.cell(row=row, column=2, value=stats['nombre_employes'])
    
    row += 1
    ws.cell(row=row, column=1, value="Total heures planifiÃ©es:")
    ws.cell(row=row, column=2, value=stats['total_heures_planifiees'])
    
    row += 1
    ws.cell(row=row, column=1, value="Moyenne heures internes:")
    ws.cell(row=row, column=2, value=stats['moyenne_heures_internes'])
    
    row += 1
    ws.cell(row=row, column=1, value="Moyenne heures externes:")
    ws.cell(row=row, column=2, value=stats['moyenne_heures_externes'])
    
    # Ajuster les largeurs
    ws.column_dimensions['A'].width = 25
    ws.column_dimensions['B'].width = 8
    ws.column_dimensions['C'].width = 15
    ws.column_dimensions['D'].width = 12
    ws.column_dimensions['E'].width = 12
    ws.column_dimensions['F'].width = 10
    
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename=rapport_heures_{date_debut}_{date_fin}.xlsx"}
    )

# ===== FIN EXPORTS PLANNING =====


@api_router.delete("/{tenant_slug}/planning/assignation/{assignation_id}")
async def retirer_assignation(tenant_slug: str, assignation_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Trouver l'assignation dans ce tenant
        assignation = await db.assignations.find_one({"id": assignation_id, "tenant_id": tenant.id})
        if not assignation:
            raise HTTPException(status_code=404, detail="Assignation non trouvÃ©e")
        
        # Supprimer l'assignation
        result = await db.assignations.delete_one({"id": assignation_id, "tenant_id": tenant.id})
        if result.deleted_count == 0:
            raise HTTPException(status_code=400, detail="Impossible de retirer l'assignation")
        
        # CrÃ©er une activitÃ©
        user = await db.users.find_one({"id": assignation["user_id"], "tenant_id": tenant.id})
        type_garde = await db.types_garde.find_one({"id": assignation.get("type_garde_id"), "tenant_id": tenant.id})
        if user and type_garde:
            await creer_activite(
                tenant_id=tenant.id,
                type_activite="assignation_retrait",
                description=f"âŒ {current_user.prenom} {current_user.nom} a retirÃ© {user['prenom']} {user['nom']} de la garde '{type_garde['nom']}' du {assignation['date']}",
                user_id=current_user.id,
                user_nom=f"{current_user.prenom} {current_user.nom}",
                data={"concerne_user_id": assignation["user_id"]}
            )
        
        return {
            "message": "Assignation retirÃ©e avec succÃ¨s",
            "assignation_supprimee": assignation_id,
            "date": assignation["date"],
            "user_id": assignation["user_id"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur suppression assignation: {str(e)}")

@api_router.post("/{tenant_slug}/planning/assignation")
async def create_assignation(tenant_slug: str, assignation: AssignationCreate, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ‰RIFICATION CRITIQUE : EmpÃªcher les doublons
    # VÃ©rifier si cet utilisateur est dÃ©jÃ  assignÃ© Ã  cette garde Ã  cette date
    existing_assignment = await db.assignations.find_one({
        "tenant_id": tenant.id,
        "user_id": assignation.user_id,
        "type_garde_id": assignation.type_garde_id,
        "date": assignation.date
    })
    
    if existing_assignment:
        raise HTTPException(
            status_code=400, 
            detail="Cet employÃ© est dÃ©jÃ  assignÃ© Ã  cette garde pour cette date"
        )
    
    # Store assignation in database avec tenant_id
    assignation_dict = assignation.dict()
    assignation_dict["tenant_id"] = tenant.id
    assignation_obj = Assignation(**assignation_dict)
    await db.assignations.insert_one(assignation_obj.dict())
    
    # CrÃ©er notification pour l'employÃ© assignÃ© (filtrÃ© par tenant)
    user_assigne = await db.users.find_one({"id": assignation.user_id, "tenant_id": tenant.id})
    type_garde = await db.types_garde.find_one({"id": assignation.type_garde_id, "tenant_id": tenant.id})
    
    if user_assigne and type_garde:
        await creer_notification(
            tenant_id=tenant.id,
            destinataire_id=assignation.user_id,
            type="planning_assigne",
            titre="Nouveau quart assignÃ©",
            message=f"Vous avez Ã©tÃ© assignÃ©(e) au quart '{type_garde['nom']}' le {assignation.date}",
            lien="/planning",
            data={
                "assignation_id": assignation_obj.id,
                "date": assignation.date,
                "type_garde": type_garde["nom"]
            }
        )
        
        # CrÃ©er une activitÃ©
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="assignation_manuelle",
            description=f"ğŸ“… {current_user.prenom} {current_user.nom} a assignÃ© {user_assigne['prenom']} {user_assigne['nom']} Ã  la garde '{type_garde['nom']}' le {assignation.date}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": assignation.user_id}  # Pour filtrage superviseur/employÃ©
        )
    
    return {"message": "Assignation crÃ©Ã©e avec succÃ¨s"}

@api_router.get("/{tenant_slug}/planning/assignations/{semaine_debut}")
async def get_assignations(tenant_slug: str, semaine_debut: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # DÃ©terminer la pÃ©riode en fonction du format de la date
    # Si c'est le 1er du mois (ex: 2024-10-01), rÃ©cupÃ©rer tout le mois
    # Sinon, rÃ©cupÃ©rer la semaine (7 jours)
    date_debut = datetime.strptime(semaine_debut, "%Y-%m-%d")
    
    if date_debut.day == 1:
        # Vue mensuelle : rÃ©cupÃ©rer tout le mois
        # Dernier jour du mois
        if date_debut.month == 12:
            date_fin = datetime(date_debut.year + 1, 1, 1) - timedelta(days=1)
        else:
            date_fin = datetime(date_debut.year, date_debut.month + 1, 1) - timedelta(days=1)
    else:
        # Vue hebdomadaire : rÃ©cupÃ©rer 7 jours
        date_fin = date_debut + timedelta(days=6)
    
    date_fin_str = date_fin.strftime("%Y-%m-%d")
    
    assignations = await db.assignations.find({
        "tenant_id": tenant.id,
        "date": {
            "$gte": semaine_debut,
            "$lte": date_fin_str
        }
    }).to_list(1000)
    
    # Clean MongoDB documents
    cleaned_assignations = [clean_mongo_doc(assignation) for assignation in assignations]
    return [Assignation(**assignation) for assignation in cleaned_assignations]

# ROUTE GÃ‰NÃ‰RIQUE - DOIT ÃŠTRE APRÃˆS TOUTES LES ROUTES SPÃ‰CIFIQUES
@api_router.get("/{tenant_slug}/planning/{semaine_debut}")
async def get_planning(tenant_slug: str, semaine_debut: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    planning = await db.planning.find_one({"semaine_debut": semaine_debut, "tenant_id": tenant.id})
    if not planning:
        # Create empty planning for the week
        semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        planning_obj = Planning(semaine_debut=semaine_debut, semaine_fin=semaine_fin)
        planning_dict = planning_obj.dict()
        planning_dict["tenant_id"] = tenant.id
        await db.planning.insert_one(planning_dict)
        planning = planning_dict
    else:
        planning = clean_mongo_doc(planning)
    
    return planning

# Remplacements routes

# ==================== SYSTÃˆME AUTOMATISÃ‰ DE REMPLACEMENT ====================

async def calculer_priorite_demande(date_garde: str) -> str:
    """
    Calcule la prioritÃ© d'une demande de remplacement
    - urgent: Si la garde est dans 24h ou moins
    - normal: Si la garde est dans plus de 24h
    """
    try:
        date_garde_obj = datetime.strptime(date_garde, "%Y-%m-%d").replace(tzinfo=timezone.utc)
        maintenant = datetime.now(timezone.utc)
        delta = date_garde_obj - maintenant
        
        if delta.total_seconds() <= 86400:  # 24 heures en secondes
            return "urgent"
        return "normal"
    except Exception as e:
        logging.error(f"Erreur calcul prioritÃ©: {e}")
        return "normal"

async def trouver_remplacants_potentiels(
    tenant_id: str,
    type_garde_id: str,
    date_garde: str,
    demandeur_id: str,
    exclus_ids: List[str] = []
) -> List[Dict[str, Any]]:
    """
    Trouve les remplaÃ§ants potentiels selon les critÃ¨res:
    1. CompÃ©tences requises pour le type de garde
    2. Grade Ã©quivalent ou supÃ©rieur (lieutenant peut remplacer pompier)
    3. Pas d'indisponibilitÃ© pour cette date
    4. DisponibilitÃ© dÃ©clarÃ©e (bonus de tri)
    5. AnciennetÃ© (date_embauche la plus ancienne)
    
    Retourne une liste triÃ©e de remplaÃ§ants par ordre de prioritÃ©
    """
    try:
        # RÃ©cupÃ©rer le type de garde pour connaÃ®tre les compÃ©tences requises
        type_garde_data = await db.types_garde.find_one({"id": type_garde_id, "tenant_id": tenant_id})
        if not type_garde_data:
            logging.error(f"Type de garde non trouvÃ©: {type_garde_id}")
            return []
        
        competences_requises = type_garde_data.get("competences_requises", [])
        officier_obligatoire = type_garde_data.get("officier_obligatoire", False)
        
        # RÃ©cupÃ©rer tous les utilisateurs du tenant (sauf demandeur et dÃ©jÃ  exclus)
        exclus_ids_set = set(exclus_ids + [demandeur_id])
        
        users_cursor = db.users.find({
            "tenant_id": tenant_id,
            "id": {"$nin": list(exclus_ids_set)},
            "type_emploi": "temps_partiel"  # Seulement temps partiel pour remplacements
        })
        users_list = await users_cursor.to_list(length=None)
        
        remplacants_potentiels = []
        
        for user in users_list:
            # 1. VÃ©rifier les compÃ©tences
            user_competences = set(user.get("competences", []))
            if competences_requises and not set(competences_requises).issubset(user_competences):
                continue  # Ne possÃ¨de pas toutes les compÃ©tences requises
            
            # 2. VÃ©rifier le grade
            user_grade = user.get("grade", "pompier")
            grades_hierarchie = ["pompier", "lieutenant", "capitaine", "chef"]
            
            if officier_obligatoire:
                # Pour officier obligatoire, il faut au moins lieutenant
                if user_grade not in ["lieutenant", "capitaine", "chef"]:
                    continue
            
            # 3. VÃ©rifier qu'il n'a PAS d'indisponibilitÃ© pour cette date
            indispo = await db.disponibilites.find_one({
                "user_id": user["id"],
                "tenant_id": tenant_id,
                "date": date_garde,
                "statut": "indisponible"
            })
            
            if indispo:
                continue  # A une indisponibilitÃ©, on passe
            
            # 3b. VÃ©rifier les limites d'heures (gestion heures supplÃ©mentaires)
            # RÃ©cupÃ©rer les paramÃ¨tres de remplacements
            parametres = await db.parametres_remplacements.find_one({"tenant_id": tenant_id})
            if parametres and parametres.get("activer_gestion_heures_sup", False):
                # Si heures sup activÃ©es, ne pas limiter
                pass  # Autoriser toutes les heures
            else:
                # Heures sup dÃ©sactivÃ©es : vÃ©rifier la limite hebdo
                heures_max_user = user.get("heures_max_semaine", 40)
                
                # Calculer heures de la semaine pour cet utilisateur
                semaine_debut = datetime.strptime(date_garde, "%Y-%m-%d")
                while semaine_debut.weekday() != 0:  # Trouver le lundi
                    semaine_debut -= timedelta(days=1)
                semaine_fin = semaine_debut + timedelta(days=6)
                
                assignations_semaine = await db.assignations.find({
                    "user_id": user["id"],
                    "tenant_id": tenant_id,
                    "date": {
                        "$gte": semaine_debut.strftime("%Y-%m-%d"),
                        "$lte": semaine_fin.strftime("%Y-%m-%d")
                    }
                }).to_list(1000)
                
                heures_semaine = sum(8 for _ in assignations_semaine)  # Simplification: 8h par garde
                duree_garde = type_garde_data.get("duree_heures", 8)
                
                if heures_semaine + duree_garde > heures_max_user:
                    continue  # Skip car dÃ©passe les heures max hebdo
            
            # 4. VÃ©rifier s'il a une disponibilitÃ© dÃ©clarÃ©e (bonus)
            dispo = await db.disponibilites.find_one({
                "user_id": user["id"],
                "tenant_id": tenant_id,
                "date": date_garde,
                "statut": "disponible"
            })
            
            has_disponibilite = dispo is not None
            
            # 5. AnciennetÃ© (date_embauche)
            date_embauche = user.get("date_embauche", "2999-12-31")  # Si pas de date, le plus rÃ©cent
            
            remplacants_potentiels.append({
                "user_id": user["id"],
                "nom_complet": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "email": user.get("email", ""),
                "grade": user_grade,
                "date_embauche": date_embauche,
                "has_disponibilite": has_disponibilite,
                "formations": list(user_formations)
            })
        
        # Trier par: 1. DisponibilitÃ© dÃ©clarÃ©e, 2. AnciennetÃ© (date la plus ancienne)
        remplacants_potentiels.sort(
            key=lambda x: (
                not x["has_disponibilite"],  # False (a dispo) avant True (pas de dispo)
                x["date_embauche"]  # Date la plus ancienne en premier
            )
        )
        
        logging.info(f"âœ… TrouvÃ© {len(remplacants_potentiels)} remplaÃ§ants potentiels pour demande {type_garde_id}")
        return remplacants_potentiels
        
    except Exception as e:
        logging.error(f"âŒ Erreur lors de la recherche de remplaÃ§ants: {e}", exc_info=True)
        return []

async def lancer_recherche_remplacant(demande_id: str, tenant_id: str):
    """
    Lance la recherche de remplaÃ§ant pour une demande
    Contacte le(s) premier(s) remplaÃ§ant(s) selon le mode de notification
    """
    try:
        # RÃ©cupÃ©rer la demande
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            logging.error(f"Demande de remplacement non trouvÃ©e: {demande_id}")
            return
        
        # RÃ©cupÃ©rer les paramÃ¨tres de remplacement
        parametres_data = await db.parametres.find_one({"tenant_id": tenant_id})
        if not parametres_data:
            # ParamÃ¨tres par dÃ©faut
            mode_notification = "un_par_un"
            delai_attente_heures = 2
            nombre_simultane = 1
        else:
            mode_notification = parametres_data.get("mode_notification", "un_par_un")
            delai_attente_heures = parametres_data.get("delai_attente_heures", 2)
            nombre_simultane = parametres_data.get("nombre_simultane", 3)
        
        # Trouver les remplaÃ§ants potentiels (excluant ceux dÃ©jÃ  contactÃ©s)
        exclus_ids = [t.get("user_id") for t in demande_data.get("tentatives_historique", [])]
        
        remplacants = await trouver_remplacants_potentiels(
            tenant_id=tenant_id,
            type_garde_id=demande_data["type_garde_id"],
            date_garde=demande_data["date"],
            demandeur_id=demande_data["demandeur_id"],
            exclus_ids=exclus_ids
        )
        
        if not remplacants:
            # Aucun remplaÃ§ant trouvÃ©, marquer comme expiree et notifier superviseur
            logging.warning(f"âš ï¸ Aucun remplaÃ§ant trouvÃ© pour la demande {demande_id}")
            await db.demandes_remplacement.update_one(
                {"id": demande_id},
                {
                    "$set": {
                        "statut": "expiree",
                        "updated_at": datetime.now(timezone.utc)
                    }
                }
            )
            
            # Notifier superviseurs qu'aucun remplaÃ§ant n'a Ã©tÃ© trouvÃ©
            superviseurs = await db.users.find({
                "tenant_id": tenant_id,
                "role": {"$in": ["superviseur", "admin"]}
            }).to_list(100)
            
            superviseur_ids = [s["id"] for s in superviseurs]
            if superviseur_ids:
                demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
                await send_push_notification_to_users(
                    user_ids=superviseur_ids,
                    title="âŒ Aucun remplaÃ§ant trouvÃ©",
                    body=f"Aucun remplaÃ§ant disponible pour {demandeur.get('prenom', '')} {demandeur.get('nom', '')} le {demande_data['date']}",
                    data={
                        "type": "remplacement_expiree",
                        "demande_id": demande_id
                    }
                )
            return
        
        # DÃ©terminer combien de remplaÃ§ants contacter
        if mode_notification == "multiple":
            nombre_a_contacter = min(nombre_simultane, len(remplacants))
        else:  # un_par_un
            nombre_a_contacter = 1
        
        remplacants_a_contacter = remplacants[:nombre_a_contacter]
        
        # Contacter les remplaÃ§ants
        remplacant_ids = []
        maintenant = datetime.now(timezone.utc)
        
        for remplacant in remplacants_a_contacter:
            # Ajouter Ã  l'historique
            tentative = {
                "user_id": remplacant["user_id"],
                "nom_complet": remplacant["nom_complet"],
                "date_contact": maintenant.isoformat(),
                "statut": "contacted",
                "date_reponse": None
            }
            
            await db.demandes_remplacement.update_one(
                {"id": demande_id},
                {
                    "$push": {"tentatives_historique": tentative},
                    "$addToSet": {"remplacants_contactes_ids": remplacant["user_id"]}
                }
            )
            
            remplacant_ids.append(remplacant["user_id"])
            
            logging.info(f"ğŸ“¤ Contact remplaÃ§ant {remplacant['nom_complet']} pour demande {demande_id}")
        
        # Calculer la date de prochaine tentative (si timeout sans rÃ©ponse)
        date_prochaine = maintenant + timedelta(hours=delai_attente_heures)
        
        # Mettre Ã  jour la demande
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "en_cours",
                    "date_prochaine_tentative": date_prochaine,
                    "updated_at": maintenant
                },
                "$inc": {"nombre_tentatives": 1}
            }
        )
        
        # Envoyer notifications push aux remplaÃ§ants
        demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
        type_garde = await db.types_garde.find_one({"id": demande_data["type_garde_id"]})
        
        await send_push_notification_to_users(
            user_ids=remplacant_ids,
            title="ğŸš¨ Demande de remplacement",
            body=f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')} cherche un remplaÃ§ant pour {type_garde.get('nom', 'une garde')} le {demande_data['date']}",
            data={
                "type": "remplacement_proposition",
                "demande_id": demande_id,
                "lien": "/remplacements"
            }
        )
        
        logging.info(f"âœ… Recherche lancÃ©e pour demande {demande_id}: {nombre_a_contacter} remplaÃ§ant(s) contactÃ©(s)")
        
    except Exception as e:
        logging.error(f"âŒ Erreur lors du lancement de la recherche de remplaÃ§ant: {e}", exc_info=True)

async def accepter_remplacement(demande_id: str, remplacant_id: str, tenant_id: str):
    """
    Traite l'acceptation d'un remplacement par un remplaÃ§ant
    - VÃ©rifie que le remplaÃ§ant est le plus ancien si plusieurs acceptations simultanÃ©es
    - Met Ã  jour le planning (assignations)
    - Notifie le demandeur et les superviseurs
    """
    try:
        # RÃ©cupÃ©rer la demande
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
        
        # VÃ©rifier que la demande est toujours en cours
        if demande_data["statut"] != "en_cours":
            raise HTTPException(status_code=400, detail="Cette demande n'est plus disponible")
        
        # VÃ©rifier que le remplaÃ§ant a bien Ã©tÃ© contactÃ©
        if remplacant_id not in demande_data.get("remplacants_contactes_ids", []):
            raise HTTPException(status_code=403, detail="Vous n'Ãªtes pas autorisÃ© Ã  accepter cette demande")
        
        # RÃ©cupÃ©rer le remplaÃ§ant
        remplacant = await db.users.find_one({"id": remplacant_id, "tenant_id": tenant_id})
        if not remplacant:
            raise HTTPException(status_code=404, detail="RemplaÃ§ant non trouvÃ©")
        
        # Mettre Ã  jour la demande
        maintenant = datetime.now(timezone.utc)
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "accepte",
                    "remplacant_id": remplacant_id,
                    "updated_at": maintenant
                }
            }
        )
        
        # Mettre Ã  jour l'historique des tentatives
        await db.demandes_remplacement.update_one(
            {
                "id": demande_id,
                "tentatives_historique.user_id": remplacant_id
            },
            {
                "$set": {
                    "tentatives_historique.$.statut": "accepted",
                    "tentatives_historique.$.date_reponse": maintenant.isoformat()
                }
            }
        )
        
        # Mettre Ã  jour le planning (assignations)
        # Trouver l'assignation du demandeur pour cette date et ce type de garde
        assignation = await db.assignations.find_one({
            "tenant_id": tenant_id,
            "user_id": demande_data["demandeur_id"],
            "date": demande_data["date"],
            "type_garde_id": demande_data["type_garde_id"]
        })
        
        if assignation:
            # Remplacer l'assignation par le remplaÃ§ant
            await db.assignations.update_one(
                {"id": assignation["id"]},
                {
                    "$set": {
                        "user_id": remplacant_id,
                        "est_remplacement": True,
                        "demandeur_original_id": demande_data["demandeur_id"],
                        "updated_at": maintenant
                    }
                }
            )
            logging.info(f"âœ… Planning mis Ã  jour: {remplacant['prenom']} {remplacant['nom']} remplace assignation {assignation['id']}")
        else:
            logging.warning(f"âš ï¸ Aucune assignation trouvÃ©e pour le demandeur {demande_data['demandeur_id']} le {demande_data['date']}")
        
        # Notifier le demandeur
        demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
        await send_push_notification_to_users(
            user_ids=[demande_data["demandeur_id"]],
            title="âœ… Remplacement trouvÃ©!",
            body=f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')} a acceptÃ© de vous remplacer le {demande_data['date']}",
            data={
                "type": "remplacement_accepte",
                "demande_id": demande_id,
                "remplacant_id": remplacant_id
            }
        )
        
        # Notifier les superviseurs
        superviseurs = await db.users.find({
            "tenant_id": tenant_id,
            "role": {"$in": ["superviseur", "admin"]}
        }).to_list(100)
        
        superviseur_ids = [s["id"] for s in superviseurs]
        if superviseur_ids:
            await send_push_notification_to_users(
                user_ids=superviseur_ids,
                title="âœ… Remplacement confirmÃ©",
                body=f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')} remplace {demandeur.get('prenom', '')} {demandeur.get('nom', '')} le {demande_data['date']}",
                data={
                    "type": "remplacement_accepte",
                    "demande_id": demande_id
                }
            )
        
        # Notifier les autres remplaÃ§ants contactÃ©s qu'ils ne sont plus nÃ©cessaires
        autres_remplacants_ids = [
            rid for rid in demande_data.get("remplacants_contactes_ids", [])
            if rid != remplacant_id
        ]
        
        if autres_remplacants_ids:
            await send_push_notification_to_users(
                user_ids=autres_remplacants_ids,
                title="Remplacement pourvu",
                body=f"Le remplacement du {demande_data['date']} a Ã©tÃ© pourvu par un autre pompier",
                data={
                    "type": "remplacement_pourvu",
                    "demande_id": demande_id
                }
            )
        
        # CrÃ©er une activitÃ©
        type_garde = await db.types_garde.find_one({"id": demande_data["type_garde_id"], "tenant_id": tenant_id})
        garde_nom = type_garde['nom'] if type_garde else 'garde'
        await creer_activite(
            tenant_id=tenant_id,
            type_activite="remplacement_accepte",
            description=f"âœ… {remplacant.get('prenom', '')} {remplacant.get('nom', '')} a acceptÃ© de remplacer {demandeur.get('prenom', '')} {demandeur.get('nom', '')} pour la {garde_nom} du {demande_data['date']}",
            user_id=remplacant_id,
            user_nom=f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')}",
            data={
                "concerne_user_id": demande_data["demandeur_id"],
                "demande_id": demande_id
            }
        )
        
        logging.info(f"âœ… Remplacement acceptÃ©: demande {demande_id}, remplaÃ§ant {remplacant['nom_complet']}")
        return True
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur lors de l'acceptation du remplacement: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur lors de l'acceptation du remplacement")

async def refuser_remplacement(demande_id: str, remplacant_id: str, tenant_id: str):
    """
    Traite le refus d'un remplacement par un remplaÃ§ant
    - Met Ã  jour l'historique
    - Si tous les remplaÃ§ants contactÃ©s ont refusÃ©, lance une nouvelle recherche
    """
    try:
        # RÃ©cupÃ©rer la demande
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
        
        # VÃ©rifier que le remplaÃ§ant a bien Ã©tÃ© contactÃ©
        if remplacant_id not in demande_data.get("remplacants_contactes_ids", []):
            raise HTTPException(status_code=403, detail="Vous n'Ãªtes pas autorisÃ© Ã  refuser cette demande")
        
        # Mettre Ã  jour l'historique
        maintenant = datetime.now(timezone.utc)
        await db.demandes_remplacement.update_one(
            {
                "id": demande_id,
                "tentatives_historique.user_id": remplacant_id
            },
            {
                "$set": {
                    "tentatives_historique.$.statut": "refused",
                    "tentatives_historique.$.date_reponse": maintenant.isoformat()
                }
            }
        )
        
        # Retirer de la liste des remplaÃ§ants en attente
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$pull": {"remplacants_contactes_ids": remplacant_id},
                "$set": {"updated_at": maintenant}
            }
        )
        
        # VÃ©rifier s'il reste des remplaÃ§ants en attente
        demande_updated = await db.demandes_remplacement.find_one({"id": demande_id})
        if not demande_updated.get("remplacants_contactes_ids"):
            # Plus personne en attente, relancer la recherche immÃ©diatement
            logging.info(f"ğŸ”„ Tous les remplaÃ§ants ont refusÃ©, relance de la recherche pour demande {demande_id}")
            await lancer_recherche_remplacant(demande_id, tenant_id)
        
        logging.info(f"âŒ Remplacement refusÃ© par remplaÃ§ant {remplacant_id} pour demande {demande_id}")
        return True
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur lors du refus du remplacement: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur lors du refus du remplacement")

async def verifier_et_traiter_timeouts():
    """
    Fonction appelÃ©e pÃ©riodiquement pour vÃ©rifier les demandes en timeout
    Relance la recherche si le dÃ©lai d'attente est dÃ©passÃ©
    """
    try:
        maintenant = datetime.now(timezone.utc)
        
        # Trouver toutes les demandes en_cours dont la date_prochaine_tentative est dÃ©passÃ©e
        demandes_cursor = db.demandes_remplacement.find({
            "statut": "en_cours",
            "date_prochaine_tentative": {"$lte": maintenant}
        })
        
        demandes_timeout = await demandes_cursor.to_list(length=None)
        
        for demande in demandes_timeout:
            logging.info(f"â±ï¸ Timeout atteint pour demande {demande['id']}, relance de la recherche")
            
            # Marquer les remplaÃ§ants contactÃ©s comme expirÃ©s dans l'historique
            for remplacant_id in demande.get("remplacants_contactes_ids", []):
                await db.demandes_remplacement.update_one(
                    {
                        "id": demande["id"],
                        "tentatives_historique.user_id": remplacant_id,
                        "tentatives_historique.statut": "contacted"
                    },
                    {
                        "$set": {
                            "tentatives_historique.$.statut": "expired",
                            "tentatives_historique.$.date_reponse": maintenant.isoformat()
                        }
                    }
                )
            
            # Vider la liste des remplaÃ§ants en attente
            await db.demandes_remplacement.update_one(
                {"id": demande["id"]},
                {
                    "$set": {
                        "remplacants_contactes_ids": [],
                        "updated_at": maintenant
                    }
                }
            )
            
            # Relancer la recherche
            await lancer_recherche_remplacant(demande["id"], demande["tenant_id"])
        
        if demandes_timeout:
            logging.info(f"âœ… TraitÃ© {len(demandes_timeout)} demande(s) en timeout")
        
    except Exception as e:
        logging.error(f"âŒ Erreur lors de la vÃ©rification des timeouts: {e}", exc_info=True)


@api_router.post("/{tenant_slug}/remplacements", response_model=DemandeRemplacement)
async def create_demande_remplacement(tenant_slug: str, demande: DemandeRemplacementCreate, current_user: User = Depends(get_current_user)):
    """
    CrÃ©er une demande de remplacement et lancer automatiquement la recherche de remplaÃ§ant
    """
    try:
        # VÃ©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Calculer la prioritÃ© automatiquement
        priorite = await calculer_priorite_demande(demande.date)
        
        demande_dict = demande.dict()
        demande_dict["tenant_id"] = tenant.id
        demande_dict["demandeur_id"] = current_user.id
        demande_dict["priorite"] = priorite
        demande_dict["statut"] = "en_attente"  # Commence en attente
        
        demande_obj = DemandeRemplacement(**demande_dict)
        await db.demandes_remplacement.insert_one(demande_obj.dict())
        
        logging.info(f"âœ… Demande de remplacement crÃ©Ã©e: {demande_obj.id} (prioritÃ©: {priorite})")
        
        # CrÃ©er notification pour les superviseurs/admins (info seulement, pas de gestion manuelle)
        superviseurs_admins = await db.users.find({
            "tenant_id": tenant.id,
            "role": {"$in": ["superviseur", "admin"]}
        }).to_list(100)
        
        superviseur_ids = []
        for user in superviseurs_admins:
            await creer_notification(
                tenant_id=tenant.id,
                destinataire_id=user["id"],
                type="remplacement_demande",
                titre=f"{'ğŸš¨ ' if priorite == 'urgent' else ''}Recherche de remplacement en cours",
                message=f"{current_user.prenom} {current_user.nom} cherche un remplaÃ§ant pour le {demande.date}",
                lien="/remplacements",
                data={"demande_id": demande_obj.id}
            )
            superviseur_ids.append(user["id"])
        
        # Envoyer notifications push aux superviseurs (pour info)
        if superviseur_ids:
            await send_push_notification_to_users(
                user_ids=superviseur_ids,
                title=f"{'ğŸš¨ ' if priorite == 'urgent' else ''}Recherche de remplacement",
                body=f"{current_user.prenom} {current_user.nom} cherche un remplaÃ§ant pour le {demande.date}",
                data={
                    "type": "remplacement_demande",
                    "demande_id": demande_obj.id,
                    "lien": "/remplacements"
                }
            )
        
        # ğŸš€ LANCER LA RECHERCHE AUTOMATIQUE DE REMPLAÃ‡ANT
        await lancer_recherche_remplacant(demande_obj.id, tenant.id)
        
        # CrÃ©er une activitÃ©
        type_garde = await db.types_garde.find_one({"id": demande.type_garde_id, "tenant_id": tenant.id})
        garde_nom = type_garde['nom'] if type_garde else 'garde'
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="remplacement_demande",
            description=f"ğŸ”„ {current_user.prenom} {current_user.nom} cherche un remplaÃ§ant pour la {garde_nom} du {demande.date}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": current_user.id, "demande_id": demande_obj.id}
        )
        
        # Clean the object before returning
        cleaned_demande = clean_mongo_doc(demande_obj.dict())
        return DemandeRemplacement(**cleaned_demande)
        
    except Exception as e:
        logging.error(f"âŒ Erreur lors de la crÃ©ation de la demande de remplacement: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur lors de la crÃ©ation de la demande")


# ===== EXPORTS REMPLACEMENTS (avant les routes dynamiques) =====

@api_router.get("/{tenant_slug}/remplacements/export-pdf")
async def export_remplacements_pdf(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des demandes de remplacement en PDF"""
    try:
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer les demandes
        if user_id:
            demandes_list = await db.demandes_remplacement.find({
                "tenant_id": tenant.id,
                "demandeur_id": user_id
            }).to_list(length=None)
        else:
            if current_user.role == "employe":
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id,
                    "demandeur_id": current_user.id
                }).to_list(length=None)
            else:
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id
                }).to_list(length=None)
        
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        types_map = {t['id']: t for t in types_garde_list}
        
        # CrÃ©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(tenant, pagesize=landscape(letter))
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Titre
        titre = "Demandes de Remplacement"
        if user_id and user_id in users_map:
            titre = f"Demandes de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        
        elements.append(Paragraph(titre, modern_styles['title']))
        elements.append(Spacer(1, 0.3*inch))
        
        # Construire le tableau
        table_data = [['Date', 'Type Garde', 'Demandeur', 'Statut', 'PrioritÃ©', 'RemplaÃ§ant', 'Notes']]
        
        for demande in sorted(demandes_list, key=lambda x: x.get('date', ''), reverse=True):
            demandeur = users_map.get(demande['demandeur_id'], {})
            demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}" if demandeur else "N/A"
            
            remplacant = users_map.get(demande.get('remplacant_id'), {})
            remplacant_nom = f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')}" if remplacant and demande.get('remplacant_id') else "Non trouvÃ©"
            
            type_garde = types_map.get(demande['type_garde_id'], {})
            type_nom = type_garde.get('nom', 'N/A') if type_garde else "N/A"
            
            statut_fr = {
                'en_cours': 'En cours',
                'approuve': 'ApprouvÃ©',
                'refuse': 'RefusÃ©',
                'annule': 'AnnulÃ©'
            }.get(demande.get('statut', ''), demande.get('statut', ''))
            
            priorite_fr = {
                'basse': 'Basse',
                'normale': 'Normale',
                'haute': 'Haute',
                'urgente': 'Urgente'
            }.get(demande.get('priorite', 'normale'), 'Normale')
            
            table_data.append([
                demande.get('date', 'N/A'),
                type_nom,
                demandeur_nom if not user_id else '',
                statut_fr,
                priorite_fr,
                remplacant_nom,
                demande.get('raison', '')[:30] if demande.get('raison') else ''
            ])
        
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('TOPPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        elements.append(table)
        doc.build(elements)
        buffer.seek(0)
        
        filename = f"remplacements_{user_id if user_id else 'tous'}.pdf"
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/remplacements/export-excel")
async def export_remplacements_excel(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des demandes de remplacement en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer les demandes
        if user_id:
            demandes_list = await db.demandes_remplacement.find({
                "tenant_id": tenant.id,
                "demandeur_id": user_id
            }).to_list(length=None)
        else:
            if current_user.role == "employe":
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id,
                    "demandeur_id": current_user.id
                }).to_list(length=None)
            else:
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id
                }).to_list(length=None)
        
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        types_map = {t['id']: t for t in types_garde_list}
        
        # CrÃ©er le workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Remplacements"
        
        # Styles
        header_fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        center_alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        # Titre
        ws.merge_cells('A1:H1')
        titre = "Demandes de Remplacement"
        if user_id and user_id in users_map:
            titre = f"Demandes de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        ws['A1'] = titre
        ws['A1'].font = Font(bold=True, size=16, color="EF4444")
        ws['A1'].alignment = center_alignment
        
        # En-tÃªtes
        row = 3
        headers = ['Date', 'Type Garde', 'Demandeur', 'Statut', 'PrioritÃ©', 'RemplaÃ§ant', 'Notes', 'CrÃ©Ã© le']
        
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = center_alignment
            cell.border = border
        
        # DonnÃ©es
        row += 1
        for demande in sorted(demandes_list, key=lambda x: x.get('date', ''), reverse=True):
            demandeur = users_map.get(demande['demandeur_id'], {})
            demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}" if demandeur else "N/A"
            
            remplacant = users_map.get(demande.get('remplacant_id'), {})
            remplacant_nom = f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')}" if remplacant and demande.get('remplacant_id') else "Non trouvÃ©"
            
            type_garde = types_map.get(demande['type_garde_id'], {})
            type_nom = type_garde.get('nom', 'N/A') if type_garde else "N/A"
            
            statut_fr = {
                'en_cours': 'En cours',
                'approuve': 'ApprouvÃ©',
                'refuse': 'RefusÃ©',
                'annule': 'AnnulÃ©'
            }.get(demande.get('statut', ''), demande.get('statut', ''))
            
            priorite_fr = {
                'basse': 'Basse',
                'normale': 'Normale',
                'haute': 'Haute',
                'urgente': 'Urgente'
            }.get(demande.get('priorite', 'normale'), 'Normale')
            
            ws.cell(row=row, column=1, value=demande.get('date', 'N/A'))
            ws.cell(row=row, column=2, value=type_nom)
            ws.cell(row=row, column=3, value=demandeur_nom)
            status_cell = ws.cell(row=row, column=4, value=statut_fr)
            ws.cell(row=row, column=5, value=priorite_fr)
            ws.cell(row=row, column=6, value=remplacant_nom)
            ws.cell(row=row, column=7, value=demande.get('raison', ''))
            ws.cell(row=row, column=8, value=demande.get('created_at', 'N/A'))
            
            # Couleur statut
            if demande.get('statut') == 'approuve':
                status_cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
            elif demande.get('statut') == 'refuse':
                status_cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
            elif demande.get('statut') == 'en_cours':
                status_cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
            
            for col in range(1, 9):
                ws.cell(row=row, column=col).border = border
                ws.cell(row=row, column=col).alignment = center_alignment
            
            row += 1
        
        # Ajuster les largeurs de colonnes
        for col in ws.columns:
            max_length = 0
            column = col[0].column_letter
            for cell in col:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column].width = adjusted_width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        filename = f"remplacements_{user_id if user_id else 'tous'}.xlsx"
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")


@api_router.get("/{tenant_slug}/remplacements", response_model=List[DemandeRemplacement])
async def get_demandes_remplacement(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role == "employe":
        demandes = await db.demandes_remplacement.find({
            "tenant_id": tenant.id,
            "demandeur_id": current_user.id
        }).to_list(1000)
    else:
        demandes = await db.demandes_remplacement.find({"tenant_id": tenant.id}).to_list(1000)
    
    cleaned_demandes = [clean_mongo_doc(demande) for demande in demandes]
    return [DemandeRemplacement(**demande) for demande in cleaned_demandes]

@api_router.get("/{tenant_slug}/remplacements/propositions")
async def get_propositions_remplacement(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """
    RÃ©cupÃ¨re les propositions de remplacement pour l'utilisateur connectÃ©
    (Les demandes oÃ¹ il a Ã©tÃ© contactÃ© et doit rÃ©pondre)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Trouver les demandes oÃ¹ l'utilisateur est dans remplacants_contactes_ids et statut = en_cours
    demandes = await db.demandes_remplacement.find({
        "tenant_id": tenant.id,
        "statut": "en_cours",
        "remplacants_contactes_ids": current_user.id
    }).to_list(1000)
    
    # Enrichir avec les dÃ©tails du demandeur et du type de garde
    propositions = []
    for demande in demandes:
        demandeur = await db.users.find_one({"id": demande["demandeur_id"]})
        type_garde = await db.types_garde.find_one({"id": demande["type_garde_id"]})
        
        demande["demandeur"] = {
            "nom": demandeur.get("nom", ""),
            "prenom": demandeur.get("prenom", ""),
            "email": demandeur.get("email", "")
        } if demandeur else None
        
        demande["type_garde"] = {
            "nom": type_garde.get("nom", ""),
            "heure_debut": type_garde.get("heure_debut", ""),
            "heure_fin": type_garde.get("heure_fin", "")
        } if type_garde else None
        
        propositions.append(clean_mongo_doc(demande))
    
    return propositions

@api_router.put("/{tenant_slug}/remplacements/{demande_id}/accepter")
async def accepter_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Accepter une proposition de remplacement
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    await accepter_remplacement(demande_id, current_user.id, tenant.id)
    
    return {
        "message": "Remplacement acceptÃ© avec succÃ¨s",
        "demande_id": demande_id
    }

@api_router.put("/{tenant_slug}/remplacements/{demande_id}/refuser")
async def refuser_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Refuser une proposition de remplacement
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    await refuser_remplacement(demande_id, current_user.id, tenant.id)
    
    return {
        "message": "Remplacement refusÃ©",
        "demande_id": demande_id
    }

@api_router.delete("/{tenant_slug}/remplacements/{demande_id}")
async def annuler_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Annuler une demande de remplacement (seulement par le demandeur)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer la demande
    demande = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant.id})
    if not demande:
        raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
    
    # VÃ©rifier que c'est bien le demandeur
    if demande["demandeur_id"] != current_user.id:
        raise HTTPException(status_code=403, detail="Seul le demandeur peut annuler la demande")
    
    # VÃ©rifier que la demande n'est pas dÃ©jÃ  acceptÃ©e
    if demande["statut"] == "accepte":
        raise HTTPException(status_code=400, detail="Impossible d'annuler une demande dÃ©jÃ  acceptÃ©e")
    
    # Marquer comme annulÃ©e
    await db.demandes_remplacement.update_one(
        {"id": demande_id},
        {
            "$set": {
                "statut": "annulee",
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    # Notifier les remplaÃ§ants contactÃ©s que la demande est annulÃ©e
    if demande.get("remplacants_contactes_ids"):
        await send_push_notification_to_users(
            user_ids=demande["remplacants_contactes_ids"],
            title="Demande annulÃ©e",
            body=f"La demande de remplacement du {demande['date']} a Ã©tÃ© annulÃ©e",
            data={
                "type": "remplacement_annulee",
                "demande_id": demande_id
            }
        )
    
    logging.info(f"âœ… Demande de remplacement annulÃ©e: {demande_id}")
    
    return {
        "message": "Demande annulÃ©e avec succÃ¨s",
        "demande_id": demande_id
    }

# ==================== COMPÃ‰TENCES ROUTES ====================

@api_router.post("/{tenant_slug}/competences", response_model=Competence)
async def create_competence(tenant_slug: str, competence: CompetenceCreate, current_user: User = Depends(get_current_user)):
    """CrÃ©e une compÃ©tence"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    competence_dict = competence.dict()
    competence_dict["tenant_id"] = tenant.id
    competence_obj = Competence(**competence_dict)
    
    comp_data = competence_obj.dict()
    comp_data["created_at"] = competence_obj.created_at.isoformat()
    
    await db.competences.insert_one(comp_data)
    return competence_obj

@api_router.get("/{tenant_slug}/competences", response_model=List[Competence])
async def get_competences(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re toutes les compÃ©tences"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    competences = await db.competences.find({"tenant_id": tenant.id}).to_list(1000)
    cleaned = [clean_mongo_doc(c) for c in competences]
    
    for c in cleaned:
        if isinstance(c.get("created_at"), str):
            c["created_at"] = datetime.fromisoformat(c["created_at"].replace('Z', '+00:00'))
    
    return [Competence(**c) for c in cleaned]

@api_router.put("/{tenant_slug}/competences/{competence_id}", response_model=Competence)
async def update_competence(
    tenant_slug: str,
    competence_id: str,
    competence_update: CompetenceUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour une compÃ©tence"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    update_data = {k: v for k, v in competence_update.dict().items() if v is not None}
    
    result = await db.competences.update_one(
        {"id": competence_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="CompÃ©tence non trouvÃ©e")
    
    updated = await db.competences.find_one({"id": competence_id, "tenant_id": tenant.id})
    cleaned = clean_mongo_doc(updated)
    
    if isinstance(cleaned.get("created_at"), str):
        cleaned["created_at"] = datetime.fromisoformat(cleaned["created_at"].replace('Z', '+00:00'))
    
    return Competence(**cleaned)

@api_router.delete("/{tenant_slug}/competences/{competence_id}")
async def delete_competence(tenant_slug: str, competence_id: str, current_user: User = Depends(get_current_user)):
    """Supprime une compÃ©tence"""

@api_router.post("/{tenant_slug}/competences/clean-invalid")
async def clean_invalid_competences(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Nettoie les compÃ©tences invalides/obsolÃ¨tes des utilisateurs
    
    Supprime des profils utilisateurs toutes les compÃ©tences qui n'existent plus 
    dans la collection competences.
    """
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer tous les IDs de compÃ©tences valides
    valid_competences = await db.competences.find({"tenant_id": tenant.id}, {"id": 1, "_id": 0}).to_list(1000)
    valid_competence_ids = {c["id"] for c in valid_competences}
    
    # RÃ©cupÃ©rer tous les utilisateurs avec des compÃ©tences
    users = await db.users.find(
        {"tenant_id": tenant.id, "competences": {"$exists": True, "$ne": []}},
        {"id": 1, "competences": 1, "prenom": 1, "nom": 1, "_id": 0}
    ).to_list(1000)
    
    cleaned_count = 0
    invalid_removed = 0
    
    for user in users:
        original_competences = user.get("competences", [])
        # Filtrer pour ne garder que les compÃ©tences valides
        valid_user_competences = [c_id for c_id in original_competences if c_id in valid_competence_ids]
        
        if len(valid_user_competences) < len(original_competences):
            # Il y avait des compÃ©tences invalides
            removed = len(original_competences) - len(valid_user_competences)
            invalid_removed += removed
            cleaned_count += 1
            
            # Mettre Ã  jour l'utilisateur
            await db.users.update_one(
                {"id": user["id"], "tenant_id": tenant.id},
                {"$set": {"competences": valid_user_competences}}
            )
            
            logging.info(f"ğŸ§¹ Nettoyage: {user['prenom']} {user['nom']} - {removed} compÃ©tence(s) invalide(s) supprimÃ©e(s)")
    
    return {
        "message": f"Nettoyage terminÃ©",
        "users_cleaned": cleaned_count,
        "invalid_competences_removed": invalid_removed
    }

    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.competences.delete_one({"id": competence_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="CompÃ©tence non trouvÃ©e")
    
    return {"message": "CompÃ©tence supprimÃ©e"}

# ==================== GRADES ROUTES ====================

@api_router.post("/{tenant_slug}/grades", response_model=Grade)
async def create_grade(tenant_slug: str, grade: GradeCreate, current_user: User = Depends(get_current_user)):
    """CrÃ©e un grade"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier si le grade existe dÃ©jÃ 
    existing = await db.grades.find_one({"nom": grade.nom, "tenant_id": tenant.id})
    if existing:
        raise HTTPException(status_code=400, detail="Ce grade existe dÃ©jÃ ")
    
    grade_dict = grade.dict()
    grade_dict["tenant_id"] = tenant.id
    grade_obj = Grade(**grade_dict)
    
    grade_data = grade_obj.dict()
    grade_data["created_at"] = grade_obj.created_at.isoformat()
    grade_data["updated_at"] = grade_obj.updated_at.isoformat()
    
    await db.grades.insert_one(grade_data)
    return grade_obj

@api_router.get("/{tenant_slug}/grades", response_model=List[Grade])
async def get_grades(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re tous les grades triÃ©s par niveau hiÃ©rarchique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    grades = await db.grades.find({"tenant_id": tenant.id}).sort("niveau_hierarchique", 1).to_list(1000)
    cleaned = [clean_mongo_doc(g) for g in grades]
    
    for g in cleaned:
        if isinstance(g.get("created_at"), str):
            g["created_at"] = datetime.fromisoformat(g["created_at"].replace('Z', '+00:00'))
        if isinstance(g.get("updated_at"), str):
            g["updated_at"] = datetime.fromisoformat(g["updated_at"].replace('Z', '+00:00'))
    
    return [Grade(**g) for g in cleaned]

@api_router.put("/{tenant_slug}/grades/{grade_id}", response_model=Grade)
async def update_grade(
    tenant_slug: str,
    grade_id: str,
    grade_update: GradeUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour un grade"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    update_data = {k: v for k, v in grade_update.dict().items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc).isoformat()
    
    result = await db.grades.update_one(
        {"id": grade_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Grade non trouvÃ©")
    
    updated = await db.grades.find_one({"id": grade_id, "tenant_id": tenant.id})
    cleaned = clean_mongo_doc(updated)
    
    if isinstance(cleaned.get("created_at"), str):
        cleaned["created_at"] = datetime.fromisoformat(cleaned["created_at"].replace('Z', '+00:00'))
    if isinstance(cleaned.get("updated_at"), str):
        cleaned["updated_at"] = datetime.fromisoformat(cleaned["updated_at"].replace('Z', '+00:00'))
    
    return Grade(**cleaned)

@api_router.delete("/{tenant_slug}/grades/{grade_id}")
async def delete_grade(tenant_slug: str, grade_id: str, current_user: User = Depends(get_current_user)):
    """Supprime un grade si aucun employÃ© ne l'utilise"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier si le grade existe
    existing_grade = await db.grades.find_one({"id": grade_id, "tenant_id": tenant.id})
    if not existing_grade:
        raise HTTPException(status_code=404, detail="Grade non trouvÃ©")
    
    # VÃ©rifier si des employÃ©s utilisent ce grade
    users_count = await db.users.count_documents({"grade": existing_grade["nom"], "tenant_id": tenant.id})
    
    if users_count > 0:
        raise HTTPException(
            status_code=400, 
            detail=f"Impossible de supprimer ce grade. {users_count} employÃ©(s) l'utilisent actuellement. Veuillez d'abord rÃ©assigner ces employÃ©s Ã  un autre grade."
        )
    
    result = await db.grades.delete_one({"id": grade_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Grade non trouvÃ©")
    
    return {"message": "Grade supprimÃ© avec succÃ¨s"}

# ==================== FORMATIONS ROUTES NFPA 1500 ====================

@api_router.post("/{tenant_slug}/formations", response_model=Formation)
async def create_formation(tenant_slug: str, formation: FormationCreate, current_user: User = Depends(get_current_user)):
    """CrÃ©e une formation"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Validation: VÃ©rifier que la compÃ©tence existe
    if not formation.competence_id or not formation.competence_id.strip():
        raise HTTPException(status_code=400, detail="La compÃ©tence associÃ©e est obligatoire")
    
    competence = await db.competences.find_one({
        "id": formation.competence_id,
        "tenant_id": tenant.id
    })
    
    if not competence:
        raise HTTPException(
            status_code=404, 
            detail=f"CompÃ©tence non trouvÃ©e. Veuillez crÃ©er la compÃ©tence dans ParamÃ¨tres > CompÃ©tences avant de crÃ©er la formation."
        )
    
    formation_dict = formation.dict()
    formation_dict["tenant_id"] = tenant.id
    formation_dict["places_restantes"] = formation.places_max
    
    # CALCUL AUTOMATIQUE de duree_heures depuis heure_debut et heure_fin
    if formation.heure_debut and formation.heure_fin:
        try:
            from datetime import datetime
            debut = datetime.strptime(formation.heure_debut, "%H:%M")
            fin = datetime.strptime(formation.heure_fin, "%H:%M")
            duree_calculee = (fin - debut).total_seconds() / 3600
            formation_dict["duree_heures"] = round(duree_calculee, 2)
        except (ValueError, AttributeError):
            # Si parsing Ã©choue, utiliser la valeur fournie
            pass
    
    formation_obj = Formation(**formation_dict)
    
    form_data = formation_obj.dict()
    form_data["created_at"] = formation_obj.created_at.isoformat()
    form_data["updated_at"] = formation_obj.updated_at.isoformat()
    
    await db.formations.insert_one(form_data)
    
    # CrÃ©er une activitÃ©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="formation_creation",
        description=f"ğŸ“ {current_user.prenom} {current_user.nom} a crÃ©Ã© la formation '{formation.nom}' du {formation.date_debut} au {formation.date_fin}",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return formation_obj

@api_router.get("/{tenant_slug}/formations", response_model=List[Formation])
async def get_formations(tenant_slug: str, annee: Optional[int] = None, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re formations (filtre annee)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    query = {"tenant_id": tenant.id}
    if annee:
        query["annee"] = annee
    
    # OPTIMISATION: Charger formations et inscriptions en parallÃ¨le
    formations = await db.formations.find(query, {"_id": 0}).sort("date_debut", 1).to_list(1000)
    
    # Charger toutes les inscriptions de l'utilisateur en UNE SEULE requÃªte
    formation_ids = [f["id"] for f in formations if "id" in f]
    inscriptions_cursor = db.inscriptions_formations.find({
        "formation_id": {"$in": formation_ids},
        "user_id": current_user.id,
        "tenant_id": tenant.id
    }, {"formation_id": 1, "_id": 0})
    inscriptions = await inscriptions_cursor.to_list(1000)
    inscriptions_set = {i["formation_id"] for i in inscriptions}
    
    cleaned = [clean_mongo_doc(f) for f in formations]
    
    for f in cleaned:
        if isinstance(f.get("created_at"), str):
            f["created_at"] = datetime.fromisoformat(f["created_at"].replace('Z', '+00:00'))
        if isinstance(f.get("updated_at"), str):
            f["updated_at"] = datetime.fromisoformat(f["updated_at"].replace('Z', '+00:00'))
        
        # VÃ©rifier inscription via le set (O(1) au lieu de requÃªte DB)
        f["user_inscrit"] = f["id"] in inscriptions_set
    
    return [Formation(**f) for f in cleaned]

@api_router.put("/{tenant_slug}/formations/{formation_id}", response_model=Formation)
async def update_formation(
    tenant_slug: str,
    formation_id: str,
    formation_update: FormationUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour une formation"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    update_data = {k: v for k, v in formation_update.dict().items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc).isoformat()
    
    # CALCUL AUTOMATIQUE de duree_heures si heure_debut ou heure_fin est modifiÃ©
    if "heure_debut" in update_data or "heure_fin" in update_data:
        # RÃ©cupÃ©rer la formation actuelle pour avoir toutes les valeurs
        formation_actuelle = await db.formations.find_one({"id": formation_id, "tenant_id": tenant.id})
        if formation_actuelle:
            heure_debut = update_data.get("heure_debut", formation_actuelle.get("heure_debut"))
            heure_fin = update_data.get("heure_fin", formation_actuelle.get("heure_fin"))
            
            if heure_debut and heure_fin:
                try:
                    from datetime import datetime as dt
                    debut = dt.strptime(heure_debut, "%H:%M")
                    fin = dt.strptime(heure_fin, "%H:%M")
                    duree_calculee = (fin - debut).total_seconds() / 3600
                    update_data["duree_heures"] = round(duree_calculee, 2)
                except (ValueError, AttributeError):
                    pass
    
    result = await db.formations.update_one(
        {"id": formation_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Formation non trouvÃ©e")
    
    updated = await db.formations.find_one({"id": formation_id, "tenant_id": tenant.id})
    cleaned = clean_mongo_doc(updated)
    
    if isinstance(cleaned.get("created_at"), str):
        cleaned["created_at"] = datetime.fromisoformat(cleaned["created_at"].replace('Z', '+00:00'))
    if isinstance(cleaned.get("updated_at"), str):
        cleaned["updated_at"] = datetime.fromisoformat(cleaned["updated_at"].replace('Z', '+00:00'))
    
    return Formation(**cleaned)

@api_router.delete("/{tenant_slug}/formations/{formation_id}")
async def delete_formation(tenant_slug: str, formation_id: str, current_user: User = Depends(get_current_user)):
    """Supprime une formation"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Supprimer inscriptions
    await db.inscriptions_formations.delete_many({
        "formation_id": formation_id,
        "tenant_id": tenant.id
    })
    
    result = await db.formations.delete_one({"id": formation_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Formation non trouvÃ©e")
    
    return {"message": "Formation supprimÃ©e"}

@api_router.post("/{tenant_slug}/formations/corriger-durees")
async def corriger_durees_formations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Corrige les durÃ©es incohÃ©rentes dans toutes les formations"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer toutes les formations
    formations = await db.formations.find({"tenant_id": tenant.id}).to_list(10000)
    
    corrections_effectuees = 0
    formations_corrigees = []
    
    for formation in formations:
        heure_debut = formation.get("heure_debut")
        heure_fin = formation.get("heure_fin")
        duree_actuelle = formation.get("duree_heures", 0)
        
        if heure_debut and heure_fin:
            try:
                from datetime import datetime as dt
                debut = dt.strptime(heure_debut, "%H:%M")
                fin = dt.strptime(heure_fin, "%H:%M")
                duree_calculee = round((fin - debut).total_seconds() / 3600, 2)
                
                # VÃ©rifier si incohÃ©rence (tolÃ©rance de 0.1h pour arrondi)
                if abs(duree_calculee - duree_actuelle) > 0.1:
                    await db.formations.update_one(
                        {"id": formation["id"], "tenant_id": tenant.id},
                        {"$set": {"duree_heures": duree_calculee}}
                    )
                    corrections_effectuees += 1
                    formations_corrigees.append({
                        "nom": formation.get("nom"),
                        "id": formation["id"],
                        "duree_avant": duree_actuelle,
                        "duree_apres": duree_calculee,
                        "difference": round(duree_calculee - duree_actuelle, 2)
                    })
            except (ValueError, AttributeError):
                pass
    
    return {
        "message": f"{corrections_effectuees} formation(s) corrigÃ©e(s)",
        "total_formations": len(formations),
        "corrections_effectuees": corrections_effectuees,
        "formations_corrigees": formations_corrigees
    }

@api_router.post("/{tenant_slug}/formations/{formation_id}/inscription")
async def inscrire_formation(
    tenant_slug: str,
    formation_id: str,
    current_user: User = Depends(get_current_user)
):
    """Inscription Ã  formation avec gestion liste d'attente"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    formation = await db.formations.find_one({"id": formation_id, "tenant_id": tenant.id})
    if not formation:
        raise HTTPException(status_code=404, detail="Formation non trouvÃ©e")
    
    # VÃ©rifier dÃ©jÃ  inscrit
    existing = await db.inscriptions_formations.find_one({
        "formation_id": formation_id,
        "user_id": current_user.id,
        "tenant_id": tenant.id
    })
    
    if existing:
        raise HTTPException(status_code=400, detail="DÃ©jÃ  inscrit")
    
    # Compter inscrits
    nb_inscrits = await db.inscriptions_formations.count_documents({
        "formation_id": formation_id,
        "tenant_id": tenant.id,
        "statut": "inscrit"
    })
    
    statut = "inscrit" if nb_inscrits < formation["places_max"] else "en_attente"
    
    inscription = InscriptionFormation(
        tenant_id=tenant.id,
        formation_id=formation_id,
        user_id=current_user.id,
        date_inscription=datetime.now(timezone.utc).date().isoformat(),
        statut=statut
    )
    
    insc_data = inscription.dict()
    insc_data["created_at"] = inscription.created_at.isoformat()
    insc_data["updated_at"] = inscription.updated_at.isoformat()
    
    await db.inscriptions_formations.insert_one(insc_data)
    
    # MAJ places
    if statut == "inscrit":
        await db.formations.update_one(
            {"id": formation_id, "tenant_id": tenant.id},
            {"$set": {"places_restantes": formation["places_max"] - nb_inscrits - 1}}
        )
    
    # Notifier si liste attente
    if statut == "en_attente":
        superviseurs = await db.users.find({
            "tenant_id": tenant.id,
            "role": {"$in": ["admin", "superviseur"]}
        }).to_list(100)
        
        for sup in superviseurs:
            await creer_notification(
                tenant_id=tenant.id,
                destinataire_id=sup["id"],
                type="formation_liste_attente",
                titre="Liste d'attente formation",
                message=f"{formation['nom']}: {current_user.prenom} {current_user.nom} en liste d'attente",
                lien="/formations"
            )
    
    return {"message": "Inscription rÃ©ussie", "statut": statut}

@api_router.delete("/{tenant_slug}/formations/{formation_id}/inscription")
async def desinscrire_formation(
    tenant_slug: str,
    formation_id: str,
    current_user: User = Depends(get_current_user)
):
    """DÃ©sinscription d'une formation"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    formation = await db.formations.find_one({"id": formation_id, "tenant_id": tenant.id})
    if not formation:
        raise HTTPException(status_code=404, detail="Formation non trouvÃ©e")
    
    # VÃ©rifier si inscrit
    existing = await db.inscriptions_formations.find_one({
        "formation_id": formation_id,
        "user_id": current_user.id,
        "tenant_id": tenant.id
    })
    
    if not existing:
        raise HTTPException(status_code=400, detail="Vous n'Ãªtes pas inscrit Ã  cette formation")
    
    # EmpÃªcher la dÃ©sinscription si prÃ©sence dÃ©jÃ  validÃ©e
    if existing.get("statut") in ["present", "absent"]:
        raise HTTPException(status_code=400, detail="Impossible de se dÃ©sinscrire, la prÃ©sence a dÃ©jÃ  Ã©tÃ© validÃ©e")
    
    # Supprimer l'inscription
    await db.inscriptions_formations.delete_one({
        "formation_id": formation_id,
        "user_id": current_user.id,
        "tenant_id": tenant.id
    })
    
    # Recalculer les places restantes
    nb_inscrits = await db.inscriptions_formations.count_documents({
        "formation_id": formation_id,
        "tenant_id": tenant.id,
        "statut": "inscrit"
    })
    
    await db.formations.update_one(
        {"id": formation_id, "tenant_id": tenant.id},
        {"$set": {"places_restantes": formation["places_max"] - nb_inscrits}}
    )
    
    return {"message": "DÃ©sinscription rÃ©ussie"}

@api_router.get("/{tenant_slug}/formations/{formation_id}/inscriptions")
async def get_inscriptions(tenant_slug: str, formation_id: str, current_user: User = Depends(get_current_user)):
    """Liste inscriptions formation"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    inscriptions = await db.inscriptions_formations.find({
        "formation_id": formation_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    
    result = []
    for insc in inscriptions:
        user = await db.users.find_one({"id": insc["user_id"], "tenant_id": tenant.id})
        if user:
            cleaned = clean_mongo_doc(insc)
            cleaned["user_nom"] = f"{user['prenom']} {user['nom']}"
            cleaned["user_grade"] = user.get("grade", "")
            result.append(cleaned)
    
    return result

@api_router.put("/{tenant_slug}/formations/{formation_id}/presence/{user_id}")
async def valider_presence(
    tenant_slug: str,
    formation_id: str,
    user_id: str,
    presence: InscriptionFormationUpdate,
    current_user: User = Depends(get_current_user)
):
    """Valide prÃ©sence et crÃ©dite heures (calcul automatique depuis horaires)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    formation = await db.formations.find_one({"id": formation_id, "tenant_id": tenant.id})
    if not formation:
        raise HTTPException(status_code=404, detail="Formation non trouvÃ©e")
    
    # Calculer heures automatiquement depuis heure_debut et heure_fin
    heures = 0
    if presence.statut == "present":
        if formation.get("heure_debut") and formation.get("heure_fin"):
            try:
                # Parser les heures au format HH:MM
                heure_debut_parts = formation["heure_debut"].split(":")
                heure_fin_parts = formation["heure_fin"].split(":")
                
                heure_debut = int(heure_debut_parts[0]) + int(heure_debut_parts[1]) / 60
                heure_fin = int(heure_fin_parts[0]) + int(heure_fin_parts[1]) / 60
                
                heures = round(heure_fin - heure_debut, 2)
            except (ValueError, IndexError, TypeError):
                # Si erreur de parsing, utiliser duree_heures si disponible
                heures = formation.get("duree_heures", 0)
        else:
            # Fallback sur duree_heures si horaires non dÃ©finis
            heures = formation.get("duree_heures", 0)
    
    await db.inscriptions_formations.update_one(
        {"formation_id": formation_id, "user_id": user_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": presence.statut,
            "heures_creditees": heures,
            "notes": presence.notes or "",
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    return {"message": "PrÃ©sence validÃ©e", "heures": heures}

@api_router.get("/{tenant_slug}/formations/rapports/debug/{user_id}")
async def debug_conformite_user(
    tenant_slug: str,
    user_id: str,
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """Debug : voir les donnÃ©es brutes d'un employÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer l'utilisateur
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    
    # RÃ©cupÃ©rer toutes ses inscriptions
    inscriptions = await db.inscriptions_formations.find({
        "user_id": user_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    
    # Pour chaque inscription, rÃ©cupÃ©rer la formation
    details = []
    for insc in inscriptions:
        formation = await db.formations.find_one({
            "id": insc["formation_id"],
            "tenant_id": tenant.id
        })
        if formation:
            details.append({
                "formation_nom": formation.get("nom"),
                "formation_date_fin": formation.get("date_fin"),
                "formation_annee_champ": formation.get("annee"),
                "inscription_statut": insc.get("statut"),
                "inscription_heures_creditees": insc.get("heures_creditees"),
                "heure_debut": formation.get("heure_debut"),
                "heure_fin": formation.get("heure_fin")
            })
    
    return {
        "user": user.get("prenom") + " " + user.get("nom"),
        "total_inscriptions": len(inscriptions),
        "details": details,
        "annee_recherchee": annee
    }

@api_router.get("/{tenant_slug}/formations/rapports/conformite")
async def rapport_conformite(tenant_slug: str, annee: int, current_user: User = Depends(get_current_user)):
    """Rapport conformitÃ© NFPA 1500 amÃ©liorÃ© avec formations obligatoires et validations manuelles"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    pompiers = await db.users.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    params = await db.parametres_formations.find_one({"tenant_id": tenant.id})
    heures_min = params.get("heures_minimales_annuelles", 100) if params else 100
    pourcentage_min = params.get("pourcentage_presence_minimum", 80) if params else 80
    
    aujourd_hui = datetime.now(timezone.utc).date()
    
    # OPTIMISATION: Charger TOUTES les formations une seule fois (au lieu de 1 requÃªte par inscription)
    toutes_formations = await db.formations.find({
        "tenant_id": tenant.id
    }, {"_id": 0}).to_list(1000)
    formations_map = {f["id"]: f for f in toutes_formations if "id" in f}
    
    # RÃ©cupÃ©rer toutes les formations obligatoires de l'annÃ©e
    formations_obligatoires = await db.formations.find({
        "tenant_id": tenant.id,
        "annee": annee,
        "obligatoire": True
    }, {"_id": 0}).to_list(1000)
    
    # OPTIMISATION: Charger toutes les inscriptions et validations en UNE FOIS
    toutes_inscriptions_db = await db.inscriptions_formations.find({
        "tenant_id": tenant.id
    }, {"_id": 0}).to_list(10000)
    
    toutes_validations_db = await db.validations_competences.find({
        "tenant_id": tenant.id
    }, {"_id": 0}).to_list(10000)
    
    # Grouper par user_id pour accÃ¨s rapide
    inscriptions_par_user = {}
    for insc in toutes_inscriptions_db:
        user_id = insc.get("user_id")
        if user_id not in inscriptions_par_user:
            inscriptions_par_user[user_id] = []
        inscriptions_par_user[user_id].append(insc)
    
    validations_par_user = {}
    for val in toutes_validations_db:
        user_id = val.get("user_id")
        if user_id not in validations_par_user:
            validations_par_user[user_id] = []
        validations_par_user[user_id].append(val)
    
    rapport = []
    for pompier in pompiers:
        # RÃ©cupÃ©rer les inscriptions et validations depuis les dictionnaires
        toutes_inscriptions = inscriptions_par_user.get(pompier["id"], [])
        validations = validations_par_user.get(pompier["id"], [])
        competences_validees = {v["competence_id"] for v in validations}
        
        total_heures = 0
        formations_passees = 0
        formations_futures = 0
        presences = 0
        formations_obligatoires_ratees = []
        
        for insc in toutes_inscriptions:
            # OPTIMISATION: Lookup dans le dictionnaire au lieu de requÃªte DB
            formation = formations_map.get(insc["formation_id"])
            
            if formation:
                try:
                    # Parser la date de fin avec gestion d'erreur
                    if "date_fin" in formation and formation["date_fin"]:
                        date_fin_str = formation["date_fin"]
                        date_fin = datetime.fromisoformat(date_fin_str.replace('Z', '+00:00')).date()
                    else:
                        continue
                    
                    # VÃ©rifier que la formation est de l'annÃ©e demandÃ©e (depuis date_fin)
                    if date_fin.year != annee:
                        continue
                    
                    # Heures crÃ©ditÃ©es
                    if insc.get("statut") == "present":
                        total_heures += insc.get("heures_creditees", 0)
                    
                    # Calcul taux de prÃ©sence
                    if date_fin < aujourd_hui:
                        formations_passees += 1
                        if insc.get("statut") == "present":
                            presences += 1
                        # VÃ©rifier si formation obligatoire ratÃ©e
                        elif formation.get("obligatoire") and insc.get("statut") == "absent":
                            # VÃ©rifier si compÃ©tence n'est pas validÃ©e manuellement
                            if formation.get("competence_id") not in competences_validees:
                                formations_obligatoires_ratees.append(formation["nom"])
                    else:
                        formations_futures += 1
                except (ValueError, TypeError, AttributeError):
                    continue
        
        # Taux de prÃ©sence = formations prÃ©sentes / formations passÃ©es (pas futures)
        taux_presence = round((presences / formations_passees * 100) if formations_passees > 0 else 100, 1)
        conforme_presence = taux_presence >= pourcentage_min
        conforme_heures = total_heures >= heures_min
        a_formation_obligatoire_ratee = len(formations_obligatoires_ratees) > 0
        
        # LOGIQUE SIMPLIFIÃ‰E : 2 niveaux (Conforme / Non conforme)
        # CONFORME par dÃ©faut, sauf si :
        # 1. Formation obligatoire ratÃ©e (non rÃ©gularisÃ©e)
        # 2. Taux de prÃ©sence < seuil (sur formations passÃ©es)
        # Note: Les heures peuvent Ãªtre en cours d'accumulation, donc on ne pÃ©nalise pas
        
        if a_formation_obligatoire_ratee:
            # Formation obligatoire ratÃ©e â†’ Non conforme (rÃ©gularisable via Personnel)
            conforme = False
        elif not conforme_presence:
            # Taux de prÃ©sence insuffisant sur formations passÃ©es â†’ Non conforme
            conforme = False
        else:
            # Par dÃ©faut : Conforme (peut encore atteindre les heures requises)
            conforme = True
        
        pompier_data = clean_mongo_doc(pompier)
        pompier_data["total_heures"] = total_heures
        pompier_data["heures_requises"] = heures_min
        pompier_data["conforme"] = conforme
        pompier_data["pourcentage"] = round((total_heures / heures_min * 100) if heures_min > 0 else 0, 1)
        pompier_data["taux_presence"] = taux_presence
        pompier_data["formations_passees"] = formations_passees
        pompier_data["formations_futures"] = formations_futures
        pompier_data["presences"] = presences
        pompier_data["formations_obligatoires_ratees"] = formations_obligatoires_ratees
        pompier_data["validations_manuelles"] = len(validations)
        rapport.append(pompier_data)
    
    rapport.sort(key=lambda x: (
        0 if x["conforme"] else 1,  # Conformes en premier
        -x["total_heures"]  # Puis par heures dÃ©croissantes
    ))
    
    return {
        "annee": annee,
        "heures_minimales": heures_min,
        "pourcentage_presence_minimum": pourcentage_min,
        "total_pompiers": len(rapport),
        "conformes": len([p for p in rapport if p["conforme"]]),
        "non_conformes": len([p for p in rapport if not p["conforme"]]),
        "pourcentage_conformite": round(len([p for p in rapport if p["conforme"]]) / len(rapport) * 100, 1) if len(rapport) > 0 else 0,
        "pompiers": rapport
    }

@api_router.get("/{tenant_slug}/formations/rapports/dashboard")
async def dashboard_formations(tenant_slug: str, annee: int, current_user: User = Depends(get_current_user)):
    """Dashboard KPIs formations"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    formations = await db.formations.find({"tenant_id": tenant.id, "annee": annee}).to_list(1000)
    heures_planifiees = sum([f.get("duree_heures", 0) for f in formations])
    
    inscriptions = await db.inscriptions_formations.find({
        "tenant_id": tenant.id,
        "statut": "present"
    }).to_list(10000)
    
    heures_effectuees = sum([i.get("heures_creditees", 0) for i in inscriptions])
    
    total_pompiers = await db.users.count_documents({"tenant_id": tenant.id})
    users_formes = len(set([i["user_id"] for i in inscriptions]))
    
    return {
        "annee": annee,
        "heures_planifiees": heures_planifiees,
        "heures_effectuees": heures_effectuees,
        "pourcentage_realisation": round((heures_effectuees / heures_planifiees * 100) if heures_planifiees > 0 else 0, 1),
        "total_pompiers": total_pompiers,
        "pompiers_formes": users_formes,
        "pourcentage_pompiers": round((users_formes / total_pompiers * 100) if total_pompiers > 0 else 0, 1)
    }


@api_router.get("/{tenant_slug}/formations/mon-taux-presence")
async def get_mon_taux_presence(
    tenant_slug: str,
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """Calcule le taux de prÃ©sence personnel (formations passÃ©es)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Date d'aujourd'hui
    aujourd_hui = datetime.now(timezone.utc).date()
    
    # RÃ©cupÃ©rer mes inscriptions
    mes_inscriptions = await db.inscriptions_formations.find({
        "user_id": current_user.id,
        "tenant_id": tenant.id
    }).to_list(1000)
    
    formations_passees = 0
    presences_validees = 0
    
    for insc in mes_inscriptions:
        formation = await db.formations.find_one({
            "id": insc["formation_id"],
            "annee": annee,
            "tenant_id": tenant.id
        })
        
        if formation:
            date_fin = datetime.fromisoformat(formation["date_fin"]).date()
            
            # Seulement les formations passÃ©es
            if date_fin < aujourd_hui:
                formations_passees += 1
                if insc.get("statut") == "present":
                    presences_validees += 1
    
    taux_presence = round((presences_validees / formations_passees * 100) if formations_passees > 0 else 0, 1)
    
    # RÃ©cupÃ©rer les paramÃ¨tres pour savoir si conforme
    params = await db.parametres_formations.find_one({"tenant_id": tenant.id})
    pourcentage_min = params.get("pourcentage_presence_minimum", 80) if params else 80
    
    conforme = taux_presence >= pourcentage_min
    
    return {
        "formations_passees": formations_passees,
        "presences_validees": presences_validees,
        "absences": formations_passees - presences_validees,
        "taux_presence": taux_presence,
        "pourcentage_minimum": pourcentage_min,
        "conforme": conforme
    }


# ====================================================================
# RAPPORTS AVANCÃ‰S - EXPORTS PDF/EXCEL ET RAPPORTS PAR COMPÃ‰TENCES
# ====================================================================

from reportlab.lib.pagesizes import letter, A4
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.chart import PieChart as ExcelPieChart, BarChart as ExcelBarChart, Reference
import io
from fastapi.responses import StreamingResponse
import matplotlib
matplotlib.use('Agg')  # Backend non-GUI
import matplotlib.pyplot as plt


@api_router.get("/{tenant_slug}/formations/rapports/export-presence")
async def export_rapport_presence(
    tenant_slug: str,
    format: str,
    type_formation: str,  # "obligatoires" ou "toutes"
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """
    Export des taux de prÃ©sence en PDF ou Excel
    - format: "pdf" ou "excel"
    - type_formation: "obligatoires" ou "toutes"
    - annee: annÃ©e concernÃ©e
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es
    pompiers = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    params = await db.parametres_formations.find_one({"tenant_id": tenant.id})
    pourcentage_min = params.get("pourcentage_presence_minimum", 80) if params else 80
    
    aujourd_hui = datetime.now(timezone.utc).date()
    
    rapport_data = []
    for pompier in pompiers:
        # Toutes les inscriptions
        mes_inscriptions = await db.inscriptions_formations.find({
            "user_id": pompier["id"],
            "tenant_id": tenant.id
        }).to_list(1000)
        
        formations_passees = 0
        presences = 0
        
        for insc in mes_inscriptions:
            formation = await db.formations.find_one({
                "id": insc["formation_id"],
                "annee": annee,
                "tenant_id": tenant.id
            })
            
            if formation:
                # Filtre selon type_formation
                if type_formation == "obligatoires" and not formation.get("obligatoire", False):
                    continue
                
                date_fin = datetime.fromisoformat(formation["date_fin"]).date()
                
                if date_fin < aujourd_hui:
                    formations_passees += 1
                    if insc.get("statut") == "present":
                        presences += 1
        
        taux_presence = round((presences / formations_passees * 100) if formations_passees > 0 else 0, 1)
        conforme = taux_presence >= pourcentage_min
        
        rapport_data.append({
            "nom": f"{pompier.get('prenom', '')} {pompier.get('nom', '')}",
            "grade": pompier.get("grade", "N/A"),
            "formations_passees": formations_passees,
            "presences": presences,
            "absences": formations_passees - presences,
            "taux_presence": taux_presence,
            "conforme": conforme
        })
    
    # Tri par taux de prÃ©sence dÃ©croissant
    rapport_data.sort(key=lambda x: -x["taux_presence"])
    
    # Statistiques globales
    total_pompiers = len(rapport_data)
    pompiers_conformes = len([p for p in rapport_data if p["conforme"]])
    taux_conformite = round((pompiers_conformes / total_pompiers * 100) if total_pompiers > 0 else 0, 1)
    
    # GÃ©nÃ©ration selon le format
    if format == "pdf":
        return await generer_pdf_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min, tenant)
    elif format == "excel":
        return await generer_excel_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min)
    else:
        raise HTTPException(status_code=400, detail="Format non supportÃ©")


async def generer_pdf_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min, tenant):
    """GÃ©nÃ¨re un PDF professionnel avec graphiques"""
    
    # Utiliser la fonction helper pour crÃ©er un PDF brandÃ©
    buffer, doc, story = create_branded_pdf(tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Titre
    type_texte = "Formations Obligatoires" if type_formation == "obligatoires" else "Toutes les Formations"
    story.append(Paragraph(f"Rapport de PrÃ©sence - {type_texte}", modern_styles['title']))
    story.append(Paragraph(f"ProFireManager - AnnÃ©e {annee}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # Statistiques globales
    stats_data = [
        ["Statistiques Globales", ""],
        ["Total pompiers", str(total_pompiers)],
        ["Pompiers conformes", f"{pompiers_conformes} ({taux_conformite}%)"],
        ["Taux minimum requis", f"{pourcentage_min}%"]
    ]
    
    stats_table = Table(stats_data, colWidths=[3*inch, 2*inch])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 0.4*inch))
    
    # Tableau des donnÃ©es
    story.append(Paragraph("DÃ©tail par Pompier", styles['Heading2']))
    story.append(Spacer(1, 0.2*inch))
    
    table_data = [["Nom", "Grade", "Formations", "PrÃ©sences", "Absences", "Taux %", "Conforme"]]
    
    for p in rapport_data:
        table_data.append([
            p["nom"],
            p["grade"],
            str(p["formations_passees"]),
            str(p["presences"]),
            str(p["absences"]),
            f"{p['taux_presence']}%",
            "âœ“" if p["conforme"] else "âœ—"
        ])
    
    detail_table = Table(table_data, colWidths=[1.5*inch, 1*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.7*inch, 0.7*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 9),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(detail_table)
    
    # Construction du PDF
    doc.build(story)
    buffer.seek(0)
    
    filename = f"rapport_presence_{type_formation}_{annee}.pdf"
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


async def generer_excel_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min):
    """GÃ©nÃ¨re un fichier Excel avec donnÃ©es et graphiques"""
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport PrÃ©sence"
    
    # En-tÃªte
    type_texte = "Formations Obligatoires" if type_formation == "obligatoires" else "Toutes les Formations"
    ws['A1'] = f"Rapport de PrÃ©sence - {type_texte} - AnnÃ©e {annee}"
    ws['A1'].font = Font(size=16, bold=True, color="DC2626")
    ws.merge_cells('A1:G1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # Statistiques
    ws['A3'] = "Statistiques Globales"
    ws['A3'].font = Font(bold=True, size=12)
    ws['A4'] = "Total pompiers"
    ws['B4'] = total_pompiers
    ws['A5'] = "Pompiers conformes"
    ws['B5'] = f"{pompiers_conformes} ({taux_conformite}%)"
    ws['A6'] = "Taux minimum requis"
    ws['B6'] = f"{pourcentage_min}%"
    
    # Tableau des donnÃ©es
    headers = ["Nom", "Grade", "Formations", "PrÃ©sences", "Absences", "Taux %", "Conforme"]
    row = 8
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=row, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    # DonnÃ©es
    for p in rapport_data:
        row += 1
        ws.cell(row=row, column=1, value=p["nom"])
        ws.cell(row=row, column=2, value=p["grade"])
        ws.cell(row=row, column=3, value=p["formations_passees"])
        ws.cell(row=row, column=4, value=p["presences"])
        ws.cell(row=row, column=5, value=p["absences"])
        ws.cell(row=row, column=6, value=p["taux_presence"])
        ws.cell(row=row, column=7, value="Oui" if p["conforme"] else "Non")
    
    # Ajuster les largeurs de colonnes
    for col in ['A', 'B', 'C', 'D', 'E', 'F', 'G']:
        ws.column_dimensions[col].width = 15
    
    # Sauvegarder dans un buffer
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    filename = f"rapport_presence_{type_formation}_{annee}.xlsx"
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


@api_router.get("/{tenant_slug}/formations/rapports/competences")
async def rapport_par_competences(
    tenant_slug: str,
    annee: int,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """
    Rapport par compÃ©tences
    - Si user_id fourni: rapport pour cette personne uniquement
    - Sinon: rapport gÃ©nÃ©ral pour toute l'organisation
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer toutes les compÃ©tences
    competences = await db.competences.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = []
    
    for comp in competences:
        # RÃ©cupÃ©rer toutes les formations pour cette compÃ©tence
        formations = await db.formations.find({
            "tenant_id": tenant.id,
            "competence_id": comp["id"],
            "annee": annee
        }).to_list(1000)
        
        total_formations = len(formations)
        total_heures_planifiees = sum([f.get("duree_heures", 0) for f in formations])
        
        # RÃ©cupÃ©rer les inscriptions
        formation_ids = [f["id"] for f in formations]
        
        query_inscriptions = {
            "tenant_id": tenant.id,
            "formation_id": {"$in": formation_ids}
        }
        
        # Filtre par user si demandÃ©
        if user_id:
            query_inscriptions["user_id"] = user_id
        
        inscriptions = await db.inscriptions_formations.find(query_inscriptions).to_list(10000)
        
        total_inscrits = len(set([i["user_id"] for i in inscriptions]))
        presences = len([i for i in inscriptions if i.get("statut") == "present"])
        absences = len([i for i in inscriptions if i.get("statut") == "absent"])
        total_inscriptions = len(inscriptions)
        
        taux_presence = round((presences / total_inscriptions * 100) if total_inscriptions > 0 else 0, 1)
        
        heures_effectuees = sum([i.get("heures_creditees", 0) for i in inscriptions if i.get("statut") == "present"])
        
        rapport.append({
            "competence_id": comp["id"],
            "competence_nom": comp["nom"],
            "total_formations": total_formations,
            "total_heures_planifiees": total_heures_planifiees,
            "total_inscrits": total_inscrits,
            "total_inscriptions": total_inscriptions,
            "presences": presences,
            "absences": absences,
            "taux_presence": taux_presence,
            "heures_effectuees": heures_effectuees,
            "taux_realisation": round((heures_effectuees / total_heures_planifiees * 100) if total_heures_planifiees > 0 else 0, 1)
        })
    
    # Tri par nombre de formations dÃ©croissant
    rapport.sort(key=lambda x: -x["total_formations"])
    
    return {
        "annee": annee,
        "user_id": user_id,
        "competences": rapport
    }


@api_router.get("/{tenant_slug}/formations/rapports/export-competences")
async def export_rapport_competences(
    tenant_slug: str,
    format: str,
    annee: int,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """
    Export du rapport par compÃ©tences en PDF ou Excel
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # RÃ©cupÃ©rer les donnÃ©es
    rapport_response = await rapport_par_competences(tenant_slug, annee, user_id, current_user)
    rapport_data = rapport_response["competences"]
    
    # RÃ©cupÃ©rer le nom de l'utilisateur si filtrÃ©
    user_nom = None
    if user_id:
        tenant = await get_tenant_from_slug(tenant_slug)
        user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        if user:
            user_nom = f"{user.get('prenom', '')} {user.get('nom', '')}"
    
    # GÃ©nÃ©ration selon le format
    if format == "pdf":
        return await generer_pdf_competences(rapport_data, annee, user_nom, tenant)
    elif format == "excel":
        return await generer_excel_competences(rapport_data, annee, user_nom)
    else:
        raise HTTPException(status_code=400, detail="Format non supportÃ©")


async def generer_pdf_competences(rapport_data, annee, user_nom, tenant):
    """GÃ©nÃ¨re un PDF pour le rapport par compÃ©tences"""
    
    # Utiliser la fonction helper pour crÃ©er un PDF brandÃ©
    buffer, doc, story = create_branded_pdf(tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Titre
    titre = f"Rapport par CompÃ©tences - {user_nom}" if user_nom else "Rapport par CompÃ©tences"
    story.append(Paragraph(titre, modern_styles['title']))
    story.append(Paragraph(f"ProFireManager - AnnÃ©e {annee}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # Statistiques globales
    total_formations = sum([c["total_formations"] for c in rapport_data])
    total_heures = sum([c["total_heures_planifiees"] for c in rapport_data])
    total_presences = sum([c["presences"] for c in rapport_data])
    total_inscriptions = sum([c["total_inscriptions"] for c in rapport_data])
    taux_presence_global = round((total_presences / total_inscriptions * 100) if total_inscriptions > 0 else 0, 1)
    
    stats_data = [
        ["Statistiques Globales", ""],
        ["Total compÃ©tences", str(len(rapport_data))],
        ["Total formations", str(total_formations)],
        ["Total heures planifiÃ©es", f"{total_heures}h"],
        ["Taux de prÃ©sence moyen", f"{taux_presence_global}%"]
    ]
    
    stats_table = Table(stats_data, colWidths=[3*inch, 2*inch])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 0.4*inch))
    
    # Tableau des compÃ©tences
    story.append(Paragraph("DÃ©tail par CompÃ©tence", styles['Heading2']))
    story.append(Spacer(1, 0.2*inch))
    
    table_data = [["CompÃ©tence", "Formations", "Heures", "Inscrits", "PrÃ©sences", "Taux %"]]
    
    for c in rapport_data:
        table_data.append([
            c["competence_nom"],
            str(c["total_formations"]),
            f"{c['total_heures_planifiees']}h",
            str(c["total_inscrits"]),
            f"{c['presences']}/{c['total_inscriptions']}",
            f"{c['taux_presence']}%"
        ])
    
    detail_table = Table(table_data, colWidths=[2*inch, 1*inch, 1*inch, 1*inch, 1.2*inch, 0.8*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#FCA5A5')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 9),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
    ]))
    
    story.append(detail_table)
    
    doc.build(story)
    buffer.seek(0)
    
    filename = f"rapport_competences_{annee}.pdf"
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


async def generer_excel_competences(rapport_data, annee, user_nom):
    """GÃ©nÃ¨re un fichier Excel pour le rapport par compÃ©tences"""
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport CompÃ©tences"
    
    # En-tÃªte
    titre = f"Rapport par CompÃ©tences - {user_nom}" if user_nom else "Rapport par CompÃ©tences"
    ws['A1'] = f"{titre} - AnnÃ©e {annee}"
    ws['A1'].font = Font(size=16, bold=True, color="DC2626")
    ws.merge_cells('A1:F1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # Statistiques globales
    total_formations = sum([c["total_formations"] for c in rapport_data])
    total_heures = sum([c["total_heures_planifiees"] for c in rapport_data])
    total_presences = sum([c["presences"] for c in rapport_data])
    total_inscriptions = sum([c["total_inscriptions"] for c in rapport_data])
    taux_presence_global = round((total_presences / total_inscriptions * 100) if total_inscriptions > 0 else 0, 1)
    
    ws['A3'] = "Statistiques Globales"
    ws['A3'].font = Font(bold=True, size=12)
    ws['A4'] = "Total compÃ©tences"
    ws['B4'] = len(rapport_data)
    ws['A5'] = "Total formations"
    ws['B5'] = total_formations
    ws['A6'] = "Total heures planifiÃ©es"
    ws['B6'] = f"{total_heures}h"
    ws['A7'] = "Taux de prÃ©sence moyen"
    ws['B7'] = f"{taux_presence_global}%"
    
    # Tableau des donnÃ©es
    headers = ["CompÃ©tence", "Formations", "Heures", "Inscrits", "PrÃ©sences", "Taux %"]
    row = 9
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=row, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    # DonnÃ©es
    for c in rapport_data:
        row += 1
        ws.cell(row=row, column=1, value=c["competence_nom"])
        ws.cell(row=row, column=2, value=c["total_formations"])
        ws.cell(row=row, column=3, value=f"{c['total_heures_planifiees']}h")
        ws.cell(row=row, column=4, value=c["total_inscrits"])
        ws.cell(row=row, column=5, value=f"{c['presences']}/{c['total_inscriptions']}")
        ws.cell(row=row, column=6, value=c["taux_presence"])
    
    # Ajuster les largeurs
    for col in ['A', 'B', 'C', 'D', 'E', 'F']:
        ws.column_dimensions[col].width = 18
    
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    filename = f"rapport_competences_{annee}.xlsx"
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

# ==================== VALIDATIONS MANUELLES COMPETENCES ====================

@api_router.post("/{tenant_slug}/validations-competences")
async def creer_validation_competence(
    tenant_slug: str,
    validation: ValidationCompetenceCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une validation manuelle de compÃ©tence"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que la compÃ©tence existe
    competence = await db.competences.find_one({
        "id": validation.competence_id,
        "tenant_id": tenant.id
    })
    if not competence:
        raise HTTPException(status_code=404, detail="CompÃ©tence non trouvÃ©e")
    
    # CrÃ©er la validation
    validation_obj = ValidationCompetence(
        **validation.dict(),
        tenant_id=tenant.id,
        validee_par=current_user.id
    )
    
    await db.validations_competences.insert_one(validation_obj.dict())
    
    # RÃ©cupÃ©rer l'employÃ© concernÃ©
    user = await db.users.find_one({"id": validation.user_id, "tenant_id": tenant.id})
    
    # CrÃ©er une activitÃ©
    if user:
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="validation_competence",
            description=f"âœ… {current_user.prenom} {current_user.nom} a validÃ© la compÃ©tence '{competence['nom']}' pour {user['prenom']} {user['nom']}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": validation.user_id}
        )
    
    return validation_obj

@api_router.get("/{tenant_slug}/validations-competences/{user_id}")
async def get_validations_competences(
    tenant_slug: str,
    user_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les validations manuelles d'un employÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    validations = await db.validations_competences.find({
        "user_id": user_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    
    return [clean_mongo_doc(v) for v in validations]

@api_router.delete("/{tenant_slug}/validations-competences/{validation_id}")
async def supprimer_validation_competence(
    tenant_slug: str,
    validation_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une validation manuelle"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.validations_competences.delete_one({
        "id": validation_id,
        "tenant_id": tenant.id
    })
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Validation non trouvÃ©e")
    
    return {"message": "Validation supprimÃ©e"}


class DemandeCongÃ©(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    demandeur_id: str
    type_conge: str  # maladie, vacances, parental, personnel
    date_debut: str  # YYYY-MM-DD
    date_fin: str  # YYYY-MM-DD
    nombre_jours: int
    raison: str
    documents: List[str] = []  # URLs des documents justificatifs
    priorite: str = "normale"  # urgente, haute, normale, faible
    statut: str = "en_attente"  # en_attente, approuve, refuse
    approuve_par: Optional[str] = None  # ID du superviseur/admin qui approuve
    date_approbation: Optional[str] = None
    commentaire_approbation: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DemandeCongeCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    type_conge: str
    date_debut: str
    date_fin: str
    raison: str = ""
    statut: str = "en_attente"

class Notification(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    destinataire_id: str
    type: str  # remplacement_disponible, conge_approuve, conge_refuse, conge_demande, planning_assigne
    titre: str
    message: str
    lien: Optional[str] = None  # Lien vers la page concernÃ©e
    statut: str = "non_lu"  # non_lu, lu
    data: Optional[Dict[str, Any]] = {}  # DonnÃ©es supplÃ©mentaires (demande_id, etc.)
    date_creation: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    date_lecture: Optional[str] = None

class NotificationRemplacement(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    demande_remplacement_id: str
    destinataire_id: str
    message: str
    type_notification: str = "remplacement_disponible"  # remplacement_disponible, approbation_requise
    statut: str = "envoye"  # envoye, lu, accepte, refuse
    date_envoi: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    date_reponse: Optional[datetime] = None
    ordre_priorite: Optional[int] = None  # Pour le mode sÃ©quentiel

class ParametresRemplacements(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    mode_notification: str = "simultane"  # simultane, sequentiel, groupe_sequentiel
    taille_groupe: int = 3  # Pour mode groupe_sequentiel
    delai_attente_heures: int = 24  # DÃ©lai avant de passer au suivant
    max_contacts: int = 5
    priorite_grade: bool = True
    priorite_competences: bool = True
    # Gestion des heures supplÃ©mentaires
    activer_gestion_heures_sup: bool = False
    seuil_max_heures: int = 40  # Nombre d'heures maximum
    periode_calcul_heures: str = "semaine"  # semaine, mois, personnalise
    jours_periode_personnalisee: int = 7  # Nombre de jours si pÃ©riode personnalisÃ©e
    # Regroupement des heures
    activer_regroupement_heures: bool = False
    duree_max_regroupement: int = 24  # DurÃ©e maximale d'une garde regroupÃ©e en heures

class ParametresValidationPlanning(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    frequence: str = "mensuel"  # mensuel, hebdomadaire
    jour_envoi: int = 25  # Jour du mois (1-28)
    heure_envoi: str = "17:00"  # Heure d'envoi (HH:MM)
    periode_couverte: str = "mois_suivant"  # mois_suivant, mois_en_cours
    envoi_automatique: bool = True  # Activer/dÃ©sactiver l'envoi automatique
    derniere_notification: Optional[str] = None  # DerniÃ¨re exÃ©cution (ISO datetime)
    
    # ParamÃ¨tres d'Ã©quitÃ© des gardes
    periode_equite: str = "mensuel"  # hebdomadaire, bi-hebdomadaire, mensuel, personnalise
    periode_equite_jours: int = 30  # Nombre de jours pour pÃ©riode personnalisÃ©e
    
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

# ==================== CONFIGURATION IMPORTS CSV ====================

class ImportFieldConfig(BaseModel):
    """Configuration d'un champ pour l'import CSV"""
    key: str
    label: str
    required: bool = False

class ImportSettings(BaseModel):
    """Configuration des imports CSV pour un tenant"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_fields: List[ImportFieldConfig] = []
    personnel_fields: List[ImportFieldConfig] = []
    rapports_fields: List[ImportFieldConfig] = []
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ImportSettingsUpdate(BaseModel):
    """Mise Ã  jour des configurations d'import"""
    epi_fields: Optional[List[ImportFieldConfig]] = None
    personnel_fields: Optional[List[ImportFieldConfig]] = None
    rapports_fields: Optional[List[ImportFieldConfig]] = None

# EPI Models
# ==================== MODÃˆLES EPI NFPA 1851 ====================

class EPI(BaseModel):
    """ModÃ¨le complet d'un Ã©quipement de protection individuelle selon NFPA 1851"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    numero_serie: str  # NumÃ©ro de sÃ©rie interne (format libre)
    type_epi: str  # casque, bottes, veste_bunker, pantalon_bunker, gants, cagoule
    marque: str
    modele: str
    numero_serie_fabricant: str = ""
    date_fabrication: Optional[str] = None
    date_mise_en_service: str
    norme_certification: str = ""  # ex: NFPA 1971, Ã©dition 2018
    cout_achat: float = 0.0
    couleur: str = ""
    taille: str = ""
    user_id: Optional[str] = None  # AffectÃ© Ã  quel pompier
    statut: str = "En service"  # En service, En inspection, En rÃ©paration, Hors service, RetirÃ©
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class EPICreate(BaseModel):
    tenant_id: Optional[str] = None
    numero_serie: str = ""  # Auto-gÃ©nÃ©rÃ© si vide
    type_epi: str
    marque: str
    modele: str
    numero_serie_fabricant: str = ""
    date_fabrication: Optional[str] = None
    date_mise_en_service: str
    norme_certification: str = ""
    cout_achat: float = 0.0
    couleur: str = ""
    taille: str = ""
    user_id: Optional[str] = None
    statut: str = "En service"
    notes: str = ""

class EPIUpdate(BaseModel):
    numero_serie: Optional[str] = None
    type_epi: Optional[str] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    numero_serie_fabricant: Optional[str] = None
    date_fabrication: Optional[str] = None
    date_mise_en_service: Optional[str] = None
    norme_certification: Optional[str] = None
    cout_achat: Optional[float] = None
    couleur: Optional[str] = None
    taille: Optional[str] = None
    user_id: Optional[str] = None
    statut: Optional[str] = None
    notes: Optional[str] = None

class InspectionEPI(BaseModel):
    """ModÃ¨le pour les 3 types d'inspections NFPA 1851"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    type_inspection: str  # apres_utilisation, routine_mensuelle, avancee_annuelle
    date_inspection: str
    inspecteur_nom: str
    inspecteur_id: Optional[str] = None  # Si c'est un utilisateur du systÃ¨me
    isp_id: Optional[str] = None  # Si inspection par ISP
    isp_nom: str = ""
    isp_accreditations: str = ""
    statut_global: str  # conforme, non_conforme, necessite_reparation, hors_service
    checklist: Dict[str, Any] = {}  # JSON avec tous les points de vÃ©rification
    photos: List[str] = []
    commentaires: str = ""
    rapport_pdf_url: str = ""  # Pour inspection avancÃ©e
    signature_numerique: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    type_inspection: str
    date_inspection: str
    inspecteur_nom: str
    inspecteur_id: Optional[str] = None
    isp_id: Optional[str] = None
    isp_nom: str = ""
    isp_accreditations: str = ""
    statut_global: str
    checklist: Dict[str, Any] = {}
    photos: List[str] = []
    commentaires: str = ""
    rapport_pdf_url: str = ""
    signature_numerique: str = ""

# Nouveaux modÃ¨les pour "Mes EPI"
class InspectionApresUsage(BaseModel):
    """Inspection simple aprÃ¨s utilisation par l'employÃ©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    user_id: str  # EmployÃ© qui fait l'inspection
    date_inspection: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    statut: str  # "ok" ou "defaut"
    defauts_constates: str = ""  # Description des dÃ©fauts si statut = "defaut"
    notes: str = ""
    photo_url: str = ""  # URL de la photo du dÃ©faut (optionnel)
    criteres_inspection: Optional[Dict[str, bool]] = {}  # CritÃ¨res cochÃ©s/dÃ©cochÃ©s

class InspectionApresUsageCreate(BaseModel):
    statut: str  # "ok" ou "defaut"
    defauts_constates: Optional[str] = ""
    notes: Optional[str] = ""
    photo_url: Optional[str] = ""
    criteres_inspection: Optional[Dict[str, bool]] = {}

class DemandeRemplacementEPI(BaseModel):
    """Demande de remplacement d'EPI par un employÃ©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    user_id: str  # EmployÃ© qui fait la demande
    raison: str  # "UsÃ©", "Perdu", "DÃ©fectueux", "Taille inadaptÃ©e"
    notes_employe: str = ""
    statut: str = "En attente"  # "En attente", "ApprouvÃ©e", "RefusÃ©e"
    date_demande: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    date_traitement: Optional[datetime] = None
    traite_par: Optional[str] = None  # ID admin/superviseur qui traite
    notes_admin: str = ""  # Notes de l'admin lors du traitement

class DemandeRemplacementEPICreate(BaseModel):
    raison: str
    notes_employe: Optional[str] = ""

class ISP(BaseModel):
    """Fournisseur de Services IndÃ©pendant"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    contact: str = ""
    telephone: str = ""
    email: str = ""
    accreditations: str = ""
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ISPCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    contact: str = ""
    telephone: str = ""
    email: str = ""
    accreditations: str = ""
    notes: str = ""

class ISPUpdate(BaseModel):
    nom: Optional[str] = None
    contact: Optional[str] = None
    telephone: Optional[str] = None
    email: Optional[str] = None
    accreditations: Optional[str] = None
    notes: Optional[str] = None

# ==================== MODÃˆLES PHASE 2 : NETTOYAGE, RÃ‰PARATIONS, RETRAIT ====================

class NettoyageEPI(BaseModel):
    """Suivi des nettoyages EPI selon NFPA 1851"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    type_nettoyage: str  # routine, avance
    date_nettoyage: str
    methode: str  # laveuse_extractrice, manuel, externe
    effectue_par: str  # Nom de la personne ou organisation
    effectue_par_id: Optional[str] = None  # ID utilisateur si interne
    isp_id: Optional[str] = None  # Si nettoyage externe
    nombre_cycles: int = 1  # Pour suivi limite fabricant
    temperature: str = ""  # Ex: "Eau tiÃ¨de max 40Â°C"
    produits_utilises: str = ""
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class NettoyageEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    type_nettoyage: str
    date_nettoyage: str
    methode: str
    effectue_par: str
    effectue_par_id: Optional[str] = None
    isp_id: Optional[str] = None
    nombre_cycles: int = 1
    temperature: str = ""
    produits_utilises: str = ""
    notes: str = ""

class ReparationEPI(BaseModel):
    """Gestion des rÃ©parations EPI"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    statut: str  # demandee, en_cours, terminee, impossible
    date_demande: str
    demandeur: str
    demandeur_id: Optional[str] = None
    date_envoi: Optional[str] = None
    date_reception: Optional[str] = None
    date_reparation: Optional[str] = None
    reparateur_type: str  # interne, externe
    reparateur_nom: str = ""
    isp_id: Optional[str] = None
    probleme_description: str
    pieces_remplacees: List[str] = []
    cout_reparation: float = 0.0
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ReparationEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    statut: str = "demandee"
    date_demande: str
    demandeur: str
    demandeur_id: Optional[str] = None
    reparateur_type: str
    reparateur_nom: str = ""
    isp_id: Optional[str] = None
    probleme_description: str
    notes: str = ""

class ReparationEPIUpdate(BaseModel):
    statut: Optional[str] = None
    date_envoi: Optional[str] = None
    date_reception: Optional[str] = None
    date_reparation: Optional[str] = None
    reparateur_nom: Optional[str] = None
    isp_id: Optional[str] = None
    pieces_remplacees: Optional[List[str]] = None
    cout_reparation: Optional[float] = None
    notes: Optional[str] = None

class RetraitEPI(BaseModel):
    """Enregistrement du retrait dÃ©finitif d'un EPI"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    date_retrait: str
    raison: str  # age_limite, dommage_irreparable, echec_inspection, autre
    description_raison: str
    methode_disposition: str  # coupe_detruit, recyclage, don, autre
    preuve_disposition: List[str] = []  # URLs photos
    certificat_disposition_url: str = ""
    cout_disposition: float = 0.0
    retire_par: str
    retire_par_id: Optional[str] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class RetraitEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    date_retrait: str
    raison: str
    description_raison: str
    methode_disposition: str
    preuve_disposition: List[str] = []
    certificat_disposition_url: str = ""
    cout_disposition: float = 0.0
    retire_par: str
    retire_par_id: Optional[str] = None
    notes: str = ""


# ==================== MULTI-TENANT DEPENDENCIES ====================

# Cache simple pour les tenants (60 secondes)
_tenant_cache = {}
_tenant_cache_time = {}

async def get_tenant_from_slug(slug: str) -> Tenant:
    """RÃ©cupÃ¨re le tenant depuis son slug avec cache"""
    # VÃ©rifier le cache (60 secondes)
    cache_key = f"tenant_{slug}"
    now = time.time()
    if cache_key in _tenant_cache and (now - _tenant_cache_time.get(cache_key, 0)) < 60:
        return _tenant_cache[cache_key]
    
    # RequÃªte simplifiÃ©e avec index
    tenant_data = await db.tenants.find_one({"slug": slug}, {"_id": 0})
    
    # Fallback pour ancienne structure
    if not tenant_data:
        tenant_data = await db.tenants.find_one({"slug": slug, "actif": True}, {"_id": 0})
    
    if not tenant_data:
        tenant_data = await db.tenants.find_one({"slug": slug, "is_active": True}, {"_id": 0})
    
    # Si toujours pas trouvÃ©
    if not tenant_data:
        tenant_data = await db.tenants.find_one({"slug": slug}, {"_id": 0})
        if tenant_data:
            # VÃ©rifier manuellement le statut
            is_active = tenant_data.get('actif', tenant_data.get('is_active', True))
            if not is_active:
                raise HTTPException(status_code=403, detail=f"Caserne '{slug}' inactive")
    
    if not tenant_data:
        raise HTTPException(status_code=404, detail=f"Caserne '{slug}' non trouvÃ©e")
    
    logging.info(f"ğŸ” Tenant data for {slug}: {tenant_data}")
    tenant = Tenant(**tenant_data)
    
    # Mettre en cache
    _tenant_cache[cache_key] = tenant
    _tenant_cache_time[cache_key] = now
    
    return tenant

async def get_current_tenant(tenant_slug: str) -> Tenant:
    """DÃ©pendance FastAPI pour obtenir le tenant actuel"""
    return await get_tenant_from_slug(tenant_slug)

# get_super_admin function moved to earlier in the file

# ==================== TENANT AUTH ROUTES ====================

@api_router.post("/{tenant_slug}/auth/login")
async def tenant_login(tenant_slug: str, user_login: UserLogin):
    """Login pour un tenant spÃ©cifique avec migration automatique SHA256 -> bcrypt"""
    try:
        logging.info(f"ğŸ”‘ Tentative de connexion pour {user_login.email} sur tenant {tenant_slug}")
        
        # VÃ©rifier que le tenant existe et est actif
        tenant = await get_tenant_from_slug(tenant_slug)
        logging.info(f"âœ… Tenant trouvÃ©: {tenant.nom} (id: {tenant.id})")
        
        # Chercher l'utilisateur dans ce tenant
        user_data = await db.users.find_one({
            "email": user_login.email,
            "tenant_id": tenant.id
        })
        
        if not user_data:
            logging.warning(f"âŒ Utilisateur non trouvÃ©: {user_login.email} dans tenant {tenant_slug}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"âœ… Utilisateur trouvÃ©: {user_data.get('nom')} {user_data.get('prenom')} (id: {user_data.get('id')})")
        
        # VÃ©rifier que l'utilisateur est actif
        if user_data.get("statut") != "Actif":
            logging.warning(f"âŒ Tentative de connexion d'un utilisateur inactif: {user_login.email}")
            raise HTTPException(
                status_code=403, 
                detail="Votre compte est dÃ©sactivÃ©. Veuillez contacter votre administrateur."
            )
        
        logging.info(f"âœ… Statut de l'utilisateur vÃ©rifiÃ©: {user_data.get('statut')}")
        
        current_hash = user_data.get("mot_de_passe_hash", "")
        hash_type = "bcrypt" if current_hash.startswith('$2') else "SHA256"
        logging.info(f"ğŸ” Type de hash dÃ©tectÃ©: {hash_type}")
        
        # VÃ©rifier le mot de passe
        if not verify_password(user_login.mot_de_passe, current_hash):
            logging.warning(f"âŒ Mot de passe incorrect pour {user_login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"âœ… Mot de passe vÃ©rifiÃ© avec succÃ¨s pour {user_login.email}")
        
        user = User(**user_data)
        
        # Inclure tenant_id dans le token
        access_token = create_access_token(data={
            "sub": user.id,
            "tenant_id": tenant.id,
            "tenant_slug": tenant.slug
        })
        
        logging.info(f"âœ… Token JWT crÃ©Ã© pour {user_login.email}")
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "tenant": {
                "id": tenant.id,
                "slug": tenant.slug,
                "nom": tenant.nom,
                "parametres": tenant.parametres  # Inclure les paramÃ¨tres du tenant
            },
            "user": {
                "id": user.id,
                "nom": user.nom,
                "prenom": user.prenom,
                "email": user.email,
                "role": user.role,
                "grade": user.grade,
                "type_emploi": user.type_emploi
            }
        }
    except HTTPException:
        # Re-lever les HTTPExceptions sans les logger Ã  nouveau
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur inattendue lors du login pour {user_login.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

# ==================== PASSWORD RESET ROUTES ====================

@api_router.post("/{tenant_slug}/auth/forgot-password")
async def forgot_password(tenant_slug: str, request: ForgotPasswordRequest):
    """
    Endpoint pour demander une rÃ©initialisation de mot de passe.
    Envoie un email avec un lien contenant un token valide 1 heure.
    """
    try:
        logging.info(f"ğŸ”‘ Demande de rÃ©initialisation de mot de passe pour {request.email} sur tenant {tenant_slug}")
        
        # VÃ©rifier que le tenant existe
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Chercher l'utilisateur dans ce tenant
        user_data = await db.users.find_one({
            "email": request.email,
            "tenant_id": tenant.id
        })
        
        # MÃªme si l'utilisateur n'existe pas, on retourne un message gÃ©nÃ©rique pour la sÃ©curitÃ©
        if not user_data:
            logging.warning(f"âš ï¸ Tentative de rÃ©initialisation pour email inexistant: {request.email} dans tenant {tenant_slug}")
            # Ne pas rÃ©vÃ©ler que l'email n'existe pas
            return {
                "message": "Si cet email existe dans notre systÃ¨me, vous recevrez un lien de rÃ©initialisation.",
                "email_sent": False
            }
        
        # GÃ©nÃ©rer un token unique
        reset_token = str(uuid.uuid4())
        
        # Calculer l'expiration (1 heure)
        expires_at = datetime.now(timezone.utc) + timedelta(hours=1)
        
        # CrÃ©er l'objet token
        token_obj = PasswordResetToken(
            tenant_id=tenant.id,
            user_id=user_data["id"],
            email=request.email,
            token=reset_token,
            expires_at=expires_at
        )
        
        # Sauvegarder le token dans la base de donnÃ©es
        await db.password_reset_tokens.insert_one(token_obj.dict())
        
        logging.info(f"âœ… Token de rÃ©initialisation crÃ©Ã© pour {request.email}, expire Ã  {expires_at}")
        
        # Envoyer l'email
        user_name = f"{user_data.get('prenom', '')} {user_data.get('nom', '')}".strip()
        email_sent = send_password_reset_email(
            user_email=request.email,
            user_name=user_name or request.email,
            reset_token=reset_token,
            tenant_slug=tenant_slug
        )
        
        if email_sent:
            logging.info(f"âœ… Email de rÃ©initialisation envoyÃ© avec succÃ¨s Ã  {request.email}")
        else:
            logging.warning(f"âš ï¸ L'email n'a pas pu Ãªtre envoyÃ© Ã  {request.email}")
        
        return {
            "message": "Si cet email existe dans notre systÃ¨me, vous recevrez un lien de rÃ©initialisation.",
            "email_sent": email_sent
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur lors de la demande de rÃ©initialisation pour {request.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")


@api_router.get("/{tenant_slug}/auth/verify-reset-token/{token}")
async def verify_reset_token(tenant_slug: str, token: str):
    """
    VÃ©rifie si un token de rÃ©initialisation est valide et non expirÃ©
    """
    try:
        # VÃ©rifier que le tenant existe
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Chercher le token
        token_data = await db.password_reset_tokens.find_one({
            "token": token,
            "tenant_id": tenant.id,
            "used": False
        })
        
        if not token_data:
            raise HTTPException(status_code=404, detail="Token invalide ou dÃ©jÃ  utilisÃ©")
        
        # VÃ©rifier l'expiration
        expires_at = token_data["expires_at"]
        if isinstance(expires_at, str):
            expires_at = datetime.fromisoformat(expires_at.replace('Z', '+00:00'))
        elif expires_at.tzinfo is None:
            # Si c'est un datetime sans timezone, on assume UTC
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        
        if datetime.now(timezone.utc) > expires_at:
            raise HTTPException(status_code=400, detail="Ce lien a expirÃ©. Veuillez demander un nouveau lien de rÃ©initialisation.")
        
        return {
            "valid": True,
            "email": token_data["email"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur lors de la vÃ©rification du token: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")


@api_router.post("/{tenant_slug}/auth/reset-password")
async def reset_password(tenant_slug: str, request: ResetPasswordRequest):
    """
    RÃ©initialise le mot de passe avec un token valide
    """
    try:
        logging.info(f"ğŸ”‘ Tentative de rÃ©initialisation de mot de passe avec token sur tenant {tenant_slug}")
        
        # VÃ©rifier que le tenant existe
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Chercher le token
        token_data = await db.password_reset_tokens.find_one({
            "token": request.token,
            "tenant_id": tenant.id,
            "used": False
        })
        
        if not token_data:
            logging.warning(f"âš ï¸ Token invalide ou dÃ©jÃ  utilisÃ©: {request.token[:8]}...")
            raise HTTPException(status_code=404, detail="Token invalide ou dÃ©jÃ  utilisÃ©")
        
        # VÃ©rifier l'expiration
        expires_at = token_data["expires_at"]
        if isinstance(expires_at, str):
            expires_at = datetime.fromisoformat(expires_at.replace('Z', '+00:00'))
        elif expires_at.tzinfo is None:
            # Si c'est un datetime sans timezone, on assume UTC
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        
        if datetime.now(timezone.utc) > expires_at:
            logging.warning(f"âš ï¸ Token expirÃ© pour {token_data['email']}")
            raise HTTPException(status_code=400, detail="Ce lien a expirÃ©. Veuillez demander un nouveau lien de rÃ©initialisation.")
        
        # Valider le nouveau mot de passe
        if not validate_complex_password(request.nouveau_mot_de_passe):
            raise HTTPException(
                status_code=400,
                detail="Le mot de passe doit contenir au moins 8 caractÃ¨res, une majuscule, un chiffre et un caractÃ¨re spÃ©cial"
            )
        
        # Hacher le nouveau mot de passe avec bcrypt
        nouveau_hash = get_password_hash(request.nouveau_mot_de_passe)
        logging.info(f"ğŸ” Nouveau mot de passe hashÃ© avec bcrypt pour {token_data['email']}")
        
        # Mettre Ã  jour le mot de passe de l'utilisateur
        result = await db.users.update_one(
            {"id": token_data["user_id"], "tenant_id": tenant.id},
            {"$set": {"mot_de_passe_hash": nouveau_hash}}
        )
        
        if result.modified_count == 0:
            logging.error(f"âŒ Ã‰chec de la mise Ã  jour du mot de passe pour user_id: {token_data['user_id']}")
            raise HTTPException(status_code=500, detail="Erreur lors de la mise Ã  jour du mot de passe")
        
        # Marquer le token comme utilisÃ©
        await db.password_reset_tokens.update_one(
            {"token": request.token},
            {"$set": {"used": True}}
        )
        
        logging.info(f"âœ… Mot de passe rÃ©initialisÃ© avec succÃ¨s pour {token_data['email']}")
        
        return {
            "message": "Votre mot de passe a Ã©tÃ© rÃ©initialisÃ© avec succÃ¨s. Vous pouvez maintenant vous connecter.",
            "email": token_data["email"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"âŒ Erreur lors de la rÃ©initialisation du mot de passe: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

# ==================== TENANT ROUTES (LEGACY / TO MIGRATE) ====================

# Demandes de congÃ© routes
@api_router.post("/{tenant_slug}/demandes-conge", response_model=DemandeCongÃ©)
async def create_demande_conge(tenant_slug: str, demande: DemandeCongeCreate, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Calculer le nombre de jours
    date_debut = datetime.strptime(demande.date_debut, "%Y-%m-%d")
    date_fin = datetime.strptime(demande.date_fin, "%Y-%m-%d")
    nombre_jours = (date_fin - date_debut).days + 1
    
    demande_dict = demande.dict()
    demande_dict["tenant_id"] = tenant.id
    demande_dict["demandeur_id"] = current_user.id
    demande_dict["nombre_jours"] = nombre_jours
    demande_obj = DemandeCongÃ©(**demande_dict)
    await db.demandes_conge.insert_one(demande_obj.dict())
    
    # CrÃ©er notification pour approbation
    if current_user.role == "employe":
        # Notifier les superviseurs et admins de ce tenant
        superviseurs_admins = await db.users.find({
            "tenant_id": tenant.id,
            "role": {"$in": ["superviseur", "admin"]}
        }).to_list(100)
        for superviseur in superviseurs_admins:
            await creer_notification(
                tenant_id=tenant.id,
                destinataire_id=superviseur["id"],
                type="conge_demande",
                titre="Nouvelle demande de congÃ©",
                message=f"{current_user.prenom} {current_user.nom} demande un congÃ© ({demande.type_conge}) du {demande.date_debut} au {demande.date_fin}",
                lien="/conges",
                data={"demande_id": demande_obj.id}
            )
    
    return demande_obj

@api_router.get("/{tenant_slug}/demandes-conge", response_model=List[DemandeCongÃ©])
async def get_demandes_conge(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role == "employe":
        # EmployÃ©s voient seulement leurs demandes
        demandes = await db.demandes_conge.find({
            "tenant_id": tenant.id,
            "demandeur_id": current_user.id
        }).to_list(1000)
    else:
        # Superviseurs et admins voient toutes les demandes de leur tenant
        demandes = await db.demandes_conge.find({"tenant_id": tenant.id}).to_list(1000)
    
    cleaned_demandes = [clean_mongo_doc(demande) for demande in demandes]
    return [DemandeCongÃ©(**demande) for demande in cleaned_demandes]

@api_router.put("/{tenant_slug}/demandes-conge/{demande_id}/approuver")
async def approuver_demande_conge(tenant_slug: str, demande_id: str, action: str, commentaire: str = "", current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    demande = await db.demandes_conge.find_one({"id": demande_id, "tenant_id": tenant.id})
    if not demande:
        raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
    
    # VÃ©rifier les permissions : superviseur peut approuver employÃ©s, admin peut tout approuver
    demandeur = await db.users.find_one({"id": demande["demandeur_id"], "tenant_id": tenant.id})
    if current_user.role == "superviseur" and demandeur["role"] != "employe":
        raise HTTPException(status_code=403, detail="Un superviseur ne peut approuver que les demandes d'employÃ©s")
    
    statut = "approuve" if action == "approuver" else "refuse"
    
    await db.demandes_conge.update_one(
        {"id": demande_id, "tenant_id": tenant.id},
        {
            "$set": {
                "statut": statut,
                "approuve_par": current_user.id,
                "date_approbation": datetime.now(timezone.utc).strftime("%Y-%m-%d"),
                "commentaire_approbation": commentaire
            }
        }
    )
    
    # CrÃ©er notification pour le demandeur
    if demandeur:
        titre = f"CongÃ© {statut}" if statut == "approuve" else "CongÃ© refusÃ©"
        message = f"Votre demande de congÃ© du {demande['date_debut']} au {demande['date_fin']} a Ã©tÃ© {statut}e"
        if commentaire:
            message += f". Commentaire: {commentaire}"
        
        await creer_notification(
            tenant_id=tenant.id,
            destinataire_id=demande["demandeur_id"],
            type=f"conge_{statut}",
            titre=titre,
            message=message,
            lien="/conges",
            data={"demande_id": demande_id}
        )
    
    return {"message": f"Demande {statut}e avec succÃ¨s"}

# Algorithme intelligent de recherche de remplaÃ§ants
@api_router.post("/remplacements/{demande_id}/recherche-automatique")
async def recherche_remplacants_automatique(demande_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # RÃ©cupÃ©rer la demande de remplacement
        demande = await db.demandes_remplacement.find_one({"id": demande_id})
        if not demande:
            raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
        
        # RÃ©cupÃ©rer les paramÃ¨tres de remplacement
        # (selon les rÃ¨gles dÃ©finies dans ParamÃ¨tres > Remplacements)
        
        # Trouver les remplaÃ§ants potentiels selon l'algorithme intelligent
        users = await db.users.find({"statut": "Actif"}).to_list(1000)
        type_garde = await db.types_garde.find_one({"id": demande["type_garde_id"]})
        
        remplacants_potentiels = []
        
        for user in users:
            if user["id"] == demande["demandeur_id"]:
                continue  # Skip demandeur
                
            # Ã‰tape 1: VÃ©rifier disponibilitÃ©s (si temps partiel)
            if user["type_emploi"] == "temps_partiel":
                # Get user disponibilitÃ©s pour cette date exacte
                user_dispos = await db.disponibilites.find({
                    "user_id": user["id"],
                    "date": demande["date"],
                    "statut": "disponible"
                }).to_list(10)
                
                # VÃ©rifier si disponible pour ce type de garde spÃ©cifiquement
                type_garde_compatible = any(
                    d.get("type_garde_id") == type_garde["id"] or d.get("type_garde_id") is None 
                    for d in user_dispos
                )
                
                if not type_garde_compatible:
                    continue  # Skip si pas disponible pour ce type de garde
            
            # Ã‰tape 2: VÃ©rifier grade Ã©quivalent (si paramÃ¨tre activÃ©)
            # Ã‰tape 3: VÃ©rifier compÃ©tences Ã©quivalentes (si paramÃ¨tre activÃ©)
            
            remplacants_potentiels.append({
                "user_id": user["id"],
                "nom": f"{user['prenom']} {user['nom']}",
                "grade": user["grade"],
                "score_compatibilite": 85  # Algorithme de scoring Ã  dÃ©velopper
            })
        
        # Trier par score de compatibilitÃ©
        remplacants_potentiels.sort(key=lambda x: x["score_compatibilite"], reverse=True)
        
        # Limiter selon max_personnes_contact des paramÃ¨tres
        max_contacts = 5  # Ã€ rÃ©cupÃ©rer des paramÃ¨tres
        remplacants_finaux = remplacants_potentiels[:max_contacts]
        
        # CrÃ©er les notifications pour les remplaÃ§ants potentiels
        for remplacant in remplacants_finaux:
            notification = Notification(
                tenant_id=tenant.id,
                destinataire_id=remplacant["user_id"],
                type="remplacement_disponible",
                titre="ğŸ”” Remplacement Disponible",
                message=f"Remplacement disponible le {demande['date']} - {type_garde['nom'] if type_garde else 'Garde'}",
                lien=f"/{tenant_slug}/remplacements",
                data={"demande_id": demande_id},
                statut="non_lu"
            )
            await db.notifications.insert_one(notification.dict())
        
        return {
            "message": "Recherche automatique effectuÃ©e",
            "remplacants_contactes": len(remplacants_finaux),
            "algorithme": "DisponibilitÃ©s â†’ Grade â†’ CompÃ©tences â†’ Score compatibilitÃ©"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur recherche automatique: {str(e)}")

# Accepter une demande de remplacement
@api_router.post("/{tenant_slug}/remplacements/{demande_id}/accepter")
async def accepter_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    commentaire: str = Body(None, embed=True),
    current_user: User = Depends(get_current_user)
):
    """
    Un employÃ© accepte une demande de remplacement
    """
    try:
        # VÃ©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer la demande
        demande = await db.demandes_remplacement.find_one({
            "id": demande_id,
            "tenant_id": tenant.id
        })
        
        if not demande:
            raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
        
        # VÃ©rifier que la demande est toujours en attente
        if demande["statut"] != "en_attente":
            raise HTTPException(
                status_code=400, 
                detail=f"Cette demande n'est plus disponible (statut: {demande['statut']})"
            )
        
        # VÃ©rifier que l'utilisateur a bien Ã©tÃ© contactÃ© pour cette demande
        remplacants_contactes = demande.get("remplacants_contactes", [])
        if current_user.id not in remplacants_contactes:
            raise HTTPException(
                status_code=403, 
                detail="Vous n'Ãªtes pas autorisÃ© Ã  accepter cette demande"
            )
        
        # Mettre Ã  jour le statut de la demande
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "accepte",
                    "remplacant_id": current_user.id,
                    "date_acceptation": datetime.now(timezone.utc).isoformat(),
                    "commentaire_remplacant": commentaire
                }
            }
        )
        
        # CrÃ©er l'assignation dans le planning
        type_garde = await db.types_garde.find_one({"id": demande["type_garde_id"]})
        
        assignation = Assignation(
            user_id=current_user.id,
            type_garde_id=demande["type_garde_id"],
            date=demande["date"],
            statut="planifie",
            assignation_type="manuel",  # Remplacement acceptÃ© = manuel
            tenant_id=tenant.id
        )
        
        await db.assignations.insert_one(assignation.dict())
        
        # Notifier le demandeur
        demandeur = await db.users.find_one({"id": demande["demandeur_id"]})
        notification_demandeur = Notification(
            user_id=demande["demandeur_id"],
            titre="âœ… Remplacement trouvÃ©",
            message=f"{current_user.prenom} {current_user.nom} a acceptÃ© votre demande de remplacement pour le {demande['date']} - {type_garde['nom'] if type_garde else 'Garde'}",
            type="remplacement_accepte",
            lien=f"/{tenant_slug}/remplacements",
            tenant_id=tenant.id
        )
        await db.notifications.insert_one(notification_demandeur.dict())
        
        # Notifier les autres candidats que la demande est pourvue
        for remplacant_id in remplacants_contactes:
            if remplacant_id != current_user.id:
                notification_autres = Notification(
                    user_id=remplacant_id,
                    titre="â„¹ï¸ Remplacement pourvu",
                    message=f"Le remplacement du {demande['date']} a Ã©tÃ© pourvu par un autre pompier",
                    type="remplacement_pourvu",
                    lien=f"/{tenant_slug}/remplacements",
                    tenant_id=tenant.id
                )
                await db.notifications.insert_one(notification_autres.dict())
        
        return {
            "message": "Demande acceptÃ©e avec succÃ¨s",
            "demande_id": demande_id,
            "assignation_creee": True,
            "remplacant": f"{current_user.prenom} {current_user.nom}"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Erreur acceptation demande: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de l'acceptation: {str(e)}")

# Refuser une demande de remplacement
@api_router.post("/{tenant_slug}/remplacements/{demande_id}/refuser")
async def refuser_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    raison: str = Body(None, embed=True),
    current_user: User = Depends(get_current_user)
):
    """
    Un employÃ© refuse une demande de remplacement
    """
    try:
        # VÃ©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer la demande
        demande = await db.demandes_remplacement.find_one({
            "id": demande_id,
            "tenant_id": tenant.id
        })
        
        if not demande:
            raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
        
        # VÃ©rifier que la demande est toujours en attente
        if demande["statut"] != "en_attente":
            raise HTTPException(
                status_code=400, 
                detail=f"Cette demande n'est plus disponible (statut: {demande['statut']})"
            )
        
        # VÃ©rifier que l'utilisateur a bien Ã©tÃ© contactÃ© pour cette demande
        remplacants_contactes = demande.get("remplacants_contactes", [])
        if current_user.id not in remplacants_contactes:
            raise HTTPException(
                status_code=403, 
                detail="Vous n'Ãªtes pas autorisÃ© Ã  refuser cette demande"
            )
        
        # Ajouter le refus Ã  l'historique
        historique = demande.get("historique_tentatives", [])
        historique.append({
            "user_id": current_user.id,
            "nom": f"{current_user.prenom} {current_user.nom}",
            "action": "refuse",
            "date": datetime.now(timezone.utc).isoformat(),
            "raison": raison
        })
        
        # Retirer cet utilisateur de la liste des contactÃ©s
        remplacants_restants = [r for r in remplacants_contactes if r != current_user.id]
        
        # Si plus personne de disponible, marquer comme expiree
        nouveau_statut = "expiree" if len(remplacants_restants) == 0 else "en_attente"
        
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "historique_tentatives": historique,
                    "remplacants_contactes": remplacants_restants,
                    "statut": nouveau_statut
                }
            }
        )
        
        # Notifier le demandeur si tous ont refusÃ©
        if nouveau_statut == "expiree":
            notification_demandeur = Notification(
                user_id=demande["demandeur_id"],
                titre="âŒ Aucun remplaÃ§ant trouvÃ©",
                message=f"Malheureusement, aucun pompier n'est disponible pour votre remplacement du {demande['date']}",
                type="remplacement_expire",
                lien=f"/{tenant_slug}/remplacements",
                tenant_id=tenant.id
            )
            await db.notifications.insert_one(notification_demandeur.dict())
        
        return {
            "message": "Demande refusÃ©e",
            "demande_id": demande_id,
            "remplacants_restants": len(remplacants_restants),
            "statut": nouveau_statut
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Erreur refus demande: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors du refus: {str(e)}")

# Rapports et exports routes
@api_router.get("/rapports/export-pdf")
async def export_pdf_report(type_rapport: str = "general", user_id: str = None, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []
        
        # En-tÃªte du rapport
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#dc2626')
        )
        
        story.append(Paragraph("ProFireManager v2.0 - Rapport d'ActivitÃ©", title_style))
        story.append(Spacer(1, 12))
        
        if type_rapport == "general":
            # Rapport gÃ©nÃ©ral
            story.append(Paragraph("ğŸ“Š Statistiques GÃ©nÃ©rales", styles['Heading2']))
            
            # RÃ©cupÃ©rer les donnÃ©es
            users = await db.users.find({"statut": "Actif"}).to_list(1000)
            assignations = await db.assignations.find().to_list(1000)
            formations = await db.formations.find().to_list(1000)
            
            data = [
                ['Indicateur', 'Valeur'],
                ['Personnel actif', str(len(users))],
                ['Assignations totales', str(len(assignations))],
                ['Formations disponibles', str(len(formations))],
                ['EmployÃ©s temps plein', str(len([u for u in users if u.get('type_emploi') == 'temps_plein']))],
                ['EmployÃ©s temps partiel', str(len([u for u in users if u.get('type_emploi') == 'temps_partiel']))],
            ]
            
            table = Table(data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 14),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            story.append(table)
            
        elif type_rapport == "employe" and user_id:
            # Rapport par employÃ©
            user_data = await db.users.find_one({"id": user_id})
            if user_data:
                story.append(Paragraph(f"ğŸ‘¤ Rapport Personnel - {user_data['prenom']} {user_data['nom']}", styles['Heading2']))
                
                user_assignations = await db.assignations.find({"user_id": user_id}).to_list(1000)
                
                data = [
                    ['Information', 'DÃ©tail'],
                    ['Nom complet', f"{user_data['prenom']} {user_data['nom']}"],
                    ['Grade', user_data['grade']],
                    ['Type emploi', user_data['type_emploi']],
                    ['Gardes assignÃ©es', str(len(user_assignations))],
                    ['Statut', user_data['statut']]
                ]
                
                table = Table(data)
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#dc2626')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                
                story.append(table)
        
        doc.build(story)
        pdf_data = buffer.getvalue()
        buffer.close()
        
        # Retourner en base64 pour le frontend
        pdf_base64 = base64.b64encode(pdf_data).decode('utf-8')
        
        return {
            "message": "Rapport PDF gÃ©nÃ©rÃ© avec succÃ¨s",
            "filename": f"rapport_{type_rapport}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
            "data": pdf_base64
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur gÃ©nÃ©ration PDF: {str(e)}")

@api_router.get("/rapports/export-excel")
async def export_excel_report(type_rapport: str = "general", current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        wb = Workbook()
        ws = wb.active
        
        # Style de l'en-tÃªte
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="DC2626", end_color="DC2626", fill_type="solid")
        
        if type_rapport == "general":
            ws.title = "Rapport GÃ©nÃ©ral"
            
            # En-tÃªte
            headers = ["Indicateur", "Valeur", "DÃ©tails"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = Alignment(horizontal="center")
            
            # DonnÃ©es
            users = await db.users.find({"statut": "Actif"}).to_list(1000)
            assignations = await db.assignations.find().to_list(1000)
            
            data_rows = [
                ["Personnel Total", len(users), f"{len([u for u in users if u.get('type_emploi') == 'temps_plein'])} temps plein, {len([u for u in users if u.get('type_emploi') == 'temps_partiel'])} temps partiel"],
                ["Assignations", len(assignations), f"PÃ©riode: {datetime.now().strftime('%B %Y')}"],
                ["Taux ActivitÃ©", "85%", "Personnel actif vs total"],
            ]
            
            for row, (indicateur, valeur, details) in enumerate(data_rows, 2):
                ws.cell(row=row, column=1, value=indicateur)
                ws.cell(row=row, column=2, value=valeur)
                ws.cell(row=row, column=3, value=details)
        
        # Sauvegarder en mÃ©moire
        buffer = BytesIO()
        wb.save(buffer)
        excel_data = buffer.getvalue()
        buffer.close()
        
        # Retourner en base64
        excel_base64 = base64.b64encode(excel_data).decode('utf-8')
        
        return {
            "message": "Rapport Excel gÃ©nÃ©rÃ© avec succÃ¨s",
            "filename": f"rapport_{type_rapport}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
            "data": excel_base64
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur gÃ©nÃ©ration Excel: {str(e)}")

@api_router.get("/{tenant_slug}/rapports/statistiques-avancees")
async def get_statistiques_avancees(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # RÃ©cupÃ©rer toutes les donnÃ©es nÃ©cessaires filtrÃ©es par tenant
        users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
        assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        formations = await db.formations.find({"tenant_id": tenant.id}).to_list(1000)
        demandes_remplacement = await db.demandes_remplacement.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Statistiques gÃ©nÃ©rales
        stats_generales = {
            "personnel_total": len(users),
            "personnel_actif": len([u for u in users if u.get("statut") == "Actif"]),
            "assignations_mois": len(assignations),
            "taux_couverture": 94.5,  # Calcul Ã  amÃ©liorer
            "formations_disponibles": len(formations),
            "remplacements_demandes": len(demandes_remplacement)
        }
        
        # Statistiques par rÃ´le
        stats_par_role = {}
        for role in ["admin", "superviseur", "employe"]:
            users_role = [u for u in users if u.get("role") == role]
            assignations_role = [a for a in assignations if any(u["id"] == a["user_id"] and u.get("role") == role for u in users)]
            
            stats_par_role[role] = {
                "nombre_utilisateurs": len(users_role),
                "assignations_totales": len(assignations_role),
                "heures_moyennes": len(assignations_role) * 8,  # Estimation
                "formations_completees": sum(len(u.get("formations", [])) for u in users_role)
            }
        
        # Statistiques par employÃ© (pour export individuel)
        stats_par_employe = []
        for user in users:
            user_assignations = [a for a in assignations if a["user_id"] == user["id"]]
            user_disponibilites = await db.disponibilites.find({"user_id": user["id"], "tenant_id": tenant.id}).to_list(100)
            
            stats_par_employe.append({
                "id": user["id"],
                "nom": f"{user['prenom']} {user['nom']}",
                "grade": user["grade"],
                "role": user["role"],
                "type_emploi": user["type_emploi"],
                "assignations_count": len(user_assignations),
                "disponibilites_count": len(user_disponibilites),
                "formations_count": len(user.get("formations", [])),
                "heures_estimees": len(user_assignations) * 8
            })
        
        return {
            "statistiques_generales": stats_generales,
            "statistiques_par_role": stats_par_role,
            "statistiques_par_employe": stats_par_employe,
            "periode": datetime.now().strftime("%B %Y"),
            "date_generation": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur calcul statistiques: {str(e)}")


# ====================================================================
# MODULE RAPPORTS AVANCÃ‰S - INTERNES ET EXTERNES
# ====================================================================

# ModÃ¨les pour les nouvelles donnÃ©es

class Budget(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    annee: int
    categorie: str  # salaires, formations, equipements, carburant, entretien, autres
    budget_alloue: float
    budget_consomme: float = 0.0
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BudgetCreate(BaseModel):
    annee: int
    categorie: str
    budget_alloue: float
    notes: str = ""

class Immobilisation(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    type_immobilisation: str  # vehicule, equipement_majeur
    nom: str
    date_acquisition: str  # YYYY-MM-DD
    cout_acquisition: float
    cout_entretien_annuel: float = 0.0
    etat: str = "bon"  # bon, moyen, mauvais
    date_remplacement_prevue: Optional[str] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ImmobilisationCreate(BaseModel):
    type_immobilisation: str
    nom: str
    date_acquisition: str
    cout_acquisition: float
    cout_entretien_annuel: float = 0.0
    etat: str = "bon"
    date_remplacement_prevue: Optional[str] = None
    notes: str = ""

class ProjetTriennal(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    description: str
    type_projet: str  # acquisition, renovation, recrutement
    annee_prevue: int
    cout_estime: float
    statut: str = "prevu"  # prevu, en_cours, termine, annule
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ProjetTriennalCreate(BaseModel):
    nom: str
    description: str
    type_projet: str
    annee_prevue: int
    cout_estime: float
    statut: str = "prevu"

class Intervention(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    date_intervention: str
    type_intervention: str  # incendie, medical, sauvetage, autre
    duree_minutes: int
    nombre_pompiers: int
    temps_reponse_minutes: Optional[int] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InterventionCreate(BaseModel):
    date_intervention: str
    type_intervention: str
    duree_minutes: int
    nombre_pompiers: int
    temps_reponse_minutes: Optional[int] = None
    notes: str = ""


# ====== MODÃˆLES POUR LE DASHBOARD ======

class MessageImportant(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    titre: str
    contenu: str
    priorite: str  # info, important, urgent
    date_expiration: Optional[str] = None
    auteur_id: str
    auteur_nom: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MessageImportantCreate(BaseModel):
    titre: str
    contenu: str
    priorite: str = "info"
    date_expiration: Optional[str] = None

class Activite(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    type_activite: str  # creation_personnel, assignation, formation, remplacement, etc.
    description: str
    user_id: Optional[str] = None
    user_nom: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


# ==================== PRÃ‰VENTION MODELS ====================

class Batiment(BaseModel):
    """Fiche d'Ã©tablissement/bÃ¢timent pour les inspections de prÃ©vention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    
    # Informations gÃ©nÃ©rales
    nom_etablissement: str = ""
    adresse_civique: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    cadastre_matricule: str = ""  # RenommÃ© de numero_lot_cadastre
    valeur_fonciere: Optional[str] = ""  # String car peut Ãªtre vide
    
    # Informations sur le bÃ¢timent
    type_batiment: str = ""
    sous_type_batiment: str = ""
    annee_construction: str = ""
    nombre_etages: str = ""
    superficie_totale_m2: str = ""
    
    # Contacts - PropriÃ©taire
    proprietaire_nom: str = ""
    proprietaire_prenom: str = ""
    proprietaire_telephone: str = ""
    proprietaire_courriel: str = ""
    
    # Contacts - GÃ©rant/Gestionnaire
    gerant_nom: str = ""
    gerant_telephone: str = ""
    gerant_courriel: str = ""
    gestionnaire_nom: str = ""  # Alias pour compatibilitÃ© frontend
    gestionnaire_prenom: str = ""
    gestionnaire_telephone: str = ""
    gestionnaire_courriel: str = ""
    
    # Contacts - Locataire
    localaire_nom: str = ""  # Orthographe originale conservÃ©e
    localaire_prenom: str = ""
    localaire_telephone: str = ""
    localaire_courriel: str = ""
    locataire_nom: str = ""  # Alias pour compatibilitÃ© frontend
    locataire_prenom: str = ""
    locataire_telephone: str = ""
    locataire_courriel: str = ""
    
    # Contacts - Responsable sÃ©curitÃ©
    responsable_securite_nom: str = ""
    responsable_securite_telephone: str = ""
    responsable_securite_courriel: str = ""
    
    # Classification selon Code national de prÃ©vention des incendies - Canada 2020
    groupe_occupation: str = ""  # A, B, C, D, E, F, G, I
    sous_groupe: str = ""  # A-1, A-2, B-1, F-1, F-2, F-3, etc.
    description_activite: str = ""
    niveau_risque: str = ""  # Faible, Moyen, Ã‰levÃ©, TrÃ¨s Ã©levÃ© (selon Tableau A1)
    
    # Risques
    risques: List[str] = []
    risques_identifes: List[str] = []  # Orthographe originale conservÃ©e
    risques_identifies: List[str] = []  # Alias pour compatibilitÃ© frontend
    
    # GÃ©olocalisation
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    
    # Photo
    photo_url: Optional[str] = ""  # URL ou base64 de la photo du bÃ¢timent
    
    # MÃ©tadonnÃ©es
    statut: str = "actif"  # actif, inactif, demolition
    notes_generales: str = ""
    notes: str = ""  # Alias pour compatibilitÃ© frontend
    preventionniste_assigne_id: Optional[str] = None  # ID de l'employÃ© prÃ©ventionniste
    historique_assignations: List[Dict[str, Any]] = []  # Historique des changements de prÃ©ventionniste
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BatimentCreate(BaseModel):
    nom_etablissement: str = ""
    adresse_civique: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    cadastre_matricule: str = ""
    valeur_fonciere: Optional[str] = ""  # String car peut Ãªtre vide
    
    # Informations sur le bÃ¢timent
    type_batiment: str = ""
    sous_type_batiment: str = ""
    annee_construction: str = ""
    nombre_etages: str = ""
    superficie_totale_m2: str = ""
    
    # Contacts - PropriÃ©taire
    proprietaire_nom: str = ""
    proprietaire_prenom: str = ""
    proprietaire_telephone: str = ""
    proprietaire_courriel: str = ""
    
    # Contacts - GÃ©rant/Gestionnaire
    gerant_nom: str = ""
    gerant_telephone: str = ""
    gerant_courriel: str = ""
    gestionnaire_nom: str = ""  # Alias pour compatibilitÃ© frontend
    gestionnaire_prenom: str = ""
    gestionnaire_telephone: str = ""
    gestionnaire_courriel: str = ""
    
    # Contacts - Locataire
    localaire_nom: str = ""  # Orthographe originale conservÃ©e
    localaire_prenom: str = ""
    localaire_telephone: str = ""
    localaire_courriel: str = ""
    locataire_nom: str = ""  # Alias pour compatibilitÃ© frontend
    locataire_prenom: str = ""
    locataire_telephone: str = ""
    locataire_courriel: str = ""
    
    # Contacts - Responsable sÃ©curitÃ©
    responsable_securite_nom: str = ""
    responsable_securite_telephone: str = ""
    responsable_securite_courriel: str = ""
    
    # Classification
    groupe_occupation: str = ""
    sous_groupe: str = ""
    description_activite: str = ""
    niveau_risque: str = ""
    
    # Risques
    risques: List[str] = []
    risques_identifes: List[str] = []  # Orthographe originale conservÃ©e
    risques_identifies: List[str] = []  # Alias pour compatibilitÃ© frontend
    
    # GÃ©olocalisation
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    
    # Photo
    photo_url: Optional[str] = ""
    
    # MÃ©tadonnÃ©es
    statut: str = "actif"
    notes_generales: str = ""
    notes: str = ""  # Alias pour compatibilitÃ© frontend
    preventionniste_assigne_id: Optional[str] = None
    
    class Config:
        extra = "ignore"  # Ignorer les champs supplÃ©mentaires

class SecteurGeographique(BaseModel):
    """Secteur gÃ©ographique pour l'assignation des prÃ©ventionnistes"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    
    # Informations du secteur
    nom: str  # Ex: "Secteur Nord", "Zone industrielle Est"
    description: str = ""
    couleur: str = "#3b82f6"  # Couleur d'affichage sur la carte (hex)
    
    # GÃ©omÃ©trie (polygone GeoJSON)
    geometry: Dict[str, Any]  # Format GeoJSON: {"type": "Polygon", "coordinates": [[[lng, lat], ...]]}
    
    # Assignation
    preventionniste_assigne_id: Optional[str] = None  # ID de l'employÃ© prÃ©ventionniste
    
    # MÃ©tadonnÃ©es
    actif: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SecteurGeographiqueCreate(BaseModel):
    """ModÃ¨le pour la crÃ©ation d'un secteur gÃ©ographique"""
    nom: str
    description: str = ""
    couleur: str = "#3b82f6"
    geometry: Dict[str, Any]
    preventionniste_assigne_id: Optional[str] = None
    actif: bool = True
    
    class Config:
        extra = "ignore"

class SymbolePersonnalise(BaseModel):
    """Symbole personnalisÃ© pour les plans d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Borne-fontaine personnalisÃ©e"
    categorie: str = "PersonnalisÃ©"  # CatÃ©gorie du symbole
    image_base64: str  # Image en base64
    couleur: str = "#3b82f6"  # Couleur de bordure dans la palette
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    created_by: str  # ID de l'utilisateur qui a crÃ©Ã©

class SymbolePersonnaliseCreate(BaseModel):
    """ModÃ¨le pour la crÃ©ation d'un symbole personnalisÃ©"""
    nom: str
    categorie: str = "PersonnalisÃ©"
    image_base64: str
    couleur: str = "#3b82f6"
    
    class Config:
        extra = "ignore"


class GrilleInspection(BaseModel):
    """Template de grille d'inspection selon le groupe d'occupation"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Grille Groupe C - RÃ©sidentiel"
    groupe_occupation: str  # C, E, F, I, etc.
    sections: List[Dict[str, Any]] = []  # Structure JSON des sections et questions
    actif: bool = True
    version: str = "1.0"
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class GrilleInspectionCreate(BaseModel):
    nom: str
    groupe_occupation: str
    sections: List[Dict[str, Any]] = []
    actif: bool = True
    version: str = "1.0"

class Inspection(BaseModel):
    """Inspection rÃ©alisÃ©e sur un bÃ¢timent"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    batiment_id: str
    grille_inspection_id: str
    preventionniste_id: str  # ID de l'employÃ© qui a fait l'inspection
    
    # MÃ©tadonnÃ©es inspection
    date_inspection: str = ""  # YYYY-MM-DD
    heure_debut: str = ""
    heure_fin: str = ""
    type_inspection: str = "reguliere"  # reguliere, suivi, urgence, plainte
    
    # RÃ©sultats
    resultats: Dict[str, Any] = {}  # RÃ©ponses JSON de la grille
    statut_global: str = "conforme"  # conforme, non_conforme, partiellement_conforme
    score_conformite: float = 100.0  # Pourcentage de conformitÃ©
    
    # Documentation
    photos: List[str] = []  # URLs des photos
    notes_inspection: str = ""
    recommandations: str = ""
    
    # Signature et validation
    signature_proprietaire: Optional[str] = None  # Signature numÃ©rique base64
    nom_representant: str = ""
    rapport_pdf_url: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionCreate(BaseModel):
    batiment_id: str
    grille_inspection_id: str
    preventionniste_id: str
    date_inspection: str
    heure_debut: str = ""
    heure_fin: str = ""
    type_inspection: str = "reguliere"
    resultats: Dict[str, Any] = {}
    statut_global: str = "conforme"
    score_conformite: float = 100.0
    photos: List[str] = []
    notes_inspection: str = ""
    recommandations: str = ""
    signature_proprietaire: Optional[str] = None
    nom_representant: str = ""

class NonConformite(BaseModel):
    """Non-conformitÃ© identifiÃ©e lors d'une inspection"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    inspection_id: str
    batiment_id: str
    
    # Description de la non-conformitÃ©
    titre: str = ""
    description: str = ""
    section_grille: str = ""  # Section de la grille oÃ¹ elle a Ã©tÃ© identifiÃ©e
    gravite: str = "moyen"  # faible, moyen, eleve, critique
    article_code: str = ""  # Article du code de sÃ©curitÃ©
    
    # Suivi
    statut: str = "ouverte"  # ouverte, en_cours, corrigee, fermee
    delai_correction: Optional[str] = None  # Date limite YYYY-MM-DD
    date_correction: Optional[str] = None
    notes_correction: str = ""
    
    # Documentation
    photos_avant: List[str] = []
    photos_apres: List[str] = []
    
    # ResponsabilitÃ©
    responsable_correction: str = ""  # PropriÃ©taire/Gestionnaire
    preventionniste_suivi_id: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class NonConformiteCreate(BaseModel):
    inspection_id: str
    batiment_id: str
    titre: str
    description: str = ""
    section_grille: str = ""
    gravite: str = "moyen"
    article_code: str = ""
    delai_correction: Optional[str] = None
    photos_avant: List[str] = []
    responsable_correction: str = ""
    preventionniste_suivi_id: Optional[str] = None


# ==================== MODÃˆLES Ã‰TENDUS POUR INSPECTIONS VISUELLES ====================

class PhotoInspection(BaseModel):
    """Photo prise lors d'une inspection"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    url: str  # URL de stockage de la photo
    categorie: str = ""  # Ex: "Preuve accroche porte", "Adresse non visible", "MatiÃ¨res dangereuses"
    secteur: Optional[str] = None  # Secteur 1, 2, 3, 4, 5 selon schÃ©ma
    cadran: Optional[str] = None  # Cadran A, B, C, D (subdivision du Secteur 1)
    description: str = ""
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ParticipantInspection(BaseModel):
    """Participant Ã  une inspection (pompier ou prÃ©ventionniste)"""
    user_id: str
    nom_complet: str
    role: str  # "pompier" ou "preventionniste"
    est_principal: bool = False  # Le pompier connectÃ© qui crÃ©e l'inspection

class InspectionVisuelle(BaseModel):
    """Inspection visuelle complÃ¨te pour tablette/mobile"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    batiment_id: str
    
    # Participants
    participants: List[ParticipantInspection] = []
    
    # Timing
    date_inspection: str = ""  # YYYY-MM-DD
    heure_debut: Optional[str] = None
    heure_fin: Optional[str] = None
    duree_minutes: Optional[int] = None
    
    # GÃ©olocalisation (capture automatique)
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    
    # Photos catÃ©gorisÃ©es
    photos: List[PhotoInspection] = []
    
    # Non-conformitÃ©s dÃ©taillÃ©es
    non_conformites_ids: List[str] = []  # RÃ©fÃ©rences aux NonConformite
    
    # Checklist dynamique selon type de bÃ¢timent
    checklist_reponses: Dict[str, Any] = {}
    
    # Statuts
    statut: str = "en_cours"  # en_cours, validee, non_conforme, suivi_requis
    statut_conformite: str = "conforme"  # conforme, non_conforme, partiellement_conforme
    
    # Plan d'intervention
    plan_intervention_url: Optional[str] = None  # URL du PDF du plan
    
    # Notes
    notes_terrain: str = ""
    recommandations: str = ""
    
    # Validation (modifiable en tout temps)
    validee_par_id: Optional[str] = None
    date_validation: Optional[datetime] = None
    
    # Mode hors-ligne
    sync_status: str = "synced"  # synced, pending, offline
    
    # MÃ©tadonnÃ©es
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionVisuelleCreate(BaseModel):
    batiment_id: str
    participants: List[ParticipantInspection]
    date_inspection: str
    heure_debut: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    notes_terrain: str = ""

class InspectionVisuelleUpdate(BaseModel):
    participants: Optional[List[ParticipantInspection]] = None
    heure_fin: Optional[str] = None
    photos: Optional[List[PhotoInspection]] = None
    checklist_reponses: Optional[Dict[str, Any]] = None
    statut: Optional[str] = None
    statut_conformite: Optional[str] = None
    notes_terrain: Optional[str] = None
    recommandations: Optional[str] = None
    validee_par_id: Optional[str] = None

class NonConformiteVisuelle(BaseModel):
    """Non-conformitÃ© avec photos et gravitÃ© dÃ©taillÃ©e"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    inspection_id: str
    batiment_id: str
    
    # Description
    titre: str
    description: str = ""
    gravite: str = "mineur"  # mineur, majeur, critique
    
    # Articles et dÃ©lais
    article_municipal: str = ""  # Ex: "Article 45.2"
    delai_correction_jours: Optional[int] = None
    date_limite: Optional[str] = None  # YYYY-MM-DD
    
    # Photos
    photos_nc: List[PhotoInspection] = []  # Photos de la non-conformitÃ©
    photos_resolution: List[PhotoInspection] = []  # Photos aprÃ¨s correction
    
    # Statut
    statut: str = "nouvelle"  # nouvelle, en_cours, resolue
    date_resolution: Optional[datetime] = None
    notes_resolution: str = ""
    
    # Suivi
    responsable_correction: str = ""  # Nom propriÃ©taire/gestionnaire
    preventionniste_suivi_id: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class NonConformiteVisuelleCreate(BaseModel):
    inspection_id: str
    batiment_id: str
    titre: str
    description: str = ""
    gravite: str = "mineur"
    article_municipal: str = ""
    delai_correction_jours: Optional[int] = None
    photos_nc: List[PhotoInspection] = []
    responsable_correction: str = ""

class BatimentMapView(BaseModel):
    """Vue simplifiÃ©e pour affichage sur carte"""
    id: str
    nom_etablissement: str
    adresse_civique: str
    ville: str
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    niveau_risque: str
    statut_inspection: str  # "fait_conforme", "a_faire", "non_conforme", "en_cours"
    derniere_inspection: Optional[str] = None  # Date ISO
    groupe_occupation: str
    sous_groupe: str

class GeocodeRequest(BaseModel):
    """RequÃªte de gÃ©ocodage d'adresse"""
    adresse_complete: str

class GeocodeResponse(BaseModel):
    """RÃ©ponse de gÃ©ocodage"""
    latitude: float
    longitude: float
    adresse_formatee: str
    precision: str  # "building", "street", "city"


# ==================== MODÃˆLES PLANS D'INTERVENTION ====================

class ElementPlanBase(BaseModel):
    """Classe de base pour tous les Ã©lÃ©ments d'un plan d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type_element: str  # hydrant, sortie, matiere_dangereuse, generatrice, gaz_naturel, reservoir_propane, vehicule
    latitude: float
    longitude: float
    numero: Optional[str] = None  # Ex: H1, S1, MD1 (auto-gÃ©nÃ©rÃ©)
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class HydrantElement(ElementPlanBase):
    """Hydrant sur le plan"""
    type_element: str = "hydrant"
    type_hydrant: str  # borne_fontaine, borne_seche, aspiration
    debit: float  # DÃ©bit
    unite_debit: str = "gal/min"  # gal/min ou L/min
    couleur_indicateur: Optional[str] = None  # Rouge, jaune, vert selon dÃ©bit

class SortieElement(ElementPlanBase):
    """Sortie d'urgence sur le plan"""
    type_element: str = "sortie"
    type_sortie: str  # urgence, principale, secondaire
    largeur_m: Optional[float] = None
    acces_fauteuil: bool = False
    eclairage_secours: bool = False

class MatiereDangereuse(ElementPlanBase):
    """MatiÃ¨re dangereuse prÃ©sente"""
    type_element: str = "matiere_dangereuse"
    nom_produit: str
    pictogramme_simdut: str  # URL ou code du pictogramme
    quantite: Optional[float] = None
    unite_quantite: str = "L"  # L, kg, mÂ³
    classe_danger: str = ""  # Ex: "Inflammable", "Toxique", "Corrosif"

class GeneratriceElement(ElementPlanBase):
    """GÃ©nÃ©ratrice d'urgence"""
    type_element: str = "generatrice"
    puissance_kw: Optional[float] = None
    emplacement_commutateur: str = ""
    type_carburant: str = ""  # diesel, essence, gaz naturel

class GazNaturelElement(ElementPlanBase):
    """EntrÃ©e de gaz naturel"""
    type_element: str = "gaz_naturel"
    emplacement_vanne_coupure: str
    accessible_exterieur: bool = True

class ReservoirPropaneElement(ElementPlanBase):
    """RÃ©servoir de propane"""
    type_element: str = "reservoir_propane"
    capacite: float
    unite_capacite: str = "gallons"  # gallons ou litres
    emplacement_vanne: str
    type_reservoir: str = ""  # aerien, enterre

class VehiculeElement(ElementPlanBase):
    """Position recommandÃ©e pour vÃ©hicules d'intervention"""
    type_element: str = "vehicule"
    type_vehicule: str  # echelle, pompe, citerne
    position_recommandee: str  # Ex: "Face faÃ§ade nord", "Cour arriÃ¨re"
    notes_stationnement: str = ""

class RouteAcces(BaseModel):
    """Route d'accÃ¨s au bÃ¢timent"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str = "Route principale"
    chemin_polyline: List[Dict[str, float]] = []  # Liste de {lat, lng}
    largeur_m: Optional[float] = None
    pente: Optional[str] = None  # faible, moyenne, forte
    notes: str = ""
    est_principale: bool = True

class ZoneDanger(BaseModel):
    """Zone de danger ou pÃ©rimÃ¨tre d'Ã©vacuation"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str
    type_zone: str  # perimetre_evacuation, zone_chaude, zone_tiede, zone_froide
    polygone: List[Dict[str, float]] = []  # Liste de {lat, lng}
    couleur: str = "#ff0000"  # Hex color
    opacite: float = 0.3
    rayon_m: Optional[float] = None
    description: str = ""

class SecteurPlan(BaseModel):
    """Secteur du bÃ¢timent (mÃªme systÃ¨me que photos inspection)"""
    numero: int  # 1, 2, 3, 4, 5
    cadran: Optional[str] = None  # A, B, C, D (subdivision secteur 1)
    description: str = ""
    elements_ids: List[str] = []  # IDs des Ã©lÃ©ments dans ce secteur

class PlanEtage(BaseModel):
    """Plan d'un Ã©tage intÃ©rieur"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    numero_etage: int  # -1 (sous-sol), 0 (RDC), 1, 2, 3...
    nom: str  # "Rez-de-chaussÃ©e", "1er Ã©tage", "Sous-sol"
    image_url: Optional[str] = None  # Image du plan d'Ã©tage
    annotations: List[Dict[str, Any]] = []  # Annotations sur le plan
    elements_interieurs: List[Dict[str, Any]] = []  # Escaliers, ascenseurs, etc.

class PhotoPlanIntervention(BaseModel):
    """Photo attachÃ©e au plan d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    url: str
    latitude: float = 0.0
    longitude: float = 0.0
    titre: str = ""
    description: str = ""
    localisation: str = ""  # Localisation textuelle dans le bÃ¢timent (ex: "EntrÃ©e principale", "2e Ã©tage - cÃ´tÃ© est")
    categorie: str = ""  # facade, entree, systeme_alarme, points_eau, risques, autre
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class IconePersonnalisee(BaseModel):
    """IcÃ´ne personnalisÃ©e pour les plans d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    image_base64: str  # Image encodÃ©e en base64
    categorie: str  # hydrants, sorties, matieres_dangereuses, generateurs, gaz_naturel, propane, vehicules, autre
    created_by_id: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class IconePersonnaliseeCreate(BaseModel):
    """CrÃ©ation d'une icÃ´ne personnalisÃ©e"""
    nom: str
    image_base64: str
    categorie: str

class PlanIntervention(BaseModel):
    """Plan d'intervention complet"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    batiment_id: str
    
    # Identification
    numero_plan: str  # Ex: "PI-2025-001"
    nom: str = ""
    
    # Versioning
    version: str = "1.0"
    version_precedente_id: Optional[str] = None
    
    # Statut et workflow
    statut: str = "brouillon"  # brouillon, en_attente_validation, valide, archive, rejete
    created_by_id: str  # ID du prÃ©ventionniste crÃ©ateur
    validated_by_id: Optional[str] = None  # ID admin/superviseur qui valide
    date_validation: Optional[datetime] = None
    commentaires_validation: str = ""
    commentaires_rejet: str = ""
    
    # Ã‰lÃ©ments du plan
    hydrants: List[HydrantElement] = []
    sorties: List[SortieElement] = []
    matieres_dangereuses: List[MatiereDangereuse] = []
    generatrices: List[GeneratriceElement] = []
    gaz_naturel: List[GazNaturelElement] = []
    reservoirs_propane: List[ReservoirPropaneElement] = []
    vehicules: List[VehiculeElement] = []
    
    # Structure spatiale
    routes_acces: List[RouteAcces] = []
    zones_danger: List[ZoneDanger] = []
    secteurs: List[SecteurPlan] = []
    plans_etages: List[PlanEtage] = []
    photos: List[PhotoPlanIntervention] = []
    
    # Layers GeoJSON pour le plan interactif (depuis le builder)
    layers: List[Dict[str, Any]] = []
    
    # Vue aÃ©rienne
    centre_lat: float
    centre_lng: float
    zoom_level: int = 18
    vue_aerienne_url: Optional[str] = None  # Google Static Map URL
    carte_image: Optional[str] = None  # Capture d'Ã©cran de la carte en base64
    predefined_symbol_overrides: Dict[str, Any] = {}  # Modifications des icÃ´nes prÃ©dÃ©finies
    
    # Calculs automatiques
    distance_caserne_km: Optional[float] = None
    distance_caserne_unite: str = "km"  # km ou m
    temps_acces_minutes: Optional[int] = None
    
    # Documentation
    notes_generales: str = ""
    instructions_particulieres: str = ""
    
    # Export
    pdf_url: Optional[str] = None
    date_derniere_maj: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    # MÃ©tadonnÃ©es
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class PlanInterventionCreate(BaseModel):
    batiment_id: str
    nom: str = ""
    centre_lat: float
    centre_lng: float
    notes_generales: str = ""
    
    # Champs optionnels pour permettre la sauvegarde depuis le builder
    layers: List[Dict[str, Any]] = Field(default_factory=list)
    hydrants: List[HydrantElement] = Field(default_factory=list)
    sorties: List[SortieElement] = Field(default_factory=list)
    matieres_dangereuses: List[MatiereDangereuse] = Field(default_factory=list)
    generatrices: List[GeneratriceElement] = Field(default_factory=list)
    gaz_naturel: List[GazNaturelElement] = Field(default_factory=list)
    reservoirs_propane: List[ReservoirPropaneElement] = Field(default_factory=list)
    vehicules: List[VehiculeElement] = Field(default_factory=list)
    routes_acces: List[RouteAcces] = Field(default_factory=list)
    zones_danger: List[ZoneDanger] = Field(default_factory=list)
    secteurs: List[SecteurPlan] = Field(default_factory=list)
    plans_etages: List[PlanEtage] = Field(default_factory=list)
    photos: List[PhotoPlanIntervention] = Field(default_factory=list)
    instructions_particulieres: str = ""
    carte_image: Optional[str] = None  # Capture d'Ã©cran de la carte en base64
    predefined_symbol_overrides: Dict[str, Any] = Field(default_factory=dict)  # Modifications des icÃ´nes prÃ©dÃ©finies

class PlanInterventionUpdate(BaseModel):
    nom: Optional[str] = None
    statut: Optional[str] = None  # Permettre la mise Ã  jour du statut (pour repasser rejete -> brouillon)
    layers: Optional[List[Dict[str, Any]]] = None  # Layers GeoJSON du builder
    hydrants: Optional[List[HydrantElement]] = None
    sorties: Optional[List[SortieElement]] = None
    matieres_dangereuses: Optional[List[MatiereDangereuse]] = None
    generatrices: Optional[List[GeneratriceElement]] = None
    gaz_naturel: Optional[List[GazNaturelElement]] = None
    reservoirs_propane: Optional[List[ReservoirPropaneElement]] = None
    vehicules: Optional[List[VehiculeElement]] = None
    routes_acces: Optional[List[RouteAcces]] = None
    zones_danger: Optional[List[ZoneDanger]] = None
    secteurs: Optional[List[SecteurPlan]] = None
    plans_etages: Optional[List[PlanEtage]] = None
    photos: Optional[List[PhotoPlanIntervention]] = None
    notes_generales: Optional[str] = None
    instructions_particulieres: Optional[str] = None
    carte_image: Optional[str] = None  # Capture d'Ã©cran de la carte en base64
    predefined_symbol_overrides: Optional[Dict[str, Any]] = None  # Modifications des icÃ´nes prÃ©dÃ©finies

class TemplatePlanIntervention(BaseModel):
    """Template prÃ©-dÃ©fini de plan d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "RÃ©sidentiel unifamilial", "Commercial petit", "Industriel F-1"
    type_batiment: str  # residentiel, commercial, industriel
    groupe_occupation: str  # A, B, C, D, E, F, G, I
    sous_groupe: Optional[str] = None  # F-1, F-2, F-3, etc.
    
    # Ã‰lÃ©ments prÃ©-configurÃ©s (positions relatives)
    hydrants_defaut: List[Dict[str, Any]] = []
    sorties_defaut: List[Dict[str, Any]] = []
    vehicules_defaut: List[Dict[str, Any]] = []
    
    # Instructions
    instructions_utilisation: str = ""
    
    actif: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ValidationRequest(BaseModel):
    """RequÃªte de validation de plan"""
    commentaires: str = ""

class RejectionRequest(BaseModel):
    """RequÃªte de rejet de plan"""
    commentaires_rejet: str





# ====== ENDPOINTS CRUD POUR LES NOUVELLES DONNÃ‰ES ======

# BUDGETS
@api_router.post("/{tenant_slug}/rapports/budgets")
async def create_budget(tenant_slug: str, budget: BudgetCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    budget_dict = budget.dict()
    budget_dict["tenant_id"] = tenant.id
    budget_obj = Budget(**budget_dict)
    await db.budgets.insert_one(budget_obj.dict())
    return clean_mongo_doc(budget_obj.dict())

@api_router.post("/{tenant_slug}/rapports/import-csv")
async def import_rapports_csv(
    tenant_slug: str,
    rapports_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse de budgets et dÃ©penses depuis un CSV"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    items = rapports_data.get("items", [])
    if not items:
        raise HTTPException(status_code=400, detail="Aucun Ã©lÃ©ment Ã  importer")
    
    results = {
        "total": len(items),
        "created_budgets": 0,
        "created_depenses": 0,
        "updated": 0,
        "errors": [],
        "duplicates": []
    }
    
    for index, item_data in enumerate(items):
        try:
            # Validation des champs obligatoires
            if not item_data.get("date") or not item_data.get("description") or not item_data.get("montant"):
                results["errors"].append({
                    "line": index + 1,
                    "error": "Date, Description et Montant sont requis",
                    "data": item_data
                })
                continue
            
            # DÃ©terminer le type (budget ou dÃ©pense)
            item_type = item_data.get("type", "depense").lower()
            if item_type not in ["budget", "depense", "dÃ©pense"]:
                results["errors"].append({
                    "line": index + 1,
                    "error": f"Type invalide: {item_type}. Doit Ãªtre 'budget' ou 'depense'",
                    "data": item_data
                })
                continue
            
            # Normaliser le type
            if item_type in ["dÃ©pense", "depense"]:
                item_type = "depense"
            
            # VÃ©rifier si l'Ã©lÃ©ment existe dÃ©jÃ  (par date + description + montant)
            collection = db.budgets if item_type == "budget" else db.depenses
            
            # CrÃ©er une date comparable
            date_str = item_data["date"]
            if isinstance(date_str, str):
                try:
                    # Essayer diffÃ©rents formats de date
                    from dateutil import parser
                    parsed_date = parser.parse(date_str)
                    date_comparable = parsed_date.strftime("%Y-%m-%d")
                except:
                    date_comparable = date_str
            else:
                date_comparable = date_str
            
            existing_item = await collection.find_one({
                "tenant_id": tenant.id,
                "date": date_comparable,
                "description": item_data["description"],
                "montant": float(item_data["montant"])
            })
            
            if existing_item:
                results["duplicates"].append({
                    "line": index + 1,
                    "type": item_type,
                    "date": date_comparable,
                    "description": item_data["description"],
                    "montant": item_data["montant"],
                    "action": item_data.get("action_doublon", "skip"),
                    "data": item_data
                })
                
                # Si action_doublon = update, mettre Ã  jour
                if item_data.get("action_doublon") == "update":
                    update_data = {
                        "description": item_data["description"],
                        "montant": float(item_data["montant"]),
                        "categorie": item_data.get("categorie", ""),
                        "numero_reference": item_data.get("numero_reference", ""),
                        "fournisseur": item_data.get("fournisseur", ""),
                        "compte_budgetaire": item_data.get("compte_budgetaire", ""),
                        "projet_service": item_data.get("projet_service", ""),
                        "notes": item_data.get("notes", ""),
                        "piece_jointe_url": item_data.get("piece_jointe_url", ""),
                        "updated_at": datetime.now(timezone.utc).isoformat()
                    }
                    
                    await collection.update_one(
                        {"id": existing_item["id"], "tenant_id": tenant.id},
                        {"$set": update_data}
                    )
                    results["updated"] += 1
                else:
                    # skip par dÃ©faut
                    continue
            
            # CrÃ©er l'Ã©lÃ©ment s'il n'existe pas
            if not existing_item:
                new_item = {
                    "id": str(uuid.uuid4()),
                    "tenant_id": tenant.id,
                    "date": date_comparable,
                    "description": item_data["description"],
                    "montant": float(item_data["montant"]),
                    "categorie": item_data.get("categorie", ""),
                    "numero_reference": item_data.get("numero_reference", ""),
                    "fournisseur": item_data.get("fournisseur", ""),
                    "compte_budgetaire": item_data.get("compte_budgetaire", ""),
                    "projet_service": item_data.get("projet_service", ""),
                    "notes": item_data.get("notes", ""),
                    "piece_jointe_url": item_data.get("piece_jointe_url", ""),
                    "created_at": datetime.now(timezone.utc).isoformat()
                }
                
                # Champs spÃ©cifiques selon le type
                if item_type == "budget":
                    new_item["annee"] = item_data.get("annee", datetime.now(timezone.utc).year)
                    await db.budgets.insert_one(new_item)
                    results["created_budgets"] += 1
                else:
                    new_item["statut"] = item_data.get("statut", "approuve")
                    await db.depenses.insert_one(new_item)
                    results["created_depenses"] += 1
        
        except Exception as e:
            results["errors"].append({
                "line": index + 1,
                "error": str(e),
                "data": item_data
            })
    
    return results



@api_router.get("/{tenant_slug}/rapports/budgets")
async def get_budgets(tenant_slug: str, annee: Optional[int] = None, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    query = {"tenant_id": tenant.id}
    if annee:
        query["annee"] = annee
    
    budgets = await db.budgets.find(query).to_list(1000)
    return [clean_mongo_doc(b) for b in budgets]

@api_router.put("/{tenant_slug}/rapports/budgets/{budget_id}")
async def update_budget(tenant_slug: str, budget_id: str, budget: BudgetCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    budget_dict = budget.dict()
    budget_dict["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.budgets.update_one(
        {"id": budget_id, "tenant_id": tenant.id},
        {"$set": budget_dict}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Budget non trouvÃ©")
    
    return {"message": "Budget mis Ã  jour"}

@api_router.delete("/{tenant_slug}/rapports/budgets/{budget_id}")
async def delete_budget(tenant_slug: str, budget_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.budgets.delete_one({"id": budget_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Budget non trouvÃ©")
    
    return {"message": "Budget supprimÃ©"}

# IMMOBILISATIONS
@api_router.post("/{tenant_slug}/rapports/immobilisations")
async def create_immobilisation(tenant_slug: str, immobilisation: ImmobilisationCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    immob_dict = immobilisation.dict()
    immob_dict["tenant_id"] = tenant.id
    immob_obj = Immobilisation(**immob_dict)
    await db.immobilisations.insert_one(immob_obj.dict())
    return clean_mongo_doc(immob_obj.dict())

@api_router.get("/{tenant_slug}/rapports/immobilisations")
async def get_immobilisations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    immobilisations = await db.immobilisations.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(i) for i in immobilisations]

@api_router.delete("/{tenant_slug}/rapports/immobilisations/{immob_id}")
async def delete_immobilisation(tenant_slug: str, immob_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.immobilisations.delete_one({"id": immob_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Immobilisation non trouvÃ©e")
    
    return {"message": "Immobilisation supprimÃ©e"}

# PROJETS TRIENNAUX
@api_router.post("/{tenant_slug}/rapports/projets-triennaux")
async def create_projet_triennal(tenant_slug: str, projet: ProjetTriennalCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    projet_dict = projet.dict()
    projet_dict["tenant_id"] = tenant.id
    projet_obj = ProjetTriennal(**projet_dict)
    await db.projets_triennaux.insert_one(projet_obj.dict())
    return clean_mongo_doc(projet_obj.dict())

@api_router.get("/{tenant_slug}/rapports/projets-triennaux")
async def get_projets_triennaux(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    projets = await db.projets_triennaux.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(p) for p in projets]

@api_router.delete("/{tenant_slug}/rapports/projets-triennaux/{projet_id}")
async def delete_projet_triennal(tenant_slug: str, projet_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.projets_triennaux.delete_one({"id": projet_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Projet non trouvÃ©")
    
    return {"message": "Projet supprimÃ©"}

# INTERVENTIONS
@api_router.post("/{tenant_slug}/rapports/interventions")
async def create_intervention(tenant_slug: str, intervention: InterventionCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    intervention_dict = intervention.dict()
    intervention_dict["tenant_id"] = tenant.id
    intervention_obj = Intervention(**intervention_dict)
    await db.interventions.insert_one(intervention_obj.dict())
    return clean_mongo_doc(intervention_obj.dict())

@api_router.get("/{tenant_slug}/rapports/interventions")
async def get_interventions(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    interventions = await db.interventions.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(i) for i in interventions]


# ====== RAPPORTS INTERNES ======

@api_router.get("/{tenant_slug}/rapports/dashboard-interne")
async def get_dashboard_interne(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Dashboard interne avec KPIs clÃ©s"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Date du mois en cours
    today = datetime.now(timezone.utc)
    debut_mois = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    # RÃ©cupÃ©rer les donnÃ©es
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(1000)
    
    # Calculer heures travaillÃ©es ce mois
    heures_mois = 0
    for assignation in assignations:
        if "date" in assignation:
            try:
                date_assignation = datetime.fromisoformat(assignation["date"])
                if date_assignation >= debut_mois:
                    # Estimer 8h par assignation
                    heures_mois += 8
            except:
                pass
    
    # Calculer coÃ»ts salariaux du mois
    cout_salarial_mois = 0
    for user in users:
        taux_horaire = user.get("taux_horaire", 0)
        user_assignations = [a for a in assignations if a["user_id"] == user["id"]]
        user_heures = len(user_assignations) * 8
        cout_salarial_mois += user_heures * taux_horaire
    
    # Pompiers disponibles actuellement
    pompiers_disponibles = len([u for u in users if u.get("statut") == "Actif" and u.get("type_emploi") == "temps_plein"])
    
    return {
        "heures_travaillees_mois": heures_mois,
        "cout_salarial_mois": round(cout_salarial_mois, 2),
        "pompiers_disponibles": pompiers_disponibles,
        "total_pompiers": len(users),
        "periode": debut_mois.strftime("%B %Y")
    }


@api_router.get("/{tenant_slug}/rapports/couts-salariaux")
async def get_rapport_couts_salariaux(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    caserne: Optional[str] = None,
    type_personnel: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """Rapport dÃ©taillÃ© des coÃ»ts salariaux"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Convertir dates
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    # RÃ©cupÃ©rer les donnÃ©es
    query_users = {"tenant_id": tenant.id}
    if type_personnel:
        query_users["type_emploi"] = type_personnel
    
    users = await db.users.find(query_users).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    cout_total = 0
    
    for user in users:
        # Filtrer assignations par pÃ©riode
        user_assignations = []
        for assignation in assignations:
            if assignation["user_id"] == user["id"] and "date" in assignation:
                try:
                    date_assign = datetime.fromisoformat(assignation["date"])
                    if date_debut_dt <= date_assign <= date_fin_dt:
                        user_assignations.append(assignation)
                except:
                    pass
        
        if len(user_assignations) > 0:
            heures_travaillees = len(user_assignations) * 8  # Estimation
            taux_horaire = user.get("taux_horaire", 0)
            cout_individuel = heures_travaillees * taux_horaire
            cout_total += cout_individuel
            
            rapport.append({
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "matricule": user.get("numero_employe", "N/A"),
                "type_emploi": user.get("type_emploi", "N/A"),
                "heures_travaillees": heures_travaillees,
                "heures_supplementaires": 0,  # Ã€ implÃ©menter
                "taux_horaire": taux_horaire,
                "cout_total": round(cout_individuel, 2)
            })
    
    return {
        "periode": {"debut": date_debut, "fin": date_fin},
        "employes": rapport,
        "cout_total": round(cout_total, 2),
        "nombre_employes": len(rapport)
    }


@api_router.get("/{tenant_slug}/rapports/disponibilite")
async def get_rapport_disponibilite(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Rapport de disponibilitÃ©/indisponibilitÃ© des pompiers"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Convertir dates
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    # RÃ©cupÃ©rer les donnÃ©es
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    disponibilites = await db.disponibilites.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    total_jours_disponibles = 0
    total_jours_indisponibles = 0
    
    for user in users:
        # Filtrer disponibilitÃ©s par pÃ©riode
        user_disponibilites = []
        for dispo in disponibilites:
            if dispo["user_id"] == user["id"] and "date" in dispo:
                try:
                    date_dispo = datetime.fromisoformat(dispo["date"]).date()
                    if date_debut_dt.date() <= date_dispo <= date_fin_dt.date():
                        user_disponibilites.append(dispo)
                except:
                    pass
        
        jours_disponibles = len([d for d in user_disponibilites if d.get("disponible") == True])
        jours_indisponibles = len([d for d in user_disponibilites if d.get("disponible") == False])
        
        # Analyser motifs d'indisponibilitÃ©
        motifs = {}
        for dispo in user_disponibilites:
            if not dispo.get("disponible"):
                motif = dispo.get("motif", "non_specifie")
                motifs[motif] = motifs.get(motif, 0) + 1
        
        total_jours = jours_disponibles + jours_indisponibles
        taux_disponibilite = round((jours_disponibles / total_jours * 100) if total_jours > 0 else 0, 1)
        
        total_jours_disponibles += jours_disponibles
        total_jours_indisponibles += jours_indisponibles
        
        rapport.append({
            "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
            "grade": user.get("grade", "N/A"),
            "jours_disponibles": jours_disponibles,
            "jours_indisponibles": jours_indisponibles,
            "taux_disponibilite": taux_disponibilite,
            "motifs_indisponibilite": motifs
        })
    
    # Calculer statistiques globales
    total_jours = total_jours_disponibles + total_jours_indisponibles
    taux_global = round((total_jours_disponibles / total_jours * 100) if total_jours > 0 else 0, 1)
    
    return {
        "periode": {"debut": date_debut, "fin": date_fin},
        "employes": rapport,
        "total_jours_disponibles": total_jours_disponibles,
        "total_jours_indisponibles": total_jours_indisponibles,
        "taux_disponibilite_global": taux_global,
        "nombre_employes": len(rapport)
    }


@api_router.get("/{tenant_slug}/rapports/couts-formations")
async def get_rapport_couts_formations(
    tenant_slug: str,
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """Rapport dÃ©taillÃ© des coÃ»ts de formation"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es
    formations = await db.formations.find({"tenant_id": tenant.id, "annee": annee}).to_list(1000)
    inscriptions = await db.inscriptions_formations.find({"tenant_id": tenant.id}).to_list(10000)
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = []
    cout_total = 0
    
    for formation in formations:
        # RÃ©cupÃ©rer inscriptions pour cette formation
        formation_inscriptions = [i for i in inscriptions if i["formation_id"] == formation["id"]]
        
        # CoÃ»t de la formation (formateur, matÃ©riel, etc.)
        cout_formation = formation.get("cout_formation", 0)
        
        # CoÃ»t salarial des participants
        cout_salarial = 0
        for inscription in formation_inscriptions:
            user = next((u for u in users if u["id"] == inscription["user_id"]), None)
            if user:
                taux_horaire = user.get("taux_horaire", 0)
                heures_formation = formation.get("duree_heures", 0)
                cout_salarial += taux_horaire * heures_formation
        
        cout_total_formation = cout_formation + cout_salarial
        cout_total += cout_total_formation
        
        rapport.append({
            "nom_formation": formation.get("nom", "N/A"),
            "date": formation.get("date_debut", "N/A"),
            "duree_heures": formation.get("duree_heures", 0),
            "nombre_participants": len(formation_inscriptions),
            "cout_formation": cout_formation,
            "cout_salarial": round(cout_salarial, 2),
            "cout_total": round(cout_total_formation, 2)
        })
    
    return {
        "annee": annee,
        "formations": rapport,
        "cout_total": round(cout_total, 2),
        "nombre_formations": len(rapport),
        "nombre_total_participants": sum([f["nombre_participants"] for f in rapport]),
        "heures_totales": sum([f["duree_heures"] for f in rapport])
    }


# ====== RAPPORTS EXTERNES ======

@api_router.get("/{tenant_slug}/rapports/tableau-bord-budgetaire")
async def get_tableau_bord_budgetaire(tenant_slug: str, annee: int, current_user: User = Depends(get_current_user)):
    """Tableau de bord budgÃ©taire pour rapports externes"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les budgets de l'annÃ©e
    budgets = await db.budgets.find({"tenant_id": tenant.id, "annee": annee}).to_list(1000)
    
    rapport_budgetaire = []
    total_alloue = 0
    total_consomme = 0
    
    for budget in budgets:
        alloue = budget.get("budget_alloue", 0)
        consomme = budget.get("budget_consomme", 0)
        total_alloue += alloue
        total_consomme += consomme
        
        rapport_budgetaire.append({
            "categorie": budget.get("categorie"),
            "budget_alloue": alloue,
            "budget_consomme": consomme,
            "pourcentage_utilise": round((consomme / alloue * 100) if alloue > 0 else 0, 1),
            "restant": alloue - consomme
        })
    
    return {
        "annee": annee,
        "budget_total_alloue": total_alloue,
        "budget_total_consomme": total_consomme,
        "pourcentage_global": round((total_consomme / total_alloue * 100) if total_alloue > 0 else 0, 1),
        "par_categorie": rapport_budgetaire
    }


@api_router.get("/{tenant_slug}/rapports/rapport-immobilisations")
async def get_rapport_immobilisations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Rapport dÃ©taillÃ© sur les immobilisations"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les immobilisations
    immobilisations = await db.immobilisations.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = {
        "vehicules": [],
        "equipements": [],
        "statistiques": {
            "nombre_vehicules": 0,
            "nombre_equipements": 0,
            "cout_acquisition_total": 0,
            "cout_entretien_annuel_total": 0,
            "age_moyen_vehicules": 0,
            "age_moyen_equipements": 0
        }
    }
    
    today = datetime.now(timezone.utc).date()
    ages_vehicules = []
    ages_equipements = []
    
    for immob in immobilisations:
        # Calculer l'Ã¢ge
        try:
            date_acquisition = datetime.fromisoformat(immob["date_acquisition"]).date()
            age_annees = (today - date_acquisition).days / 365.25
        except:
            age_annees = 0
        
        item = {
            "id": immob["id"],
            "nom": immob["nom"],
            "date_acquisition": immob["date_acquisition"],
            "age_annees": round(age_annees, 1),
            "cout_acquisition": immob["cout_acquisition"],
            "cout_entretien_annuel": immob["cout_entretien_annuel"],
            "etat": immob["etat"],
            "date_remplacement_prevue": immob.get("date_remplacement_prevue"),
            "notes": immob.get("notes", "")
        }
        
        if immob["type_immobilisation"] == "vehicule":
            rapport["vehicules"].append(item)
            rapport["statistiques"]["nombre_vehicules"] += 1
            ages_vehicules.append(age_annees)
        else:
            rapport["equipements"].append(item)
            rapport["statistiques"]["nombre_equipements"] += 1
            ages_equipements.append(age_annees)
        
        rapport["statistiques"]["cout_acquisition_total"] += immob["cout_acquisition"]
        rapport["statistiques"]["cout_entretien_annuel_total"] += immob["cout_entretien_annuel"]
    
    # Calculer Ã¢ges moyens
    if ages_vehicules:
        rapport["statistiques"]["age_moyen_vehicules"] = round(sum(ages_vehicules) / len(ages_vehicules), 1)
    if ages_equipements:
        rapport["statistiques"]["age_moyen_equipements"] = round(sum(ages_equipements) / len(ages_equipements), 1)
    
    return rapport


# ====== EXPORTS PDF/EXCEL POUR LES RAPPORTS ======

@api_router.get("/{tenant_slug}/rapports/export-dashboard-pdf")
async def export_dashboard_pdf(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Export PDF du Dashboard interne"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es du dashboard
    today = datetime.now(timezone.utc)
    debut_mois = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(1000)
    
    heures_mois = 0
    for assignation in assignations:
        if "date" in assignation:
            try:
                date_assignation = datetime.fromisoformat(assignation["date"])
                if date_assignation >= debut_mois:
                    heures_mois += 8
            except:
                pass
    
    cout_salarial_mois = 0
    for user in users:
        taux_horaire = user.get("taux_horaire", 0)
        user_assignations = [a for a in assignations if a["user_id"] == user["id"]]
        user_heures = len(user_assignations) * 8
        cout_salarial_mois += user_heures * taux_horaire
    
    pompiers_disponibles = len([u for u in users if u.get("statut") == "Actif" and u.get("type_emploi") == "temps_plein"])
    
    # GÃ©nÃ©rer le PDF
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # DÃ©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame, onPage=doc.afterPage)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Header personnalisÃ© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    story.append(Paragraph("Dashboard Interne ProFireManager", modern_styles['title']))
    story.append(Paragraph(f"PÃ©riode: {debut_mois.strftime('%B %Y')}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # KPIs
    kpi_data = [
        ["Indicateur", "Valeur"],
        ["Heures travaillÃ©es ce mois", f"{heures_mois}h"],
        ["CoÃ»t salarial du mois", f"${cout_salarial_mois:,.2f}"],
        ["Pompiers disponibles", str(pompiers_disponibles)],
        ["Total pompiers", str(len(users))]
    ]
    
    kpi_table = Table(kpi_data, colWidths=[3*inch, 2*inch])
    kpi_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 11),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(kpi_table)
    doc.build(story)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=dashboard_interne_{debut_mois.strftime('%Y%m')}.pdf"}
    )


@api_router.get("/{tenant_slug}/rapports/export-salaires-pdf")
async def export_salaires_pdf(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Export PDF du rapport coÃ»ts salariaux"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    cout_total = 0
    
    for user in users:
        user_assignations = []
        for assignation in assignations:
            if assignation["user_id"] == user["id"] and "date" in assignation:
                try:
                    date_assign = datetime.fromisoformat(assignation["date"])
                    if date_debut_dt <= date_assign <= date_fin_dt:
                        user_assignations.append(assignation)
                except:
                    pass
        
        if len(user_assignations) > 0:
            heures_travaillees = len(user_assignations) * 8
            taux_horaire = user.get("taux_horaire", 0)
            cout_individuel = heures_travaillees * taux_horaire
            cout_total += cout_individuel
            
            rapport.append({
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "matricule": user.get("numero_employe", "N/A"),
                "type_emploi": user.get("type_emploi", "N/A"),
                "heures_travaillees": heures_travaillees,
                "taux_horaire": taux_horaire,
                "cout_total": cout_individuel
            })
    
    # GÃ©nÃ©rer PDF
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # DÃ©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame, onPage=doc.afterPage)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    
    # Header personnalisÃ© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        textColor=colors.HexColor('#DC2626'),
        spaceAfter=12,
        alignment=TA_CENTER
    )
    
    story.append(Paragraph("Rapport de CoÃ»ts Salariaux DÃ©taillÃ©s", title_style))
    story.append(Paragraph(f"PÃ©riode: {date_debut} au {date_fin}", styles['Normal']))
    story.append(Spacer(1, 0.3*inch))
    
    # RÃ©sumÃ©
    summary_data = [
        ["RÃ©sumÃ©", ""],
        ["CoÃ»t total", f"${cout_total:,.2f}"],
        ["Nombre d'employÃ©s", str(len(rapport))],
        ["Total heures", f"{sum([r['heures_travaillees'] for r in rapport])}h"]
    ]
    
    summary_table = Table(summary_data, colWidths=[2.5*inch, 2*inch])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#FCA5A5')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    
    story.append(summary_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Tableau dÃ©taillÃ©
    table_data = [["Nom", "Matricule", "Type", "Heures", "Taux/h", "CoÃ»t"]]
    for emp in rapport:
        table_data.append([
            emp["nom"],
            emp["matricule"],
            "TP" if emp["type_emploi"] == "temps_plein" else "TPa",
            f"{emp['heures_travaillees']}h",
            f"${emp['taux_horaire']}",
            f"${emp['cout_total']:,.2f}"
        ])
    
    detail_table = Table(table_data, colWidths=[1.8*inch, 1*inch, 0.7*inch, 0.8*inch, 0.8*inch, 1.2*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#FCA5A5')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
    ]))
    
    story.append(detail_table)
    doc.build(story)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=rapport_salaires_{date_debut}_{date_fin}.pdf"}
    )


@api_router.get("/{tenant_slug}/rapports/export-salaires-excel")
async def export_salaires_excel(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Export Excel du rapport coÃ»ts salariaux"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les donnÃ©es (mÃªme logique que PDF)
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    cout_total = 0
    
    for user in users:
        user_assignations = []
        for assignation in assignations:
            if assignation["user_id"] == user["id"] and "date" in assignation:
                try:
                    date_assign = datetime.fromisoformat(assignation["date"])
                    if date_debut_dt <= date_assign <= date_fin_dt:
                        user_assignations.append(assignation)
                except:
                    pass
        
        if len(user_assignations) > 0:
            heures_travaillees = len(user_assignations) * 8
            taux_horaire = user.get("taux_horaire", 0)
            cout_individuel = heures_travaillees * taux_horaire
            cout_total += cout_individuel
            
            rapport.append({
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "matricule": user.get("numero_employe", "N/A"),
                "type_emploi": user.get("type_emploi", "N/A"),
                "heures_travaillees": heures_travaillees,
                "taux_horaire": taux_horaire,
                "cout_total": cout_individuel
            })
    
    # GÃ©nÃ©rer Excel
    wb = Workbook()
    ws = wb.active
    ws.title = "CoÃ»ts Salariaux"
    
    # En-tÃªte
    ws['A1'] = f"Rapport de CoÃ»ts Salariaux - {date_debut} au {date_fin}"
    ws['A1'].font = Font(size=14, bold=True, color="DC2626")
    ws.merge_cells('A1:F1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # RÃ©sumÃ©
    ws['A3'] = "CoÃ»t Total"
    ws['B3'] = f"${cout_total:,.2f}"
    ws['C3'] = "EmployÃ©s"
    ws['D3'] = len(rapport)
    ws['E3'] = "Total Heures"
    ws['F3'] = f"{sum([r['heures_travaillees'] for r in rapport])}h"
    
    # Tableau
    headers = ["Nom", "Matricule", "Type", "Heures", "Taux/h", "CoÃ»t Total"]
    row = 5
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=row, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    for emp in rapport:
        row += 1
        ws.cell(row=row, column=1, value=emp["nom"])
        ws.cell(row=row, column=2, value=emp["matricule"])
        ws.cell(row=row, column=3, value=emp["type_emploi"])
        ws.cell(row=row, column=4, value=emp["heures_travaillees"])
        ws.cell(row=row, column=5, value=emp["taux_horaire"])
        ws.cell(row=row, column=6, value=emp["cout_total"])
    
    # Ajuster largeurs
    for col in ['A', 'B', 'C', 'D', 'E', 'F']:
        ws.column_dimensions[col].width = 18
    
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename=rapport_salaires_{date_debut}_{date_fin}.xlsx"}
    )


# ====================================================================
# DASHBOARD - MESSAGES IMPORTANTS ET ACTIVITÃ‰S
# ====================================================================

# MESSAGES IMPORTANTS
@api_router.post("/{tenant_slug}/dashboard/messages")
async def create_message_important(tenant_slug: str, message: MessageImportantCreate, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    message_dict = message.dict()
    message_dict["tenant_id"] = tenant.id
    message_dict["auteur_id"] = current_user.id
    message_dict["auteur_nom"] = f"{current_user.prenom} {current_user.nom}"
    message_obj = MessageImportant(**message_dict)
    await db.messages_importants.insert_one(message_obj.dict())
    return clean_mongo_doc(message_obj.dict())

@api_router.get("/{tenant_slug}/dashboard/messages")
async def get_messages_importants(tenant_slug: str, current_user: User = Depends(get_current_user)):
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer messages non expirÃ©s
    today = datetime.now(timezone.utc).date().isoformat()
    messages = await db.messages_importants.find({
        "tenant_id": tenant.id,
        "$or": [
            {"date_expiration": None},
            {"date_expiration": {"$gte": today}}
        ]
    }).sort("created_at", -1).to_list(100)
    
    return [clean_mongo_doc(m) for m in messages]

@api_router.delete("/{tenant_slug}/dashboard/messages/{message_id}")
async def delete_message_important(tenant_slug: str, message_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.messages_importants.delete_one({"id": message_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Message non trouvÃ©")
    
    return {"message": "Message supprimÃ©"}


# DASHBOARD DONNÃ‰ES COMPLÃˆTES
@api_router.get("/{tenant_slug}/dashboard/donnees-completes")
async def get_dashboard_donnees_completes(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Endpoint central pour toutes les donnÃ©es du dashboard"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Date du mois en cours
    today = datetime.now(timezone.utc)
    debut_mois = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    fin_mois = (debut_mois + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    debut_mois_prochain = fin_mois + timedelta(days=1)
    fin_mois_prochain = (debut_mois_prochain + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # RÃ©cupÃ©rer uniquement les donnÃ©es nÃ©cessaires avec filtres
    # Types de garde (petite collection, OK de tout charger)
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
    
    # Assignations du mois en cours UNIQUEMENT pour l'utilisateur
    mes_assignations_mois = await db.assignations.find({
        "tenant_id": tenant.id,
        "user_id": current_user.id,
        "date": {
            "$gte": debut_mois.isoformat(),
            "$lte": fin_mois.isoformat()
        }
    }).to_list(1000)
    
    # Inscriptions de l'utilisateur uniquement
    mes_inscriptions = await db.inscriptions_formations.find({
        "tenant_id": tenant.id,
        "user_id": current_user.id
    }).to_list(1000)
    
    # Formations pour les inscriptions + futures
    formation_ids = [i["formation_id"] for i in mes_inscriptions]
    formations = await db.formations.find({
        "tenant_id": tenant.id,
        "$or": [
            {"id": {"$in": formation_ids}},
            {"date_debut": {"$gte": today.isoformat()}}
        ]
    }).to_list(1000)
    
    # Pour section admin : charger donnÃ©es agrÃ©gÃ©es uniquement si nÃ©cessaire
    if current_user.role in ["admin", "superviseur"]:
        users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
        assignations = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": debut_mois.isoformat(),
                "$lte": fin_mois.isoformat()
            }
        }).to_list(5000)
        demandes_remplacement = await db.demandes_remplacement.find({"tenant_id": tenant.id}).to_list(1000)
    else:
        users = []
        assignations = mes_assignations_mois
        demandes_remplacement = []
    
    # CrÃ©er un mapping des types de garde pour accÃ¨s rapide
    type_garde_map = {t["id"]: t for t in types_garde}
    
    # VÃ©rifier si le tenant a au moins une garde externe
    has_garde_externe = any(t.get("est_garde_externe", False) for t in types_garde)
    
    # ===== SECTION PERSONNELLE =====
    # Heures travaillÃ©es ce mois (sÃ©parÃ© interne/externe)
    logger.info(f"ğŸ“Š Dashboard - User {current_user.email}: {len(mes_assignations_mois)} assignations trouvÃ©es")
    heures_mois_internes = 0
    heures_mois_externes = 0
    heures_mois_total = 0
    nombre_gardes_mois = 0
    for assignation in mes_assignations_mois:
        try:
            date_str = assignation["date"]
            logger.info(f"ğŸ“Š Traitement assignation - date: {date_str}, type: {type(date_str)}")
            
            # GÃ©rer les diffÃ©rents formats de date
            if isinstance(date_str, str):
                # Retirer le 'Z' et gÃ©rer le timezone
                date_str = date_str.replace('Z', '+00:00')
                if 'T' in date_str:
                    date_assign = datetime.fromisoformat(date_str)
                else:
                    # Format date simple YYYY-MM-DD
                    date_assign = datetime.fromisoformat(date_str + "T00:00:00").replace(tzinfo=timezone.utc)
            else:
                # Si c'est dÃ©jÃ  un datetime
                date_assign = date_str
            
            logger.info(f"ğŸ“Š Date parsÃ©e: {date_assign}, debut_mois: {debut_mois}, fin_mois: {fin_mois}")
            
            if debut_mois <= date_assign <= fin_mois:
                # RÃ©cupÃ©rer le type de garde pour calculer la durÃ©e exacte
                type_garde = type_garde_map.get(assignation.get("type_garde_id"))
                logger.info(f"ğŸ“Š Type garde trouvÃ©: {type_garde.get('nom') if type_garde else 'None'}")
                if type_garde:
                    duree = type_garde.get("duree_heures", 8)
                    if type_garde.get("est_garde_externe", False):
                        heures_mois_externes += duree
                    else:
                        heures_mois_internes += duree
                    heures_mois_total += duree
                    logger.info(f"ğŸ“Š Heures ajoutÃ©es: {duree}h (total: {heures_mois_total}h)")
                else:
                    # Fallback si type garde non trouvÃ©
                    heures_mois_internes += 8
                    heures_mois_total += 8
                    logger.info(f"ğŸ“Š Heures ajoutÃ©es (fallback): 8h (total: {heures_mois_total}h)")
                nombre_gardes_mois += 1
            else:
                logger.info(f"ğŸ“Š Date hors du mois en cours, ignorÃ©e")
        except Exception as e:
            logger.error(f"ğŸ“Š Erreur traitement assignation: {e}, assignation: {assignation}")
            pass
    
    # PrÃ©sence aux formations
    formations_passees = 0
    presences = 0
    for insc in mes_inscriptions:
        formation = next((f for f in formations if f["id"] == insc["formation_id"]), None)
        if formation:
            try:
                date_fin_formation = datetime.fromisoformat(formation["date_fin"]).date()
                if date_fin_formation < today.date():
                    formations_passees += 1
                    if insc.get("statut") == "present":
                        presences += 1
            except:
                pass
    
    pourcentage_presence_formations = round((presences / formations_passees * 100) if formations_passees > 0 else 0, 1)
    
    # Formations Ã  venir (toutes les formations futures Ã  partir d'aujourd'hui)
    formations_a_venir = []
    for formation in formations:
        try:
            if "date_debut" in formation and formation["date_debut"]:
                date_debut_formation = datetime.fromisoformat(formation["date_debut"].replace('Z', '+00:00'))
                # Inclure toutes les formations qui commencent aujourd'hui ou dans le futur
                if date_debut_formation.date() >= today.date():
                    # VÃ©rifier si inscrit
                    est_inscrit = any(i for i in mes_inscriptions if i["formation_id"] == formation["id"])
                    formations_a_venir.append({
                        "id": formation["id"],
                        "nom": formation["nom"],
                        "date_debut": formation["date_debut"],
                        "date_fin": formation["date_fin"],
                        "est_inscrit": est_inscrit
                    })
        except (ValueError, TypeError, AttributeError):
            # Ignorer les formations avec des dates invalides
            pass
    
    formations_a_venir.sort(key=lambda x: x["date_debut"])
    
    section_personnelle = {
        "heures_travaillees_mois": heures_mois_total,  # Total pour compatibilitÃ©
        "heures_internes_mois": heures_mois_internes,
        "heures_externes_mois": heures_mois_externes,
        "has_garde_externe": has_garde_externe,  # Indicateur si garde externe existe
        "nombre_gardes_mois": nombre_gardes_mois,
        "pourcentage_presence_formations": pourcentage_presence_formations,
        "formations_a_venir": formations_a_venir
    }
    
    # ===== SECTION GÃ‰NÃ‰RALE (Admin/Superviseur uniquement) =====
    section_generale = None
    if current_user.role in ["admin", "superviseur"]:
        # OPTIMISATION : Calculs simplifiÃ©s pour dashboard rapide
        # Compter assignations et statistiques avec agrÃ©gation MongoDB
        
        # Nombre total d'assignations du mois
        nb_assignations_mois = len(assignations)
        
        # Estimation rapide de couverture (Ã©viter boucles coÃ»teuses)
        # Personnel requis estimÃ© : types_garde Ã— jours_mois Ã— personnel moyen
        jours_mois = (fin_mois - debut_mois).days + 1
        personnel_moyen_par_garde = sum(t.get("personnel_requis", 1) for t in types_garde) / len(types_garde) if types_garde else 1
        total_personnel_requis_estime = len(types_garde) * jours_mois * personnel_moyen_par_garde * 0.7  # 70% des jours (moyenne)
        
        couverture_planning = round((nb_assignations_mois / total_personnel_requis_estime * 100), 1) if total_personnel_requis_estime > 0 else 0
        couverture_planning = min(couverture_planning, 100.0)  # Cap Ã  100%
        
        # Postes Ã  pourvoir estimÃ©s
        postes_a_pourvoir = max(0, int(total_personnel_requis_estime - nb_assignations_mois))
        
        # Demandes de congÃ© Ã  approuver (dÃ©jÃ  filtrÃ©es)
        demandes_en_attente = len([d for d in demandes_remplacement if d.get("statut") == "en_attente"])
        
        # Stats du mois - Utiliser les donnÃ©es dÃ©jÃ  chargÃ©es
        nb_formations_mois = await db.formations.count_documents({
            "tenant_id": tenant.id,
            "date_debut": {
                "$gte": debut_mois.isoformat(),
                "$lte": fin_mois.isoformat()
            }
        })
        
        nb_personnel_actif = await db.users.count_documents({
            "tenant_id": tenant.id,
            "statut": "Actif"
        })
        
        stats_mois = {
            "total_assignations": nb_assignations_mois,
            "total_personnel_actif": nb_personnel_actif,
            "formations_ce_mois": nb_formations_mois
        }
        
        section_generale = {
            "couverture_planning": couverture_planning,
            "postes_a_pourvoir": postes_a_pourvoir,  # RenommÃ© pour clartÃ©
            "demandes_conges_en_attente": demandes_en_attente,
            "statistiques_mois": stats_mois
        }
    
    # ===== ACTIVITÃ‰S RÃ‰CENTES (Filtrage selon le rÃ´le) =====
    activites_recentes = []
    
    # Filtrer selon le rÃ´le
    if current_user.role == "admin":
        # Admins voient tout (sauf paramÃ¨tres)
        activites = await db.activites.find({
            "tenant_id": tenant.id,
            "type_activite": {"$nin": ["parametres"]}  # Exclure les paramÃ¨tres
        }).sort("created_at", -1).limit(50).to_list(50)
        activites_recentes = [clean_mongo_doc(a) for a in activites]
    
    elif current_user.role in ["superviseur", "employe"]:
        # Superviseurs et employÃ©s voient :
        # - Formations crÃ©Ã©es
        # - Planning validÃ©/publiÃ©
        # - ActivitÃ©s les concernant directement
        # - Messages importants
        activites = await db.activites.find({
            "tenant_id": tenant.id,
            "$or": [
                {"type_activite": {"$in": ["formation_creation", "planning_publication", "message_important"]}},
                {"user_id": current_user.id},  # Leurs propres activitÃ©s
                {"data.concerne_user_id": current_user.id}  # ActivitÃ©s qui les concernent
            ]
        }).sort("created_at", -1).limit(30).to_list(30)
        activites_recentes = [clean_mongo_doc(a) for a in activites]
    
    return {
        "section_personnelle": section_personnelle,
        "section_generale": section_generale,
        "activites_recentes": activites_recentes
    }


# Fonction helper pour crÃ©er des activitÃ©s
async def creer_activite(
    tenant_id: str, 
    type_activite: str, 
    description: str, 
    user_id: Optional[str] = None, 
    user_nom: Optional[str] = None,
    data: Optional[dict] = None  # DonnÃ©es supplÃ©mentaires pour filtrage
):
    """Helper pour crÃ©er une activitÃ© dans le systÃ¨me avec auto-nettoyage aprÃ¨s 30 jours"""
    activite = Activite(
        tenant_id=tenant_id,
        type_activite=type_activite,
        description=description,
        user_id=user_id,
        user_nom=user_nom
    )
    
    activite_dict = activite.dict()
    if data:
        activite_dict["data"] = data  # Ajouter les donnÃ©es supplÃ©mentaires
    
    await db.activites.insert_one(activite_dict)
    
    # Nettoyage automatique des activitÃ©s > 30 jours
    date_limite = datetime.now(timezone.utc) - timedelta(days=30)
    await db.activites.delete_many({
        "tenant_id": tenant_id,
        "created_at": {"$lt": date_limite}
    })


# ====================================================================
# MODULE PERSONNEL - EXPORTS PDF/EXCEL
# ====================================================================

@api_router.get("/{tenant_slug}/personnel/export-pdf")
async def export_personnel_pdf(
    tenant_slug: str,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """Export PDF de la liste personnel ou d'un utilisateur individuel"""
    if current_user.role == "employe":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les utilisateurs
    if user_id:
        users_data = await db.users.find({"id": user_id, "tenant_id": tenant.id}).to_list(1)
    else:
        users_data = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    
    # GÃ©nÃ©rer PDF
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # DÃ©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame, onPage=doc.afterPage)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    
    # Header personnalisÃ© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        textColor=colors.HexColor('#DC2626'),
        spaceAfter=12,
        alignment=TA_CENTER
    )
    
    titre = "Fiche EmployÃ©" if user_id else "Liste du Personnel"
    story.append(Paragraph(titre, title_style))
    story.append(Spacer(1, 0.3*inch))
    
    if not user_id:
        # Statistiques globales
        total = len(users_data)
        actifs = len([u for u in users_data if u.get("statut") == "Actif"])
        temps_plein = len([u for u in users_data if u.get("type_emploi") == "temps_plein"])
        temps_partiel = len([u for u in users_data if u.get("type_emploi") == "temps_partiel"])
        
        stats_data = [
            ["Statistiques", ""],
            ["Total personnel", str(total)],
            ["Actifs", str(actifs)],
            ["Temps plein", str(temps_plein)],
            ["Temps partiel", str(temps_partiel)]
        ]
        
        stats_table = Table(stats_data, colWidths=[2.5*inch, 2*inch])
        stats_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#FCA5A5')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(stats_table)
        story.append(Spacer(1, 0.3*inch))
    
    # Tableau ou fiche individuelle
    if user_id and users_data:
        # Fiche individuelle dÃ©taillÃ©e
        user = users_data[0]
        fiche_data = [
            ["Nom complet", f"{user.get('prenom', '')} {user.get('nom', '')}"],
            ["Email", user.get("email", "N/A")],
            ["TÃ©lÃ©phone", user.get("telephone", "N/A")],
            ["Grade", user.get("grade", "N/A")],
            ["RÃ´le", user.get("role", "N/A")],
            ["Type emploi", user.get("type_emploi", "N/A")],
            ["Statut", user.get("statut", "N/A")],
            ["Taux horaire", f"${user.get('taux_horaire', 0)}/h"],
            ["Adresse", user.get("adresse", "N/A")]
        ]
        
        fiche_table = Table(fiche_data, colWidths=[2*inch, 4*inch])
        fiche_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#FCA5A5')),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('PADDING', (0, 0), (-1, -1), 8),
            ('BACKGROUND', (1, 0), (1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(fiche_table)
    else:
        # Liste complÃ¨te
        table_data = [["Nom", "Email", "Grade", "RÃ´le", "Type", "Statut"]]
        
        for user in users_data:
            table_data.append([
                f"{user.get('prenom', '')} {user.get('nom', '')}",
                user.get("email", "N/A"),
                user.get("grade", "N/A"),
                user.get("role", "N/A"),
                "TP" if user.get("type_emploi") == "temps_plein" else "TPa",
                user.get("statut", "N/A")
            ])
        
        detail_table = Table(table_data, colWidths=[1.5*inch, 1.5*inch, 1.2*inch, 1*inch, 0.6*inch, 0.8*inch])
        detail_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#FCA5A5')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
        ]))
        
        story.append(detail_table)
    
    doc.build(story)
    buffer.seek(0)
    
    filename = f"fiche_employe_{user_id}.pdf" if user_id else "liste_personnel.pdf"
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


@api_router.get("/{tenant_slug}/personnel/export-excel")
async def export_personnel_excel(
    tenant_slug: str,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """Export Excel de la liste personnel ou d'un utilisateur individuel"""
    if current_user.role == "employe":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les utilisateurs
    if user_id:
        users_data = await db.users.find({"id": user_id, "tenant_id": tenant.id}).to_list(1)
    else:
        users_data = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    
    # GÃ©nÃ©rer Excel
    wb = Workbook()
    ws = wb.active
    ws.title = "Personnel"
    
    # En-tÃªte
    titre = "Fiche EmployÃ©" if user_id else "Liste du Personnel"
    ws['A1'] = titre
    ws['A1'].font = Font(size=14, bold=True, color="DC2626")
    ws.merge_cells('A1:F1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    if not user_id:
        # Stats
        total = len(users_data)
        actifs = len([u for u in users_data if u.get("statut") == "Actif"])
        
        ws['A3'] = "Total personnel"
        ws['B3'] = total
        ws['A4'] = "Personnel actif"
        ws['B4'] = actifs
        
        # Tableau
        headers = ["Nom", "PrÃ©nom", "Email", "Grade", "RÃ´le", "Type", "Statut", "TÃ©lÃ©phone"]
        row = 6
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
            cell.alignment = Alignment(horizontal='center')
        
        for user in users_data:
            row += 1
            ws.cell(row=row, column=1, value=user.get("nom", ""))
            ws.cell(row=row, column=2, value=user.get("prenom", ""))
            ws.cell(row=row, column=3, value=user.get("email", ""))
            ws.cell(row=row, column=4, value=user.get("grade", ""))
            ws.cell(row=row, column=5, value=user.get("role", ""))
            ws.cell(row=row, column=6, value=user.get("type_emploi", ""))
            ws.cell(row=row, column=7, value=user.get("statut", ""))
            ws.cell(row=row, column=8, value=user.get("telephone", ""))
    else:
        # Fiche individuelle
        if users_data:
            user = users_data[0]
            row = 3
            fields = [
                ("Nom", user.get("nom", "")),
                ("PrÃ©nom", user.get("prenom", "")),
                ("Email", user.get("email", "")),
                ("TÃ©lÃ©phone", user.get("telephone", "")),
                ("Grade", user.get("grade", "")),
                ("RÃ´le", user.get("role", "")),
                ("Type emploi", user.get("type_emploi", "")),
                ("Statut", user.get("statut", "")),
                ("Adresse", user.get("adresse", ""))
            ]
            
            for field, value in fields:
                ws.cell(row=row, column=1, value=field).font = Font(bold=True)
                ws.cell(row=row, column=2, value=value)
                row += 1
    
    # Ajuster largeurs
    for col in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']:
        ws.column_dimensions[col].width = 18
    
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    filename = f"fiche_employe_{user_id}.xlsx" if user_id else "liste_personnel.xlsx"
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


# Sessions de formation routes
@api_router.post("/{tenant_slug}/sessions-formation", response_model=SessionFormation)
async def create_session_formation(tenant_slug: str, session: SessionFormationCreate, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    session_dict = session.dict()
    session_dict["tenant_id"] = tenant.id
    session_obj = SessionFormation(**session_dict)
    await db.sessions_formation.insert_one(session_obj.dict())
    return session_obj

@api_router.get("/{tenant_slug}/sessions-formation", response_model=List[SessionFormation])
async def get_sessions_formation(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    sessions = await db.sessions_formation.find({"tenant_id": tenant.id}).to_list(1000)
    cleaned_sessions = [clean_mongo_doc(session) for session in sessions]
    return [SessionFormation(**session) for session in cleaned_sessions]

@api_router.post("/{tenant_slug}/sessions-formation/{session_id}/inscription")
async def inscrire_formation(tenant_slug: str, session_id: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que la session existe dans ce tenant
    session = await db.sessions_formation.find_one({"id": session_id, "tenant_id": tenant.id})
    if not session:
        raise HTTPException(status_code=404, detail="Session de formation non trouvÃ©e")
    
    # VÃ©rifier si dÃ©jÃ  inscrit
    if current_user.id in session.get("participants", []):
        raise HTTPException(status_code=400, detail="Vous Ãªtes dÃ©jÃ  inscrit Ã  cette formation")
    
    # VÃ©rifier les places disponibles
    if len(session.get("participants", [])) >= session.get("places_max", 20):
        raise HTTPException(status_code=400, detail="Formation complÃ¨te - Plus de places disponibles")
    
    # Ajouter l'utilisateur aux participants
    await db.sessions_formation.update_one(
        {"id": session_id, "tenant_id": tenant.id},
        {"$push": {"participants": current_user.id}}
    )
    
    # CrÃ©er l'inscription
    inscription_dict = {
        "tenant_id": tenant.id,
        "session_id": session_id,
        "user_id": current_user.id
    }
    inscription_obj = InscriptionFormation(**inscription_dict)
    await db.inscriptions_formation.insert_one(inscription_obj.dict())
    
    return {"message": "Inscription rÃ©ussie", "session_id": session_id}

@api_router.delete("/{tenant_slug}/sessions-formation/{session_id}/desinscription")
async def desinscrire_formation(tenant_slug: str, session_id: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que la session existe dans ce tenant
    session = await db.sessions_formation.find_one({"id": session_id, "tenant_id": tenant.id})
    if not session:
        raise HTTPException(status_code=404, detail="Session de formation non trouvÃ©e")
    
    # VÃ©rifier si inscrit
    if current_user.id not in session.get("participants", []):
        raise HTTPException(status_code=400, detail="Vous n'Ãªtes pas inscrit Ã  cette formation")
    
    # Retirer l'utilisateur des participants
    await db.sessions_formation.update_one(
        {"id": session_id, "tenant_id": tenant.id},
        {"$pull": {"participants": current_user.id}}
    )
    
    # Supprimer l'inscription
    await db.inscriptions_formation.delete_one({
        "session_id": session_id,
        "user_id": current_user.id,
        "tenant_id": tenant.id
    })
    
    return {"message": "DÃ©sinscription rÃ©ussie", "session_id": session_id}

# ==================== GESTION DES CONFLITS DISPONIBILITÃ‰S/INDISPONIBILITÃ‰S ====================

async def detect_conflicts(tenant_id: str, user_id: str, date: str, heure_debut: str, 
                          heure_fin: str, type_garde_id: Optional[str], 
                          element_type: str) -> List[Dict[str, Any]]:
    """
    DÃ©tecte les conflits entre disponibilitÃ©s/indisponibilitÃ©s
    
    DÃ©tecte 3 types de conflits:
    1. DisponibilitÃ© â†” IndisponibilitÃ© (incompatible)
    2. DisponibilitÃ© â†” DisponibilitÃ© avec horaires diffÃ©rents (peut fusionner)
    3. IndisponibilitÃ© â†” IndisponibilitÃ© (peut fusionner)
    
    Args:
        tenant_id: ID du tenant
        user_id: ID de l'utilisateur
        date: Date au format YYYY-MM-DD
        heure_debut: Heure de dÃ©but (HH:MM)
        heure_fin: Heure de fin (HH:MM)
        type_garde_id: ID du type de garde (optionnel)
        element_type: "disponibilite" ou "indisponibilite"
        
    Returns:
        Liste des conflits avec dÃ©tails et type (incompatible/mergeable)
    """
    from datetime import datetime
    
    conflicts = []
    
    # NOUVELLE LOGIQUE: Chercher TOUS les Ã©lÃ©ments du mÃªme jour (pas seulement l'opposÃ©)
    # On filtrera aprÃ¨s pour dÃ©terminer si c'est incompatible ou fusionnable
    existing_entries = await db.disponibilites.find({
        "tenant_id": tenant_id,
        "user_id": user_id,
        "date": date
    }).to_list(length=None)
    
    # Convertir les heures en minutes pour comparaison
    def time_to_minutes(time_str):
        h, m = map(int, time_str.split(':'))
        return h * 60 + m
    
    new_start = time_to_minutes(heure_debut)
    new_end = time_to_minutes(heure_fin)
    
    # RÃ©cupÃ©rer les types de garde pour affichage
    types_garde_map = {}
    types_garde_list = await db.types_garde.find({"tenant_id": tenant_id}).to_list(length=None)
    for tg in types_garde_list:
        types_garde_map[tg["id"]] = tg.get("nom", "N/A")
    
    for entry in existing_entries:
        existing_start = time_to_minutes(entry["heure_debut"])
        existing_end = time_to_minutes(entry["heure_fin"])
        
        # VÃ©rifier le chevauchement
        if not (new_end <= existing_start or new_start >= existing_end):
            # Il y a chevauchement
            overlap_start = max(new_start, existing_start)
            overlap_end = min(new_end, existing_end)
            
            # Convertir retour en HH:MM
            def minutes_to_time(minutes):
                h = minutes // 60
                m = minutes % 60
                return f"{h:02d}:{m:02d}"
            
            # DÃ©terminer le type de conflit
            is_same_type = entry["statut"] == element_type
            
            # VÃ©rifier si c'est une couverture complÃ¨te (fusionnable)
            is_covered = (existing_start <= new_start and existing_end >= new_end)
            
            conflict_detail = {
                "conflict_id": entry["id"],
                "conflict_type": entry["statut"],
                "date": entry["date"],
                "heure_debut": entry["heure_debut"],
                "heure_fin": entry["heure_fin"],
                "type_garde_id": entry.get("type_garde_id"),
                "type_garde_nom": types_garde_map.get(entry.get("type_garde_id"), "Tous types"),
                "statut": entry["statut"],
                "overlap_start": minutes_to_time(overlap_start),
                "overlap_end": minutes_to_time(overlap_end),
                "origine": entry.get("origine", "manuelle"),
                "conflict_severity": "compatible_covered" if (is_same_type and is_covered) else ("compatible_overlap" if is_same_type else "incompatible")
            }
            
            # Ajouter un message descriptif
            if is_same_type and is_covered:
                conflict_detail["message"] = "Cette plage horaire est dÃ©jÃ  couverte par une entrÃ©e existante."
            elif is_same_type:
                conflict_detail["message"] = f"Chevauchement avec une autre {element_type}. Fusion automatique possible."
            else:
                action = "disponibilitÃ©" if element_type == "disponibilite" else "indisponibilitÃ©"
                conflict = "indisponibilitÃ©" if entry["statut"] == "indisponible" else "disponibilitÃ©"
                conflict_detail["message"] = f"Incompatible: Vous essayez d'ajouter une {action} alors qu'une {conflict} existe dÃ©jÃ ."
            
            conflicts.append(conflict_detail)
    
    return conflicts

# DisponibilitÃ©s routes
@api_router.post("/{tenant_slug}/disponibilites", response_model=Disponibilite)
async def create_disponibilite(
    tenant_slug: str, 
    disponibilite: DisponibiliteCreate, 
    force: bool = False,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une disponibilitÃ© avec dÃ©tection de conflits"""
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # DÃ©tecter les conflits si force=False
    if not force:
        conflicts = await detect_conflicts(
            tenant_id=tenant.id,
            user_id=disponibilite.user_id,
            date=disponibilite.date,
            heure_debut=disponibilite.heure_debut,
            heure_fin=disponibilite.heure_fin,
            type_garde_id=disponibilite.type_garde_id,
            element_type="disponibilite"
        )
        
        if conflicts:
            # SÃ©parer les conflits incompatibles des compatibles
            incompatible_conflicts = [c for c in conflicts if c.get("conflict_severity") == "incompatible"]
            compatible_conflicts = [c for c in conflicts if c.get("conflict_severity") in ["compatible_overlap", "compatible_covered"]]
            
            # Si conflit couvert complÃ¨tement, ne rien crÃ©er (dÃ©jÃ  existe)
            if any(c.get("conflict_severity") == "compatible_covered" for c in conflicts):
                raise HTTPException(
                    status_code=409,
                    detail={
                        "message": "Cette disponibilitÃ© est dÃ©jÃ  couverte par une entrÃ©e existante",
                        "conflicts": compatible_conflicts,
                        "new_item": disponibilite.dict(),
                        "action_required": "none"  # Aucune action nÃ©cessaire
                    }
                )
            
            # Si conflits incompatibles (dispo vs indispo), demander confirmation
            if incompatible_conflicts:
                raise HTTPException(
                    status_code=409,
                    detail={
                        "message": "Conflits incompatibles dÃ©tectÃ©s",
                        "conflicts": incompatible_conflicts,
                        "new_item": disponibilite.dict(),
                        "action_required": "choose"  # L'utilisateur doit choisir
                    }
                )
            
            # Si seulement des conflits compatibles (chevauchement dispo-dispo), proposer fusion
            if compatible_conflicts:
                raise HTTPException(
                    status_code=409,
                    detail={
                        "message": "Chevauchement dÃ©tectÃ© - Fusion possible",
                        "conflicts": compatible_conflicts,
                        "new_item": disponibilite.dict(),
                        "action_required": "merge"  # Proposer la fusion automatique
                    }
                )
    
    # CrÃ©er la disponibilitÃ©
    dispo_dict = disponibilite.dict()
    dispo_dict["tenant_id"] = tenant.id
    disponibilite_obj = Disponibilite(**dispo_dict)
    await db.disponibilites.insert_one(disponibilite_obj.dict())
    
    # CrÃ©er une activitÃ© (seulement si l'utilisateur modifie ses propres disponibilitÃ©s)
    if disponibilite.user_id == current_user.id:
        statut_text = "disponible" if disponibilite.statut == "disponible" else "indisponible"
        type_garde = await db.types_garde.find_one({"id": disponibilite.type_garde_id, "tenant_id": tenant.id})
        garde_text = f" pour la garde '{type_garde['nom']}'" if type_garde else ""
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="disponibilite_ajout",
            description=f"ğŸ“… {current_user.prenom} {current_user.nom} s'est dÃ©clarÃ©(e) {statut_text}{garde_text} le {disponibilite.date}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": current_user.id}
        )
    
    return disponibilite_obj

@api_router.get("/{tenant_slug}/disponibilites/{user_id}", response_model=List[Disponibilite])
async def get_user_disponibilites(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    disponibilites = await db.disponibilites.find({
        "user_id": user_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    cleaned_disponibilites = [clean_mongo_doc(dispo) for dispo in disponibilites]
    return [Disponibilite(**dispo) for dispo in cleaned_disponibilites]

@api_router.post("/{tenant_slug}/disponibilites/resolve-conflict")
async def resolve_disponibilite_conflict(
    tenant_slug: str,
    data: Dict[str, Any] = Body(...),
    current_user: User = Depends(get_current_user)
):
    """
    RÃ©sout un conflit lors de la crÃ©ation d'une disponibilitÃ©
    
    Actions possibles:
    - supprimer_conflits: Supprime les indisponibilitÃ©s en conflit et crÃ©e la disponibilitÃ©
    - creer_quand_meme: CrÃ©e la disponibilitÃ© sans supprimer les conflits
    - annuler: Ne fait rien
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    action = data.get("action")  # "supprimer_conflits", "creer_quand_meme", "annuler"
    new_item_data = data.get("new_item")
    conflict_ids = data.get("conflict_ids", [])
    
    if action == "annuler":
        return {"message": "OpÃ©ration annulÃ©e", "action": "annuler"}
    
    # RÃ©cupÃ©rer les dÃ©tails des conflits avant suppression pour l'historique
    conflicts_to_delete = []
    if action == "supprimer_conflits" and conflict_ids:
        for conflict_id in conflict_ids:
            conflict_doc = await db.disponibilites.find_one({"id": conflict_id, "tenant_id": tenant.id})
            if conflict_doc:
                conflicts_to_delete.append(conflict_doc)
        
        # Supprimer les conflits
        await db.disponibilites.delete_many({
            "id": {"$in": conflict_ids},
            "tenant_id": tenant.id
        })
        
        # Notifier l'utilisateur affectÃ© si diffÃ©rent de l'utilisateur courant
        affected_user_id = new_item_data.get("user_id")
        if affected_user_id != current_user.id:
            notification = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant.id,
                "user_id": affected_user_id,
                "titre": "IndisponibilitÃ©s modifiÃ©es",
                "message": f"{len(conflict_ids)} indisponibilitÃ©(s) supprimÃ©e(s) en raison d'un conflit avec une nouvelle disponibilitÃ©",
                "type": "disponibilite",
                "lue": False,
                "created_at": datetime.now(timezone.utc).isoformat()
            }
            await db.notifications.insert_one(notification)
    
    # CrÃ©er la disponibilitÃ©
    dispo_dict = new_item_data.copy()
    dispo_dict["tenant_id"] = tenant.id
    dispo_dict["id"] = str(uuid.uuid4())
    dispo_dict["created_at"] = datetime.now(timezone.utc).isoformat()
    
    await db.disponibilites.insert_one(dispo_dict)
    
    # Enregistrer dans l'historique
    resolution = ConflictResolution(
        tenant_id=tenant.id,
        user_id=current_user.id,
        affected_user_id=new_item_data.get("user_id"),
        action=action,
        type_created="disponibilite",
        conflicts_deleted=conflicts_to_delete,
        created_item=dispo_dict
    )
    await db.conflict_resolutions.insert_one(resolution.dict())
    
    return {
        "message": f"DisponibilitÃ© crÃ©Ã©e avec succÃ¨s. Action: {action}",
        "action": action,
        "conflicts_deleted": len(conflicts_to_delete),
        "created_item": dispo_dict
    }

@api_router.put("/{tenant_slug}/disponibilites/{user_id}")
async def update_user_disponibilites(tenant_slug: str, user_id: str, disponibilites: List[DisponibiliteCreate], current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Delete existing disponibilitÃ©s for this user dans ce tenant
    await db.disponibilites.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    
    # Insert new disponibilitÃ©s
    if disponibilites:
        dispo_docs = []
        for dispo in disponibilites:
            dispo_dict = dispo.dict()
            dispo_dict["tenant_id"] = tenant.id
            dispo_obj = Disponibilite(**dispo_dict)
            dispo_docs.append(dispo_obj.dict())
        
        await db.disponibilites.insert_many(dispo_docs)
    
    return {"message": f"DisponibilitÃ©s mises Ã  jour avec succÃ¨s ({len(disponibilites)} entrÃ©es)"}


@api_router.post("/{tenant_slug}/disponibilites/import-csv")
async def import_disponibilites_csv(
    tenant_slug: str,
    disponibilites_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse de disponibilitÃ©s depuis un CSV/XLS"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    disponibilites = disponibilites_data.get("disponibilites", [])
    if not disponibilites:
        raise HTTPException(status_code=400, detail="Aucune disponibilitÃ© Ã  importer")
    
    results = {
        "total": len(disponibilites),
        "created": 0,
        "updated": 0,
        "errors": [],
        "skipped": 0
    }
    
    # PrÃ©charger les utilisateurs et types de garde pour optimisation
    users_list = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    users_by_num = {u.get("numero_employe"): u for u in users_list if u.get("numero_employe")}
    users_by_name = create_user_matching_index(users_list)
    
    types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(100)
    types_garde_by_name = {tg.get("nom", "").strip().lower(): tg for tg in types_garde_list}
    
    for index, dispo_data in enumerate(disponibilites):
        try:
            # 1. Trouver l'utilisateur avec matching intelligent
            employe_str = dispo_data.get("EmployÃ©", "").strip()
            if not employe_str:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": "EmployÃ© manquant"
                })
                continue
            
            # Utiliser la fonction de matching intelligent
            user_obj = find_user_intelligent(
                search_string=employe_str,
                users_by_name=users_by_name,
                users_by_num=users_by_num,
                numero_field="numero_employe"
            )
            
            if not user_obj:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"EmployÃ© non trouvÃ©: {employe_str}"
                })
                continue
            
            # 2. Parser les dates/heures
            debut_str = str(dispo_data.get("DÃ©but", "")).strip()
            fin_str = str(dispo_data.get("Fin", "")).strip()
            
            if not debut_str or not fin_str:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": "Date/heure de dÃ©but ou fin manquante"
                })
                continue
            
            try:
                # Parser les dates/heures (format: "2025-12-01 06:00")
                from datetime import datetime as dt
                debut_dt = dt.strptime(debut_str, "%Y-%m-%d %H:%M")
                fin_dt = dt.strptime(fin_str, "%Y-%m-%d %H:%M")
                
                date_str = debut_dt.strftime("%Y-%m-%d")
                heure_debut = debut_dt.strftime("%H:%M")
                heure_fin = fin_dt.strftime("%H:%M")
                
            except ValueError as e:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"Format de date/heure invalide: {e}"
                })
                continue
            
            # 3. Mapper la sÃ©lection au statut
            selection = dispo_data.get("SÃ©lection", "").strip().lower()
            
            # Si "Aucune", ignorer cette ligne (ne pas crÃ©er de disponibilitÃ©)
            if selection == "aucune" or not selection:
                results["skipped"] += 1
                continue
            
            # Seulement crÃ©er une disponibilitÃ© si "Disponible"
            if selection != "disponible":
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"SÃ©lection invalide: '{selection}'. Attendu: 'Disponible' ou 'Aucune'"
                })
                continue
            
            statut = "disponible"
            
            # 4. Trouver le type de garde (optionnel)
            type_garde_id = None
            quart_str = dispo_data.get("Quart", "").strip().lower()
            if quart_str:
                type_garde_obj = types_garde_by_name.get(quart_str)
                if type_garde_obj:
                    type_garde_id = type_garde_obj.get("id")
            
            # 5. VÃ©rifier si une disponibilitÃ© existe dÃ©jÃ 
            existing = await db.disponibilites.find_one({
                "tenant_id": tenant.id,
                "user_id": user_obj["id"],
                "date": date_str,
                "heure_debut": heure_debut,
                "heure_fin": heure_fin
            })
            
            dispo_obj = Disponibilite(
                tenant_id=tenant.id,
                user_id=user_obj["id"],
                date=date_str,
                heure_debut=heure_debut,
                heure_fin=heure_fin,
                statut=statut,
                type_garde_id=type_garde_id,
                origine="import_csv"
            )
            
            if existing:
                # Mettre Ã  jour
                await db.disponibilites.update_one(
                    {"id": existing["id"]},
                    {"$set": dispo_obj.dict()}
                )
                results["updated"] += 1
            else:
                # CrÃ©er nouveau
                await db.disponibilites.insert_one(dispo_obj.dict())
                results["created"] += 1
                
        except Exception as e:
            results["errors"].append({
                "ligne": index + 2,
                "erreur": str(e)
            })
    
    # CrÃ©er une activitÃ©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="import_disponibilites",
        description=f"ğŸ“Š {current_user.prenom} {current_user.nom} a importÃ© {results['created'] + results['updated']} disponibilitÃ©s ({results['created']} crÃ©Ã©es, {results['updated']} mises Ã  jour, {results['skipped']} ignorÃ©es)",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return results


# ===== EXPORTS DISPONIBILITES =====

@api_router.get("/{tenant_slug}/disponibilites/export-pdf")
async def export_disponibilites_pdf(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des disponibilitÃ©s en PDF"""
    try:
        from reportlab.lib.pagesizes import letter
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer les disponibilitÃ©s
        if user_id:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id,
                "user_id": user_id
            }).to_list(length=None)
            users_list = [await db.users.find_one({"id": user_id, "tenant_id": tenant.id})]
        else:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id
            }).to_list(length=None)
            users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        
        # CrÃ©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(tenant, pagesize=letter)
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Titre
        titre = "DisponibilitÃ©s du Personnel Temps Partiel"
        if user_id and user_id in users_map:
            titre = f"DisponibilitÃ©s de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        
        elements.append(Paragraph(titre, modern_styles['title']))
        elements.append(Spacer(1, 0.3*inch))
        
        # Construire le tableau
        table_data = [['Date', 'Heure DÃ©but', 'Heure Fin', 'Statut', 'Type Garde', 'Pompier']]
        
        for dispo in sorted(disponibilites_list, key=lambda x: x.get('date', '')):
            user = users_map.get(dispo['user_id'], {})
            pompier_nom = f"{user.get('prenom', '')} {user.get('nom', '')}" if user else "N/A"
            
            statut_fr = {
                'disponible': 'Disponible',
                'indisponible': 'Indisponible',
                'conge': 'CongÃ©'
            }.get(dispo.get('statut', ''), dispo.get('statut', ''))
            
            table_data.append([
                dispo.get('date', 'N/A'),
                dispo.get('heure_debut', 'N/A'),
                dispo.get('heure_fin', 'N/A'),
                statut_fr,
                dispo.get('type_garde_id', 'Tous') if dispo.get('type_garde_id') else 'Tous',
                pompier_nom if not user_id else ''
            ])
        
        # Si pas de user_id, afficher la colonne pompier, sinon la cacher
        if user_id:
            table_data = [[row[i] for i in range(5)] for row in table_data]
        
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('TOPPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        elements.append(table)
        doc.build(elements)
        buffer.seek(0)
        
        filename = f"disponibilites_{user_id if user_id else 'tous'}.pdf"
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/disponibilites/export-excel")
async def export_disponibilites_excel(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des disponibilitÃ©s en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer les disponibilitÃ©s
        if user_id:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id,
                "user_id": user_id
            }).to_list(length=None)
            users_list = [await db.users.find_one({"id": user_id, "tenant_id": tenant.id})]
        else:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id
            }).to_list(length=None)
            users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        
        # CrÃ©er le workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "DisponibilitÃ©s"
        
        # Styles
        header_fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        center_alignment = Alignment(horizontal="center", vertical="center")
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        # Titre
        ws.merge_cells('A1:F1')
        titre = "DisponibilitÃ©s du Personnel Temps Partiel"
        if user_id and user_id in users_map:
            titre = f"DisponibilitÃ©s de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        ws['A1'] = titre
        ws['A1'].font = Font(bold=True, size=16, color="EF4444")
        ws['A1'].alignment = center_alignment
        
        # En-tÃªtes
        row = 3
        if user_id:
            headers = ['Date', 'Heure DÃ©but', 'Heure Fin', 'Statut', 'Type Garde']
        else:
            headers = ['Date', 'Heure DÃ©but', 'Heure Fin', 'Statut', 'Type Garde', 'Pompier']
        
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = center_alignment
            cell.border = border
        
        # DonnÃ©es
        row += 1
        for dispo in sorted(disponibilites_list, key=lambda x: x.get('date', '')):
            user = users_map.get(dispo['user_id'], {})
            pompier_nom = f"{user.get('prenom', '')} {user.get('nom', '')}" if user else "N/A"
            
            statut_fr = {
                'disponible': 'Disponible',
                'indisponible': 'Indisponible',
                'conge': 'CongÃ©'
            }.get(dispo.get('statut', ''), dispo.get('statut', ''))
            
            ws.cell(row=row, column=1, value=dispo.get('date', 'N/A'))
            ws.cell(row=row, column=2, value=dispo.get('heure_debut', 'N/A'))
            ws.cell(row=row, column=3, value=dispo.get('heure_fin', 'N/A'))
            status_cell = ws.cell(row=row, column=4, value=statut_fr)
            ws.cell(row=row, column=5, value=dispo.get('type_garde_id', 'Tous') if dispo.get('type_garde_id') else 'Tous')
            
            if not user_id:
                ws.cell(row=row, column=6, value=pompier_nom)
            
            # Couleur statut
            if dispo.get('statut') == 'disponible':
                status_cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
            elif dispo.get('statut') == 'indisponible':
                status_cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
            else:
                status_cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
            
            for col in range(1, len(headers) + 1):
                ws.cell(row=row, column=col).border = border
                ws.cell(row=row, column=col).alignment = center_alignment
            
            row += 1
        
        # Ajuster les largeurs de colonnes
        for col in ws.columns:
            max_length = 0
            column = col[0].column_letter
            for cell in col:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column].width = adjusted_width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        filename = f"disponibilites_{user_id if user_id else 'tous'}.xlsx"
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")


@api_router.delete("/{tenant_slug}/disponibilites/reinitialiser")
async def reinitialiser_disponibilites(
    tenant_slug: str,
    reinit_data: DisponibiliteReinitialiser,
    current_user: User = Depends(get_current_user)
):
    """
    RÃ©initialise les disponibilitÃ©s/indisponibilitÃ©s pour une pÃ©riode donnÃ©e
    """
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier les permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.id != reinit_data.user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Calculer les dates de dÃ©but et fin selon la pÃ©riode
        today = datetime.now(timezone.utc).date()
        
        if reinit_data.periode == "semaine":
            # Semaine courante : lundi Ã  dimanche
            days_since_monday = today.weekday()  # 0 = lundi, 6 = dimanche
            date_debut = today - timedelta(days=days_since_monday)
            date_fin = date_debut + timedelta(days=6)
        elif reinit_data.periode == "mois":
            # Mois courant : 1er du mois Ã  dernier jour
            date_debut = today.replace(day=1)
            # Dernier jour du mois
            if today.month == 12:
                date_fin = today.replace(day=31)
            else:
                next_month = today.replace(month=today.month + 1, day=1)
                date_fin = next_month - timedelta(days=1)
        elif reinit_data.periode == "mois_prochain":
            # Mois prochain : 1er du mois prochain Ã  dernier jour du mois prochain
            if today.month == 12:
                # Si on est en dÃ©cembre, mois prochain = janvier de l'annÃ©e suivante
                date_debut = today.replace(year=today.year + 1, month=1, day=1)
                next_next_month = date_debut.replace(month=2, day=1)
                date_fin = next_next_month - timedelta(days=1)
            else:
                # Mois prochain
                date_debut = today.replace(month=today.month + 1, day=1)
                # Dernier jour du mois prochain
                if today.month == 11:
                    # Si on est en novembre, mois prochain = dÃ©cembre
                    date_fin = date_debut.replace(day=31)
                else:
                    next_next_month = today.replace(month=today.month + 2, day=1)
                    date_fin = next_next_month - timedelta(days=1)
        elif reinit_data.periode == "annee":
            # AnnÃ©e courante : 1er janvier Ã  31 dÃ©cembre
            date_debut = today.replace(month=1, day=1)
            date_fin = today.replace(month=12, day=31)
        elif reinit_data.periode == "personnalisee":
            # PÃ©riode personnalisÃ©e : dates fournies
            if not reinit_data.date_debut or not reinit_data.date_fin:
                raise HTTPException(
                    status_code=400,
                    detail="date_debut et date_fin sont requis pour une pÃ©riode personnalisÃ©e"
                )
            try:
                date_debut = datetime.fromisoformat(reinit_data.date_debut).date()
                date_fin = datetime.fromisoformat(reinit_data.date_fin).date()
                
                # Validation : date_debut <= date_fin
                if date_debut > date_fin:
                    raise HTTPException(
                        status_code=400,
                        detail="date_debut doit Ãªtre avant ou Ã©gale Ã  date_fin"
                    )
                
                # Validation : plage maximale de 1 an
                if (date_fin - date_debut).days > 365:
                    raise HTTPException(
                        status_code=400,
                        detail="La plage de dates ne peut pas dÃ©passer 1 an"
                    )
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail="Format de date invalide. Utilisez YYYY-MM-DD"
                )
        else:
            raise HTTPException(
                status_code=400,
                detail="periode doit Ãªtre 'semaine', 'mois', 'mois_prochain', 'annee' ou 'personnalisee'"
            )
        
        # Construire la requÃªte de suppression
        delete_query = {
            "user_id": reinit_data.user_id,
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut.isoformat(),
                "$lte": date_fin.isoformat()
            }
        }
        
        # Filtre par type d'entrÃ©e (disponibilitÃ©s/indisponibilitÃ©s)
        if reinit_data.type_entree == "disponibilites":
            delete_query["statut"] = "disponible"
        elif reinit_data.type_entree == "indisponibilites":
            delete_query["statut"] = "indisponible"
        elif reinit_data.type_entree != "les_deux":
            raise HTTPException(
                status_code=400,
                detail="type_entree doit Ãªtre 'disponibilites', 'indisponibilites' ou 'les_deux'"
            )
        
        # Si mode "generees_seulement", ne supprimer que les entrÃ©es gÃ©nÃ©rÃ©es automatiquement
        if reinit_data.mode == "generees_seulement":
            # Supprimer uniquement celles avec origine diffÃ©rente de "manuelle"
            # ET qui ont un champ origine (pour gÃ©rer les anciennes entrÃ©es)
            delete_query["$or"] = [
                {"origine": {"$exists": True, "$ne": "manuelle"}},
                {"origine": {"$exists": False}}  # Anciennes entrÃ©es sans champ origine
            ]
        elif reinit_data.mode != "tout":
            raise HTTPException(
                status_code=400,
                detail="mode doit Ãªtre 'tout' ou 'generees_seulement'"
            )
        
        # Supprimer les disponibilitÃ©s
        result = await db.disponibilites.delete_many(delete_query)
        
        return {
            "message": "RÃ©initialisation effectuÃ©e avec succÃ¨s",
            "periode": reinit_data.periode,
            "mode": reinit_data.mode,
            "date_debut": date_debut.isoformat(),
            "date_fin": date_fin.isoformat(),
            "nombre_supprimees": result.deleted_count
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur lors de la rÃ©initialisation: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la rÃ©initialisation: {str(e)}")

@api_router.delete("/{tenant_slug}/disponibilites/{disponibilite_id}")
async def delete_disponibilite(tenant_slug: str, disponibilite_id: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Find the disponibilitÃ© to check ownership dans ce tenant
    disponibilite = await db.disponibilites.find_one({
        "id": disponibilite_id,
        "tenant_id": tenant.id
    })
    if not disponibilite:
        raise HTTPException(status_code=404, detail="DisponibilitÃ© non trouvÃ©e")
    
    if current_user.role not in ["admin", "superviseur"] and current_user.id != disponibilite["user_id"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    result = await db.disponibilites.delete_one({
        "id": disponibilite_id,
        "tenant_id": tenant.id
    })
    if result.deleted_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de supprimer la disponibilitÃ©")
    
    # CrÃ©er une activitÃ© (seulement si l'utilisateur supprime ses propres disponibilitÃ©s)
    if disponibilite["user_id"] == current_user.id:
        statut_text = "disponibilitÃ©" if disponibilite["statut"] == "disponible" else "indisponibilitÃ©"
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="disponibilite_suppression",
            description=f"ğŸ—‘ï¸ {current_user.prenom} {current_user.nom} a supprimÃ© une {statut_text} du {disponibilite['date']}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": current_user.id}
        )
    
    return {"message": "DisponibilitÃ© supprimÃ©e avec succÃ¨s"}

# ==================== PUSH NOTIFICATIONS ROUTES ====================

@api_router.post("/{tenant_slug}/notifications/register-device")
async def register_device_token(
    tenant_slug: str,
    device_data: DeviceTokenRegister,
    current_user: User = Depends(get_current_user)
):
    """
    Enregistre un device token pour les notifications push
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur enregistre son propre device
    if current_user.id != device_data.user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # VÃ©rifier si un token existe dÃ©jÃ  pour cet utilisateur et cette plateforme
        existing = await db.device_tokens.find_one({
            "user_id": device_data.user_id,
            "platform": device_data.platform
        })
        
        if existing:
            # Mettre Ã  jour le token existant
            await db.device_tokens.update_one(
                {"_id": existing["_id"]},
                {"$set": {
                    "device_token": device_data.device_token,
                    "updated_at": datetime.now(timezone.utc)
                }}
            )
            message = "Device token mis Ã  jour"
        else:
            # CrÃ©er un nouveau token
            new_token = DeviceToken(
                user_id=device_data.user_id,
                device_token=device_data.device_token,
                platform=device_data.platform
            )
            await db.device_tokens.insert_one(new_token.dict())
            message = "Device token enregistrÃ©"
        
        return {"message": message, "platform": device_data.platform}
    
    except Exception as e:
        print(f"Erreur lors de l'enregistrement du device token: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

async def send_push_notification_to_users(user_ids: List[str], title: str, body: str, data: Optional[dict] = None):
    """
    Helper function pour envoyer des notifications push Ã  plusieurs utilisateurs
    """
    if not firebase_admin._apps:
        print("âš ï¸ Firebase not initialized, skipping push notification")
        return
    
    try:
        # RÃ©cupÃ©rer tous les device tokens pour ces utilisateurs
        tokens_cursor = db.device_tokens.find({"user_id": {"$in": user_ids}})
        tokens_list = await tokens_cursor.to_list(length=None)
        
        if not tokens_list:
            print(f"No device tokens found for users: {user_ids}")
            return
        
        device_tokens = [token["device_token"] for token in tokens_list]
        
        # CrÃ©er le message
        message = messaging.MulticastMessage(
            notification=messaging.Notification(
                title=title,
                body=body
            ),
            data=data or {},
            tokens=device_tokens
        )
        
        # Envoyer
        response = messaging.send_multicast(message)
        print(f"âœ… Push notification sent: {response.success_count} success, {response.failure_count} failures")
        
        # Supprimer les tokens invalides
        if response.failure_count > 0:
            failed_tokens = [device_tokens[idx] for idx, resp in enumerate(response.responses) if not resp.success]
            await db.device_tokens.delete_many({"device_token": {"$in": failed_tokens}})
            print(f"Removed {len(failed_tokens)} invalid tokens")
        
        return response
    
    except Exception as e:
        print(f"Error sending push notification: {str(e)}")
        return None

@api_router.post("/{tenant_slug}/notifications/send")
async def send_push_notification(
    tenant_slug: str,
    notification_data: PushNotificationSend,
    current_user: User = Depends(get_current_user)
):
    """
    Envoie une notification push Ã  des utilisateurs spÃ©cifiques (Admin/Superviseur uniquement)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Seuls les admins et superviseurs peuvent envoyer des notifications
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        response = await send_push_notification_to_users(
            user_ids=notification_data.user_ids,
            title=notification_data.title,
            body=notification_data.body,
            data=notification_data.data
        )
        
        return {
            "message": "Notification envoyÃ©e",
            "success_count": response.success_count if response else 0,
            "failure_count": response.failure_count if response else 0
        }
    
    except Exception as e:
        print(f"Erreur lors de l'envoi de la notification: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# ==================== FONCTIONS HELPER POUR GÃ‰NÃ‰RATION D'INDISPONIBILITÃ‰S ====================

def generer_indisponibilites_montreal(user_id: str, tenant_id: str, equipe: str, date_debut: str, date_fin: str) -> List[Dict]:
    """
    GÃ©nÃ¨re les indisponibilitÃ©s pour l'horaire Montreal 7/24
    Cycle de 28 jours commenÃ§ant le 27 janvier 2025 (premier lundi rouge = jour 1)
    
    Pattern RÃ‰EL Montreal 7/24 (vÃ©rifiÃ© avec calendrier 2025):
    Chaque Ã©quipe travaille exactement 7 jours spÃ©cifiques sur le cycle de 28 jours
    
    Ã‰quipes avec numÃ©ros et patterns:
    - Vert (Ã‰quipe #1) : jours 2, 8, 11, 19, 21, 24, 27 du cycle
    - Bleu (Ã‰quipe #2) : jours 3, 6, 9, 15, 18, 26, 28 du cycle
    - Jaune (Ã‰quipe #3) : jours 5, 7, 10, 13, 16, 22, 25 du cycle
    - Rouge (Ã‰quipe #4) : jours 1, 4, 12, 14, 17, 20, 23 du cycle
    
    Le jour 1 du cycle = 27 janvier 2025 (premier lundi rouge)
    
    On gÃ©nÃ¨re les INDISPONIBILITÃ‰S pour les jours oÃ¹ l'Ã©quipe TRAVAILLE Ã  son emploi principal
    """
    
    # Mapping Ã©quipe -> numÃ©ro -> jours de travail dans le cycle de 28 jours
    equipes_config = {
        "Vert": {
            "numero": 1,
            "jours_cycle": [2, 8, 11, 19, 21, 24, 27]
        },
        "Bleu": {
            "numero": 2,
            "jours_cycle": [3, 6, 9, 15, 18, 26, 28]
        },
        "Jaune": {
            "numero": 3,
            "jours_cycle": [5, 7, 10, 13, 16, 22, 25]
        },
        "Rouge": {
            "numero": 4,
            "jours_cycle": [1, 4, 12, 14, 17, 20, 23]
        }
    }
    
    if equipe not in equipes_config:
        raise ValueError(f"Ã‰quipe invalide: {equipe}. Doit Ãªtre Vert, Bleu, Jaune ou Rouge")
    
    config = equipes_config[equipe]
    jours_travail_cycle = config["jours_cycle"]
    
    logging.info(f"Montreal 7/24 - {equipe} (#{config['numero']}): jours de travail dans cycle = {jours_travail_cycle}")
    
    # Le jour 1 du cycle = 27 janvier 2025
    jour_1_cycle = datetime(2025, 1, 27).date()
    
    # Parser les dates de dÃ©but et fin
    date_debut_obj = datetime.strptime(date_debut, "%Y-%m-%d").date()
    date_fin_obj = datetime.strptime(date_fin, "%Y-%m-%d").date()
    
    indisponibilites = []
    current_date = date_debut_obj
    
    while current_date <= date_fin_obj:
        # Calculer le jour dans le cycle (1-28)
        jours_depuis_jour1 = (current_date - jour_1_cycle).days
        jour_cycle = (jours_depuis_jour1 % 28) + 1
        
        # Si nÃ©gatif (avant le 27 janvier 2025), calculer en arriÃ¨re
        if jours_depuis_jour1 < 0:
            jour_cycle = 28 - ((-jours_depuis_jour1 - 1) % 28)
        
        # Si le jour EST dans les jours de travail de l'Ã©quipe, c'est une INDISPONIBILITÃ‰
        if jour_cycle in jours_travail_cycle:
            indispo = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant_id,
                "user_id": user_id,
                "date": current_date.isoformat(),
                "type_garde_id": None,
                "heure_debut": "00:00",
                "heure_fin": "23:59",
                "statut": "indisponible",
                "origine": "montreal_7_24",
                "created_at": datetime.now(timezone.utc)
            }
            indisponibilites.append(indispo)
        
        current_date += timedelta(days=1)
    
    logging.info(f"âœ… Montreal 7/24 - {equipe} (#{config['numero']}): {len(indisponibilites)} indisponibilitÃ©s gÃ©nÃ©rÃ©es de {date_debut} Ã  {date_fin}")
    return indisponibilites

def generer_indisponibilites_quebec(user_id: str, tenant_id: str, equipe: str, date_debut: str, date_fin: str) -> List[Dict]:
    """
    GÃ©nÃ¨re les indisponibilitÃ©s pour l'horaire Quebec 10/14
    Cycle de 28 jours commenÃ§ant le 1er fÃ©vrier 2026 (jour 1 du cycle)
    
    Pattern RÃ‰EL Quebec 10/14 (basÃ© sur fÃ©vrier 2026):
    Chaque Ã©quipe travaille selon un pattern spÃ©cifique sur 28 jours
    
    Ã‰quipes avec numÃ©ros et jours de travail:
    - Vert (Ã‰quipe #1) : jours 2,3,4,5, 12,13,14, 20,21, 22, 23,24,25
    - Bleu (Ã‰quipe #2) : jours 6,7, 8, 9,10,11, 16,17,18,19, 26,27,28
    - Jaune (Ã‰quipe #3) : jours 1, 2,3,4, 9,10,11,12, 19,20,21, 27,28
    - Rouge (Ã‰quipe #4) : jours 5,6,7, 13,14, 15, 16,17,18, 23,24,25,26
    
    Le jour 1 du cycle = 1er fÃ©vrier 2026 (DATE FIXE CODÃ‰E EN DUR)
    Le cycle recommence tous les 28 jours (1er mars, 29 mars, 26 avril, etc.)
    
    On gÃ©nÃ¨re les INDISPONIBILITÃ‰S pour les jours oÃ¹ l'Ã©quipe TRAVAILLE Ã  son emploi principal
    (car ils ne sont pas disponibles pour les gardes de pompiers ces jours-lÃ )
    
    Note: Pour les gardes de nuit (17h-7h), on marque seulement le jour de dÃ©but comme indisponible
    """
    
    # Mapping Ã©quipe -> numÃ©ro -> jours de travail dans le cycle de 28 jours
    equipes_config = {
        "Vert": {
            "numero": 1,
            "jours_cycle": [2, 3, 4, 5, 12, 13, 14, 20, 21, 22, 23, 24, 25]
        },
        "Bleu": {
            "numero": 2,
            "jours_cycle": [6, 7, 8, 9, 10, 11, 16, 17, 18, 19, 26, 27, 28]
        },
        "Jaune": {
            "numero": 3,
            "jours_cycle": [1, 2, 3, 4, 9, 10, 11, 12, 19, 20, 21, 27, 28]
        },
        "Rouge": {
            "numero": 4,
            "jours_cycle": [5, 6, 7, 13, 14, 15, 16, 17, 18, 23, 24, 25, 26]
        }
    }
    
    if equipe not in equipes_config:
        raise ValueError(f"Ã‰quipe invalide: {equipe}. Doit Ãªtre Vert, Bleu, Jaune ou Rouge")
    
    config = equipes_config[equipe]
    jours_travail_cycle = config["jours_cycle"]
    
    logging.info(f"Quebec 10/14 - {equipe} (#{config['numero']}): jours de travail dans cycle = {jours_travail_cycle}")
    
    # Le jour 1 du cycle = 1er fÃ©vrier 2026 (DATE FIXE)
    jour_1_cycle = datetime(2026, 2, 1).date()
    
    # Parser les dates de dÃ©but et fin
    date_debut_obj = datetime.strptime(date_debut, "%Y-%m-%d").date()
    date_fin_obj = datetime.strptime(date_fin, "%Y-%m-%d").date()
    
    indisponibilites = []
    current_date = date_debut_obj
    
    while current_date <= date_fin_obj:
        # Calculer le jour dans le cycle (1-28)
        jours_depuis_jour1 = (current_date - jour_1_cycle).days
        jour_cycle = (jours_depuis_jour1 % 28) + 1
        
        # Si nÃ©gatif (avant le jour 1), calculer en arriÃ¨re
        if jours_depuis_jour1 < 0:
            jour_cycle = 28 - ((-jours_depuis_jour1 - 1) % 28)
        
        # Si le jour EST dans les jours de travail de l'Ã©quipe, c'est une INDISPONIBILITÃ‰
        if jour_cycle in jours_travail_cycle:
            indispo = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant_id,
                "user_id": user_id,
                "date": current_date.isoformat(),
                "type_garde_id": None,
                "heure_debut": "00:00",
                "heure_fin": "23:59",
                "statut": "indisponible",
                "origine": "quebec_10_14",
                "created_at": datetime.now(timezone.utc)
            }
            indisponibilites.append(indispo)
        
        current_date += timedelta(days=1)
    
    logging.info(f"âœ… Quebec 10/14 - {equipe} (#{config['numero']}): {len(indisponibilites)} indisponibilitÃ©s gÃ©nÃ©rÃ©es de {date_debut} Ã  {date_fin}")
    return indisponibilites

# ==================== ROUTE DE GÃ‰NÃ‰RATION D'INDISPONIBILITÃ‰S ====================

@api_router.post("/{tenant_slug}/disponibilites/generer")
async def generer_indisponibilites(
    tenant_slug: str,
    generation_data: IndisponibiliteGenerate,
    current_user: User = Depends(get_current_user)
):
    """
    GÃ©nÃ¨re automatiquement les indisponibilitÃ©s selon l'horaire sÃ©lectionnÃ©
    """
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier les permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.id != generation_data.user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Supprimer les anciennes disponibilitÃ©s gÃ©nÃ©rÃ©es automatiquement si demandÃ©
        if not generation_data.conserver_manuelles:
            # Supprimer toutes les disponibilitÃ©s de cet utilisateur pour la pÃ©riode
            await db.disponibilites.delete_many({
                "user_id": generation_data.user_id,
                "tenant_id": tenant.id,
                "date": {
                    "$gte": generation_data.date_debut,
                    "$lte": generation_data.date_fin
                }
            })
        else:
            # Supprimer uniquement les disponibilitÃ©s gÃ©nÃ©rÃ©es automatiquement (prÃ©server manuelles)
            origine_type = "montreal_7_24" if generation_data.horaire_type == "montreal" else "quebec_10_14"
            await db.disponibilites.delete_many({
                "user_id": generation_data.user_id,
                "tenant_id": tenant.id,
                "origine": origine_type,
                "date": {
                    "$gte": generation_data.date_debut,
                    "$lte": generation_data.date_fin
                }
            })
        
        # GÃ©nÃ©rer les nouvelles indisponibilitÃ©s
        if generation_data.horaire_type == "montreal":
            indispos = generer_indisponibilites_montreal(
                user_id=generation_data.user_id,
                tenant_id=tenant.id,
                equipe=generation_data.equipe,
                date_debut=generation_data.date_debut,
                date_fin=generation_data.date_fin
            )
        elif generation_data.horaire_type == "quebec":
            indispos = generer_indisponibilites_quebec(
                user_id=generation_data.user_id,
                tenant_id=tenant.id,
                equipe=generation_data.equipe,
                date_debut=generation_data.date_debut,
                date_fin=generation_data.date_fin
            )
        else:
            raise HTTPException(
                status_code=400,
                detail="horaire_type doit Ãªtre 'montreal' ou 'quebec'"
            )
        
        # InsÃ©rer les indisponibilitÃ©s dans la base de donnÃ©es
        if indispos:
            await db.disponibilites.insert_many(indispos)
        
        # CrÃ©er une activitÃ©
        horaire_text = "MontrÃ©al 7/24" if generation_data.horaire_type == "montreal" else "QuÃ©bec 10/14"
        user = await db.users.find_one({"id": generation_data.user_id, "tenant_id": tenant.id})
        if user:
            await creer_activite(
                tenant_id=tenant.id,
                type_activite="disponibilite_generation_auto",
                description=f"ğŸ”„ {current_user.prenom} {current_user.nom} a gÃ©nÃ©rÃ© {len(indispos)} indisponibilitÃ©s automatiques ({horaire_text} - {generation_data.equipe}) pour {user['prenom']} {user['nom']}",
                user_id=current_user.id,
                user_nom=f"{current_user.prenom} {current_user.nom}",
                data={"concerne_user_id": generation_data.user_id}
            )
        
        return {
            "message": "IndisponibilitÃ©s gÃ©nÃ©rÃ©es avec succÃ¨s",
            "horaire_type": generation_data.horaire_type,
            "equipe": generation_data.equipe,
            "date_debut": generation_data.date_debut,
            "date_fin": generation_data.date_fin,
            "nombre_indisponibilites": len(indispos),
            "conserver_manuelles": generation_data.conserver_manuelles
        }
        
    except HTTPException:
        # Re-raise HTTPExceptions as-is (don't convert to 500)
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        print(f"Erreur lors de la gÃ©nÃ©ration des indisponibilitÃ©s: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la gÃ©nÃ©ration: {str(e)}")

# Assignation manuelle avancÃ©e avec rÃ©currence
@api_router.post("/{tenant_slug}/planning/assignation-avancee")
async def assignation_manuelle_avancee(
    tenant_slug: str,
    assignation_data: dict,
    current_user: User = Depends(get_current_user)
):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        user_id = assignation_data.get("user_id")
        type_garde_id = assignation_data.get("type_garde_id")
        recurrence_type = assignation_data.get("recurrence_type", "unique")
        date_debut = datetime.strptime(assignation_data.get("date_debut"), "%Y-%m-%d").date()
        date_fin = datetime.strptime(assignation_data.get("date_fin", assignation_data.get("date_debut")), "%Y-%m-%d").date()
        jours_semaine = assignation_data.get("jours_semaine", [])
        bi_hebdomadaire = assignation_data.get("bi_hebdomadaire", False)
        recurrence_intervalle = assignation_data.get("recurrence_intervalle", 1)
        recurrence_frequence = assignation_data.get("recurrence_frequence", "jours")
        
        assignations_creees = []
        
        if recurrence_type == "unique":
            # Assignation unique
            assignation_obj = Assignation(
                user_id=user_id,
                type_garde_id=type_garde_id,
                date=date_debut.strftime("%Y-%m-%d"),
                assignation_type="manuel_avance",
                tenant_id=tenant.id
            )
            await db.assignations.insert_one(assignation_obj.dict())
            assignations_creees.append(assignation_obj.dict())
            
        elif recurrence_type == "hebdomadaire":
            # RÃ©currence hebdomadaire (avec option bi-hebdomadaire)
            current_date = date_debut
            jours_semaine_index = {
                'monday': 0, 'tuesday': 1, 'wednesday': 2, 'thursday': 3,
                'friday': 4, 'saturday': 5, 'sunday': 6
            }
            
            # Pour bi-hebdomadaire : calculer le numÃ©ro de semaine ISO de la date de dÃ©but
            def get_iso_week_number(date):
                # Python's isocalendar() retourne (annÃ©e, semaine, jour_semaine)
                return date.isocalendar()[1]
            
            reference_week = get_iso_week_number(date_debut)
            
            while current_date <= date_fin:
                day_name = current_date.strftime("%A").lower()
                
                # VÃ©rifier si c'est un jour sÃ©lectionnÃ©
                if day_name in jours_semaine:
                    # Si bi-hebdomadaire, vÃ©rifier la diffÃ©rence de semaines
                    current_week = get_iso_week_number(current_date)
                    weeks_difference = current_week - reference_week
                    
                    if not bi_hebdomadaire or weeks_difference % 2 == 0:
                        # VÃ©rifier qu'il n'y a pas dÃ©jÃ  une assignation
                        existing = await db.assignations.find_one({
                            "user_id": user_id,
                            "type_garde_id": type_garde_id,
                            "date": current_date.strftime("%Y-%m-%d"),
                            "tenant_id": tenant.id
                        })
                        
                        if not existing:
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_garde_id,
                                date=current_date.strftime("%Y-%m-%d"),
                                assignation_type="manuel_avance",
                                tenant_id=tenant.id
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_creees.append(assignation_obj.dict())
                
                current_date += timedelta(days=1)
        
        elif recurrence_type == "bihebdomadaire":
            # RÃ©currence bi-hebdomadaire (toutes les 2 semaines)
            current_date = date_debut
            
            # Calculer le numÃ©ro de semaine ISO de rÃ©fÃ©rence
            def get_iso_week_number(date):
                return date.isocalendar()[1]
            
            reference_week = get_iso_week_number(date_debut)
            
            while current_date <= date_fin:
                day_name = current_date.strftime("%A").lower()
                
                # Calculer la diffÃ©rence de semaines
                current_week = get_iso_week_number(current_date)
                weeks_difference = current_week - reference_week
                
                # VÃ©rifier si c'est un jour sÃ©lectionnÃ© et une semaine paire
                if day_name in jours_semaine and weeks_difference % 2 == 0:
                    existing = await db.assignations.find_one({
                        "user_id": user_id,
                        "type_garde_id": type_garde_id,
                        "date": current_date.strftime("%Y-%m-%d"),
                        "tenant_id": tenant.id
                    })
                    
                    if not existing:
                        assignation_obj = Assignation(
                            user_id=user_id,
                            type_garde_id=type_garde_id,
                            date=current_date.strftime("%Y-%m-%d"),
                            assignation_type="manuel_avance",
                            tenant_id=tenant.id
                        )
                        await db.assignations.insert_one(assignation_obj.dict())
                        assignations_creees.append(assignation_obj.dict())
                
                current_date += timedelta(days=1)
                
        elif recurrence_type == "mensuel" or recurrence_type == "mensuelle":
            # RÃ©currence mensuelle (mÃªme jour du mois)
            jour_mois = date_debut.day
            current_month = date_debut.replace(day=1)
            
            while current_month <= date_fin:
                try:
                    # Essayer de crÃ©er la date pour ce mois
                    target_date = current_month.replace(day=jour_mois)
                    
                    if date_debut <= target_date <= date_fin:
                        existing = await db.assignations.find_one({
                            "user_id": user_id,
                            "type_garde_id": type_garde_id,
                            "date": target_date.strftime("%Y-%m-%d"),
                            "tenant_id": tenant.id
                        })
                        
                        if not existing:
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_garde_id,
                                date=target_date.strftime("%Y-%m-%d"),
                                assignation_type="manuel_avance",
                                tenant_id=tenant.id
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_creees.append(assignation_obj.dict())
                            
                except ValueError:
                    # Jour n'existe pas dans ce mois (ex: 31 fÃ©vrier)
                    pass
                
                # Passer au mois suivant
                if current_month.month == 12:
                    current_month = current_month.replace(year=current_month.year + 1, month=1)
                else:
                    current_month = current_month.replace(month=current_month.month + 1)
        
        elif recurrence_type == "annuelle":
            # RÃ©currence annuelle (mÃªme jour et mois chaque annÃ©e)
            jour_mois = date_debut.day
            mois = date_debut.month
            current_year = date_debut.year
            
            while True:
                try:
                    target_date = date(current_year, mois, jour_mois)
                    
                    if target_date > date_fin:
                        break
                    
                    if target_date >= date_debut:
                        existing = await db.assignations.find_one({
                            "user_id": user_id,
                            "type_garde_id": type_garde_id,
                            "date": target_date.strftime("%Y-%m-%d"),
                            "tenant_id": tenant.id
                        })
                        
                        if not existing:
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_garde_id,
                                date=target_date.strftime("%Y-%m-%d"),
                                assignation_type="manuel_avance",
                                tenant_id=tenant.id
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_creees.append(assignation_obj.dict())
                    
                    current_year += 1
                except ValueError:
                    # Jour n'existe pas (ex: 29 fÃ©vrier dans une annÃ©e non bissextile)
                    current_year += 1
        
        elif recurrence_type == "personnalisee":
            # RÃ©currence personnalisÃ©e
            current_date = date_debut
            
            if recurrence_frequence == "jours":
                delta = timedelta(days=recurrence_intervalle)
            elif recurrence_frequence == "semaines":
                delta = timedelta(weeks=recurrence_intervalle)
            else:
                # Pour mois et ans, on gÃ©rera diffÃ©remment
                delta = None
            
            if delta:
                while current_date <= date_fin:
                    existing = await db.assignations.find_one({
                        "user_id": user_id,
                        "type_garde_id": type_garde_id,
                        "date": current_date.strftime("%Y-%m-%d"),
                        "tenant_id": tenant.id
                    })
                    
                    if not existing:
                        assignation_obj = Assignation(
                            user_id=user_id,
                            type_garde_id=type_garde_id,
                            date=current_date.strftime("%Y-%m-%d"),
                            assignation_type="manuel_avance",
                            tenant_id=tenant.id
                        )
                        await db.assignations.insert_one(assignation_obj.dict())
                        assignations_creees.append(assignation_obj.dict())
                    
                    current_date += delta
            else:
                # Pour mois et ans
                current_date = date_debut
                while current_date <= date_fin:
                    existing = await db.assignations.find_one({
                        "user_id": user_id,
                        "type_garde_id": type_garde_id,
                        "date": current_date.strftime("%Y-%m-%d"),
                        "tenant_id": tenant.id
                    })
                    
                    if not existing:
                        assignation_obj = Assignation(
                            user_id=user_id,
                            type_garde_id=type_garde_id,
                            date=current_date.strftime("%Y-%m-%d"),
                            assignation_type="manuel_avance",
                            tenant_id=tenant.id
                        )
                        await db.assignations.insert_one(assignation_obj.dict())
                        assignations_creees.append(assignation_obj.dict())
                    
                    if recurrence_frequence == "mois":
                        # Ajouter X mois
                        month = current_date.month + recurrence_intervalle
                        year = current_date.year
                        while month > 12:
                            month -= 12
                            year += 1
                        try:
                            current_date = current_date.replace(year=year, month=month)
                        except ValueError:
                            # Jour invalide pour ce mois
                            break
                    elif recurrence_frequence == "ans":
                        # Ajouter X ans
                        try:
                            current_date = current_date.replace(year=current_date.year + recurrence_intervalle)
                        except ValueError:
                            # Jour invalide (29 fÃ©vrier)
                            break
        
        return {
            "message": "Assignation avancÃ©e crÃ©Ã©e avec succÃ¨s",
            "assignations_creees": len(assignations_creees),
            "recurrence": recurrence_type,
            "periode": f"{date_debut.strftime('%Y-%m-%d')} Ã  {date_fin.strftime('%Y-%m-%d')}"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur assignation avancÃ©e: {str(e)}")

# Mode dÃ©mo spÃ©cial - Attribution automatique agressive pour impression client
@api_router.post("/{tenant_slug}/planning/attribution-auto-demo")
async def attribution_automatique_demo(tenant_slug: str, semaine_debut: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Get all available users and types de garde pour ce tenant
        users = await db.users.find({"statut": "Actif", "tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Get existing assignations for the week
        semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        existing_assignations = await db.assignations.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "tenant_id": tenant.id
        }).to_list(1000)
        
        nouvelles_assignations = []
        
        # MODE DÃ‰MO AGRESSIF - REMPLIR AU MAXIMUM
        for type_garde in types_garde:
            for day_offset in range(7):
                current_date = datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=day_offset)
                date_str = current_date.strftime("%Y-%m-%d")
                day_name = current_date.strftime("%A").lower()
                
                # CORRECTION CRITIQUE: Skip if type garde doesn't apply to this day
                jours_app = type_garde.get("jours_application", [])
                if jours_app and len(jours_app) > 0 and day_name not in jours_app:
                    logging.debug(f"â­ï¸ [SKIP DAY DEMO] {type_garde['nom']} - {date_str} ({day_name}): Jour non applicable (limitÃ© Ã  {jours_app})")
                    continue
                
                # Compter combien de personnel dÃ©jÃ  assignÃ© pour cette garde
                existing_for_garde = [a for a in existing_assignations 
                                    if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                
                personnel_deja_assigne = len(existing_for_garde)
                personnel_requis = type_garde.get("personnel_requis", 1)
                
                # Assigner jusqu'au maximum requis
                for i in range(personnel_requis - personnel_deja_assigne):
                    # Trouver utilisateurs disponibles
                    available_users = []
                    
                    for user in users:
                        # Skip si dÃ©jÃ  assignÃ© cette garde ce jour
                        if any(a["user_id"] == user["id"] and a["date"] == date_str and a["type_garde_id"] == type_garde["id"] 
                               for a in existing_assignations):
                            continue
                        
                        # Skip si dÃ©jÃ  assignÃ© autre garde ce jour (Ã©viter conflits)
                        if any(a["user_id"] == user["id"] and a["date"] == date_str 
                               for a in existing_assignations):
                            continue
                        
                        # VÃ©rifier disponibilitÃ©s
                        user_dispos = await db.disponibilites.find({
                            "user_id": user["id"],
                            "date": date_str,
                            "type_garde_id": type_garde["id"],
                            "statut": "disponible"
                        }).to_list(10)
                        
                        if user_dispos:
                            available_users.append(user)
                    
                    if not available_users:
                        break  # Pas d'utilisateurs disponibles pour ce poste
                    
                    # MODE DÃ‰MO : ASSOUPLIR CONTRAINTE OFFICIER
                    if type_garde.get("officier_obligatoire", False):
                        # Chercher officiers d'abord
                        officers = [u for u in available_users if u["grade"] in ["Capitaine", "Lieutenant", "Directeur"]]
                        # Sinon pompiers avec fonction supÃ©rieur
                        if not officers:
                            officers = [u for u in available_users if u.get("fonction_superieur", False)]
                        # En dernier recours : tous pompiers (MODE DÃ‰MO)
                        if not officers:
                            officers = available_users
                        
                        if officers:
                            selected_user = officers[0]
                        else:
                            continue
                    else:
                        selected_user = available_users[0]
                    
                    # CrÃ©er assignation
                    assignation_obj = Assignation(
                        user_id=selected_user["id"],
                        type_garde_id=type_garde["id"],
                        date=date_str,
                        assignation_type="auto_demo",
                        tenant_id=tenant.id
                    )
                    
                    await db.assignations.insert_one(assignation_obj.dict())
                    nouvelles_assignations.append(assignation_obj.dict())
                    existing_assignations.append(assignation_obj.dict())
        
        return {
            "message": "Attribution DÃ‰MO agressive effectuÃ©e avec succÃ¨s",
            "assignations_creees": len(nouvelles_assignations),
            "algorithme": "Mode dÃ©mo : Contraintes assouplies pour impression maximum",
            "semaine": f"{semaine_debut} - {semaine_fin}"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur attribution dÃ©mo: {str(e)}")

# VÃ©rification des assignations existantes pour une pÃ©riode
@api_router.get("/{tenant_slug}/planning/assignations/check-periode")
async def check_assignations_periode(
    tenant_slug: str, 
    debut: str, 
    fin: str, 
    current_user: User = Depends(get_current_user)
):
    """VÃ©rifie s'il existe des assignations pour la pÃ©riode donnÃ©e"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        existing_count = await db.assignations.count_documents({
            "date": {
                "$gte": debut,
                "$lte": fin
            },
            "tenant_id": tenant.id
        })
        
        return {
            "existing_count": existing_count,
            "periode": f"{debut} au {fin}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur vÃ©rification pÃ©riode: {str(e)}")

# ==================== SSE ENDPOINT POUR PROGRESSION ====================
@api_router.get("/{tenant_slug}/planning/attribution-auto/progress/{task_id}")
async def attribution_progress_stream(
    tenant_slug: str,
    task_id: str
):
    """Stream SSE pour suivre la progression de l'attribution automatique
    
    Note: Pas d'authentification JWT car EventSource ne peut pas envoyer de headers.
    La sÃ©curitÃ© est assurÃ©e par le task_id unique et Ã©phÃ©mÃ¨re.
    """
    # VÃ©rifier que le task_id existe (sÃ©curitÃ© basique)
    if task_id not in attribution_progress_store and task_id != "test":
        # Attendre un peu que la tÃ¢che soit crÃ©Ã©e
        await asyncio.sleep(1)
        if task_id not in attribution_progress_store:
            raise HTTPException(status_code=404, detail="Task ID non trouvÃ©")
    
    return StreamingResponse(
        progress_event_generator(task_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"  # Nginx buffering disabled
        }
    )

# Attribution automatique intelligente avec rotation Ã©quitable et anciennetÃ©
@api_router.post("/{tenant_slug}/planning/attribution-auto")
async def attribution_automatique(
    tenant_slug: str, 
    semaine_debut: str, 
    semaine_fin: str = None,
    reset: bool = False,  # Nouveau paramÃ¨tre pour rÃ©initialiser
    current_user: User = Depends(get_current_user)
):
    """Attribution automatique pour une ou plusieurs semaines avec progression temps rÃ©el
    
    Args:
        reset: Si True, supprime d'abord toutes les assignations AUTO de la pÃ©riode
        
    Returns:
        task_id: Identifiant pour suivre la progression via SSE
    """
    logging.info(f"ğŸ”¥ [ENDPOINT] Attribution auto appelÃ© par {current_user.email}")
    logging.info(f"ğŸ”¥ [ENDPOINT] ParamÃ¨tres reÃ§us: tenant={tenant_slug}, debut={semaine_debut}, fin={semaine_fin}, reset={reset}")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # GÃ©nÃ©rer un task_id unique
    task_id = str(uuid.uuid4())
    
    # Lancer la tÃ¢che en arriÃ¨re-plan
    asyncio.create_task(
        process_attribution_auto_async(
            task_id, tenant, semaine_debut, semaine_fin, reset
        )
    )
    
    # Retourner immÃ©diatement le task_id
    return {
        "task_id": task_id,
        "message": "Attribution automatique lancÃ©e en arriÃ¨re-plan",
        "stream_url": f"/api/{tenant_slug}/planning/attribution-auto/progress/{task_id}"
    }

async def process_attribution_auto_async(
    task_id: str,
    tenant,
    semaine_debut: str,
    semaine_fin: str = None,
    reset: bool = False
):
    """Traite l'attribution automatique de maniÃ¨re asynchrone avec suivi de progression"""
    progress = AttributionProgress(task_id)
    
    try:
        start_time = time.time()
        logging.info(f"â±ï¸ [PERF] Attribution auto dÃ©marrÃ©e - Task ID: {task_id}")
        logging.info(f"ğŸ” [DEBUG] reset={reset}, type={type(reset)}, tenant_id={tenant.id}")
        logging.info(f"ğŸ” [DEBUG] PÃ©riode: {semaine_debut} â†’ {semaine_fin}")
        
        # Si pas de semaine_fin fournie, calculer pour une seule semaine
        if not semaine_fin:
            semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        
        progress.update("Initialisation...", 5)
        
        # Si reset=True, supprimer d'abord toutes les assignations AUTO de la pÃ©riode
        assignations_supprimees = 0
        if reset:
            logging.info(f"ğŸ” [DEBUG] RESET MODE ACTIVÃ‰ - Tentative de suppression...")
            
            # VÃ©rifier combien d'assignations existent
            count_before = await db.assignations.count_documents({
                "tenant_id": tenant.id,
                "date": {"$gte": semaine_debut, "$lte": semaine_fin}
            })
            logging.info(f"ğŸ” [DEBUG] Assignations totales dans pÃ©riode: {count_before}")
            
            # VÃ©rifier les types d'assignation existants
            distinct_types = await db.assignations.distinct("assignation_type", {
                "tenant_id": tenant.id,
                "date": {"$gte": semaine_debut, "$lte": semaine_fin}
            })
            logging.info(f"ğŸ” [DEBUG] Types d'assignation existants: {distinct_types}")
            
            progress.update("Suppression des assignations existantes...", 10)
            # CORRECTION: Supprimer TOUTES les assignations AUTO + celles sans type (anciennes)
            result = await db.assignations.delete_many({
                "tenant_id": tenant.id,
                "date": {
                    "$gte": semaine_debut,
                    "$lte": semaine_fin
                },
                "$or": [
                    {"assignation_type": {"$in": ["auto", "automatique"]}},
                    {"assignation_type": {"$exists": False}},  # Assignations sans type (anciennes)
                    {"assignation_type": None}  # Assignations avec type null
                ]
            })
            assignations_supprimees = result.deleted_count
            logging.info(f"â±ï¸ [PERF] âœ… {assignations_supprimees} assignations supprimÃ©es (incluant anciennes sans type)")
        else:
            logging.info(f"ğŸ” [DEBUG] RESET MODE DÃ‰SACTIVÃ‰ - Pas de suppression")
        
        # Pour une pÃ©riode complÃ¨te (mois), traiter semaine par semaine
        start_date = datetime.strptime(semaine_debut, "%Y-%m-%d")
        end_date = datetime.strptime(semaine_fin, "%Y-%m-%d")
        
        # Calculer le nombre total de semaines
        total_weeks = ((end_date - start_date).days // 7) + 1
        progress.total_gardes = total_weeks
        
        total_assignations_creees = 0
        current_week_start = start_date
        week_number = 0
        
        # ItÃ©rer sur toutes les semaines de la pÃ©riode
        while current_week_start <= end_date:
            week_number += 1
            current_week_end = current_week_start + timedelta(days=6)
            if current_week_end > end_date:
                current_week_end = end_date
            
            week_start_str = current_week_start.strftime("%Y-%m-%d")
            week_end_str = current_week_end.strftime("%Y-%m-%d")
            
            # Mise Ã  jour progression
            progress_percent = 15 + int((week_number / total_weeks) * 80)
            progress.update(
                f"Traitement semaine {week_number}/{total_weeks} ({week_start_str})",
                progress_percent,
                gardes_traitees=week_number
            )
            
            week_start_time = time.time()
            
            # Traiter cette semaine
            assignations_cette_semaine = await traiter_semaine_attribution_auto(
                tenant, 
                week_start_str, 
                week_end_str,
                progress=progress  # Passer l'objet progress pour mises Ã  jour granulaires
            )
            
            week_elapsed = time.time() - week_start_time
            logging.info(f"â±ï¸ [PERF] Semaine {week_number} traitÃ©e en {week_elapsed:.2f}s - {assignations_cette_semaine} assignations")
            
            total_assignations_creees += assignations_cette_semaine
            progress.assignations_creees = total_assignations_creees
            
            # Passer Ã  la semaine suivante
            current_week_start += timedelta(days=7)
        
        # Terminer
        total_elapsed = time.time() - start_time
        logging.info(f"â±ï¸ [PERF] Attribution auto terminÃ©e en {total_elapsed:.2f}s - Total: {total_assignations_creees} assignations")
        
        progress.complete(total_assignations_creees)
        
    except Exception as e:
        logging.error(f"âŒ [ERROR] Attribution auto Ã©chouÃ©e: {str(e)}", exc_info=True)
        progress.error(str(e))

async def generer_justification_attribution(
    selected_user: Dict,
    all_candidates: List[Dict],
    type_garde: Dict,
    date_str: str,
    user_monthly_hours_internes: Dict,
    user_monthly_hours_externes: Dict,
    activer_heures_sup: bool,
    existing_assignations: List[Dict],
    disponibilites_evaluees: List[Dict] = None,
    dispos_lookup: Dict = None  # NOUVEAU: pour vÃ©rifier les disponibilitÃ©s
) -> Dict[str, Any]:
    """
    GÃ©nÃ¨re une justification dÃ©taillÃ©e pour une attribution automatique
    """
    # Utiliser le compteur appropriÃ© selon le type de garde
    user_monthly_hours = user_monthly_hours_externes if type_garde.get("est_garde_externe", False) else user_monthly_hours_internes
    
    # Calculer les scores pour l'utilisateur sÃ©lectionnÃ©
    heures_selectionnee = user_monthly_hours.get(selected_user["id"], 0)
    moyenne_equipe = sum(user_monthly_hours.values()) / len(user_monthly_hours) if user_monthly_hours else 0
    
    # Score d'Ã©quitÃ© (0-100) - Plus les heures sont basses, meilleur le score
    if moyenne_equipe > 0:
        ecart_ratio = (moyenne_equipe - heures_selectionnee) / moyenne_equipe
        score_equite = min(100, max(0, 50 + (ecart_ratio * 50)))
    else:
        score_equite = 50
    
    # Score d'anciennetÃ© (0-100)
    try:
        date_embauche = selected_user.get("date_embauche", "1900-01-01")
        try:
            embauche_dt = datetime.strptime(date_embauche, "%Y-%m-%d")
        except:
            embauche_dt = datetime.strptime(date_embauche, "%d/%m/%Y")
        
        annees_service = (datetime.now() - embauche_dt).days / 365.25
        score_anciennete = min(100, annees_service * 5)  # 5 points par an, max 100
    except:
        annees_service = 0
        score_anciennete = 0
    
    # Score de disponibilitÃ© (0-100)
    if selected_user.get("type_emploi") == "temps_partiel":
        score_disponibilite = 100 if disponibilites_evaluees else 50
    else:
        score_disponibilite = 75  # Temps plein toujours disponible
    
    # Score de compÃ©tences (0-100) - basÃ© sur le grade
    grade_scores = {
        "Directeur": 100,
        "Capitaine": 85,
        "Lieutenant": 70,
        "Pompier": 50
    }
    score_competences = grade_scores.get(selected_user.get("grade", "Pompier"), 50)
    
    # Score total
    score_total = score_equite + score_anciennete + score_disponibilite + score_competences
    
    # DÃ©tails de l'utilisateur sÃ©lectionnÃ©
    assigned_user_info = {
        "user_id": selected_user["id"],
        "nom_complet": f"{selected_user['prenom']} {selected_user['nom']}",
        "grade": selected_user.get("grade", "N/A"),
        "type_emploi": selected_user.get("type_emploi", "N/A"),
        "scores": {
            "equite": round(score_equite, 1),
            "anciennete": round(score_anciennete, 1),
            "disponibilite": round(score_disponibilite, 1),
            "competences": round(score_competences, 1),
            "total": round(score_total, 1)
        },
        "details": {
            "heures_ce_mois": heures_selectionnee,
            "moyenne_equipe": round(moyenne_equipe, 1),
            "annees_service": round(annees_service, 1),
            "disponibilite_declaree": selected_user.get("type_emploi") == "temps_partiel" and bool(disponibilites_evaluees),
            "heures_max_autorisees": selected_user.get("heures_max_semaine", 40) if not activer_heures_sup else None
        }
    }
    
    # Ã‰valuer les autres candidats
    other_candidates = []
    for candidate in all_candidates:
        if candidate["id"] == selected_user["id"]:
            continue  # Skip l'utilisateur sÃ©lectionnÃ©
        
        # DÃ©terminer la raison d'exclusion
        raison_exclusion = None
        candidate_scores = None
        
        # VÃ©rifier heures supplÃ©mentaires (seulement si dÃ©sactivÃ©es)
        if not activer_heures_sup:
            # Calculer heures de la semaine pour ce candidat
            heures_semaine_candidate = 0
            for assignation in existing_assignations:
                if assignation["user_id"] == candidate["id"]:
                    heures_semaine_candidate += 8  # Simplification
            
            heures_max_user = candidate.get("heures_max_semaine", 40)
            
            if heures_semaine_candidate + type_garde.get("duree_heures", 8) > heures_max_user:
                raison_exclusion = f"Heures max atteintes ({heures_semaine_candidate}h/{heures_max_user}h)"
        
        # VÃ©rifier disponibilitÃ© (temps partiel)
        if not raison_exclusion and candidate.get("type_emploi") == "temps_partiel":
            # VÃ©rifier s'il a dÃ©clarÃ© une disponibilitÃ© (mÃªme logique que l'attribution)
            has_dispo = False
            if dispos_lookup and candidate["id"] in dispos_lookup and date_str in dispos_lookup[candidate["id"]]:
                # DisponibilitÃ© spÃ©cifique pour ce type de garde
                if type_garde["id"] in dispos_lookup[candidate["id"]][date_str]:
                    has_dispo = True
                # OU disponibilitÃ© gÃ©nÃ©rale (type_garde_id = None)
                elif None in dispos_lookup[candidate["id"]][date_str]:
                    has_dispo = True
            
            if not has_dispo:
                raison_exclusion = "DisponibilitÃ© non dÃ©clarÃ©e"
        
        # VÃ©rifier s'il est dÃ©jÃ  assignÃ©
        if not raison_exclusion:
            deja_assigne = any(
                a["user_id"] == candidate["id"] and 
                a["date"] == date_str and 
                a["type_garde_id"] == type_garde["id"]
                for a in existing_assignations
            )
            if deja_assigne:
                raison_exclusion = "DÃ©jÃ  assignÃ© Ã  cette garde"
        
        # Si pas exclu, calculer les scores
        if not raison_exclusion:
            heures_candidate = user_monthly_hours.get(candidate["id"], 0)
            
            # Scores similaires Ã  l'utilisateur sÃ©lectionnÃ©
            if moyenne_equipe > 0:
                ecart_ratio = (moyenne_equipe - heures_candidate) / moyenne_equipe
                cand_score_equite = min(100, max(0, 50 + (ecart_ratio * 50)))
            else:
                cand_score_equite = 50
            
            try:
                date_emb = candidate.get("date_embauche", "1900-01-01")
                try:
                    emb_dt = datetime.strptime(date_emb, "%Y-%m-%d")
                except:
                    emb_dt = datetime.strptime(date_emb, "%d/%m/%Y")
                cand_annees = (datetime.now() - emb_dt).days / 365.25
                cand_score_anc = min(100, cand_annees * 5)
            except:
                cand_score_anc = 0
            
            cand_score_dispo = 100 if candidate.get("type_emploi") == "temps_partiel" else 75
            cand_score_comp = grade_scores.get(candidate.get("grade", "Pompier"), 50)
            cand_total = cand_score_equite + cand_score_anc + cand_score_dispo + cand_score_comp
            
            candidate_scores = {
                "equite": round(cand_score_equite, 1),
                "anciennete": round(cand_score_anc, 1),
                "disponibilite": round(cand_score_dispo, 1),
                "competences": round(cand_score_comp, 1),
                "total": round(cand_total, 1)
            }
            
            raison_exclusion = f"Score infÃ©rieur (total: {round(cand_total, 1)} vs {round(score_total, 1)})"
        
        other_candidates.append({
            "user_id": candidate["id"],
            "nom_complet": f"{candidate['prenom']} {candidate['nom']}",
            "grade": candidate.get("grade", "N/A"),
            "excluded_reason": raison_exclusion,
            "scores": candidate_scores,
            "heures_ce_mois": user_monthly_hours.get(candidate["id"], 0)
        })
    
    # Trier les autres candidats par score dÃ©croissant (si scores disponibles)
    other_candidates.sort(key=lambda x: x["scores"]["total"] if x["scores"] else 0, reverse=True)
    
    return {
        "assigned_user": assigned_user_info,
        "other_candidates": other_candidates[:10],  # Limiter Ã  10 pour ne pas surcharger
        "total_candidates_evaluated": len(all_candidates),
        "date_attribution": datetime.now(timezone.utc).isoformat(),
        "type_garde_info": {
            "nom": type_garde.get("nom", "N/A"),
            "duree_heures": type_garde.get("duree_heures", 8),
            "personnel_requis": type_garde.get("personnel_requis", 1)
        }
    }


async def traiter_semaine_attribution_auto(tenant, semaine_debut: str, semaine_fin: str, progress: AttributionProgress = None):
    """Traite l'attribution automatique pour une seule semaine avec suivi de performance"""
    perf_start = time.time()
    
    try:
        # Get all available users and types de garde pour ce tenant
        users = await db.users.find({"statut": "Actif", "tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        
        # RÃ©cupÃ©rer les paramÃ¨tres de remplacements (incluant gestion heures sup)
        parametres = await db.parametres_remplacements.find_one({"tenant_id": tenant.id})
        if not parametres:
            # CrÃ©er des paramÃ¨tres par dÃ©faut
            default_params = ParametresRemplacements(tenant_id=tenant.id)
            await db.parametres_remplacements.insert_one(default_params.dict())
            parametres = default_params.dict()
        
        activer_heures_sup = parametres.get("activer_gestion_heures_sup", False)
        
        # CORRECTION CRITIQUE: Charger les paramÃ¨tres des niveaux d'attribution
        niveaux_actifs = {
            "niveau_2": tenant.parametres.get("niveau_2_actif", True),
            "niveau_3": tenant.parametres.get("niveau_3_actif", True),
            "niveau_4": tenant.parametres.get("niveau_4_actif", True),
            "niveau_5": tenant.parametres.get("niveau_5_actif", True)
        }
        logging.info(f"ğŸ“Š [NIVEAUX] Niveaux d'attribution actifs: {niveaux_actifs}")
        
        # RÃ©cupÃ©rer les grades pour vÃ©rifier les officiers
        grades = await db.grades.find({"tenant_id": tenant.id}).to_list(1000)
        grades_map = {g["nom"]: g for g in grades}
        
        # RÃ©cupÃ©rer les compÃ©tences pour la priorisation des gardes
        competences = await db.competences.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Get existing assignations for the week
        semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        existing_assignations = await db.assignations.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "tenant_id": tenant.id
        }).to_list(1000)
        
        # Get monthly statistics for rotation Ã©quitable (current month)
        current_month_start = datetime.strptime(semaine_debut, "%Y-%m-%d").replace(day=1).strftime("%Y-%m-%d")
        current_month_end = (datetime.strptime(current_month_start, "%Y-%m-%d") + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        current_month_end = current_month_end.strftime("%Y-%m-%d")
        
        monthly_assignations = await db.assignations.find({
            "date": {
                "$gte": current_month_start,
                "$lte": current_month_end
            },
            "tenant_id": tenant.id
        }).to_list(1000)
        
        # âš¡ OPTIMIZATION: PrÃ©charger TOUTES les disponibilitÃ©s de la semaine en UNE SEULE requÃªte
        # Cela Ã©vite le problÃ¨me N+1 (une requÃªte par user/garde)
        all_disponibilites = await db.disponibilites.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "statut": "disponible",
            "tenant_id": tenant.id
        }).to_list(10000)
        
        # CrÃ©er un index/dictionnaire pour lookup rapide
        # Structure: {user_id: {date: {type_garde_id: [list of dispos with horaires]}}}
        dispos_lookup = {}
        for dispo in all_disponibilites:
            user_id = dispo.get("user_id")
            date = dispo.get("date")
            type_garde_id = dispo.get("type_garde_id")
            
            if user_id not in dispos_lookup:
                dispos_lookup[user_id] = {}
            if date not in dispos_lookup[user_id]:
                dispos_lookup[user_id][date] = {}
            if type_garde_id not in dispos_lookup[user_id][date]:
                dispos_lookup[user_id][date][type_garde_id] = []
            
            # Stocker la dispo complÃ¨te avec ses horaires
            dispos_lookup[user_id][date][type_garde_id].append({
                "heure_debut": dispo.get("heure_debut"),
                "heure_fin": dispo.get("heure_fin")
            })
        
        # âš¡ OPTIMIZATION: PrÃ©charger TOUTES les indisponibilitÃ©s de la semaine
        all_indisponibilites = await db.disponibilites.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "statut": "indisponible",
            "tenant_id": tenant.id
        }).to_list(10000)
        
        # CrÃ©er un index pour les indisponibilitÃ©s
        # Structure: {user_id: {date: True}}
        # PRIORITÃ‰: Les disponibilitÃ©s manuelles ont prioritÃ© sur les indisponibilitÃ©s auto-gÃ©nÃ©rÃ©es
        indispos_lookup = {}
        for indispo in all_indisponibilites:
            user_id = indispo.get("user_id")
            date = indispo.get("date")
            source = indispo.get("source", "manuel")  # Par dÃ©faut: manuel
            
            # VÃ©rifier s'il existe une disponibilitÃ© manuelle pour ce user/date
            has_manual_dispo = any(
                d.get("user_id") == user_id and 
                d.get("date") == date and 
                d.get("source", "manuel") == "manuel"
                for d in all_disponibilites
            )
            
            # N'ajouter l'indisponibilitÃ© que si:
            # - C'est une indispo manuelle OU
            # - Il n'y a pas de dispo manuelle qui la contredit
            if source == "manuel" or not has_manual_dispo:
                if user_id not in indispos_lookup:
                    indispos_lookup[user_id] = {}
                indispos_lookup[user_id][date] = True
            else:
                logging.info(f"âœ… [CONFLIT RÃ‰SOLU] Indispo auto-gÃ©nÃ©rÃ©e ignorÃ©e pour {user_id} le {date} (dispo manuelle trouvÃ©e)")
        
        # RÃ©cupÃ©rer les paramÃ¨tres d'Ã©quitÃ©
        params_planning = await db.parametres_validation_planning.find_one({"tenant_id": tenant.id})
        periode_equite = params_planning.get("periode_equite", "mensuel") if params_planning else "mensuel"
        periode_equite_jours = params_planning.get("periode_equite_jours", 30) if params_planning else 30
        
        # Calculer la date de dÃ©but de la pÃ©riode d'Ã©quitÃ©
        start_date = datetime.strptime(semaine_debut, "%Y-%m-%d")
        end_date = datetime.strptime(semaine_fin, "%Y-%m-%d")
        date_debut_periode = start_date
        if periode_equite == "hebdomadaire":
            # DÃ©but de la semaine (lundi)
            jours_depuis_lundi = date_debut_periode.weekday()
            date_debut_periode = date_debut_periode - timedelta(days=jours_depuis_lundi)
        elif periode_equite == "bi-hebdomadaire":
            # DÃ©but de la bi-semaine (14 jours glissants)
            date_debut_periode = start_date - timedelta(days=14)
        elif periode_equite == "mensuel":
            # DÃ©but du mois
            date_debut_periode = date_debut_periode.replace(day=1)
        elif periode_equite == "personnalise":
            # PÃ©riode personnalisÃ©e en jours
            date_debut_periode = start_date - timedelta(days=periode_equite_jours)
        
        logging.info(f"ğŸ“Š [Ã‰QUITÃ‰] PÃ©riode: {periode_equite}, DÃ©but: {date_debut_periode}, Jours: {periode_equite_jours if periode_equite == 'personnalise' else 'N/A'}")
        
        # RÃ©cupÃ©rer les assignations de la pÃ©riode d'Ã©quitÃ©
        assignations_periode = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut_periode.strftime("%Y-%m-%d"),
                "$lt": end_date.strftime("%Y-%m-%d")
            }
        }).to_list(length=None)
        
        logging.info(f"ğŸ“Š [Ã‰QUITÃ‰] {len(assignations_periode)} assignations trouvÃ©es pour la pÃ©riode d'Ã©quitÃ©")
        
        # Calculate hours for each user based on equity period (sÃ©parÃ© interne/externe)
        user_monthly_hours_internes = {}
        user_monthly_hours_externes = {}
        for user in users:
            user_hours_internes = 0
            user_hours_externes = 0
            for assignation in assignations_periode:
                if assignation["user_id"] == user["id"]:
                    # Find type garde to get duration
                    type_garde = next((t for t in types_garde if t["id"] == assignation["type_garde_id"]), None)
                    if type_garde:
                        duree = type_garde.get("duree_heures", 8)
                        # SÃ©parer les heures selon le type de garde
                        if type_garde.get("est_garde_externe", False):
                            user_hours_externes += duree
                        else:
                            user_hours_internes += duree
            user_monthly_hours_internes[user["id"]] = user_hours_internes
            user_monthly_hours_externes[user["id"]] = user_hours_externes
        
        logging.info(f"ğŸ“Š [Ã‰QUITÃ‰] Heures calculÃ©es pour {len(users)} utilisateurs sur la pÃ©riode")
        
        # Initialiser la liste des nouvelles assignations
        nouvelles_assignations = []
        
        # REGROUPEMENT DES HEURES - TEMPORAIREMENT DÃ‰SACTIVÃ‰ (cause des doublons)
        # TODO: RÃ©implÃ©menter avec vÃ©rifications correctes de personnel_requis
        regroupements_traites = []
        if False:  # DÃ©sactivÃ© car cause des assignations multiples incorrectes
            # Code de regroupement commentÃ© pour investigation future
            pass
        
        # Attribution automatique logic (5 niveaux de prioritÃ©)
        # nouvelles_assignations dÃ©jÃ  dÃ©clarÃ© plus haut
        
        # ==================== FONCTION HELPER: VÃ‰RIFICATION COUVERTURE HORAIRE ====================
        def dispo_couvre_garde(dispos_list, heure_debut_garde, heure_fin_garde):
            """
            VÃ©rifie si au moins UNE des disponibilitÃ©s couvre COMPLÃˆTEMENT l'horaire de la garde.
            GÃ¨re les gardes qui traversent minuit (ex: 18:00-06:00).
            """
            if not dispos_list or not heure_debut_garde or not heure_fin_garde:
                return False
            
            def time_to_minutes(time_str):
                if not time_str:
                    return None
                h, m = map(int, time_str.split(':'))
                return h * 60 + m
            
            debut_garde_min = time_to_minutes(heure_debut_garde)
            fin_garde_min = time_to_minutes(heure_fin_garde)
            
            if debut_garde_min is None or fin_garde_min is None:
                return False
            
            garde_traverse_minuit = fin_garde_min < debut_garde_min
            
            for dispo in dispos_list:
                debut_dispo_min = time_to_minutes(dispo.get("heure_debut"))
                fin_dispo_min = time_to_minutes(dispo.get("heure_fin"))
                
                if debut_dispo_min is None or fin_dispo_min is None:
                    continue
                
                dispo_traverse_minuit = fin_dispo_min < debut_dispo_min
                
                # Logique de couverture complÃ¨te
                if garde_traverse_minuit and dispo_traverse_minuit:
                    # Les deux traversent minuit - vÃ©rifier si dispo couvre garde
                    if debut_dispo_min <= debut_garde_min and fin_dispo_min >= fin_garde_min:
                        return True
                elif garde_traverse_minuit:
                    # Garde traverse minuit, pas la dispo - impossible de couvrir complÃ¨tement
                    continue
                elif dispo_traverse_minuit:
                    # Dispo traverse minuit, pas la garde - impossible de couvrir une garde qui ne traverse pas minuit
                    continue
                else:
                    # Aucune ne traverse minuit - vÃ©rification standard
                    if debut_dispo_min <= debut_garde_min and fin_dispo_min >= fin_garde_min:
                        return True
            
            return False
        
        # ==================== PRIORISATION DES GARDES PAR COMPÃ‰TENCES ====================
        # Trier les types de garde par criticitÃ© des compÃ©tences requises
        # Les gardes avec compÃ©tences rares/uniques sont traitÃ©es EN PREMIER
        
        def calculate_garde_priority(type_garde):
            """Calcule un score de prioritÃ© pour trier les gardes
            Score plus Ã‰LEVÃ‰ = Plus prioritaire (traitÃ© en premier)
            """
            score = 0
            
            # CRITÃˆRE 1: CompÃ©tences requises (score Ã©levÃ© si compÃ©tences rares)
            competences_requises = type_garde.get("competences_requises", [])
            if competences_requises:
                # Pour chaque compÃ©tence requise, compter combien d'users l'ont
                for comp_id in competences_requises:
                    users_with_comp = sum(1 for u in users if comp_id in u.get("competences", []))
                    if users_with_comp == 0:
                        score += 10000  # CompÃ©tence impossible (personne ne l'a) - prioritÃ© maximale
                    elif users_with_comp == 1:
                        score += 1000   # CompÃ©tence unique (1 seul user) - trÃ¨s haute prioritÃ©
                    elif users_with_comp <= 3:
                        score += 500    # CompÃ©tence rare (2-3 users) - haute prioritÃ©
                    elif users_with_comp <= 5:
                        score += 100    # CompÃ©tence peu commune (4-5 users) - prioritÃ© moyenne
                    else:
                        score += 10     # CompÃ©tence commune (6+ users) - faible prioritÃ©
            
            # CRITÃˆRE 2: Officier obligatoire (aussi une contrainte rare)
            if type_garde.get("officier_obligatoire", False):
                officiers_count = sum(1 for u in users 
                                    if grades_map.get(u.get("grade", ""), {}).get("est_officier", False))
                if officiers_count <= 2:
                    score += 300  # Peu d'officiers disponibles
                else:
                    score += 50   # Plusieurs officiers disponibles
            
            # CRITÃˆRE 3: Personnel requis Ã©levÃ© (plus difficile Ã  remplir)
            personnel_requis = type_garde.get("personnel_requis", 1)
            if personnel_requis >= 3:
                score += 50
            
            return score
        
        # Trier les types de garde par prioritÃ© dÃ©croissante (score Ã©levÃ© en premier)
        types_garde_sorted = sorted(types_garde, key=calculate_garde_priority, reverse=True)
        
        logging.info(f"ğŸ“Š [ATTRIBUTION] Ordre de traitement des gardes (par prioritÃ© de compÃ©tences):")
        for tg in types_garde_sorted[:5]:  # Logger les 5 premiÃ¨res
            priority = calculate_garde_priority(tg)
            comp_names = [c for c in competences if c["id"] in tg.get("competences_requises", [])]
            logging.info(f"  - {tg['nom']}: prioritÃ©={priority}, compÃ©tences={[c['nom'] for c in comp_names]}")
        
        # ==================== FIN PRIORISATION ====================
        
        for type_garde in types_garde_sorted:  # Utiliser la liste triÃ©e au lieu de types_garde
            # Check each day for this type de garde
            for day_offset in range(7):
                current_date = datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=day_offset)
                date_str = current_date.strftime("%Y-%m-%d")
                day_name = current_date.strftime("%A").lower()
                
                # CORRECTION CRITIQUE: Skip if type garde doesn't apply to this day
                jours_app = type_garde.get("jours_application", [])
                if jours_app and len(jours_app) > 0 and day_name not in jours_app:
                    logging.info(f"â­ï¸ [SKIP DAY] {type_garde['nom']} - {date_str} ({day_name}): Jour non applicable (limitÃ© Ã  {jours_app})")
                    continue
                
                # Ã‰TAPE 1: VÃ©rifier si la garde est dÃ©jÃ  complÃ¨te
                existing_for_garde = [a for a in existing_assignations 
                                     if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                
                personnel_requis = type_garde.get("personnel_requis", 1)
                personnel_assigne = len(existing_for_garde)
                
                # ğŸ” LOG pour debug sur-assignation
                logging.info(f"ğŸ” [ASSIGNATION] {type_garde['nom']} - {date_str}: {personnel_assigne}/{personnel_requis} assignÃ©s")
                
                # Si dÃ©jÃ  complet ou plus, passer Ã  la garde suivante
                if personnel_assigne >= personnel_requis:
                    logging.info(f"âœ… [SKIP] {type_garde['nom']} - {date_str}: Garde dÃ©jÃ  complÃ¨te ({personnel_assigne}/{personnel_requis})")
                    continue  # Garde dÃ©jÃ  complÃ¨te, ne rien ajouter
                
                # Calculer combien de pompiers il faut encore assigner
                places_restantes = personnel_requis - personnel_assigne
                
                # Find available users for this slot
                available_users = []
                for user in users:
                    # VÃ‰RIFICATION CRITIQUE: Ã‰viter les conflits d'horaires
                    # Un utilisateur ne peut pas Ãªtre sur 2 gardes qui se chevauchent
                    user_a_conflit_horaire = False
                    
                    # RÃ©cupÃ©rer les horaires de la garde actuelle
                    heure_debut_actuelle = type_garde.get("heure_debut", "")
                    heure_fin_actuelle = type_garde.get("heure_fin", "")
                    
                    for assignation in existing_assignations:
                        if assignation["user_id"] == user["id"] and assignation["date"] == date_str:
                            # L'utilisateur est dÃ©jÃ  assignÃ© Ã  une garde ce jour
                            garde_existante = next((g for g in types_garde if g["id"] == assignation["type_garde_id"]), None)
                            if garde_existante:
                                # VÃ©rifier si les horaires se chevauchent RÃ‰ELLEMENT
                                heure_debut_existante = garde_existante.get("heure_debut", "")
                                heure_fin_existante = garde_existante.get("heure_fin", "")
                                
                                # VÃ©rification intelligente de chevauchement avec support des gardes traversant minuit
                                if heure_debut_actuelle and heure_fin_actuelle and heure_debut_existante and heure_fin_existante:
                                    # Convertir les heures en minutes depuis minuit pour comparaison correcte
                                    def time_to_minutes(time_str):
                                        h, m = map(int, time_str.split(':'))
                                        return h * 60 + m
                                    
                                    debut_actuelle_min = time_to_minutes(heure_debut_actuelle)
                                    fin_actuelle_min = time_to_minutes(heure_fin_actuelle)
                                    debut_existante_min = time_to_minutes(heure_debut_existante)
                                    fin_existante_min = time_to_minutes(heure_fin_existante)
                                    
                                    # DÃ©tecter si les gardes traversent minuit
                                    actuelle_traverse_minuit = fin_actuelle_min < debut_actuelle_min
                                    existante_traverse_minuit = fin_existante_min < debut_existante_min
                                    
                                    # Logique de chevauchement selon les cas
                                    if actuelle_traverse_minuit and existante_traverse_minuit:
                                        # Les deux traversent minuit - elles se chevauchent forcÃ©ment
                                        chevauchement = True
                                    elif actuelle_traverse_minuit:
                                        # Actuelle traverse minuit (ex: 18:00-06:00)
                                        # Chevauche si existante commence avant fin_actuelle OU termine aprÃ¨s debut_actuelle
                                        chevauchement = (debut_existante_min < fin_actuelle_min) or (fin_existante_min > debut_actuelle_min)
                                    elif existante_traverse_minuit:
                                        # Existante traverse minuit
                                        chevauchement = (debut_actuelle_min < fin_existante_min) or (fin_actuelle_min > debut_existante_min)
                                    else:
                                        # Aucune ne traverse minuit - logique standard
                                        chevauchement = (debut_actuelle_min < fin_existante_min) and (debut_existante_min < fin_actuelle_min)
                                    
                                    if chevauchement:
                                        user_a_conflit_horaire = True
                                        logging.info(f"âŒ [CONFLIT HORAIRE] {user['prenom']} {user['nom']} dÃ©jÃ  sur {garde_existante['nom']} ({heure_debut_existante}-{heure_fin_existante}) chevauche {type_garde['nom']} ({heure_debut_actuelle}-{heure_fin_actuelle})")
                                        logging.info(f"   [DEBUG CONFLIT] Garde existante externe: {garde_existante.get('est_garde_externe', False)}, Garde actuelle externe: {type_garde.get('est_garde_externe', False)}")
                                        break
                                else:
                                    # Si pas d'horaires dÃ©finis, on considÃ¨re conflit par sÃ©curitÃ©
                                    user_a_conflit_horaire = True
                                    logging.info(f"âš ï¸ [CONFLIT] {user['prenom']} {user['nom']} dÃ©jÃ  assignÃ© Ã  {garde_existante['nom']} le {date_str} (horaires non dÃ©finis)")
                                    break
                    
                    if user_a_conflit_horaire:
                        continue  # Skip cet utilisateur pour Ã©viter le conflit
                    
                    # VÃ‰RIFICATION GLOBALE: Gestion de la limite heures_max_semaine
                    # RÃˆGLE IMPORTANTE: Les gardes EXTERNES n'ont AUCUNE limite d'heures
                    # MÃªme si un employÃ© a dÃ©passÃ© ses heures max en INTERNE, il peut toujours avoir des gardes EXTERNES
                    if type_garde.get("est_garde_externe", False):
                        # Garde EXTERNE: Pas de vÃ©rification d'heures max
                        logging.info(f"âœ… [GARDE_EXTERNE] {user['prenom']} {user['nom']}: Pas de limite d'heures pour garde externe {type_garde['nom']}")
                    else:
                        # Garde INTERNE: VÃ©rifier heures_max_semaine POUR LA SEMAINE CALENDAIRE de cette garde
                        heures_max_user = user.get("heures_max_semaine", 40)
                        
                        # Calculer la semaine calendaire de cette garde (lundi = dÃ©but de semaine)
                        garde_date = datetime.strptime(date_str, "%Y-%m-%d")
                        # Trouver le lundi de cette semaine
                        days_since_monday = garde_date.weekday()  # 0 = lundi, 6 = dimanche
                        semaine_start = garde_date - timedelta(days=days_since_monday)
                        semaine_end = semaine_start + timedelta(days=6)
                        semaine_start_str = semaine_start.strftime("%Y-%m-%d")
                        semaine_end_str = semaine_end.strftime("%Y-%m-%d")
                        
                        if activer_heures_sup:
                            # Heures sup activÃ©es : peut dÃ©passer heures_max_user mais respecter limite systÃ¨me si elle existe
                            # Pour l'instant, on ne limite pas (les heures sup sont autorisÃ©es)
                            pass  # Pas de skip, autoriser l'attribution
                        else:
                            # Heures sup DÃ‰SACTIVÃ‰ES : appliquer limite intelligente
                            # Si employÃ© a mis > 42h, on limite Ã  42h (overtime standard = au-delÃ  de 42h)
                            # Si employÃ© a mis < 42h (ex: 25h, 30h), on respecte sa limite
                            heures_max_user = min(heures_max_user, 42)
                            logging.info(f"ğŸ”’ [LIMITE] {user['prenom']} {user['nom']}: heures_max_semaine limitÃ©e Ã  {heures_max_user}h (heures sup dÃ©sactivÃ©es)")
                            # Heures sup DÃ‰SACTIVÃ‰ES : vÃ©rifier strictement heures_max_semaine
                            # CORRECTION CRITIQUE: Calculer les heures pour LA SEMAINE CALENDAIRE de cette garde
                            # (lundi Ã  dimanche), pas pour toute la pÃ©riode d'attribution
                            heures_semaine_actuelle = 0
                            
                            # Compter les assignations EXISTANTES + NOUVELLES (avec dÃ©duplication par ID)
                            assignations_vues = set()  # Pour Ã©viter de compter 2 fois la mÃªme assignation
                            toutes_assignations_semaine = existing_assignations + nouvelles_assignations
                            
                            for assignation in toutes_assignations_semaine:
                                # DÃ©duplication: ne compter chaque assignation qu'une seule fois
                                assignation_key = f"{assignation['user_id']}_{assignation['type_garde_id']}_{assignation['date']}"
                                if assignation_key in assignations_vues:
                                    continue
                                assignations_vues.add(assignation_key)
                                
                                if assignation["user_id"] == user["id"]:
                                    # CORRECTION CRITIQUE: VÃ©rifier que l'assignation est dans LA SEMAINE CALENDAIRE de cette garde
                                    # (pas dans toute la pÃ©riode d'attribution)
                                    if semaine_start_str <= assignation["date"] <= semaine_end_str:
                                        type_g = next((t for t in types_garde if t["id"] == assignation["type_garde_id"]), None)
                                        if type_g:
                                            # Ne compter QUE les gardes internes (gardes externes ne sont pas des heures travaillÃ©es)
                                            if not type_g.get("est_garde_externe", False):
                                                heures_semaine_actuelle += type_g.get("duree_heures", 8)
                            
                            # Log spÃ©cifique pour SÃ©bastien Charest
                            if user.get("email") == "sebas.charest18@hotmail.com":
                                logging.info(f"ğŸ” [HEURES] SÃ©bastien Charest - VÃ©rification heures:")
                                logging.info(f"    heures_max_semaine: {heures_max_user}")
                                logging.info(f"    heures_semaine_actuelle (INTERNES uniquement): {heures_semaine_actuelle}")
                                logging.info(f"    duree_garde: {type_garde.get('duree_heures', 8)}")
                                logging.info(f"    est_garde_externe: {type_garde.get('est_garde_externe', False)}")
                                logging.info(f"    total_si_assignÃ©: {heures_semaine_actuelle + type_garde.get('duree_heures', 8)}")
                                logging.info(f"    dÃ©passe_limite: {heures_semaine_actuelle + type_garde.get('duree_heures', 8) > heures_max_user}")
                            
                            # Pour les gardes INTERNES uniquement : vÃ©rifier heures_max_semaine
                            # Pour les gardes EXTERNES : pas de vÃ©rification heures (ce ne sont pas des heures travaillÃ©es)
                            if not type_garde.get("est_garde_externe", False):
                                # Ne PAS attribuer si dÃ©passe heures_max_semaine
                                if heures_semaine_actuelle + type_garde.get("duree_heures", 8) > heures_max_user:
                                    if user.get("email") == "sebas.charest18@hotmail.com":
                                        logging.info(f"âŒ [HEURES] SÃ©bastien Charest EXCLU pour dÃ©passement limite heures!")
                                    continue  # Skip si dÃ©passe la limite hebdo
                    
                    # Ã‰TAPE 2: Check if user has availability 
                    # Temps partiel : DOIVENT dÃ©clarer disponibilitÃ© (obligatoire) ET accepter les gardes externes
                    # Temps plein : Ã‰ligibles comme backup si pas assez de temps partiel disponibles ET acceptent les gardes externes
                    
                    # NOUVELLE VÃ‰RIFICATION: Gardes externes - vÃ©rifier accepte_gardes_externes
                    if type_garde.get("est_garde_externe", False):
                        if not user.get("accepte_gardes_externes", True):  # Default True pour compatibilitÃ©
                            # Log spÃ©cifique pour debug
                            if user.get("email") == "sebas.charest18@hotmail.com":
                                logging.info(f"âŒ [GARDE_EXTERNE] SÃ©bastien Charest EXCLU: accepte_gardes_externes=False")
                            continue  # Skip si n'accepte pas les gardes externes
                    
                    if user["type_emploi"] == "temps_partiel":
                        # VÃ©rifier si a dÃ©clarÃ© une INDISPONIBILITÃ‰ (exclusion totale)
                        has_indispo = (
                            user["id"] in indispos_lookup and
                            date_str in indispos_lookup[user["id"]]
                        )
                        
                        if has_indispo:
                            continue  # Skip temps partiel si INDISPONIBLE
                        
                        # Note: Les temps partiel sans dispo (stand-by) sont maintenant inclus
                        # Ils seront triÃ©s en prioritÃ© 2 dans l'Ã©tape 4
                    
                    # Temps plein : Ã©ligibles automatiquement pour gardes vacantes (backup)
                    # Note: Les temps plein sont traitÃ©s aprÃ¨s les temps partiel pour prioritÃ©
                    # VÃ©rification heures/compÃ©tences dÃ©jÃ  faite avant
                    
                    # VÃ‰RIFICATION : Check if user already assigned to THIS TYPE DE GARDE on this date
                    # Important : On permet plusieurs gardes diffÃ©rentes le mÃªme jour (ex: matin + aprÃ¨s-midi)
                    already_assigned = next((a for a in existing_assignations 
                                           if a["date"] == date_str 
                                           and a["user_id"] == user["id"]
                                           and a["type_garde_id"] == type_garde["id"]), None)
                    if already_assigned:
                        continue
                    
                    # VÃ‰RIFICATION DES COMPÃ‰TENCES REQUISES
                    competences_requises = type_garde.get("competences_requises", [])
                    if competences_requises:
                        # VÃ©rifier si l'utilisateur possÃ¨de toutes les compÃ©tences requises
                        user_competences = user.get("competences", [])
                        has_all_competences = all(comp_id in user_competences for comp_id in competences_requises)
                        
                        # LOG DÃ‰TAILLÃ‰ pour TOUTES les gardes (pas seulement PrÃ©ventionniste)
                        logging.info(f"ğŸ” [COMPETENCE CHECK] Garde: {type_garde['nom']}")
                        logging.info(f"   User: {user['prenom']} {user['nom']} (Grade: {user.get('grade', 'N/A')})")
                        logging.info(f"   CompÃ©tences requises: {competences_requises}")
                        logging.info(f"   CompÃ©tences user: {user_competences}")
                        logging.info(f"   A toutes les compÃ©tences: {has_all_competences}")
                        
                        if not has_all_competences:
                            # CORRECTION: VÃ©rification stricte des compÃ©tences - AUCUNE exception
                            # Un Premier RÃ©pondant ne peut PAS faire une garde de Pompier
                            # Un Pompier Auxiliaire ne peut PAS faire une garde nÃ©cessitant Pompier 1
                            logging.info(f"âŒ [COMPETENCE] {user['prenom']} {user['nom']} (Grade: {user.get('grade')}) EXCLU - compÃ©tences manquantes")
                            continue  # Skip si compÃ©tences manquantes - AUCUNE EXCEPTION
                        else:
                            logging.info(f"âœ… [COMPETENCE] {user['prenom']} {user['nom']} ELIGIBLE - a toutes les compÃ©tences")
                    
                    # DÃ‰DUPLICATION CRITIQUE : Comparer par ID car dict comparison ne fonctionne pas
                    if user["id"] not in [u["id"] for u in available_users]:
                        available_users.append(user)
                
                if not available_users:
                    continue
                
                # Ã‰TAPE 3: Apply grade requirements (1 officier obligatoire si configurÃ©)
                # Logique amÃ©liorÃ©e avec support fonction_superieur pour officiers
                # Un Lieutenant en fonction supÃ©rieure peut couvrir un poste de Capitaine (N+1)
                if type_garde.get("officier_obligatoire", False):
                    # RÃ©cupÃ©rer le grade minimum requis pour cette garde (si spÃ©cifiÃ©)
                    grade_minimum_requis = type_garde.get("grade_minimum_requis", None)
                    
                    # VÃ©rifier s'il y a dÃ©jÃ  un officier assignÃ© Ã  cette garde
                    officier_deja_assigne = False
                    for assignation in existing_for_garde:
                        assigned_user = next((u for u in users if u["id"] == assignation["user_id"]), None)
                        if assigned_user:
                            grade_obj = grades_map.get(assigned_user.get("grade"))
                            if (grade_obj and grade_obj.get("est_officier", False)) or assigned_user.get("fonction_superieur", False):
                                officier_deja_assigne = True
                                break
                    
                    # Si aucun officier n'est encore assignÃ©, appliquer la contrainte
                    if not officier_deja_assigne:
                        logging.info(f"ğŸ–ï¸ [OFFICIER] {type_garde['nom']} - {date_str}: Aucun officier assignÃ©, application de la contrainte")
                        
                        # SÃ©parer en 3 catÃ©gories avec priorisation
                        officers_grade_exact = []      # Grade exact demandÃ©
                        officers_fonction_sup = []     # Officiers N-1 avec fonction supÃ©rieure
                        pompiers_fonction_sup = []     # Pompiers (non-officiers) avec fonction supÃ©rieure
                        
                        for u in available_users:
                            grade_obj = grades_map.get(u.get("grade"))
                            
                            if grade_obj and grade_obj.get("est_officier", False):
                                # C'est un officier
                                if grade_minimum_requis:
                                    grade_requis_obj = grades_map.get(grade_minimum_requis)
                                    
                                    if u.get("grade") == grade_minimum_requis:
                                        # Grade exact - PrioritÃ© 1
                                        officers_grade_exact.append(u)
                                    elif u.get("fonction_superieur", False) and grade_requis_obj:
                                        # Officier avec fonction supÃ©rieure - vÃ©rifier si niveau N-1
                                        niveau_user = grade_obj.get("niveau_hierarchique", 0)
                                        niveau_requis = grade_requis_obj.get("niveau_hierarchique", 0)
                                        
                                        if niveau_user == niveau_requis - 1:
                                            # Exactement 1 niveau en dessous - PrioritÃ© 2
                                            officers_fonction_sup.append(u)
                                            logging.info(f"âœ… [FONCTION_SUP] {u['prenom']} {u['nom']} ({u['grade']}) peut couvrir {grade_minimum_requis}")
                                        else:
                                            # Trop d'Ã©cart de niveau - ne pas considÃ©rer
                                            pass
                                    else:
                                        # Officier mais grade insuffisant et pas fonction_superieur
                                        pass
                                else:
                                    # Aucun grade spÃ©cifique requis, tous les officiers sont OK
                                    officers_grade_exact.append(u)
                            elif u.get("fonction_superieur", False):
                                # Non-officier avec fonction supÃ©rieure (pompier)
                                pompiers_fonction_sup.append(u)
                        
                        # Application de la prioritÃ©
                        # PrioritÃ© 1: Officiers avec grade exact
                        if officers_grade_exact:
                            available_users = officers_grade_exact
                            logging.info(f"âœ… [OFFICIER] {len(officers_grade_exact)} officiers grade exact trouvÃ©s")
                        # PrioritÃ© 2: Officiers N-1 avec fonction supÃ©rieure
                        elif officers_fonction_sup:
                            available_users = officers_fonction_sup
                            logging.info(f"âœ… [OFFICIER] {len(officers_fonction_sup)} officiers fonction supÃ©rieure (N-1) trouvÃ©s")
                        # PrioritÃ© 3 (Fallback): Pompiers fonction_superieur si aucun officier
                        elif pompiers_fonction_sup:
                            available_users = pompiers_fonction_sup
                            logging.info(f"âœ… [OFFICIER] {len(pompiers_fonction_sup)} pompiers fonction supÃ©rieur trouvÃ©s (fallback)")
                        # PrioritÃ© 4: Aucun candidat qualifiÃ©
                        else:
                            logging.warning(f"âš ï¸ [OFFICIER] Aucun officier ou fonction supÃ©rieur disponible")
                            # Si aucun officier trouvÃ© mais contrainte active, skip cette garde
                            available_users = []
                    else:
                        logging.info(f"âœ… [OFFICIER] {type_garde['nom']} - {date_str}: Officier dÃ©jÃ  assignÃ©, contrainte respectÃ©e - tous les candidats Ã©ligibles")
                        # CORRECTION: RÃ©initialiser available_users pour inclure tous les candidats
                        # IMPORTANT: Le tri par niveaux N2-N5 sera fait APRÃˆS cette Ã©tape
                        available_users = []
                        for user in users:
                            # RÃ©appliquer filtres de base seulement
                            if user.get("statut") != "Actif":
                                continue
                            
                            # Check indisponibilitÃ©
                            if user["id"] in indispos_lookup and date_str in indispos_lookup[user["id"]]:
                                continue
                            
                            # Check dÃ©jÃ  assignÃ©
                            already_assigned = next((a for a in existing_assignations 
                                                   if a["date"] == date_str 
                                                   and a["user_id"] == user["id"]
                                                   and a["type_garde_id"] == type_garde["id"]), None)
                            if already_assigned:
                                continue
                            
                            # Check compÃ©tences
                            competences_requises = type_garde.get("competences_requises", [])
                            if competences_requises:
                                user_competences = user.get("competences", [])
                                if not all(comp_id in user_competences for comp_id in competences_requises):
                                    continue
                            
                            available_users.append(user)
                
                # Ã‰TAPE 4: TRI PAR NIVEAUX DE PRIORITÃ‰ (N2, N3, N4, N5)
                # IMPORTANT: Ce tri doit se faire ICI, aprÃ¨s l'Ã©tape officier
                # Pour garantir que les niveaux sont appliquÃ©s sur la liste finale de candidats
                
                # CatÃ©gorie 1: Temps partiel DISPONIBLES (ont dÃ©clarÃ© une disponibilitÃ©)
                tp_disponibles = []
                # CatÃ©gorie 2: Temps partiel STAND-BY (rien dÃ©clarÃ©, ni dispo ni indispo)
                tp_standby = []
                # CatÃ©gorie 3: Temps plein INCOMPLETS (< heures_max_semaine)
                tf_incomplets = []
                # CatÃ©gorie 4: Temps plein COMPLETS (â‰¥ heures_max_semaine)
                tf_complets = []
                
                for u in available_users:
                    # Log spÃ©cifique pour Guillaume Dubeau
                    if "guillaume" in u.get("prenom", "").lower() and "dubeau" in u.get("nom", "").lower():
                        logging.info(f"ğŸ” [GUILLAUME] Traitement pour {type_garde['nom']} - {date_str}")
                        logging.info(f"    Type emploi: {u['type_emploi']}")
                        logging.info(f"    Statut: {u.get('statut', 'N/A')}")
                    
                    if u["type_emploi"] == "temps_partiel":
                        # CORRECTION CRITIQUE: VÃ©rifier si a dÃ©clarÃ© une disponibilitÃ© QUI COUVRE l'horaire de la garde
                        has_dispo_covering = False
                        
                        if u["id"] in dispos_lookup and date_str in dispos_lookup[u["id"]]:
                            # RÃ©cupÃ©rer les horaires de la garde
                            heure_debut_garde = type_garde.get("heure_debut")
                            heure_fin_garde = type_garde.get("heure_fin")
                            
                            # VÃ©rifier disponibilitÃ© spÃ©cifique pour ce type de garde
                            if type_garde["id"] in dispos_lookup[u["id"]][date_str]:
                                dispos_list = dispos_lookup[u["id"]][date_str][type_garde["id"]]
                                if dispo_couvre_garde(dispos_list, heure_debut_garde, heure_fin_garde):
                                    has_dispo_covering = True
                                    logging.info(f"âœ… [DISPO_COUVRE] {u['prenom']} {u['nom']} a une dispo qui couvre {type_garde['nom']} ({heure_debut_garde}-{heure_fin_garde})")
                                else:
                                    logging.info(f"âš ï¸ [DISPO_PARTIELLE] {u['prenom']} {u['nom']} a une dispo pour {type_garde['nom']} mais ne couvre pas l'horaire complet")
                            
                            # OU disponibilitÃ© gÃ©nÃ©rale (type_garde_id = None)
                            if not has_dispo_covering and None in dispos_lookup[u["id"]][date_str]:
                                dispos_list = dispos_lookup[u["id"]][date_str][None]
                                if dispo_couvre_garde(dispos_list, heure_debut_garde, heure_fin_garde):
                                    has_dispo_covering = True
                                    logging.info(f"âœ… [DISPO_GENERALE_COUVRE] {u['prenom']} {u['nom']} a une dispo gÃ©nÃ©rale qui couvre {type_garde['nom']} ({heure_debut_garde}-{heure_fin_garde})")
                                else:
                                    logging.info(f"âš ï¸ [DISPO_GENERALE_PARTIELLE] {u['prenom']} {u['nom']} a une dispo gÃ©nÃ©rale mais ne couvre pas l'horaire complet")
                        
                        # VÃ©rifier si a dÃ©clarÃ© une indisponibilitÃ© (dÃ©jÃ  filtrÃ© normalement, mais double vÃ©rification)
                        has_indispo = (
                            u["id"] in indispos_lookup and
                            date_str in indispos_lookup[u["id"]]
                        )
                        
                        if has_dispo_covering:
                            tp_disponibles.append(u)
                            logging.info(f"âœ… [N2] {u['prenom']} {u['nom']} ajoutÃ© Ã  T.Partiel DISPONIBLES pour {type_garde['nom']}")
                        elif not has_indispo:  # Ni dispo ni indispo = stand-by
                            tp_standby.append(u)
                            logging.info(f"âš ï¸ [N3] {u['prenom']} {u['nom']} ajoutÃ© Ã  T.Partiel STAND-BY (pas de dispo couvrant l'horaire)")
                        # Si indispo, ne rien faire (exclu)
                    else:  # temps_plein
                        # Calculer les heures de LA SEMAINE CALENDAIRE de cette garde (lundi-dimanche)
                        # CORRECTION: Inclure TOUTES les assignations (existantes + nouvelles) avec dÃ©duplication
                        
                        # Calculer la semaine calendaire de cette garde (mÃªme logique que plus haut)
                        garde_date = datetime.strptime(date_str, "%Y-%m-%d")
                        days_since_monday = garde_date.weekday()
                        semaine_start_tf = garde_date - timedelta(days=days_since_monday)
                        semaine_end_tf = semaine_start_tf + timedelta(days=6)
                        semaine_start_tf_str = semaine_start_tf.strftime("%Y-%m-%d")
                        semaine_end_tf_str = semaine_end_tf.strftime("%Y-%m-%d")
                        
                        heures_semaine_actuelle = 0
                        assignations_vues_tf = set()
                        toutes_assignations_tf = existing_assignations + nouvelles_assignations
                        
                        for assignation in toutes_assignations_tf:
                            # DÃ©duplication
                            assignation_key = f"{assignation['user_id']}_{assignation['type_garde_id']}_{assignation['date']}"
                            if assignation_key in assignations_vues_tf:
                                continue
                            assignations_vues_tf.add(assignation_key)
                            
                            if assignation["user_id"] == u["id"]:
                                # CORRECTION CRITIQUE: VÃ©rifier que c'est dans LA SEMAINE CALENDAIRE de cette garde
                                if semaine_start_tf_str <= assignation["date"] <= semaine_end_tf_str:
                                    type_g = next((t for t in types_garde if t["id"] == assignation["type_garde_id"]), None)
                                    if type_g and not type_g.get("est_garde_externe", False):
                                        heures_semaine_actuelle += type_g.get("duree_heures", 8)
                        
                        heures_max_user = u.get("heures_max_semaine", 40)
                        
                        if heures_semaine_actuelle < heures_max_user:
                            tf_incomplets.append(u)
                        else:
                            tf_complets.append(u)
                
                # Trier chaque catÃ©gorie par Ã©quitÃ© (heures du mois) puis anciennetÃ©
                def sort_by_equity_and_seniority(users_list):
                    if type_garde.get("est_garde_externe", False):
                        users_list.sort(key=lambda u: (
                            user_monthly_hours_externes.get(u["id"], 0),  # Ã‰quitÃ© mensuelle
                            -parse_date_flexible(u.get("date_embauche", "1900-01-01")).timestamp()  # AnciennetÃ© (plus ancien = prioritÃ©)
                        ))
                    else:
                        users_list.sort(key=lambda u: (
                            user_monthly_hours_internes.get(u["id"], 0),  # Ã‰quitÃ© mensuelle
                            -parse_date_flexible(u.get("date_embauche", "1900-01-01")).timestamp()  # AnciennetÃ©
                        ))
                
                # Fonction helper pour parse_date_flexible
                def parse_date_flexible(date_str):
                    try:
                        return datetime.strptime(date_str, "%Y-%m-%d")
                    except:
                        try:
                            return datetime.strptime(date_str, "%d/%m/%Y")
                        except:
                            return datetime(1900, 1, 1)
                
                sort_by_equity_and_seniority(tp_disponibles)
                sort_by_equity_and_seniority(tp_standby)
                
                # Pour temps plein incomplets : trier par heures manquantes (plus loin de limite = prioritÃ©)
                def calculer_heures_user_semaine(user_id):
                    """Calcule les heures internes d'un user pour LA SEMAINE CALENDAIRE de cette garde"""
                    # Utiliser la mÃªme semaine calendaire que calculÃ©e plus haut
                    heures = 0
                    assignations_vues_sort = set()
                    toutes_assign = existing_assignations + nouvelles_assignations
                    for a in toutes_assign:
                        key = f"{a['user_id']}_{a['type_garde_id']}_{a['date']}"
                        if key in assignations_vues_sort:
                            continue
                        assignations_vues_sort.add(key)
                        
                        # CORRECTION CRITIQUE: VÃ©rifier la semaine calendaire de cette garde
                        if a["user_id"] == user_id and semaine_start_tf_str <= a["date"] <= semaine_end_tf_str:
                            type_g = next((t for t in types_garde if t["id"] == a["type_garde_id"]), None)
                            if type_g and not type_g.get("est_garde_externe", False):
                                heures += type_g.get("duree_heures", 8)
                    return heures
                
                tf_incomplets.sort(key=lambda u: (
                    # Heures manquantes (plus c'est Ã©levÃ©, plus prioritaire)
                    -(u.get("heures_max_semaine", 40) - calculer_heures_user_semaine(u["id"])),
                    user_monthly_hours_externes.get(u["id"], 0) if type_garde.get("est_garde_externe", False) else user_monthly_hours_internes.get(u["id"], 0),
                    -parse_date_flexible(u.get("date_embauche", "1900-01-01")).timestamp()
                ))
                
                sort_by_equity_and_seniority(tf_complets)
                
                # CORRECTION CRITIQUE: Filtrer selon les niveaux d'attribution actifs
                liste_niveaux = []
                if niveaux_actifs["niveau_2"]:
                    liste_niveaux.extend(tp_disponibles)
                else:
                    logging.info(f"âš ï¸ [NIVEAU 2 DÃ‰SACTIVÃ‰] {len(tp_disponibles)} T.Partiel disponibles exclus")
                
                if niveaux_actifs["niveau_3"]:
                    liste_niveaux.extend(tp_standby)
                else:
                    logging.info(f"âš ï¸ [NIVEAU 3 DÃ‰SACTIVÃ‰] {len(tp_standby)} T.Partiel stand-by exclus")
                
                if niveaux_actifs["niveau_4"]:
                    liste_niveaux.extend(tf_incomplets)
                else:
                    logging.info(f"âš ï¸ [NIVEAU 4 DÃ‰SACTIVÃ‰] {len(tf_incomplets)} T.Plein incomplets exclus")
                
                if niveaux_actifs["niveau_5"]:
                    if activer_heures_sup:
                        liste_niveaux.extend(tf_complets)
                    else:
                        logging.info(f"âš ï¸ [NIVEAU 5] Heures sup dÃ©sactivÃ©es - {len(tf_complets)} T.Plein complets exclus")
                else:
                    logging.info(f"âš ï¸ [NIVEAU 5 DÃ‰SACTIVÃ‰] {len(tf_complets)} T.Plein complets exclus")
                
                # Reconstruire available_users avec SEULEMENT les niveaux actifs
                available_users = liste_niveaux
                
                logging.info(f"ğŸ“Š [PRIORITÃ‰ FILTRÃ‰E] {type_garde['nom']} - {date_str}:")
                logging.info(f"    T.Partiel Disponibles: {len(tp_disponibles)} {'âœ…' if niveaux_actifs['niveau_2'] else 'âŒ EXCLUS'}")
                logging.info(f"    T.Partiel Stand-by: {len(tp_standby)} {'âœ…' if niveaux_actifs['niveau_3'] else 'âŒ EXCLUS'}")
                logging.info(f"    T.Plein Incomplets: {len(tf_incomplets)} {'âœ…' if niveaux_actifs['niveau_4'] else 'âŒ EXCLUS'}")
                logging.info(f"    T.Plein Complets: {len(tf_complets)} {'âœ…' if niveaux_actifs['niveau_5'] and activer_heures_sup else 'âŒ EXCLUS'}")
                logging.info(f"    Total candidats aprÃ¨s filtrage: {len(available_users)}")
                
                # Ã‰TAPE 5: Les candidats sont dÃ©jÃ  triÃ©s par prioritÃ©, Ã©quitÃ© et anciennetÃ©
                # Utiliser directement available_users
                users_with_min_hours = available_users  # DÃ©jÃ  triÃ©s correctement
                
                # Assigner autant de pompiers que nÃ©cessaire pour remplir la garde
                pompiers_assignes_cette_iteration = 0
                
                # ğŸ” DEBUG LOGGING pour diagnostic auto-attribution
                logging.info(f"ğŸ” [DEBUG] {type_garde['nom']} - {date_str}:")
                logging.info(f"    places_restantes={places_restantes}")
                logging.info(f"    available_users={len(available_users)} utilisateurs")
                if available_users:
                    logging.info(f"    premier available_user: {available_users[0].get('prenom')} {available_users[0].get('nom')} ({available_users[0].get('type_emploi')})")
                logging.info(f"    users_with_min_hours={len(users_with_min_hours)} utilisateurs")
                if users_with_min_hours:
                    logging.info(f"    premier min_hours_user: {users_with_min_hours[0].get('prenom')} {users_with_min_hours[0].get('nom')}")
                
                for _ in range(places_restantes):
                    if not users_with_min_hours:
                        break  # Plus de pompiers disponibles
                    
                    # Select the best candidate
                    selected_user = users_with_min_hours[0]
                    
                    # GÃ©nÃ©rer la justification dÃ©taillÃ©e
                    justification = await generer_justification_attribution(
                        selected_user=selected_user,
                        all_candidates=available_users,
                        type_garde=type_garde,
                        date_str=date_str,
                        user_monthly_hours_internes=user_monthly_hours_internes,
                        user_monthly_hours_externes=user_monthly_hours_externes,
                        activer_heures_sup=activer_heures_sup,
                        existing_assignations=existing_assignations,
                        disponibilites_evaluees=None,
                        dispos_lookup=dispos_lookup  # Passer le lookup pour vÃ©rifier les dispos
                    )
                    
                    # CrÃ©er l'assignation avec justification
                    assignation_obj = Assignation(
                        user_id=selected_user["id"],
                        type_garde_id=type_garde["id"],
                        date=date_str,
                        assignation_type="auto",
                        tenant_id=tenant.id,
                        justification=justification,
                        notes_admin=None,
                        justification_historique=[]
                    )
                    
                    await db.assignations.insert_one(assignation_obj.dict())
                    nouvelles_assignations.append(assignation_obj.dict())
                    existing_assignations.append(assignation_obj.dict())
                    pompiers_assignes_cette_iteration += 1
                    
                    # Log de l'assignation pour debug
                    duree = type_garde.get("duree_heures", 8)
                    type_garde_str = "EXTERNE" if type_garde.get("est_garde_externe", False) else "INTERNE"
                    logging.info(f"âœ… [ASSIGNATION] {selected_user['prenom']} {selected_user['nom']} assignÃ© Ã  {type_garde['nom']} ({type_garde_str}, {duree}h) le {date_str}")
                    
                    # Update monthly hours for next iteration (compteur appropriÃ© selon type de garde)
                    if type_garde.get("est_garde_externe", False):
                        user_monthly_hours_externes[selected_user["id"]] += duree
                        logging.info(f"   Heures externes mois: {user_monthly_hours_externes[selected_user['id']]}h")
                    else:
                        user_monthly_hours_internes[selected_user["id"]] += duree
                        logging.info(f"   Heures internes mois: {user_monthly_hours_internes[selected_user['id']]}h")
                    
                    # Retirer ce pompier de la liste des disponibles pour cette garde
                    users_with_min_hours.pop(0)
        
        # Logs de performance
        perf_end = time.time()
        perf_elapsed = perf_end - perf_start
        logging.info(f"â±ï¸ [PERF] Semaine {semaine_debut} traitÃ©e en {perf_elapsed:.2f}s - {len(nouvelles_assignations)} assignations crÃ©Ã©es")
        
        return len(nouvelles_assignations)
        
    except Exception as e:
        logging.error(f"âŒ [ERROR] Erreur traitement semaine {semaine_debut}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Erreur traitement semaine: {str(e)}")

# Endpoint pour mettre Ã  jour les notes admin d'une assignation
@api_router.put("/{tenant_slug}/assignations/{assignation_id}/notes")
async def update_assignation_notes(
    tenant_slug: str,
    assignation_id: str,
    notes: str = Body(..., embed=True),
    current_user: User = Depends(get_current_user)
):
    """Permet Ã  un admin de mettre Ã  jour les notes sur une assignation auto"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Trouver l'assignation
    assignation = await db.assignations.find_one({
        "id": assignation_id,
        "tenant_id": tenant.id
    })
    
    if not assignation:
        raise HTTPException(status_code=404, detail="Assignation non trouvÃ©e")
    
    # Mettre Ã  jour les notes
    await db.assignations.update_one(
        {"id": assignation_id},
        {"$set": {"notes_admin": notes}}
    )
    
    return {"message": "Notes mises Ã  jour avec succÃ¨s", "notes": notes}

# Endpoint pour gÃ©nÃ©rer le rapport d'audit des assignations automatiques
@api_router.get("/{tenant_slug}/planning/rapport-audit")
async def generer_rapport_audit_assignations(
    tenant_slug: str,
    mois: str,  # Format: YYYY-MM
    format: str = "pdf",  # pdf ou excel
    current_user: User = Depends(get_current_user)
):
    """GÃ©nÃ¨re un rapport d'audit complet des assignations automatiques pour un mois donnÃ©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Parser le mois
        annee, mois_num = map(int, mois.split('-'))
        date_debut = datetime(annee, mois_num, 1)
        
        # Calculer la date de fin du mois
        if mois_num == 12:
            date_fin = datetime(annee + 1, 1, 1) - timedelta(days=1)
        else:
            date_fin = datetime(annee, mois_num + 1, 1) - timedelta(days=1)
        
        date_debut_str = date_debut.strftime("%Y-%m-%d")
        date_fin_str = date_fin.strftime("%Y-%m-%d")
        
        # RÃ©cupÃ©rer toutes les assignations automatiques du mois
        assignations_auto = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut_str,
                "$lte": date_fin_str
            },
            "assignation_type": "auto",
            "justification": {"$exists": True, "$ne": None}
        }).to_list(1000)
        
        if not assignations_auto:
            raise HTTPException(status_code=404, detail="Aucune assignation automatique trouvÃ©e pour ce mois")
        
        # RÃ©cupÃ©rer les infos complÃ©mentaires (users, types garde)
        users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Mapper users et types garde
        user_map = {u["id"]: u for u in users}
        type_garde_map = {t["id"]: t for t in types_garde}
        
        # GÃ©nÃ©rer le rapport selon le format
        if format == "pdf":
            return await generer_pdf_audit(assignations_auto, user_map, type_garde_map, tenant, mois)
        else:  # excel
            return await generer_excel_audit(assignations_auto, user_map, type_garde_map, tenant, mois)
            
    except ValueError:
        raise HTTPException(status_code=400, detail="Format de mois invalide. Utilisez YYYY-MM")
    except Exception as e:
        logging.error(f"Erreur gÃ©nÃ©ration rapport audit: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur gÃ©nÃ©ration rapport: {str(e)}")

async def generer_pdf_audit(assignations, user_map, type_garde_map, tenant, mois):
    """GÃ©nÃ¨re un PDF du rapport d'audit"""
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.platypus import Table, TableStyle, Paragraph, Spacer, PageBreak
    from reportlab.lib.styles import ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    
    # Utiliser la fonction helper pour crÃ©er un PDF brandÃ©
    buffer, doc, elements = create_branded_pdf(tenant, pagesize=A4)
    styles = getSampleStyleSheet()
    
    # Style titre
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    
    # Titre
    titre = Paragraph(f"<b>Rapport d'Audit des Affectations Automatiques</b><br/>{tenant.nom}<br/>PÃ©riode: {mois}", title_style)
    elements.append(titre)
    elements.append(Spacer(1, 0.3*inch))
    
    # Statistiques globales
    stats = Paragraph(f"<b>Total d'assignations automatiques: {len(assignations)}</b>", styles['Normal'])
    elements.append(stats)
    elements.append(Spacer(1, 0.2*inch))
    
    # Tableau pour chaque assignation
    for idx, assignation in enumerate(assignations[:50], 1):  # Limiter Ã  50 pour PDF
        user = user_map.get(assignation["user_id"], {})
        type_garde = type_garde_map.get(assignation["type_garde_id"], {})
        justif = assignation.get("justification", {})
        
        # Info assignation
        info_title = Paragraph(f"<b>{idx}. {user.get('prenom', 'N/A')} {user.get('nom', 'N/A')} - {type_garde.get('nom', 'N/A')} - {assignation['date']}</b>", styles['Heading3'])
        elements.append(info_title)
        
        # Scores
        assigned_user = justif.get("assigned_user", {})
        scores = assigned_user.get("scores", {})
        details = assigned_user.get("details", {})
        
        data_scores = [
            ["CritÃ¨re", "Score", "DÃ©tail"],
            ["Ã‰quitÃ©", f"{scores.get('equite', 0)}/100", f"{details.get('heures_ce_mois', 0)}h (moy: {details.get('moyenne_equipe', 0)}h)"],
            ["AnciennetÃ©", f"{scores.get('anciennete', 0)}/100", f"{details.get('annees_service', 0)} ans"],
            ["DisponibilitÃ©", f"{scores.get('disponibilite', 0)}/100", "DÃ©clarÃ©e" if details.get('disponibilite_declaree') else "Temps plein"],
            ["CompÃ©tences", f"{scores.get('competences', 0)}/100", user.get('grade', 'N/A')],
            ["TOTAL", f"{scores.get('total', 0)}/400", ""]
        ]
        
        table_scores = Table(data_scores, colWidths=[2*inch, 1.5*inch, 2.5*inch])
        table_scores.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#e5e7eb')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.grey)
        ]))
        
        elements.append(table_scores)
        elements.append(Spacer(1, 0.1*inch))
        
        # Notes admin
        notes = assignation.get("notes_admin")
        if notes:
            notes_para = Paragraph(f"<b>Notes admin:</b> {notes}", styles['Normal'])
            elements.append(notes_para)
        
        # Autres candidats (top 3)
        other_candidates = justif.get("other_candidates", [])[:3]
        if other_candidates:
            autres_title = Paragraph("<b>Autres candidats Ã©valuÃ©s:</b>", styles['Normal'])
            elements.append(autres_title)
            
            for cand in other_candidates:
                cand_text = f"â€¢ {cand.get('nom_complet', 'N/A')} - {cand.get('excluded_reason', 'N/A')}"
                cand_para = Paragraph(cand_text, styles['Normal'])
                elements.append(cand_para)
        
        elements.append(Spacer(1, 0.3*inch))
        
        # Page break tous les 5 pour Ã©viter surcharge
        if idx % 5 == 0 and idx < len(assignations):
            elements.append(PageBreak())
    
    doc.build(elements)
    buffer.seek(0)
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename=audit_affectations_{mois}.pdf"
        }
    )

async def generer_excel_audit(assignations, user_map, type_garde_map, tenant, mois):
    """GÃ©nÃ¨re un fichier Excel du rapport d'audit"""
    from io import BytesIO
    import openpyxl
    from openpyxl.styles import Font, Alignment, PatternFill
    
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Audit Affectations"
    
    # En-tÃªte
    ws['A1'] = f"Rapport d'Audit - {tenant.nom}"
    ws['A1'].font = Font(size=14, bold=True)
    ws['A2'] = f"PÃ©riode: {mois}"
    ws['A3'] = f"Total d'assignations: {len(assignations)}"
    
    # Colonnes
    headers = ["Date", "Garde", "Pompier", "Grade", "Heures mois", "Score Ã‰quitÃ©", 
               "Score AnciennetÃ©", "Score Dispo", "Score CompÃ©t", "Score Total", 
               "Candidats Ã©valuÃ©s", "Notes Admin"]
    
    for col_num, header in enumerate(headers, 1):
        cell = ws.cell(row=5, column=col_num)
        cell.value = header
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    # DonnÃ©es
    row_num = 6
    for assignation in assignations:
        user = user_map.get(assignation["user_id"], {})
        type_garde = type_garde_map.get(assignation["type_garde_id"], {})
        justif = assignation.get("justification", {})
        assigned_user = justif.get("assigned_user", {})
        scores = assigned_user.get("scores", {})
        details = assigned_user.get("details", {})
        
        ws.cell(row=row_num, column=1).value = assignation["date"]
        ws.cell(row=row_num, column=2).value = type_garde.get("nom", "N/A")
        ws.cell(row=row_num, column=3).value = f"{user.get('prenom', '')} {user.get('nom', '')}"
        ws.cell(row=row_num, column=4).value = user.get("grade", "N/A")
        ws.cell(row=row_num, column=5).value = details.get("heures_ce_mois", 0)
        ws.cell(row=row_num, column=6).value = scores.get("equite", 0)
        ws.cell(row=row_num, column=7).value = scores.get("anciennete", 0)
        ws.cell(row=row_num, column=8).value = scores.get("disponibilite", 0)
        ws.cell(row=row_num, column=9).value = scores.get("competences", 0)
        ws.cell(row=row_num, column=10).value = scores.get("total", 0)
        ws.cell(row=row_num, column=11).value = justif.get("total_candidates_evaluated", 0)
        ws.cell(row=row_num, column=12).value = assignation.get("notes_admin", "")
        
        row_num += 1
    
    # Ajuster les largeurs
    for col in ws.columns:
        max_length = 0
        column = col[0].column_letter
        for cell in col:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(cell.value)
            except:
                pass
        adjusted_width = min(max_length + 2, 50)
        ws.column_dimensions[column].width = adjusted_width
    
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={
            "Content-Disposition": f"attachment; filename=audit_affectations_{mois}.xlsx"
        }
    )

# Endpoint pour obtenir les statistiques personnelles mensuelles
@api_router.get("/{tenant_slug}/users/{user_id}/stats-mensuelles")
async def get_user_monthly_stats(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Get current month assignations for this user
        today = datetime.now(timezone.utc)
        month_start = today.replace(day=1).strftime("%Y-%m-%d")
        month_end = (today.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        month_end = month_end.strftime("%Y-%m-%d")
        
        user_assignations = await db.assignations.find({
            "user_id": user_id,
            "tenant_id": tenant.id,
            "date": {
                "$gte": month_start,
                "$lte": month_end
            }
        }).to_list(1000)
        
        # Get types garde for calculating hours
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        types_dict = {t["id"]: t for t in types_garde}
        
        # Calculate stats
        gardes_ce_mois = len(user_assignations)
        heures_travaillees = 0
        
        for assignation in user_assignations:
            type_garde = types_dict.get(assignation["type_garde_id"])
            if type_garde:
                heures_travaillees += type_garde.get("duree_heures", 8)
        
        # Get user formations count
        user_data = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        certifications = len(user_data.get("formations", [])) if user_data else 0
        
        return {
            "gardes_ce_mois": gardes_ce_mois,
            "heures_travaillees": heures_travaillees,
            "certifications": certifications,
            "mois": today.strftime("%B %Y")
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du calcul des statistiques: {str(e)}")

# Statistics routes
@api_router.get("/{tenant_slug}/statistiques", response_model=Statistiques)
async def get_statistiques(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # 1. Personnel actif (100% dynamique)
        personnel_count = await db.users.count_documents({"statut": "Actif", "tenant_id": tenant.id})
        
        # 2. Gardes cette semaine (100% dynamique)
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        gardes_count = await db.assignations.count_documents({
            "tenant_id": tenant.id,
            "date": {
                "$gte": start_week.strftime("%Y-%m-%d"),
                "$lte": end_week.strftime("%Y-%m-%d")
            }
        })
        
        # 3. Formations planifiÃ©es (100% dynamique)
        formations_count = await db.sessions_formation.count_documents({"statut": "planifie", "tenant_id": tenant.id})
        
        # 4. Taux de couverture dynamique - CALCUL CORRECT
        # Calculer le total de personnel requis pour la semaine
        total_assignations_required = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        total_personnel_requis = 0
        total_personnel_assigne = 0
        
        # Pour chaque jour de la semaine
        for day_offset in range(7):
            current_day = start_week + timedelta(days=day_offset)
            day_name = current_day.strftime("%A").lower()
            
            # Pour chaque type de garde
            for type_garde in total_assignations_required:
                jours_app = type_garde.get("jours_application", [])
                
                # Si ce type de garde s'applique Ã  ce jour
                if not jours_app or day_name in jours_app:
                    personnel_requis = type_garde.get("personnel_requis", 1)
                    total_personnel_requis += personnel_requis
                    
                    # Compter combien de personnes sont assignÃ©es pour cette garde ce jour
                    assignations_jour = await db.assignations.count_documents({
                        "tenant_id": tenant.id,
                        "date": current_day.strftime("%Y-%m-%d"),
                        "type_garde_id": type_garde["id"]
                    })
                    
                    total_personnel_assigne += min(assignations_jour, personnel_requis)
        
        # Calcul correct : (personnel assignÃ© / personnel requis) Ã— 100
        taux_couverture = (total_personnel_assigne / total_personnel_requis * 100) if total_personnel_requis > 0 else 0
        
        # Cap Ã  100% maximum
        taux_couverture = min(taux_couverture, 100.0)
        
        # 5. Heures travaillÃ©es ce mois (100% dynamique)
        start_month = today.replace(day=1)
        end_month = (start_month + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        
        assignations_mois = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": start_month.strftime("%Y-%m-%d"),
                "$lte": end_month.strftime("%Y-%m-%d")
            }
        }).to_list(1000)
        
        # Calculer les heures basÃ©es sur les types de garde
        heures_totales = 0
        types_garde_dict = {tg["id"]: tg for tg in total_assignations_required}
        
        for assignation in assignations_mois:
            type_garde = types_garde_dict.get(assignation["type_garde_id"])
            if type_garde:
                heures_totales += type_garde.get("duree_heures", 8)
        
        # 6. Remplacements effectuÃ©s (100% dynamique)
        remplacements_count = await db.demandes_remplacement.count_documents({"statut": "approuve", "tenant_id": tenant.id})
        
        return Statistiques(
            personnel_actif=personnel_count,
            gardes_cette_semaine=gardes_count,
            formations_planifiees=formations_count,
            taux_couverture=round(taux_couverture, 1),
            heures_travaillees=heures_totales,
            remplacements_effectues=remplacements_count
        )
        
    except Exception as e:
        # Fallback en cas d'erreur
        print(f"Erreur calcul statistiques: {str(e)}")
        return Statistiques(
            personnel_actif=0,
            gardes_cette_semaine=0,
            formations_planifiees=0,
            taux_couverture=0.0,
            heures_travaillees=0,
            remplacements_effectues=0
        )

# RÃ©initialiser tout le planning (vider toutes assignations)
@api_router.post("/planning/reinitialiser")
async def reinitialiser_planning(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Supprimer toutes les assignations
        result = await db.assignations.delete_many({})
        
        return {
            "message": "Planning rÃ©initialisÃ© avec succÃ¨s",
            "assignations_supprimees": result.deleted_count
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur rÃ©initialisation: {str(e)}")



# ==================== PARAMÃˆTRES DE VALIDATION DU PLANNING ====================

@api_router.get("/{tenant_slug}/parametres/validation-planning")
async def get_parametres_validation(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """
    RÃ©cupÃ©rer les paramÃ¨tres de validation du planning pour le tenant
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer les paramÃ¨tres de validation ou retourner valeurs par dÃ©faut
        validation_params = tenant.parametres.get('validation_planning', {
            'frequence': 'mensuel',
            'jour_envoi': 25,  # 25 du mois
            'heure_envoi': '17:00',
            'periode_couverte': 'mois_suivant',
            'envoi_automatique': True,
            'derniere_notification': None
        })
        
        return validation_params
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur rÃ©cupÃ©ration paramÃ¨tres: {str(e)}")

@api_router.get("/{tenant_slug}/parametres/formations")
async def get_parametres_formations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """
    RÃ©cupÃ©rer les paramÃ¨tres de formations pour le tenant
    """
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer les paramÃ¨tres de formations ou retourner valeurs par dÃ©faut
        formation_params = tenant.parametres.get('formations', {
            'heures_minimales_annuelles': 100,
            'delai_notification_liste_attente': 7,
            'email_notifications_actif': True
        })
        
        return formation_params
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur rÃ©cupÃ©ration paramÃ¨tres formations: {str(e)}")

@api_router.put("/{tenant_slug}/parametres/formations")
async def update_parametres_formations(tenant_slug: str, parametres: dict, current_user: User = Depends(get_current_user)):
    """
    Mettre Ã  jour les paramÃ¨tres de formations
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        tenant_doc = await db.tenants.find_one({"id": tenant.id})
        
        if not tenant_doc:
            raise HTTPException(status_code=404, detail="Tenant non trouvÃ©")
        
        # Mettre Ã  jour les paramÃ¨tres
        current_parametres = tenant_doc.get('parametres', {})
        current_parametres['formations'] = parametres
        
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": {"parametres": current_parametres}}
        )
        
        return {"message": "ParamÃ¨tres mis Ã  jour", "parametres": parametres}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise Ã  jour paramÃ¨tres formations: {str(e)}")

@api_router.put("/{tenant_slug}/parametres/validation-planning")
async def update_parametres_validation(tenant_slug: str, parametres: dict, current_user: User = Depends(get_current_user)):
    """
    Mettre Ã  jour les paramÃ¨tres de validation du planning
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        tenant_doc = await db.tenants.find_one({"id": tenant.id})
        
        if not tenant_doc:
            raise HTTPException(status_code=404, detail="Tenant non trouvÃ©")
        
        # Mettre Ã  jour les paramÃ¨tres
        current_parametres = tenant_doc.get('parametres', {})
        current_parametres['validation_planning'] = parametres
        
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": {"parametres": current_parametres}}
        )
        
        return {"message": "ParamÃ¨tres mis Ã  jour avec succÃ¨s", "parametres": parametres}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise Ã  jour paramÃ¨tres: {str(e)}")

@api_router.post("/{tenant_slug}/planning/envoyer-notifications")
async def envoyer_notifications_planning(tenant_slug: str, periode_debut: str, periode_fin: str, current_user: User = Depends(get_current_user)):
    """
    Envoyer les notifications par email Ã  tous les pompiers avec leurs gardes assignÃ©es
    
    Args:
        tenant_slug: slug de la caserne
        periode_debut: Date dÃ©but (YYYY-MM-DD)
        periode_fin: Date fin (YYYY-MM-DD)
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # RÃ©cupÃ©rer toutes les assignations de la pÃ©riode
        assignations_list = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {"$gte": periode_debut, "$lte": periode_fin}
        }).to_list(length=None)
        
        # RÃ©cupÃ©rer tous les users et types de garde
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        
        # CrÃ©er des maps pour accÃ¨s rapide
        users_map = {u['id']: u for u in users_list}
        types_garde_map = {t['id']: t for t in types_garde_list}
        
        # Grouper les assignations par user
        gardes_par_user = {}
        for assignation in assignations_list:
            user_id = assignation['user_id']
            if user_id not in gardes_par_user:
                gardes_par_user[user_id] = []
            
            type_garde = types_garde_map.get(assignation['type_garde_id'], {})
            
            # Trouver les collÃ¨gues pour cette garde
            collegues = [
                f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}"
                for a in assignations_list
                if a['date'] == assignation['date'] and 
                   a['type_garde_id'] == assignation['type_garde_id'] and 
                   a['user_id'] != user_id and 
                   a['user_id'] in users_map
            ]
            
            # Formater la date
            from datetime import datetime as dt
            date_obj = dt.strptime(assignation['date'], '%Y-%m-%d')
            jour_fr = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'][date_obj.weekday()]
            
            gardes_par_user[user_id].append({
                'date': date_obj.strftime('%d %B %Y'),
                'jour': jour_fr,
                'type_garde': type_garde.get('nom', 'Garde'),
                'horaire': f"{type_garde.get('heure_debut', '08:00')} - {type_garde.get('heure_fin', '08:00')}",
                'collegues': collegues
            })
        
        # Envoyer les emails
        emails_envoyes = 0
        emails_echoues = 0
        
        periode_str = f"{dt.strptime(periode_debut, '%Y-%m-%d').strftime('%B %Y')}"
        
        for user_id, gardes in gardes_par_user.items():
            user = users_map.get(user_id)
            if not user or not user.get('email'):
                continue
            
            user_name = f"{user['prenom']} {user['nom']}"
            email_sent = send_gardes_notification_email(
                user['email'],
                user_name,
                gardes,
                tenant_slug,
                periode_str
            )
            
            if email_sent:
                emails_envoyes += 1
            else:
                emails_echoues += 1
        
        # Mettre Ã  jour la date de derniÃ¨re notification
        tenant_doc = await db.tenants.find_one({"id": tenant.id})
        current_parametres = tenant_doc.get('parametres', {})
        if 'validation_planning' not in current_parametres:
            current_parametres['validation_planning'] = {}
        current_parametres['validation_planning']['derniere_notification'] = datetime.now(timezone.utc).isoformat()
        
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": {"parametres": current_parametres}}
        )
        
        return {
            "message": "Notifications envoyÃ©es",
            "emails_envoyes": emails_envoyes,
            "emails_echoues": emails_echoues,
            "total_pompiers": len(gardes_par_user)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur envoi notifications: {str(e)}")



 


# RÃ©parer tous les mots de passe dÃ©mo
@api_router.post("/repair-demo-passwords")
async def repair_demo_passwords():
    try:
        password_fixes = [
            ("admin@firemanager.ca", "admin123"),
            ("superviseur@firemanager.ca", "superviseur123"),
            ("employe@firemanager.ca", "employe123"),
            ("partiel@firemanager.ca", "partiel123")
        ]
        
        fixed_count = 0
        for email, password in password_fixes:
            user = await db.users.find_one({"email": email})
            if user:
                new_hash = get_password_hash(password)
                await db.users.update_one(
                    {"email": email},
                    {"$set": {"mot_de_passe_hash": new_hash}}
                )
                fixed_count += 1
                print(f"Fixed password for {email}")
        
        return {"message": f"{fixed_count} mots de passe dÃ©mo rÃ©parÃ©s"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Fix all demo passwords endpoint
@api_router.post("/fix-all-passwords")
async def fix_all_passwords():
    try:
        # Fix all demo account passwords
        password_fixes = [
            ("admin@firemanager.ca", "admin123"),
            ("superviseur@firemanager.ca", "superviseur123"),
            ("employe@firemanager.ca", "employe123"),
            ("partiel@firemanager.ca", "partiel123")
        ]
        
        fixed_count = 0
        for email, password in password_fixes:
            user = await db.users.find_one({"email": email})
            if user:
                new_hash = get_password_hash(password)
                await db.users.update_one(
                    {"email": email},
                    {"$set": {"mot_de_passe_hash": new_hash}}
                )
                fixed_count += 1
                print(f"Fixed password for {email}")
        
        return {"message": f"{fixed_count} mots de passe rÃ©parÃ©s"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Fix admin password endpoint
@api_router.post("/fix-admin-password")
async def fix_admin_password():
    try:
        # Find admin user
        admin_user = await db.users.find_one({"email": "admin@firemanager.ca"})
        if admin_user:
            # Update password hash
            new_password_hash = get_password_hash("admin123")
            await db.users.update_one(
                {"email": "admin@firemanager.ca"},
                {"$set": {"mot_de_passe_hash": new_password_hash}}
            )
            return {"message": "Mot de passe admin rÃ©parÃ©"}
        else:
            return {"message": "Compte admin non trouvÃ©"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Clean up endpoint
@api_router.post("/cleanup-duplicates")
async def cleanup_duplicates(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Clean formations duplicates - keep only unique ones by name
        formations = await db.formations.find().to_list(1000)
        unique_formations = {}
        
        for formation in formations:
            name = formation['nom']
            if name not in unique_formations:
                unique_formations[name] = formation
        
        # Delete all formations and re-insert unique ones
        await db.formations.delete_many({})
        
        if unique_formations:
            formations_to_insert = []
            for formation in unique_formations.values():
                formation.pop('_id', None)  # Remove MongoDB _id
                formations_to_insert.append(formation)
            
            await db.formations.insert_many(formations_to_insert)
        
        # Clean types garde duplicates
        types_garde = await db.types_garde.find().to_list(1000)
        unique_types = {}
        
        for type_garde in types_garde:
            key = f"{type_garde['nom']}_{type_garde['heure_debut']}_{type_garde['heure_fin']}"
            if key not in unique_types:
                unique_types[key] = type_garde
        
        # Delete all types garde and re-insert unique ones
        await db.types_garde.delete_many({})
        
        if unique_types:
            types_to_insert = []
            for type_garde in unique_types.values():
                type_garde.pop('_id', None)  # Remove MongoDB _id
                types_to_insert.append(type_garde)
            
            await db.types_garde.insert_many(types_to_insert)
        
        formations_count = len(unique_formations)
        types_count = len(unique_types)
        
        return {
            "message": f"Nettoyage terminÃ©: {formations_count} formations uniques, {types_count} types de garde uniques"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du nettoyage: {str(e)}")

# CrÃ©er donnÃ©es de dÃ©monstration rÃ©alistes avec historique
@api_router.post("/init-demo-data-realiste")
async def init_demo_data_realiste():
    try:
        # Clear existing data
        await db.users.delete_many({})
        await db.types_garde.delete_many({})
        await db.assignations.delete_many({})
        await db.planning.delete_many({})
        await db.demandes_remplacement.delete_many({})
        await db.formations.delete_many({})
        await db.sessions_formation.delete_many({})
        await db.disponibilites.delete_many({})
        
        # CrÃ©er plus d'utilisateurs rÃ©alistes
        demo_users = [
            {
                "nom": "Dupont", "prenom": "Jean", "email": "admin@firemanager.ca",
                "telephone": "514-111-2233", "contact_urgence": "514-999-1111",
                "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "admin", "numero_employe": "ADM001",
                "date_embauche": "14/01/2020", "formations": [], "mot_de_passe": "admin123"
            },
            {
                "nom": "Dubois", "prenom": "Sophie", "email": "superviseur@firemanager.ca",
                "telephone": "514-444-5566", "contact_urgence": "514-888-2222",
                "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "POM001",
                "date_embauche": "07/01/2022", "formations": [], "mot_de_passe": "superviseur123"
            },
            {
                "nom": "Bernard", "prenom": "Pierre", "email": "employe@firemanager.ca",
                "telephone": "418-555-9999", "contact_urgence": "418-777-3333",
                "grade": "Capitaine", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM002",
                "date_embauche": "21/09/2019", "formations": [], "mot_de_passe": "employe123"
            },
            {
                "nom": "Garcia", "prenom": "Claire", "email": "partiel@firemanager.ca",
                "telephone": "514-888-9900", "contact_urgence": "514-666-4444",
                "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel",
                "heures_max_semaine": 25, "role": "employe", "numero_employe": "POM005",
                "date_embauche": "02/11/2020", "formations": [], "mot_de_passe": "partiel123"
            },
            # Nouveaux utilisateurs pour dÃ©mo rÃ©aliste
            {
                "nom": "Tremblay", "prenom": "Marc", "email": "marc.tremblay@firemanager.ca",
                "telephone": "418-222-3333", "contact_urgence": "418-999-4444",
                "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM003",
                "date_embauche": "15/03/2021", "formations": [], "mot_de_passe": "TempPass123!"
            },
            {
                "nom": "Martin", "prenom": "Sarah", "email": "sarah.martin@firemanager.ca",
                "telephone": "514-333-4444", "contact_urgence": "514-777-8888",
                "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel",
                "heures_max_semaine": 20, "role": "employe", "numero_employe": "POM006",
                "date_embauche": "10/08/2023", "formations": [], "mot_de_passe": "TempPass123!"
            }
        ]
        
        # CrÃ©er formations avec plus de dÃ©tails
        demo_formations = [
            {"nom": "Classe 4A", "description": "Formation de conduite vÃ©hicules lourds", "duree_heures": 40, "validite_mois": 60, "obligatoire": False},
            {"nom": "DÃ©sincarcÃ©ration", "description": "Techniques de dÃ©sincarcÃ©ration", "duree_heures": 24, "validite_mois": 36, "obligatoire": True},
            {"nom": "Pompier 1", "description": "Formation de base pompier niveau 1", "duree_heures": 200, "validite_mois": 24, "obligatoire": True},
            {"nom": "Officier 2", "description": "Formation officier niveau 2", "duree_heures": 120, "validite_mois": 36, "obligatoire": False},
            {"nom": "Premiers RÃ©pondants", "description": "Formation premiers secours", "duree_heures": 16, "validite_mois": 12, "obligatoire": True},
            {"nom": "Sauvetage Aquatique", "description": "Techniques de sauvetage en milieu aquatique", "duree_heures": 32, "validite_mois": 24, "obligatoire": False}
        ]
        
        formation_ids = {}
        for formation_data in demo_formations:
            formation_obj = Formation(**formation_data)
            await db.formations.insert_one(formation_obj.dict())
            formation_ids[formation_data["nom"]] = formation_obj.id
        
        # Assigner formations aux utilisateurs
        demo_users[0]["formations"] = [formation_ids["Officier 2"], formation_ids["Pompier 1"]]
        demo_users[1]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"]]
        demo_users[2]["formations"] = [formation_ids["Classe 4A"], formation_ids["DÃ©sincarcÃ©ration"], formation_ids["Premiers RÃ©pondants"]]
        demo_users[3]["formations"] = [formation_ids["Pompier 1"]]
        demo_users[4]["formations"] = [formation_ids["DÃ©sincarcÃ©ration"], formation_ids["Premiers RÃ©pondants"], formation_ids["Sauvetage Aquatique"]]
        demo_users[5]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"]]
        
        # CrÃ©er utilisateurs
        user_ids = {}
        for user_data in demo_users:
            user_dict = user_data.copy()
            user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
            user_dict["statut"] = "Actif"
            user_obj = User(**user_dict)
            await db.users.insert_one(user_obj.dict())
            user_ids[user_data["email"]] = user_obj.id
        
        # CrÃ©er assignations historiques (3 mois)
        assignations_created = 0
        for week_offset in range(-12, 1):  # 12 semaines passÃ©es + semaine courante
            week_start = datetime.now(timezone.utc).date() + timedelta(weeks=week_offset)
            week_start = week_start - timedelta(days=week_start.weekday())
            
            for day_offset in range(7):
                date_assignation = week_start + timedelta(days=day_offset)
                date_str = date_assignation.strftime("%Y-%m-%d")
                
                # Assigner quelques gardes alÃ©atoirement
                if assignations_created % 3 == 0:  # Environ 1/3 des jours
                    # Garde Interne AM
                    assignation_obj = Assignation(
                        user_id=user_ids["employe@firemanager.ca"],
                        type_garde_id="garde-interne-am",  # Sera crÃ©Ã© aprÃ¨s
                        date=date_str,
                        assignation_type="auto"
                    )
                    await db.assignations.insert_one(assignation_obj.dict())
                    assignations_created += 1
        
        return {"message": f"DonnÃ©es de dÃ©monstration rÃ©alistes crÃ©Ã©es : {len(demo_users)} utilisateurs, {len(demo_formations)} formations, {assignations_created} assignations historiques"}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Affecter disponibilitÃ©s Ã  TOUS les employÃ©s temps partiel existants (auto-dÃ©tection)
@api_router.post("/auto-affecter-disponibilites-temps-partiel")
async def auto_affecter_disponibilites_temps_partiel(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # DÃ‰TECTION AUTOMATIQUE de tous les employÃ©s temps partiel
        tous_temps_partiel = await db.users.find({
            "type_emploi": "temps_partiel",
            "statut": "Actif"
        }).to_list(1000)
        
        print(f"TrouvÃ© {len(tous_temps_partiel)} employÃ©s temps partiel")
        
        # Supprimer les anciennes disponibilitÃ©s de la semaine courante
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        await db.disponibilites.delete_many({
            "date": {
                "$gte": start_week.strftime("%Y-%m-%d"),
                "$lte": end_week.strftime("%Y-%m-%d")
            }
        })
        
        # RÃ©cupÃ©rer types de garde
        types_garde = await db.types_garde.find().to_list(100)
        
        disponibilites_created = 0
        
        # AFFECTER DISPONIBILITÃ‰S Ã€ TOUS LES TEMPS PARTIEL DÃ‰TECTÃ‰S
        for index, user in enumerate(tous_temps_partiel):
            print(f"Affectation pour {user['prenom']} {user['nom']} ({user['grade']})")
            
            # Pattern de disponibilitÃ© selon l'index pour variÃ©tÃ©
            if index % 4 == 0:  # Pattern 1: Lun-Mer-Ven
                jours_disponibles = [0, 2, 4]
            elif index % 4 == 1:  # Pattern 2: Mar-Jeu-Sam  
                jours_disponibles = [1, 3, 5]
            elif index % 4 == 2:  # Pattern 3: Mer-Ven-Dim
                jours_disponibles = [2, 4, 6]
            else:  # Pattern 4: Lun-Jeu-Dim
                jours_disponibles = [0, 3, 6]
            
            for day_offset in jours_disponibles:
                date_dispo = start_week + timedelta(days=day_offset)
                date_str = date_dispo.strftime("%Y-%m-%d")
                day_name = date_dispo.strftime("%A").lower()
                
                # CrÃ©er disponibilitÃ©s pour TOUS les types de garde applicables
                for type_garde in types_garde:
                    jours_app = type_garde.get("jours_application", [])
                    if jours_app and day_name not in jours_app:
                        continue
                    
                    # CrÃ©er disponibilitÃ© (stratÃ©gie intensive pour dÃ©mo)
                    dispo_obj = Disponibilite(
                        user_id=user["id"],
                        date=date_str,
                        type_garde_id=type_garde["id"],
                        heure_debut=type_garde["heure_debut"],
                        heure_fin=type_garde["heure_fin"],
                        statut="disponible"
                    )
                    await db.disponibilites.insert_one(dispo_obj.dict())
                    disponibilites_created += 1
        
        return {
            "message": "DisponibilitÃ©s affectÃ©es automatiquement",
            "employes_temps_partiel_detectes": len(tous_temps_partiel),
            "disponibilites_creees": disponibilites_created,
            "semaine": f"{start_week.strftime('%Y-%m-%d')} - {end_week.strftime('%Y-%m-%d')}",
            "patterns": "4 patterns diffÃ©rents pour variÃ©tÃ© dÃ©mo",
            "employÃ©s_dÃ©tectÃ©s": [f"{u['prenom']} {u['nom']} ({u['grade']})" for u in tous_temps_partiel]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur auto-affectation: {str(e)}")

# CrÃ©er disponibilitÃ©s MAXIMALES pour dÃ©mo parfaite
@api_router.post("/init-disponibilites-demo-complete")
async def init_disponibilites_demo_complete(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Supprimer toutes les disponibilitÃ©s existantes
        await db.disponibilites.delete_many({})
        
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        # RÃ©cupÃ©rer TOUS les utilisateurs (temps plein ET temps partiel pour dÃ©mo)
        all_users = await db.users.find({"statut": "Actif"}).to_list(100)
        types_garde = await db.types_garde.find().to_list(100)
        
        disponibilites_created = 0
        
        # STRATÃ‰GIE DÃ‰MO : TOUS LES EMPLOYÃ‰S DISPONIBLES POUR TOUS LES TYPES
        for user in all_users:
            for day_offset in range(7):  # Chaque jour
                date_dispo = start_week + timedelta(days=day_offset)
                date_str = date_dispo.strftime("%Y-%m-%d")
                day_name = date_dispo.strftime("%A").lower()
                
                for type_garde in types_garde:
                    # VÃ©rifier jours d'application
                    jours_app = type_garde.get("jours_application", [])
                    if jours_app and day_name not in jours_app:
                        continue
                    
                    # CRÃ‰ER DISPONIBILITÃ‰ POUR TOUS (temps plein et temps partiel)
                    # Exception : respecter les heures max pour temps partiel
                    if user["type_emploi"] == "temps_partiel":
                        # Temps partiel : disponible seulement 3 jours par semaine
                        user_number = int(user["numero_employe"][-1]) if user["numero_employe"][-1].isdigit() else 0
                        
                        # Pattern par employÃ© pour Ã©viter Ã©puisement
                        if user_number % 3 == 0 and day_offset in [0, 2, 4]:  # Lun-Mer-Ven
                            pass
                        elif user_number % 3 == 1 and day_offset in [1, 3, 5]:  # Mar-Jeu-Sam
                            pass  
                        elif user_number % 3 == 2 and day_offset in [2, 4, 6]:  # Mer-Ven-Dim
                            pass
                        else:
                            continue  # Skip ce jour pour cet employÃ©
                    
                    # CRÃ‰ER DISPONIBILITÃ‰
                    dispo_obj = Disponibilite(
                        user_id=user["id"],
                        date=date_str,
                        type_garde_id=type_garde["id"],
                        heure_debut=type_garde["heure_debut"],
                        heure_fin=type_garde["heure_fin"],
                        statut="disponible"
                    )
                    await db.disponibilites.insert_one(dispo_obj.dict())
                    disponibilites_created += 1
        
        return {
            "message": "DisponibilitÃ©s DÃ‰MO COMPLÃˆTES crÃ©Ã©es",
            "semaine": f"{start_week.strftime('%Y-%m-%d')} - {end_week.strftime('%Y-%m-%d')}",
            "disponibilites_creees": disponibilites_created,
            "all_users_included": len(all_users),
            "strategy": "TOUS employÃ©s (TP+TPa) avec patterns optimisÃ©s"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# CrÃ©er disponibilitÃ©s pour semaine courante (dÃ©mo assignation auto)
@api_router.post("/init-disponibilites-semaine-courante")
async def init_disponibilites_semaine_courante(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    try:
        # Supprimer les disponibilitÃ©s existantes pour la semaine courante
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        await db.disponibilites.delete_many({
            "date": {
                "$gte": start_week.strftime("%Y-%m-%d"),
                "$lte": end_week.strftime("%Y-%m-%d")
            }
        })
        
        # RÃ©cupÃ©rer tous les types de garde
        types_garde = await db.types_garde.find().to_list(100)
        # DÃ‰TECTION AUTOMATIQUE de TOUS les employÃ©s temps partiel (peu importe le nombre)
        tous_temps_partiel = await db.users.find({
            "type_emploi": "temps_partiel",
            "statut": "Actif"
        }).to_list(1000)
        
        print(f"AUTO-DÃ‰TECTION: {len(tous_temps_partiel)} employÃ©s temps partiel trouvÃ©s")
        
        disponibilites_created = 0
        
        # ALGORITHME OPTIMISÃ‰ POUR TOUS VOS EMPLOYÃ‰S TEMPS PARTIEL
        for user_index, user in enumerate(tous_temps_partiel):
            for day_offset in range(7):  # Chaque jour de la semaine courante
                date_dispo = start_week + timedelta(days=day_offset)
                date_str = date_dispo.strftime("%Y-%m-%d")
                day_name = date_dispo.strftime("%A").lower()
                
                # Pattern de disponibilitÃ© variÃ© selon l'employÃ©
                if user_index % 3 == 0:  # 1/3 des employÃ©s : Lun-Mer-Ven
                    jours_pattern = ['monday', 'wednesday', 'friday']
                elif user_index % 3 == 1:  # 1/3 des employÃ©s : Mar-Jeu-Sam
                    jours_pattern = ['tuesday', 'thursday', 'saturday']
                else:  # 1/3 des employÃ©s : Mer-Ven-Dim
                    jours_pattern = ['wednesday', 'friday', 'sunday']
                
                if day_name in jours_pattern:
                    # CrÃ©er disponibilitÃ©s pour TOUS les types de garde applicables
                    for type_garde in types_garde:
                        jours_app = type_garde.get("jours_application", [])
                        if jours_app and day_name not in jours_app:
                            continue
                        
                        # CRÃ‰ER DISPONIBILITÃ‰ pour vos employÃ©s (pompiers ET lieutenants)
                        dispo_obj = Disponibilite(
                            user_id=user["id"],
                            date=date_str,
                            type_garde_id=type_garde["id"],
                            heure_debut=type_garde["heure_debut"],
                            heure_fin=type_garde["heure_fin"],
                            statut="disponible"
                        )
                        await db.disponibilites.insert_one(dispo_obj.dict())
                        disponibilites_created += 1
        
        return {
            "message": "DisponibilitÃ©s crÃ©Ã©es pour TOUS vos employÃ©s temps partiel",
            "employes_temps_partiel": len(tous_temps_partiel),
            "disponibilites_creees": disponibilites_created,
            "all_users_included": len(tous_temps_partiel),
            "strategy": f"AUTO-DÃ‰TECTION: {len(tous_temps_partiel)} employÃ©s temps partiel avec patterns optimisÃ©s"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# CrÃ©er donnÃ©es de dÃ©monstration OPTIMALES pour dÃ©mo client
@api_router.post("/init-demo-client-data")
async def init_demo_client_data():
    try:
        # Clear existing data
        await db.users.delete_many({})
        await db.types_garde.delete_many({})
        await db.assignations.delete_many({})
        await db.formations.delete_many({})
        await db.sessions_formation.delete_many({})
        await db.disponibilites.delete_many({})
        await db.demandes_remplacement.delete_many({})
        
        # 1. Ã‰QUIPE RÃ‰ALISTE CASERNE (15 pompiers)
        demo_users = [
            # DIRECTION ET ADMINISTRATION
            {"nom": "Dupont", "prenom": "Jean", "email": "admin@firemanager.ca", "telephone": "514-111-2233", "contact_urgence": "514-999-1111", "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "admin", "numero_employe": "DIR001", "date_embauche": "14/01/2015", "formations": [], "mot_de_passe": "admin123"},
            {"nom": "Tremblay", "prenom": "Marie", "email": "directrice@firemanager.ca", "telephone": "514-222-3344", "contact_urgence": "514-888-1111", "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "DIR002", "date_embauche": "03/06/2018", "formations": [], "mot_de_passe": "superviseur123"},
            
            # SUPERVISEURS / CAPITAINES
            {"nom": "Dubois", "prenom": "Sophie", "email": "superviseur@firemanager.ca", "telephone": "514-444-5566", "contact_urgence": "514-888-2222", "grade": "Capitaine", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "CAP001", "date_embauche": "07/01/2019", "formations": [], "mot_de_passe": "superviseur123"},
            {"nom": "Leblanc", "prenom": "Michel", "email": "michel.leblanc@firemanager.ca", "telephone": "418-333-4455", "contact_urgence": "418-777-5555", "grade": "Capitaine", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "CAP002", "date_embauche": "15/08/2020", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # LIEUTENANTS
            {"nom": "Bernard", "prenom": "Pierre", "email": "employe@firemanager.ca", "telephone": "418-555-9999", "contact_urgence": "418-777-3333", "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "LT001", "date_embauche": "21/09/2019", "formations": [], "mot_de_passe": "employe123"},
            {"nom": "Gagnon", "prenom": "Julie", "email": "julie.gagnon@firemanager.ca", "telephone": "514-666-7788", "contact_urgence": "514-999-3333", "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "LT002", "date_embauche": "10/03/2021", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Roy", "prenom": "Alexandre", "email": "alex.roy@firemanager.ca", "telephone": "450-111-2222", "contact_urgence": "450-888-4444", "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "LT003", "date_embauche": "05/11/2022", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # POMPIERS TEMPS PLEIN
            {"nom": "Lavoie", "prenom": "Marc", "email": "marc.lavoie@firemanager.ca", "telephone": "514-777-8899", "contact_urgence": "514-666-5555", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM001", "date_embauche": "12/04/2021", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "CÃ´tÃ©", "prenom": "David", "email": "david.cote@firemanager.ca", "telephone": "418-888-9900", "contact_urgence": "418-555-6666", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM002", "date_embauche": "28/09/2022", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Bouchard", "prenom": "Simon", "email": "simon.bouchard@firemanager.ca", "telephone": "514-999-1234", "contact_urgence": "514-777-7777", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM003", "date_embauche": "16/01/2023", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # POMPIERS TEMPS PARTIEL POUR DÃ‰MO ASSIGNATION AUTO (12 employÃ©s)
            {"nom": "Garcia", "prenom": "Claire", "email": "partiel@firemanager.ca", "telephone": "514-888-9900", "contact_urgence": "514-666-4444", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 25, "role": "employe", "numero_employe": "PTP001", "date_embauche": "02/11/2023", "formations": [], "mot_de_passe": "partiel123"},
            {"nom": "Martin", "prenom": "Sarah", "email": "sarah.martin@firemanager.ca", "telephone": "450-555-6666", "contact_urgence": "450-999-8888", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 30, "role": "employe", "numero_employe": "PTP002", "date_embauche": "15/06/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Pelletier", "prenom": "Ã‰milie", "email": "emilie.pelletier@firemanager.ca", "telephone": "418-333-7777", "contact_urgence": "418-666-9999", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 20, "role": "employe", "numero_employe": "PTP003", "date_embauche": "08/02/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Bergeron", "prenom": "Thomas", "email": "thomas.bergeron@firemanager.ca", "telephone": "514-444-8888", "contact_urgence": "514-333-9999", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 28, "role": "employe", "numero_employe": "PTP004", "date_embauche": "22/08/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Rousseau", "prenom": "Jessica", "email": "jessica.rousseau@firemanager.ca", "telephone": "514-777-1111", "contact_urgence": "514-888-2222", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 24, "role": "employe", "numero_employe": "PTP005", "date_embauche": "12/03/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Fournier", "prenom": "Antoine", "email": "antoine.fournier@firemanager.ca", "telephone": "418-555-2222", "contact_urgence": "418-777-3333", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 32, "role": "employe", "numero_employe": "PTP006", "date_embauche": "05/01/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Leclerc", "prenom": "Mathieu", "email": "mathieu.leclerc@firemanager.ca", "telephone": "450-666-3333", "contact_urgence": "450-888-4444", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 26, "role": "employe", "numero_employe": "PTP007", "date_embauche": "18/07/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Gauthier", "prenom": "Isabelle", "email": "isabelle.gauthier@firemanager.ca", "telephone": "514-999-4444", "contact_urgence": "514-666-5555", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 22, "role": "employe", "numero_employe": "PTP008", "date_embauche": "30/04/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Beaulieu", "prenom": "Nicolas", "email": "nicolas.beaulieu@firemanager.ca", "telephone": "418-444-5555", "contact_urgence": "418-777-6666", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 35, "role": "employe", "numero_employe": "PTP009", "date_embauche": "14/09/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Caron", "prenom": "Melissa", "email": "melissa.caron@firemanager.ca", "telephone": "514-333-6666", "contact_urgence": "514-999-7777", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 29, "role": "employe", "numero_employe": "PTP010", "date_embauche": "25/05/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Simard", "prenom": "Gabriel", "email": "gabriel.simard@firemanager.ca", "telephone": "450-777-7777", "contact_urgence": "450-333-8888", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 27, "role": "employe", "numero_employe": "PTP011", "date_embauche": "03/11/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Mercier", "prenom": "ValÃ©rie", "email": "valerie.mercier@firemanager.ca", "telephone": "418-888-8888", "contact_urgence": "418-555-9999", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 31, "role": "employe", "numero_employe": "PTP012", "date_embauche": "17/12/2023", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # NOUVELLES RECRUES
            {"nom": "Morin", "prenom": "Kevin", "email": "kevin.morin@firemanager.ca", "telephone": "514-111-9999", "contact_urgence": "514-222-8888", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM004", "date_embauche": "01/09/2024", "formations": [], "mot_de_passe": "TempPass123!"}
        ]
        
        # 2. FORMATIONS COMPLÃˆTES POUR CASERNE
        demo_formations = [
            {"nom": "Pompier 1", "description": "Formation de base pompier niveau 1 - Obligatoire pour tous", "duree_heures": 200, "validite_mois": 24, "obligatoire": True},
            {"nom": "Premiers RÃ©pondants", "description": "Formation premiers secours et rÃ©animation", "duree_heures": 16, "validite_mois": 12, "obligatoire": True},
            {"nom": "DÃ©sincarcÃ©ration", "description": "Techniques de dÃ©sincarcÃ©ration et sauvetage routier", "duree_heures": 24, "validite_mois": 36, "obligatoire": True},
            {"nom": "Classe 4A", "description": "Permis de conduire vÃ©hicules lourds et Ã©chelles", "duree_heures": 40, "validite_mois": 60, "obligatoire": False},
            {"nom": "Officier 2", "description": "Formation commandement et leadership", "duree_heures": 120, "validite_mois": 36, "obligatoire": False},
            {"nom": "Sauvetage Aquatique", "description": "Techniques de sauvetage en milieu aquatique", "duree_heures": 32, "validite_mois": 24, "obligatoire": False},
            {"nom": "MatiÃ¨res Dangereuses", "description": "Intervention matiÃ¨res dangereuses HAZMAT", "duree_heures": 48, "validite_mois": 36, "obligatoire": False},
            {"nom": "Sauvetage Technique", "description": "Sauvetage en espace clos et hauteur", "duree_heures": 56, "validite_mois": 24, "obligatoire": False}
        ]
        
        formation_ids = {}
        for formation_data in demo_formations:
            formation_obj = Formation(**formation_data)
            await db.formations.insert_one(formation_obj.dict())
            formation_ids[formation_data["nom"]] = formation_obj.id
        
        # 3. ASSIGNER FORMATIONS RÃ‰ALISTES PAR GRADE
        # Directeur - Toutes formations + Officier
        demo_users[0]["formations"] = [formation_ids["Pompier 1"], formation_ids["Officier 2"], formation_ids["Premiers RÃ©pondants"], formation_ids["Classe 4A"]]
        demo_users[1]["formations"] = [formation_ids["Pompier 1"], formation_ids["Officier 2"], formation_ids["Premiers RÃ©pondants"], formation_ids["Sauvetage Aquatique"]]
        
        # Capitaines - Formations supervision
        demo_users[2]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["DÃ©sincarcÃ©ration"], formation_ids["Classe 4A"]]
        demo_users[3]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["MatiÃ¨res Dangereuses"]]
        
        # Lieutenants - Formations techniques
        demo_users[4]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["DÃ©sincarcÃ©ration"]]
        demo_users[5]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["Sauvetage Aquatique"]]
        demo_users[6]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["Sauvetage Technique"]]
        
        # Pompiers temps plein - Formations de base + spÃ©cialisations
        demo_users[7]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["DÃ©sincarcÃ©ration"]]
        demo_users[8]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"]]
        demo_users[9]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"], formation_ids["Classe 4A"]]
        
        # Pompiers temps partiel - Formations variables
        demo_users[10]["formations"] = [formation_ids["Pompier 1"]]
        demo_users[11]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"]]
        demo_users[12]["formations"] = [formation_ids["Pompier 1"]]
        demo_users[13]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"]]
        
        # Nouvelles recrues - Formations de base seulement
        demo_users[14]["formations"] = [formation_ids["Pompier 1"]]
        
        # CrÃ©er utilisateurs
        user_ids = {}
        for user_data in demo_users:
            user_dict = user_data.copy()
            user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
            user_dict["statut"] = "Actif"
            user_obj = User(**user_dict)
            await db.users.insert_one(user_obj.dict())
            user_ids[user_data["email"]] = user_obj.id
        
        # 4. CRÃ‰ER TYPES DE GARDE RÃ‰ALISTES
        demo_types_garde = [
            {"nom": "Garde Interne AM - Semaine", "heure_debut": "06:00", "heure_fin": "18:00", "personnel_requis": 4, "duree_heures": 12, "couleur": "#10B981", "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"], "officier_obligatoire": True},
            {"nom": "Garde Interne PM - Semaine", "heure_debut": "18:00", "heure_fin": "06:00", "personnel_requis": 3, "duree_heures": 12, "couleur": "#3B82F6", "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"], "officier_obligatoire": True},
            {"nom": "Garde Weekend Jour", "heure_debut": "08:00", "heure_fin": "20:00", "personnel_requis": 3, "duree_heures": 12, "couleur": "#F59E0B", "jours_application": ["saturday", "sunday"], "officier_obligatoire": True},
            {"nom": "Garde Weekend Nuit", "heure_debut": "20:00", "heure_fin": "08:00", "personnel_requis": 2, "duree_heures": 12, "couleur": "#8B5CF6", "jours_application": ["saturday", "sunday"], "officier_obligatoire": False},
            {"nom": "Garde Externe Citerne", "heure_debut": "00:00", "heure_fin": "23:59", "personnel_requis": 1, "duree_heures": 24, "couleur": "#EF4444", "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"], "officier_obligatoire": False}
        ]
        
        type_garde_ids = {}
        for type_garde_data in demo_types_garde:
            type_garde_obj = TypeGarde(**type_garde_data)
            await db.types_garde.insert_one(type_garde_obj.dict())
            type_garde_ids[type_garde_data["nom"]] = type_garde_obj.id
        
        # 5. CRÃ‰ER HISTORIQUE ASSIGNATIONS (6 semaines)
        assignations_created = 0
        users_list = list(user_ids.values())
        
        for week_offset in range(-6, 1):  # 6 semaines passÃ©es + courante
            week_start = datetime.now(timezone.utc).date() + timedelta(weeks=week_offset)
            week_start = week_start - timedelta(days=week_start.weekday())
            
            for day_offset in range(7):
                date_assignation = week_start + timedelta(days=day_offset)
                date_str = date_assignation.strftime("%Y-%m-%d")
                day_name = date_assignation.strftime("%A").lower()
                
                # Assigner gardes selon jours d'application
                for type_nom, type_id in type_garde_ids.items():
                    type_garde = next(t for t in demo_types_garde if t["nom"] == type_nom)
                    
                    if day_name in type_garde["jours_application"]:
                        # Assigner alÃ©atoirement 70% des gardes
                        if assignations_created % 3 != 2:  # 2/3 des gardes assignÃ©es
                            import random
                            user_id = random.choice(users_list)
                            
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_id,
                                date=date_str,
                                assignation_type="auto"
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_created += 1
        
        # 6. CRÃ‰ER DISPONIBILITÃ‰S MASSIVES POUR TEMPS PARTIEL (pour dÃ©mo assignation auto)
        temps_partiel_users = [
            user_ids["partiel@firemanager.ca"],
            user_ids["sarah.martin@firemanager.ca"],
            user_ids["emilie.pelletier@firemanager.ca"],
            user_ids["thomas.bergeron@firemanager.ca"],
            user_ids["jessica.rousseau@firemanager.ca"],
            user_ids["antoine.fournier@firemanager.ca"],
            user_ids["mathieu.leclerc@firemanager.ca"],
            user_ids["isabelle.gauthier@firemanager.ca"],
            user_ids["nicolas.beaulieu@firemanager.ca"],
            user_ids["melissa.caron@firemanager.ca"],
            user_ids["gabriel.simard@firemanager.ca"],
            user_ids["valerie.mercier@firemanager.ca"]
        ]
        
        disponibilites_created = 0
        
        # Pour chaque employÃ© temps partiel, crÃ©er des disponibilitÃ©s variÃ©es
        for i, user_id in enumerate(temps_partiel_users):
            # Patterns de disponibilitÃ© diffÃ©rents pour variÃ©tÃ©
            if i % 4 == 0:  # Pattern 1: Lun-Mer-Ven
                jours_pattern = [0, 2, 4]  # Lundi, Mercredi, Vendredi
            elif i % 4 == 1:  # Pattern 2: Mar-Jeu-Sam
                jours_pattern = [1, 3, 5]  # Mardi, Jeudi, Samedi
            elif i % 4 == 2:  # Pattern 3: Mer-Ven-Dim
                jours_pattern = [2, 4, 6]  # Mercredi, Vendredi, Dimanche
            else:  # Pattern 4: Lun-Jeu-Sam
                jours_pattern = [0, 3, 5]  # Lundi, Jeudi, Samedi
            
            # CrÃ©er disponibilitÃ©s pour 8 semaines (2 mois futurs)
            for week_offset in range(0, 8):
                week_start = datetime.now(timezone.utc).date() + timedelta(weeks=week_offset)
                week_start = week_start - timedelta(days=week_start.weekday())
                
                for day_offset in jours_pattern:
                    date_dispo = week_start + timedelta(days=day_offset)
                    
                    # CrÃ©er disponibilitÃ©s pour diffÃ©rents types de garde
                    # 80% pour Garde Interne (semaine)
                    if day_offset < 5:  # Lundi-Vendredi
                        # Disponible pour garde AM ou PM (alternativement)
                        type_garde_am = type_garde_ids["Garde Interne AM - Semaine"]
                        type_garde_pm = type_garde_ids["Garde Interne PM - Semaine"]
                        
                        # Disponible pour garde AM
                        if disponibilites_created % 3 != 2:  # 66% de chance
                            dispo_obj = Disponibilite(
                                user_id=user_id,
                                date=date_dispo.strftime("%Y-%m-%d"),
                                type_garde_id=type_garde_am,
                                heure_debut="06:00",
                                heure_fin="18:00",
                                statut="disponible"
                            )
                            await db.disponibilites.insert_one(dispo_obj.dict())
                            disponibilites_created += 1
                        
                        # Disponible pour garde PM
                        if disponibilites_created % 4 != 3:  # 75% de chance
                            dispo_obj = Disponibilite(
                                user_id=user_id,
                                date=date_dispo.strftime("%Y-%m-%d"),
                                type_garde_id=type_garde_pm,
                                heure_debut="18:00",
                                heure_fin="06:00",
                                statut="disponible"
                            )
                            await db.disponibilites.insert_one(dispo_obj.dict())
                            disponibilites_created += 1
                    else:  # Weekend
                        # Disponible pour garde weekend
                        if disponibilites_created % 2 == 0:  # 50% de chance
                            type_garde_weekend = type_garde_ids["Garde Weekend Jour"]
                            dispo_obj = Disponibilite(
                                user_id=user_id,
                                date=date_dispo.strftime("%Y-%m-%d"),
                                type_garde_id=type_garde_weekend,
                                heure_debut="08:00",
                                heure_fin="20:00",
                                statut="disponible"
                            )
                            await db.disponibilites.insert_one(dispo_obj.dict())
                            disponibilites_created += 1
        
        # 7. CRÃ‰ER SESSIONS DE FORMATION
        demo_sessions = [
            {"titre": "Formation Sauvetage Aquatique - Niveau 1", "competence_id": formation_ids["Sauvetage Aquatique"], "duree_heures": 32, "date_debut": "2025-01-15", "heure_debut": "09:00", "lieu": "Piscine municipale", "formateur": "Capitaine Sarah Tremblay", "descriptif": "Formation complÃ¨te aux techniques de sauvetage aquatique", "plan_cours": "", "places_max": 12, "participants": [], "statut": "planifie"},
            {"titre": "Perfectionnement DÃ©sincarcÃ©ration", "competence_id": formation_ids["DÃ©sincarcÃ©ration"], "duree_heures": 16, "date_debut": "2025-01-22", "heure_debut": "13:00", "lieu": "Centre formation sÃ©curitÃ©", "formateur": "Lieutenant Pierre Bernard", "descriptif": "Perfectionnement techniques de dÃ©sincarcÃ©ration moderne", "plan_cours": "", "places_max": 8, "participants": [], "statut": "planifie"},
            {"titre": "MatiÃ¨res Dangereuses HAZMAT", "competence_id": formation_ids["MatiÃ¨res Dangereuses"], "duree_heures": 48, "date_debut": "2025-02-05", "heure_debut": "08:00", "lieu": "Centre HAZMAT MontrÃ©al", "formateur": "Expert externe - Dr. Martin Dubois", "descriptif": "Formation complÃ¨te intervention matiÃ¨res dangereuses", "plan_cours": "", "places_max": 15, "participants": [], "statut": "planifie"}
        ]
        
        for session_data in demo_sessions:
            session_obj = SessionFormation(**session_data)
            await db.sessions_formation.insert_one(session_obj.dict())
        
        return {
            "message": "DonnÃ©es dÃ©mo CLIENT crÃ©Ã©es avec succÃ¨s",
            "details": {
                "utilisateurs": len(demo_users),
                "formations": len(demo_formations),
                "types_garde": len(demo_types_garde),
                "assignations_historiques": assignations_created,
                "disponibilites": disponibilites_created,
                "sessions_formation": len(demo_sessions),
                "breakdown": {
                    "admins": 1,
                    "superviseurs": 3,
                    "employes_temps_plein": 7,
                    "employes_temps_partiel": 12,
                    "total_personnel": 23
                }
            }
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Initialize demo data
@api_router.post("/init-demo-data")
async def init_demo_data():
    # Clear existing data
    await db.users.delete_many({})
    await db.types_garde.delete_many({})
    await db.assignations.delete_many({})
    await db.planning.delete_many({})
    await db.demandes_remplacement.delete_many({})
    
    # Create demo users
    demo_users = [
        {
            "nom": "Dupont",
            "prenom": "Jean",
            "email": "admin@firemanager.ca",
            "telephone": "514-111-2233",
            "contact_urgence": "514-999-1111",
            "grade": "Directeur",
            "type_emploi": "temps_plein",
            "heures_max_semaine": 40,  # Temps plein standard
            "role": "admin",
            "numero_employe": "ADM001",
            "date_embauche": "14/01/2020",
            "formations": [],
            "mot_de_passe": "admin123"
        },
        {
            "nom": "Dubois",
            "prenom": "Sophie",
            "email": "superviseur@firemanager.ca",
            "telephone": "514-444-5566",
            "contact_urgence": "514-888-2222",
            "grade": "Directeur",
            "type_emploi": "temps_plein",
            "heures_max_semaine": 40,  # Temps plein standard
            "role": "superviseur",
            "numero_employe": "POM001",
            "date_embauche": "07/01/2022",
            "formations": [],
            "mot_de_passe": "superviseur123"
        },
        {
            "nom": "Bernard",
            "prenom": "Pierre",
            "email": "employe@firemanager.ca",
            "telephone": "418-555-9999",
            "contact_urgence": "418-777-3333",
            "grade": "Capitaine",
            "type_emploi": "temps_plein",
            "heures_max_semaine": 40,  # Temps plein standard
            "role": "employe",
            "numero_employe": "POM002",
            "date_embauche": "21/09/2019",
            "formations": [],
            "mot_de_passe": "employe123"
        },
        {
            "nom": "Garcia",
            "prenom": "Claire",
            "email": "partiel@firemanager.ca",
            "telephone": "514-888-9900",
            "contact_urgence": "514-666-4444",
            "grade": "Pompier",
            "type_emploi": "temps_partiel",
            "heures_max_semaine": 25,  # 25h max par semaine
            "role": "employe",
            "numero_employe": "POM005",
            "date_embauche": "02/11/2020",
            "formations": [],
            "mot_de_passe": "partiel123"
        }
    ]
    
    # First create formations
    demo_formations = [
        {
            "nom": "Classe 4A",
            "description": "Formation de conduite vÃ©hicules lourds",
            "duree_heures": 40,
            "validite_mois": 60,
            "obligatoire": False
        },
        {
            "nom": "DÃ©sincarcÃ©ration",
            "description": "Techniques de dÃ©sincarcÃ©ration",
            "duree_heures": 24,
            "validite_mois": 36,
            "obligatoire": True
        },
        {
            "nom": "Pompier 1",
            "description": "Formation de base pompier niveau 1",
            "duree_heures": 200,
            "validite_mois": 24,
            "obligatoire": True
        },
        {
            "nom": "Officier 2",
            "description": "Formation officier niveau 2",
            "duree_heures": 120,
            "validite_mois": 36,
            "obligatoire": False
        },
        {
            "nom": "Premiers RÃ©pondants",
            "description": "Formation premiers secours",
            "duree_heures": 16,
            "validite_mois": 12,
            "obligatoire": True
        }
    ]
    
    formation_ids = {}
    for formation_data in demo_formations:
        formation_obj = Formation(**formation_data)
        await db.formations.insert_one(formation_obj.dict())
        formation_ids[formation_data["nom"]] = formation_obj.id
    
    # Update users with formation IDs
    demo_users[0]["formations"] = [formation_ids["Officier 2"], formation_ids["Pompier 1"]]  # Jean
    demo_users[1]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers RÃ©pondants"]]  # Sophie  
    demo_users[2]["formations"] = [formation_ids["Classe 4A"], formation_ids["DÃ©sincarcÃ©ration"]]  # Pierre
    demo_users[3]["formations"] = []  # Claire - aucune formation
    
    for user_data in demo_users:
        user_dict = user_data.copy()
        user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
        user_dict["statut"] = "Actif"
        user_obj = User(**user_dict)
        await db.users.insert_one(user_obj.dict())
    
    # Create demo garde types
    demo_types_garde = [
        {
            "nom": "Garde Interne AM - Semaine",
            "heure_debut": "06:00",
            "heure_fin": "12:00",
            "personnel_requis": 4,
            "duree_heures": 6,
            "couleur": "#10B981",
            "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"],
            "officier_obligatoire": True
        },
        {
            "nom": "Garde Interne PM - Semaine",
            "heure_debut": "12:00",
            "heure_fin": "18:00",
            "personnel_requis": 4,
            "duree_heures": 6,
            "couleur": "#3B82F6",
            "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"],
            "officier_obligatoire": True
        },
        {
            "nom": "Garde Externe Citerne",
            "heure_debut": "18:00",
            "heure_fin": "06:00",
            "personnel_requis": 1,
            "duree_heures": 12,
            "couleur": "#8B5CF6",
            "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"],
            "officier_obligatoire": False
        }
    ]
    
    for type_garde_data in demo_types_garde:
        type_garde_obj = TypeGarde(**type_garde_data)
        await db.types_garde.insert_one(type_garde_obj.dict())
    
    # Create demo disponibilitÃ©s for part-time employee (Claire Garcia) with specific dates
    claire_user = await db.users.find_one({"email": "partiel@firemanager.ca"})
    if claire_user:
        # Create availabilities for next 2 weeks
        today = datetime.now(timezone.utc).date()
        demo_disponibilites = []
        
        # Generate availabilities for specific dates
        for week_offset in range(4):  # Next 4 weeks
            week_start = today + timedelta(weeks=week_offset)
            week_start = week_start - timedelta(days=week_start.weekday())  # Get Monday
            
            # Claire is available Monday, Wednesday, Friday
            for day_offset in [0, 2, 4]:  # Monday, Wednesday, Friday
                date_available = week_start + timedelta(days=day_offset)
                demo_disponibilites.append({
                    "user_id": claire_user["id"],
                    "date": date_available.strftime("%Y-%m-%d"),
                    "heure_debut": "08:00",
                    "heure_fin": "16:00",
                    "statut": "disponible"
                })
        
        for dispo_data in demo_disponibilites:
            dispo_obj = Disponibilite(**dispo_data)
            await db.disponibilites.insert_one(dispo_obj.dict())
    
    return {"message": "DonnÃ©es de dÃ©monstration crÃ©Ã©es avec succÃ¨s"}

# ==================== NOTIFICATIONS ====================

@api_router.get("/{tenant_slug}/notifications", response_model=List[Notification])
async def get_notifications(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re toutes les notifications de l'utilisateur connectÃ©"""
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    notifications = await db.notifications.find({
        "tenant_id": tenant.id,
        "destinataire_id": current_user.id
    }).sort("date_creation", -1).limit(50).to_list(50)
    
    cleaned_notifications = [clean_mongo_doc(notif) for notif in notifications]
    return [Notification(**notif) for notif in cleaned_notifications]

@api_router.get("/{tenant_slug}/notifications/non-lues/count")
async def get_unread_count(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Compte le nombre de notifications non lues"""
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    count = await db.notifications.count_documents({
        "tenant_id": tenant.id,
        "destinataire_id": current_user.id,
        "statut": "non_lu"
    })
    return {"count": count}

@api_router.put("/{tenant_slug}/notifications/{notification_id}/marquer-lu")
async def marquer_notification_lue(tenant_slug: str, notification_id: str, current_user: User = Depends(get_current_user)):
    """Marque une notification comme lue"""
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    notification = await db.notifications.find_one({
        "id": notification_id,
        "tenant_id": tenant.id,
        "destinataire_id": current_user.id
    })
    
    if not notification:
        raise HTTPException(status_code=404, detail="Notification non trouvÃ©e")
    
    await db.notifications.update_one(
        {"id": notification_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "lu",
            "date_lecture": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    return {"message": "Notification marquÃ©e comme lue"}

@api_router.put("/{tenant_slug}/notifications/marquer-toutes-lues")
async def marquer_toutes_lues(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Marque toutes les notifications comme lues"""
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.notifications.update_many(
        {
            "tenant_id": tenant.id,
            "destinataire_id": current_user.id,
            "statut": "non_lu"
        },
        {"$set": {
            "statut": "lu",
            "date_lecture": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    return {"message": f"{result.modified_count} notification(s) marquÃ©e(s) comme lue(s)"}

# Helper function pour crÃ©er des notifications
async def creer_notification(
    tenant_id: str,
    destinataire_id: str,
    type: str,
    titre: str,
    message: str,
    lien: Optional[str] = None,
    data: Optional[Dict[str, Any]] = None
):
    """CrÃ©e une notification dans la base de donnÃ©es"""
    notification = Notification(
        tenant_id=tenant_id,
        destinataire_id=destinataire_id,
        type=type,
        titre=titre,
        message=message,
        lien=lien,
        data=data or {}
    )
    await db.notifications.insert_one(notification.dict())
    return notification

# ==================== PARAMÃˆTRES REMPLACEMENTS ====================

@api_router.get("/{tenant_slug}/parametres/remplacements")
async def get_parametres_remplacements(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re les paramÃ¨tres de remplacements"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Chercher pour ce tenant spÃ©cifique
    parametres = await db.parametres_remplacements.find_one({"tenant_id": tenant.id})
    
    if not parametres:
        # CrÃ©er paramÃ¨tres par dÃ©faut pour ce tenant
        default_params = ParametresRemplacements(tenant_id=tenant.id)
        await db.parametres_remplacements.insert_one(default_params.dict())
        return default_params
    
    cleaned_params = clean_mongo_doc(parametres)
    return cleaned_params  # Retourner le dict directement pour plus de flexibilitÃ©

@api_router.put("/{tenant_slug}/parametres/remplacements")
async def update_parametres_remplacements(
    tenant_slug: str,
    parametres_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour les paramÃ¨tres de remplacements"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Chercher les paramÃ¨tres existants pour ce tenant
    existing = await db.parametres_remplacements.find_one({"tenant_id": tenant.id})
    
    # S'assurer que tenant_id est prÃ©sent dans les donnÃ©es
    parametres_data["tenant_id"] = tenant.id
    
    if existing:
        # Mettre Ã  jour les paramÃ¨tres existants
        await db.parametres_remplacements.update_one(
            {"tenant_id": tenant.id},
            {"$set": parametres_data}
        )
    else:
        # CrÃ©er de nouveaux paramÃ¨tres avec un ID
        if "id" not in parametres_data:
            parametres_data["id"] = str(uuid.uuid4())
        await db.parametres_remplacements.insert_one(parametres_data)
    
    return {"message": "ParamÃ¨tres mis Ã  jour avec succÃ¨s"}


# ==================== PARAMÃˆTRES NIVEAUX D'ATTRIBUTION ====================

@api_router.get("/{tenant_slug}/parametres/niveaux-attribution")
async def get_niveaux_attribution(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re les paramÃ¨tres des niveaux d'attribution automatique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Les niveaux sont stockÃ©s dans les paramÃ¨tres du tenant
    return {
        "niveau_2_actif": tenant.parametres.get("niveau_2_actif", True),
        "niveau_3_actif": tenant.parametres.get("niveau_3_actif", True),
        "niveau_4_actif": tenant.parametres.get("niveau_4_actif", True),
        "niveau_5_actif": tenant.parametres.get("niveau_5_actif", True)
    }

@api_router.put("/{tenant_slug}/parametres/niveaux-attribution")
async def update_niveaux_attribution(
    tenant_slug: str,
    niveaux_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour les paramÃ¨tres des niveaux d'attribution automatique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Mettre Ã  jour les niveaux dans les paramÃ¨tres du tenant
    update_fields = {}
    for key in ['niveau_2_actif', 'niveau_3_actif', 'niveau_4_actif', 'niveau_5_actif']:
        if key in niveaux_data:
            update_fields[f"parametres.{key}"] = niveaux_data[key]
    
    if update_fields:
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": update_fields}
        )
        logging.info(f"âœ… Niveaux d'attribution mis Ã  jour pour {tenant.slug}: {update_fields}")
    
    return {"message": "Niveaux d'attribution mis Ã  jour avec succÃ¨s"}


# ==================== PARAMÃˆTRES VALIDATION PLANNING ====================

@api_router.get("/{tenant_slug}/parametres/validation-planning")
async def get_parametres_validation_planning(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re les paramÃ¨tres de validation/notification du planning"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_validation_planning.find_one({"tenant_id": tenant.id})
    
    if not params:
        # CrÃ©er paramÃ¨tres par dÃ©faut
        default_params = ParametresValidationPlanning(
            tenant_id=tenant.id,
            frequence="mensuel",
            jour_envoi=25,
            heure_envoi="17:00",
            periode_couverte="mois_suivant",
            envoi_automatique=True,
            derniere_notification=None
        )
        await db.parametres_validation_planning.insert_one(default_params.dict())
        params = default_params.dict()
    
    return clean_mongo_doc(params)

@api_router.put("/{tenant_slug}/parametres/validation-planning")
async def update_parametres_validation_planning(
    tenant_slug: str,
    params: dict = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour les paramÃ¨tres de validation/notification du planning"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Valider les donnÃ©es
    if params.get("jour_envoi") and (params["jour_envoi"] < 1 or params["jour_envoi"] > 28):
        raise HTTPException(status_code=400, detail="Le jour d'envoi doit Ãªtre entre 1 et 28")
    
    # VÃ©rifier si paramÃ¨tres existent
    existing = await db.parametres_validation_planning.find_one({"tenant_id": tenant.id})
    
    if existing:
        # Mettre Ã  jour
        await db.parametres_validation_planning.update_one(
            {"tenant_id": tenant.id},
            {"$set": {**params, "updated_at": datetime.now(timezone.utc).isoformat()}}
        )
    else:
        # CrÃ©er
        new_params = ParametresValidationPlanning(
            tenant_id=tenant.id,
            **params
        )
        await db.parametres_validation_planning.insert_one(new_params.dict())
    
    # Si les notifications automatiques ont Ã©tÃ© activÃ©es, redÃ©marrer le scheduler
    if params.get("envoi_automatique"):
        # Le scheduler sera automatiquement rechargÃ© au prochain tick
        logging.info(f"Notifications automatiques activÃ©es pour {tenant.nom}")
    
    return {"message": "ParamÃ¨tres mis Ã  jour avec succÃ¨s"}


# ==================== PARAMÃˆTRES DISPONIBILITÃ‰S ====================

@api_router.get("/{tenant_slug}/parametres/disponibilites")
async def get_parametres_disponibilites(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re les paramÃ¨tres disponibilitÃ©s"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_disponibilites.find_one({"tenant_id": tenant.id})
    
    if not params:
        # CrÃ©er paramÃ¨tres par dÃ©faut
        default_params = {
            "tenant_id": tenant.id,
            "jour_blocage_dispos": 15,
            "exceptions_admin_superviseur": True,
            "admin_peut_modifier_temps_partiel": True,
            "notifications_dispos_actives": True,
            "jours_avance_notification": 3
        }
        await db.parametres_disponibilites.insert_one(default_params)
        return default_params
    
    return clean_mongo_doc(params)

@api_router.put("/{tenant_slug}/parametres/disponibilites")
async def update_parametres_disponibilites(
    tenant_slug: str,
    params: dict,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour les paramÃ¨tres disponibilitÃ©s"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.parametres_disponibilites.update_one(
        {"tenant_id": tenant.id},
        {"$set": params},
        upsert=True
    )
    
    return {"message": "ParamÃ¨tres disponibilitÃ©s mis Ã  jour"}

# ==================== EPI ROUTES NFPA 1851 ====================

# ========== EPI CRUD ==========

@api_router.post("/{tenant_slug}/epi", response_model=EPI)
async def create_epi(tenant_slug: str, epi: EPICreate, current_user: User = Depends(get_current_user)):
    """CrÃ©e un nouvel Ã©quipement EPI (Admin/Superviseur/EmployÃ© pour lui-mÃªme)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Les admins/superviseurs peuvent crÃ©er pour n'importe qui
    # Les employÃ©s peuvent crÃ©er uniquement pour eux-mÃªmes
    if current_user.role not in ["admin", "superviseur"]:
        if epi.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Vous ne pouvez crÃ©er des EPI que pour vous-mÃªme")
    
    epi_dict = epi.dict()
    epi_dict["tenant_id"] = tenant.id
    
    # GÃ©nÃ©rer numÃ©ro de sÃ©rie automatique si vide
    if not epi_dict.get("numero_serie") or epi_dict["numero_serie"].strip() == "":
        # Compter les EPI existants pour gÃ©nÃ©rer un numÃ©ro unique
        count = await db.epis.count_documents({"tenant_id": tenant.id})
        annee = datetime.now(timezone.utc).year
        epi_dict["numero_serie"] = f"EPI-{annee}-{count + 1:04d}"
    else:
        # VÃ©rifier que le numÃ©ro de sÃ©rie est unique
        existing_epi = await db.epis.find_one({
            "numero_serie": epi_dict["numero_serie"],
            "tenant_id": tenant.id
        })
        
        if existing_epi:
            raise HTTPException(
                status_code=400,
                detail=f"Un EPI avec le numÃ©ro de sÃ©rie {epi_dict['numero_serie']} existe dÃ©jÃ "
            )
    
    epi_obj = EPI(**epi_dict)
    
    # PrÃ©parer pour MongoDB (conversion datetime -> ISO string)
    epi_data = epi_obj.dict()
    epi_data["created_at"] = epi_obj.created_at.isoformat()
    epi_data["updated_at"] = epi_obj.updated_at.isoformat()
    
    await db.epis.insert_one(epi_data)
    
    # CrÃ©er une activitÃ©
    user = await db.users.find_one({"id": epi.user_id, "tenant_id": tenant.id})
    if user:
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="epi_attribution",
            description=f"ğŸ§° {current_user.prenom} {current_user.nom} a attribuÃ© l'EPI '{epi.type_equipement}' (#{epi_dict['numero_serie']}) Ã  {user['prenom']} {user['nom']}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": epi.user_id}
        )
    
    return epi_obj

@api_router.post("/{tenant_slug}/epi/import-csv")
async def import_epis_csv(
    tenant_slug: str,
    epis_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse d'EPI depuis un CSV"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    epis = epis_data.get("epis", [])
    if not epis:
        raise HTTPException(status_code=400, detail="Aucun EPI Ã  importer")
    
    results = {
        "total": len(epis),
        "created": 0,
        "updated": 0,
        "errors": [],
        "duplicates": []
    }
    
    # PrÃ©charger les utilisateurs pour matching intelligent
    users_list = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    users_by_name = create_user_matching_index(users_list)
    users_by_num = {u.get("numero_employe"): u for u in users_list if u.get("numero_employe")}
    
    for index, epi_data in enumerate(epis):
        try:
            # Validation des champs obligatoires
            if not epi_data.get("type_epi") or not epi_data.get("numero_serie"):
                results["errors"].append({
                    "line": index + 1,
                    "error": "Type EPI et NumÃ©ro de sÃ©rie requis",
                    "data": epi_data
                })
                continue
            
            # Rechercher l'employÃ© avec matching intelligent
            user_id = None
            if epi_data.get("employe_nom"):
                employe_str = epi_data["employe_nom"].strip()
                
                # Utiliser le matching intelligent
                user_obj = find_user_intelligent(
                    search_string=employe_str,
                    users_by_name=users_by_name,
                    users_by_num=users_by_num,
                    numero_field="numero_employe"
                )
                
                if user_obj:
                    user_id = user_obj["id"]
                else:
                    results["errors"].append({
                        "line": index + 1,
                        "error": f"EmployÃ© non trouvÃ©: {employe_str}",
                        "data": epi_data
                    })
                    continue
            
            # VÃ©rifier si l'EPI existe dÃ©jÃ  (par numÃ©ro de sÃ©rie)
            existing_epi = await db.epis.find_one({
                "numero_serie": epi_data["numero_serie"],
                "tenant_id": tenant.id
            })
            
            if existing_epi:
                results["duplicates"].append({
                    "line": index + 1,
                    "numero_serie": epi_data["numero_serie"],
                    "action": epi_data.get("action_doublon", "skip"),  # skip, update, create
                    "data": epi_data
                })
                
                # Si action_doublon = update, mettre Ã  jour
                if epi_data.get("action_doublon") == "update":
                    update_data = {
                        "type_epi": epi_data.get("type_epi"),
                        "marque": epi_data.get("marque", ""),
                        "modele": epi_data.get("modele", ""),
                        "taille": epi_data.get("taille", ""),
                        "statut": epi_data.get("statut", "bon"),
                        "norme_certification": epi_data.get("norme_certification", ""),
                        "notes": epi_data.get("notes", ""),
                        "updated_at": datetime.now(timezone.utc).isoformat()
                    }
                    
                    if user_id:
                        update_data["user_id"] = user_id
                    
                    # Dates optionnelles
                    if epi_data.get("date_mise_en_service"):
                        update_data["date_mise_en_service"] = epi_data["date_mise_en_service"]
                    if epi_data.get("date_dernier_controle"):
                        update_data["date_dernier_controle"] = epi_data["date_dernier_controle"]
                    if epi_data.get("date_prochain_controle"):
                        update_data["date_prochain_controle"] = epi_data["date_prochain_controle"]
                    
                    await db.epis.update_one(
                        {"id": existing_epi["id"], "tenant_id": tenant.id},
                        {"$set": update_data}
                    )
                    results["updated"] += 1
                elif epi_data.get("action_doublon") == "create":
                    # CrÃ©er quand mÃªme avec un numÃ©ro de sÃ©rie modifiÃ©
                    count = await db.epis.count_documents({"tenant_id": tenant.id})
                    epi_data["numero_serie"] = f"{epi_data['numero_serie']}-DUP-{count + 1}"
                    # Continue avec la crÃ©ation ci-dessous
                else:
                    # skip par dÃ©faut
                    continue
            
            # CrÃ©er l'EPI s'il n'existe pas (ou si action_doublon = create)
            if not existing_epi or epi_data.get("action_doublon") == "create":
                new_epi = {
                    "id": str(uuid.uuid4()),
                    "tenant_id": tenant.id,
                    "type_epi": epi_data["type_epi"],
                    "numero_serie": epi_data["numero_serie"],
                    "marque": epi_data.get("marque", ""),
                    "modele": epi_data.get("modele", ""),
                    "taille": epi_data.get("taille", ""),
                    "statut": epi_data.get("statut", "bon"),
                    "norme_certification": epi_data.get("norme_certification", ""),
                    "notes": epi_data.get("notes", ""),
                    "created_at": datetime.now(timezone.utc).isoformat(),
                    "updated_at": datetime.now(timezone.utc).isoformat()
                }
                
                if user_id:
                    new_epi["user_id"] = user_id
                
                # Dates optionnelles
                if epi_data.get("date_mise_en_service"):
                    new_epi["date_mise_en_service"] = epi_data["date_mise_en_service"]
                if epi_data.get("date_dernier_controle"):
                    new_epi["date_dernier_controle"] = epi_data["date_dernier_controle"]
                if epi_data.get("date_prochain_controle"):
                    new_epi["date_prochain_controle"] = epi_data["date_prochain_controle"]
                
                await db.epis.insert_one(new_epi)
                results["created"] += 1
        
        except Exception as e:
            results["errors"].append({
                "line": index + 1,
                "error": str(e),
                "data": epi_data
            })
    
    return results


# ==================== CONFIGURATION IMPORTS CSV ====================

@api_router.get("/{tenant_slug}/config/import-settings")
async def get_import_settings(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re la configuration des imports CSV pour le tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur a les droits
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s non autorisÃ©")
    
    # RÃ©cupÃ©rer ou crÃ©er la configuration par dÃ©faut
    settings = await db.import_settings.find_one({"tenant_id": tenant.id})
    
    if not settings:
        # CrÃ©er une configuration par dÃ©faut avec tous les champs disponibles
        default_epi_fields = [
            {"key": "numero_serie", "label": "NumÃ©ro de sÃ©rie interne (optionnel)", "required": False},
            {"key": "type_epi", "label": "Type d'EPI", "required": True},
            {"key": "marque", "label": "Marque", "required": True},
            {"key": "modele", "label": "ModÃ¨le", "required": True},
            {"key": "numero_serie_fabricant", "label": "NÂ° sÃ©rie fabricant", "required": False},
            {"key": "date_fabrication", "label": "Date fabrication (YYYY-MM-DD)", "required": False},
            {"key": "date_mise_en_service", "label": "Date mise en service (YYYY-MM-DD)", "required": True},
            {"key": "norme_certification", "label": "Norme certification", "required": False},
            {"key": "cout_achat", "label": "CoÃ»t d'achat", "required": False},
            {"key": "couleur", "label": "Couleur", "required": False},
            {"key": "taille", "label": "Taille", "required": False},
            {"key": "user_id", "label": "AssignÃ© Ã  (ID utilisateur)", "required": False},
            {"key": "statut", "label": "Statut", "required": True},
            {"key": "notes", "label": "Notes", "required": False}
        ]
        
        default_personnel_fields = [
            {"key": "prenom", "label": "PrÃ©nom", "required": True},
            {"key": "nom", "label": "Nom", "required": True},
            {"key": "email", "label": "Email", "required": True},
            {"key": "numero_badge", "label": "NumÃ©ro de badge", "required": False},
            {"key": "telephone", "label": "TÃ©lÃ©phone", "required": False},
            {"key": "adresse", "label": "Adresse", "required": False},
            {"key": "ville", "label": "Ville", "required": False},
            {"key": "code_postal", "label": "Code postal", "required": False},
            {"key": "date_naissance", "label": "Date de naissance", "required": False},
            {"key": "date_embauche", "label": "Date d'embauche", "required": False},
            {"key": "role", "label": "RÃ´le", "required": False},
            {"key": "statut", "label": "Statut", "required": False},
            {"key": "contact_urgence_nom", "label": "Contact urgence - Nom", "required": False},
            {"key": "contact_urgence_telephone", "label": "Contact urgence - TÃ©lÃ©phone", "required": False},
            {"key": "contact_urgence_relation", "label": "Contact urgence - Relation", "required": False}
        ]
        
        default_rapports_fields = [
            {"key": "type", "label": "Type (budget/depense)", "required": True},
            {"key": "date", "label": "Date", "required": True},
            {"key": "description", "label": "Description", "required": True},
            {"key": "categorie", "label": "CatÃ©gorie", "required": False},
            {"key": "montant", "label": "Montant", "required": True},
            {"key": "notes", "label": "Notes", "required": False}
        ]
        
        settings = {
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "epi_fields": default_epi_fields,
            "personnel_fields": default_personnel_fields,
            "rapports_fields": default_rapports_fields,
            "updated_at": datetime.now(timezone.utc).isoformat()
        }
        
        await db.import_settings.insert_one(settings)
    
    # Remove MongoDB ObjectId and return clean data
    if settings and "_id" in settings:
        del settings["_id"]
    
    return settings


@api_router.put("/{tenant_slug}/config/import-settings")
async def update_import_settings(
    tenant_slug: str,
    settings_update: ImportSettingsUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour la configuration des imports CSV"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur a les droits
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s non autorisÃ©")
    
    # RÃ©cupÃ©rer la configuration existante
    existing_settings = await db.import_settings.find_one({"tenant_id": tenant.id})
    
    if not existing_settings:
        raise HTTPException(status_code=404, detail="Configuration non trouvÃ©e")
    
    # Mettre Ã  jour uniquement les champs fournis
    update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}
    
    if settings_update.epi_fields is not None:
        update_data["epi_fields"] = [field.dict() for field in settings_update.epi_fields]
    
    if settings_update.personnel_fields is not None:
        update_data["personnel_fields"] = [field.dict() for field in settings_update.personnel_fields]
    
    if settings_update.rapports_fields is not None:
        update_data["rapports_fields"] = [field.dict() for field in settings_update.rapports_fields]
    
    await db.import_settings.update_one(
        {"tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    # Retourner la configuration mise Ã  jour
    updated_settings = await db.import_settings.find_one({"tenant_id": tenant.id})
    return updated_settings



@api_router.get("/{tenant_slug}/epi", response_model=List[EPI])
async def get_all_epis(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re tous les EPI du tenant (Admin/Superviseur)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    epis = await db.epis.find({"tenant_id": tenant.id}).to_list(1000)
    cleaned_epis = [clean_mongo_doc(epi) for epi in epis]
    
    # Convertir les dates ISO string vers datetime
    for epi in cleaned_epis:
        if isinstance(epi.get("created_at"), str):
            epi["created_at"] = datetime.fromisoformat(epi["created_at"].replace('Z', '+00:00'))
        if isinstance(epi.get("updated_at"), str):
            epi["updated_at"] = datetime.fromisoformat(epi["updated_at"].replace('Z', '+00:00'))
    
    return [EPI(**epi) for epi in cleaned_epis]

@api_router.get("/{tenant_slug}/epi/employe/{user_id}", response_model=List[EPI])
async def get_epis_by_employe(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re tous les EPI d'un employÃ© spÃ©cifique"""
    # Un employÃ© peut voir ses propres EPIs, admin/superviseur peuvent voir tous les EPIs
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer les EPIs assignÃ©s Ã  cet employÃ©
    epis = await db.epis.find({"tenant_id": tenant.id, "user_id": user_id}).to_list(1000)
    cleaned_epis = [clean_mongo_doc(epi) for epi in epis]
    
    # Convertir les dates ISO string vers datetime
    for epi in cleaned_epis:
        if isinstance(epi.get("created_at"), str):
            epi["created_at"] = datetime.fromisoformat(epi["created_at"].replace('Z', '+00:00'))
        if isinstance(epi.get("updated_at"), str):
            epi["updated_at"] = datetime.fromisoformat(epi["updated_at"].replace('Z', '+00:00'))
    
    return [EPI(**epi) for epi in cleaned_epis]

@api_router.get("/{tenant_slug}/epi/demandes-remplacement")
async def get_demandes_remplacement_epi(
    tenant_slug: str,
    statut: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re les demandes de remplacement EPI (admin/superviseur)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Filtrer par statut si spÃ©cifiÃ©
    query = {"tenant_id": tenant.id}
    if statut:
        query["statut"] = statut
    
    demandes = await db.demandes_remplacement_epi.find(query).sort("date_demande", -1).to_list(1000)
    
    # Enrichir avec les infos EPI et utilisateur
    for demande in demandes:
        # Remove MongoDB ObjectId to prevent JSON serialization errors
        if "_id" in demande:
            del demande["_id"]
            
        epi = await db.epis.find_one({"id": demande["epi_id"], "tenant_id": tenant.id})
        user = await db.users.find_one({"id": demande["user_id"], "tenant_id": tenant.id})
        
        if epi:
            demande["epi_info"] = {
                "type_epi": epi.get("type_epi"),
                "marque": epi.get("marque"),
                "modele": epi.get("modele"),
                "numero_serie": epi.get("numero_serie")
            }
        
        if user:
            demande["user_nom"] = f"{user.get('prenom', '')} {user.get('nom', '')}"
        
        # Ajouter info admin si traitÃ©
        if demande.get("traite_par"):
            admin = await db.users.find_one({"id": demande["traite_par"], "tenant_id": tenant.id})
            if admin:
                demande["traite_par_nom"] = f"{admin.get('prenom', '')} {admin.get('nom', '')}"
    
    return demandes

@api_router.put("/{tenant_slug}/epi/demandes-remplacement/{demande_id}")
async def traiter_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    statut: str,
    notes_admin: str = "",
    current_user: User = Depends(get_current_user)
):
    """Approuver ou refuser une demande de remplacement (admin/superviseur)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if statut not in ["ApprouvÃ©e", "RefusÃ©e"]:
        raise HTTPException(status_code=400, detail="Statut invalide. Doit Ãªtre 'ApprouvÃ©e' ou 'RefusÃ©e'")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer la demande
    demande = await db.demandes_remplacement_epi.find_one({"id": demande_id, "tenant_id": tenant.id})
    if not demande:
        raise HTTPException(status_code=404, detail="Demande non trouvÃ©e")
    
    if demande["statut"] != "En attente":
        raise HTTPException(status_code=400, detail="Cette demande a dÃ©jÃ  Ã©tÃ© traitÃ©e")
    
    # Mettre Ã  jour la demande
    await db.demandes_remplacement_epi.update_one(
        {"id": demande_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": statut,
            "date_traitement": datetime.now(timezone.utc),
            "traite_par": current_user.id,
            "notes_admin": notes_admin
        }}
    )
    
    # Envoyer notification Ã  l'employÃ©
    await creer_notification(
        tenant_id=tenant.id,
        destinataire_id=demande["user_id"],
        type="reponse_demande_remplacement_epi",
        titre=f"Demande de remplacement EPI {'approuvÃ©e' if statut == 'ApprouvÃ©e' else 'refusÃ©e'}",
        message=f"Votre demande de remplacement EPI a Ã©tÃ© {statut.lower()}. {notes_admin}",
        lien="/mes-epi",
        data={"demande_id": demande_id, "statut": statut}
    )
    
    return {"message": f"Demande {statut.lower()} avec succÃ¨s"}

@api_router.post("/{tenant_slug}/epi/demandes-remplacement/{demande_id}/approuver")
async def approuver_demande_remplacement_epi(
    tenant_slug: str,
    demande_id: str,
    notes_admin: str = "",
    current_user: User = Depends(get_current_user)
):
    """Approuver une demande de remplacement EPI"""
    return await traiter_demande_remplacement(tenant_slug, demande_id, "ApprouvÃ©e", notes_admin, current_user)

@api_router.post("/{tenant_slug}/epi/demandes-remplacement/{demande_id}/refuser")
async def refuser_demande_remplacement_epi(
    tenant_slug: str,
    demande_id: str,
    notes_admin: str = "",
    current_user: User = Depends(get_current_user)
):
    """Refuser une demande de remplacement EPI"""
    return await traiter_demande_remplacement(tenant_slug, demande_id, "RefusÃ©e", notes_admin, current_user)
@api_router.get("/{tenant_slug}/epi/{epi_id}", response_model=EPI)
async def get_epi_by_id(tenant_slug: str, epi_id: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re un EPI spÃ©cifique par son ID"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    cleaned_epi = clean_mongo_doc(epi)
    
    # Convertir les dates
    if isinstance(cleaned_epi.get("created_at"), str):
        cleaned_epi["created_at"] = datetime.fromisoformat(cleaned_epi["created_at"].replace('Z', '+00:00'))
    if isinstance(cleaned_epi.get("updated_at"), str):
        cleaned_epi["updated_at"] = datetime.fromisoformat(cleaned_epi["updated_at"].replace('Z', '+00:00'))
    
    return EPI(**cleaned_epi)

@api_router.put("/{tenant_slug}/epi/{epi_id}", response_model=EPI)
async def update_epi(
    tenant_slug: str,
    epi_id: str,
    epi_update: EPIUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour un EPI (Admin/Superviseur/EmployÃ© pour sa taille uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    # Les admins/superviseurs peuvent tout modifier
    # Les employÃ©s peuvent modifier uniquement la taille de leurs propres EPIs
    if current_user.role not in ["admin", "superviseur"]:
        if epi.get("user_id") != current_user.id:
            raise HTTPException(status_code=403, detail="Vous ne pouvez modifier que vos propres EPIs")
        
        # Restreindre les modifications aux champs autorisÃ©s pour un employÃ©
        allowed_fields = ["taille"]
        update_data_dict = epi_update.dict()
        for key in list(update_data_dict.keys()):
            if key not in allowed_fields and update_data_dict[key] is not None:
                raise HTTPException(status_code=403, detail=f"Vous ne pouvez modifier que la taille de vos EPIs")
    
    # PrÃ©parer les champs Ã  mettre Ã  jour
    update_data = {k: v for k, v in epi_update.dict().items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc).isoformat()
    
    # VÃ©rifier si changement d'affectation (user_id)
    ancien_user_id = epi.get("user_id")
    nouveau_user_id = update_data.get("user_id")
    
    await db.epis.update_one(
        {"id": epi_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    # Notifier si changement d'affectation
    if nouveau_user_id and nouveau_user_id != ancien_user_id:
        type_epi_nom = epi.get("type_epi", "EPI")
        await creer_notification(
            tenant_id=tenant.id,
            destinataire_id=nouveau_user_id,
            type="epi_nouvel_assignation",
            titre="Nouvel EPI assignÃ©",
            message=f"Un {type_epi_nom} #{epi.get('numero_serie', '')} vous a Ã©tÃ© assignÃ©",
            lien="/epi"
        )
    
    updated_epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    cleaned_epi = clean_mongo_doc(updated_epi)
    
    # Convertir les dates
    if isinstance(cleaned_epi.get("created_at"), str):
        cleaned_epi["created_at"] = datetime.fromisoformat(cleaned_epi["created_at"].replace('Z', '+00:00'))
    if isinstance(cleaned_epi.get("updated_at"), str):
        cleaned_epi["updated_at"] = datetime.fromisoformat(cleaned_epi["updated_at"].replace('Z', '+00:00'))
    
    return EPI(**cleaned_epi)

@api_router.delete("/{tenant_slug}/epi/{epi_id}")
async def delete_epi(tenant_slug: str, epi_id: str, current_user: User = Depends(get_current_user)):
    """Supprime un EPI (Admin/Superviseur)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.epis.delete_one({"id": epi_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    # Supprimer aussi toutes les inspections associÃ©es
    await db.inspections_epi.delete_many({"epi_id": epi_id, "tenant_id": tenant.id})
    
    return {"message": "EPI supprimÃ© avec succÃ¨s"}

# ========== INSPECTIONS EPI ==========

@api_router.post("/{tenant_slug}/epi/{epi_id}/inspection", response_model=InspectionEPI)
async def create_inspection(
    tenant_slug: str,
    epi_id: str,
    inspection: InspectionEPICreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©e une nouvelle inspection pour un EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'EPI existe
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    inspection_dict = inspection.dict()
    inspection_dict["tenant_id"] = tenant.id
    inspection_dict["epi_id"] = epi_id
    inspection_obj = InspectionEPI(**inspection_dict)
    
    # PrÃ©parer pour MongoDB
    inspection_data = inspection_obj.dict()
    inspection_data["created_at"] = inspection_obj.created_at.isoformat()
    
    await db.inspections_epi.insert_one(inspection_data)
    
    # Mettre Ã  jour le statut de l'EPI si nÃ©cessaire
    if inspection.statut_global == "hors_service":
        await db.epis.update_one(
            {"id": epi_id, "tenant_id": tenant.id},
            {"$set": {"statut": "Hors service"}}
        )
    elif inspection.statut_global == "necessite_reparation":
        await db.epis.update_one(
            {"id": epi_id, "tenant_id": tenant.id},
            {"$set": {"statut": "En rÃ©paration"}}
        )
    
    # Notifier le pompier assignÃ©
    if epi.get("user_id"):
        type_epi_nom = epi.get("type_epi", "EPI")
        type_inspection_nom = {
            'apres_utilisation': 'aprÃ¨s utilisation',
            'routine_mensuelle': 'de routine mensuelle',
            'avancee_annuelle': 'avancÃ©e annuelle'
        }.get(inspection.type_inspection, 'inspection')
        
        statut_msg = {
            'conforme': 'est conforme',
            'non_conforme': 'n\'est pas conforme',
            'necessite_reparation': 'nÃ©cessite une rÃ©paration',
            'hors_service': 'est hors service'
        }.get(inspection.statut_global, 'a Ã©tÃ© inspectÃ©')
        
        await creer_notification(
            tenant_id=tenant.id,
            destinataire_id=epi["user_id"],
            type="epi_inspection",
            titre=f"Inspection {type_inspection_nom}",
            message=f"Votre {type_epi_nom} #{epi.get('numero_serie', '')} {statut_msg}",
            lien="/epi"
        )
    
    return inspection_obj

@api_router.get("/{tenant_slug}/epi/{epi_id}/inspections", response_model=List[InspectionEPI])
async def get_epi_inspections(tenant_slug: str, epi_id: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re toutes les inspections d'un EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    inspections = await db.inspections_epi.find({
        "epi_id": epi_id,
        "tenant_id": tenant.id
    }).sort("date_inspection", -1).to_list(1000)
    
    cleaned_inspections = [clean_mongo_doc(insp) for insp in inspections]
    
    # Convertir les dates
    for insp in cleaned_inspections:
        if isinstance(insp.get("created_at"), str):
            insp["created_at"] = datetime.fromisoformat(insp["created_at"].replace('Z', '+00:00'))
    
    return [InspectionEPI(**insp) for insp in cleaned_inspections]

# ========== ISP (Fournisseurs) ==========

@api_router.post("/{tenant_slug}/isp", response_model=ISP)
async def create_isp(tenant_slug: str, isp: ISPCreate, current_user: User = Depends(get_current_user)):
    """CrÃ©e un nouveau fournisseur de services indÃ©pendant"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    isp_dict = isp.dict()
    isp_dict["tenant_id"] = tenant.id
    isp_obj = ISP(**isp_dict)
    
    # PrÃ©parer pour MongoDB
    isp_data = isp_obj.dict()
    isp_data["created_at"] = isp_obj.created_at.isoformat()
    
    await db.isps.insert_one(isp_data)
    
    return isp_obj

@api_router.get("/{tenant_slug}/isp", response_model=List[ISP])
async def get_all_isps(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re tous les ISP du tenant"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    isps = await db.isps.find({"tenant_id": tenant.id}).to_list(100)
    cleaned_isps = [clean_mongo_doc(isp) for isp in isps]
    
    # Convertir les dates
    for isp in cleaned_isps:
        if isinstance(isp.get("created_at"), str):
            isp["created_at"] = datetime.fromisoformat(isp["created_at"].replace('Z', '+00:00'))
    
    return [ISP(**isp) for isp in cleaned_isps]

@api_router.put("/{tenant_slug}/isp/{isp_id}", response_model=ISP)
async def update_isp(
    tenant_slug: str,
    isp_id: str,
    isp_update: ISPUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour un ISP"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    isp = await db.isps.find_one({"id": isp_id, "tenant_id": tenant.id})
    if not isp:
        raise HTTPException(status_code=404, detail="ISP non trouvÃ©")
    
    update_data = {k: v for k, v in isp_update.dict().items() if v is not None}
    
    await db.isps.update_one(
        {"id": isp_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    updated_isp = await db.isps.find_one({"id": isp_id, "tenant_id": tenant.id})
    cleaned_isp = clean_mongo_doc(updated_isp)
    
    if isinstance(cleaned_isp.get("created_at"), str):
        cleaned_isp["created_at"] = datetime.fromisoformat(cleaned_isp["created_at"].replace('Z', '+00:00'))
    
    return ISP(**cleaned_isp)

@api_router.delete("/{tenant_slug}/isp/{isp_id}")
async def delete_isp(tenant_slug: str, isp_id: str, current_user: User = Depends(get_current_user)):
    """Supprime un ISP"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.isps.delete_one({"id": isp_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="ISP non trouvÃ©")
    
    return {"message": "ISP supprimÃ© avec succÃ¨s"}

# ========== RAPPORTS ==========

@api_router.get("/{tenant_slug}/epi/rapports/conformite")
async def get_rapport_conformite(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Rapport de conformitÃ© gÃ©nÃ©rale avec code couleur"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer tous les EPI
    epis = await db.epis.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = {
        "total": len(epis),
        "en_service": 0,
        "en_inspection": 0,
        "en_reparation": 0,
        "hors_service": 0,
        "retire": 0,
        "epis": []
    }
    
    for epi in epis:
        statut = epi.get("statut", "En service")
        
        # Compter par statut
        if statut == "En service":
            rapport["en_service"] += 1
        elif statut == "En inspection":
            rapport["en_inspection"] += 1
        elif statut == "En rÃ©paration":
            rapport["en_reparation"] += 1
        elif statut == "Hors service":
            rapport["hors_service"] += 1
        elif statut == "RetirÃ©":
            rapport["retire"] += 1
        
        # RÃ©cupÃ©rer la derniÃ¨re inspection
        derniere_inspection = await db.inspections_epi.find_one(
            {"epi_id": epi["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        
        # DÃ©terminer le code couleur
        couleur = "vert"  # Par dÃ©faut
        
        if statut in ["Hors service", "RetirÃ©"]:
            couleur = "rouge"
        elif statut == "En rÃ©paration":
            couleur = "jaune"
        elif derniere_inspection:
            # VÃ©rifier si l'inspection est rÃ©cente
            date_inspection = datetime.fromisoformat(derniere_inspection["date_inspection"])
            jours_depuis_inspection = (datetime.now(timezone.utc) - date_inspection).days
            
            if jours_depuis_inspection > 365:  # Inspection avancÃ©e en retard
                couleur = "rouge"
            elif jours_depuis_inspection > 330:  # Inspection bientÃ´t en retard (dans 35 jours)
                couleur = "jaune"
        else:
            # Pas d'inspection du tout
            couleur = "rouge"
        
        cleaned_epi = clean_mongo_doc(epi)
        cleaned_epi["code_couleur"] = couleur
        cleaned_epi["derniere_inspection"] = clean_mongo_doc(derniere_inspection) if derniere_inspection else None
        
        rapport["epis"].append(cleaned_epi)
    
    return rapport

@api_router.get("/{tenant_slug}/epi/rapports/echeances")
async def get_rapport_echeances(tenant_slug: str, jours: int = 30, current_user: User = Depends(get_current_user)):
    """Rapport des Ã©chÃ©ances d'inspection (dans X jours)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer tous les EPI
    epis = await db.epis.find({"tenant_id": tenant.id}).to_list(1000)
    
    echeances = []
    aujourd_hui = datetime.now(timezone.utc)
    
    for epi in epis:
        # RÃ©cupÃ©rer la derniÃ¨re inspection
        derniere_inspection = await db.inspections_epi.find_one(
            {"epi_id": epi["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        
        if derniere_inspection:
            date_inspection = datetime.fromisoformat(derniere_inspection["date_inspection"])
            type_inspection = derniere_inspection["type_inspection"]
            
            # Calculer la prochaine Ã©chÃ©ance selon le type
            if type_inspection == "avancee_annuelle":
                prochaine_echeance = date_inspection + timedelta(days=365)
            elif type_inspection == "routine_mensuelle":
                prochaine_echeance = date_inspection + timedelta(days=30)
            else:  # apres_utilisation
                prochaine_echeance = date_inspection + timedelta(days=30)  # Routine dans 30 jours
            
            # VÃ©rifier si dans la fenÃªtre de X jours
            jours_restants = (prochaine_echeance - aujourd_hui).days
            
            if 0 <= jours_restants <= jours:
                cleaned_epi = clean_mongo_doc(epi)
                cleaned_epi["prochaine_echeance"] = prochaine_echeance.isoformat()
                cleaned_epi["jours_restants"] = jours_restants
                cleaned_epi["type_inspection_requise"] = "avancee_annuelle" if type_inspection == "avancee_annuelle" else "routine_mensuelle"
                echeances.append(cleaned_epi)
        else:
            # Pas d'inspection = inspection immÃ©diate requise
            cleaned_epi = clean_mongo_doc(epi)
            cleaned_epi["prochaine_echeance"] = aujourd_hui.isoformat()
            cleaned_epi["jours_restants"] = 0
            cleaned_epi["type_inspection_requise"] = "routine_mensuelle"
            echeances.append(cleaned_epi)
    
    # Trier par jours restants
    echeances.sort(key=lambda x: x["jours_restants"])
    
    return {
        "total": len(echeances),
        "echeances": echeances
    }

# Alias pour compatibilitÃ© frontend
@api_router.get("/{tenant_slug}/epi/rapports/echeances-inspection")
async def get_rapport_echeances_inspection_alias(tenant_slug: str, jours: int = 30, current_user: User = Depends(get_current_user)):
    """Alias pour /echeances (compatibilitÃ© frontend)"""
    return await get_rapport_echeances(tenant_slug, jours, current_user)


# ========== PHASE 2 : NETTOYAGE EPI ==========

@api_router.post("/{tenant_slug}/epi/{epi_id}/nettoyage", response_model=NettoyageEPI)
async def create_nettoyage(
    tenant_slug: str,
    epi_id: str,
    nettoyage: NettoyageEPICreate,
    current_user: User = Depends(get_current_user)
):
    """Enregistre un nettoyage EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier EPI existe
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    nettoyage_dict = nettoyage.dict()
    nettoyage_dict["tenant_id"] = tenant.id
    nettoyage_dict["epi_id"] = epi_id
    nettoyage_obj = NettoyageEPI(**nettoyage_dict)
    
    nettoyage_data = nettoyage_obj.dict()
    nettoyage_data["created_at"] = nettoyage_obj.created_at.isoformat()
    
    await db.nettoyages_epi.insert_one(nettoyage_data)
    
    return nettoyage_obj

@api_router.get("/{tenant_slug}/epi/{epi_id}/nettoyages", response_model=List[NettoyageEPI])
async def get_nettoyages_epi(
    tenant_slug: str,
    epi_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re l'historique de nettoyage d'un EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    nettoyages = await db.nettoyages_epi.find({
        "epi_id": epi_id,
        "tenant_id": tenant.id
    }).sort("date_nettoyage", -1).to_list(1000)
    
    cleaned_nettoyages = [clean_mongo_doc(n) for n in nettoyages]
    
    for n in cleaned_nettoyages:
        if isinstance(n.get("created_at"), str):
            n["created_at"] = datetime.fromisoformat(n["created_at"].replace('Z', '+00:00'))
    
    return [NettoyageEPI(**n) for n in cleaned_nettoyages]

# ========== PHASE 2 : RÃ‰PARATIONS EPI ==========

@api_router.post("/{tenant_slug}/epi/{epi_id}/reparation", response_model=ReparationEPI)
async def create_reparation(
    tenant_slug: str,
    epi_id: str,
    reparation: ReparationEPICreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©e une demande de rÃ©paration"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier EPI existe
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    reparation_dict = reparation.dict()
    reparation_dict["tenant_id"] = tenant.id
    reparation_dict["epi_id"] = epi_id
    reparation_obj = ReparationEPI(**reparation_dict)
    
    reparation_data = reparation_obj.dict()
    reparation_data["created_at"] = reparation_obj.created_at.isoformat()
    reparation_data["updated_at"] = reparation_obj.updated_at.isoformat()
    
    await db.reparations_epi.insert_one(reparation_data)
    
    # Mettre Ã  jour statut EPI
    await db.epis.update_one(
        {"id": epi_id, "tenant_id": tenant.id},
        {"$set": {"statut": "En rÃ©paration"}}
    )
    
    return reparation_obj

@api_router.get("/{tenant_slug}/epi/{epi_id}/reparations", response_model=List[ReparationEPI])
async def get_reparations_epi(
    tenant_slug: str,
    epi_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re l'historique de rÃ©parations d'un EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    reparations = await db.reparations_epi.find({
        "epi_id": epi_id,
        "tenant_id": tenant.id
    }).sort("date_demande", -1).to_list(1000)
    
    cleaned_reparations = [clean_mongo_doc(r) for r in reparations]
    
    for r in cleaned_reparations:
        if isinstance(r.get("created_at"), str):
            r["created_at"] = datetime.fromisoformat(r["created_at"].replace('Z', '+00:00'))
        if isinstance(r.get("updated_at"), str):
            r["updated_at"] = datetime.fromisoformat(r["updated_at"].replace('Z', '+00:00'))
    
    return [ReparationEPI(**r) for r in cleaned_reparations]

@api_router.put("/{tenant_slug}/epi/{epi_id}/reparation/{reparation_id}", response_model=ReparationEPI)
async def update_reparation(
    tenant_slug: str,
    epi_id: str,
    reparation_id: str,
    reparation_update: ReparationEPIUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour une rÃ©paration"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    reparation = await db.reparations_epi.find_one({
        "id": reparation_id,
        "epi_id": epi_id,
        "tenant_id": tenant.id
    })
    
    if not reparation:
        raise HTTPException(status_code=404, detail="RÃ©paration non trouvÃ©e")
    
    update_data = {k: v for k, v in reparation_update.dict().items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc).isoformat()
    
    await db.reparations_epi.update_one(
        {"id": reparation_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    # Si rÃ©paration terminÃ©e, remettre EPI en service
    if reparation_update.statut == "terminee":
        epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
        
        await db.epis.update_one(
            {"id": epi_id, "tenant_id": tenant.id},
            {"$set": {"statut": "En service"}}
        )
        
        # Notifier le pompier assignÃ© que son EPI est de retour
        if epi and epi.get("user_id"):
            type_epi_nom = epi.get("type_epi", "EPI")
            await creer_notification(
                tenant_id=tenant.id,
                destinataire_id=epi["user_id"],
                type="epi_reparation_terminee",
                titre="EPI de retour de rÃ©paration",
                message=f"Votre {type_epi_nom} #{epi.get('numero_serie', '')} est de retour et remis en service",
                lien="/epi"
            )
    
    updated_reparation = await db.reparations_epi.find_one({
        "id": reparation_id,
        "tenant_id": tenant.id
    })
    
    cleaned = clean_mongo_doc(updated_reparation)
    if isinstance(cleaned.get("created_at"), str):
        cleaned["created_at"] = datetime.fromisoformat(cleaned["created_at"].replace('Z', '+00:00'))
    if isinstance(cleaned.get("updated_at"), str):
        cleaned["updated_at"] = datetime.fromisoformat(cleaned["updated_at"].replace('Z', '+00:00'))
    
    return ReparationEPI(**cleaned)

# ========== PHASE 2 : RETRAIT EPI ==========

@api_router.post("/{tenant_slug}/epi/{epi_id}/retrait", response_model=RetraitEPI)
async def create_retrait(
    tenant_slug: str,
    epi_id: str,
    retrait: RetraitEPICreate,
    current_user: User = Depends(get_current_user)
):
    """Enregistre le retrait dÃ©finitif d'un EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier EPI existe
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    retrait_dict = retrait.dict()
    retrait_dict["tenant_id"] = tenant.id
    retrait_dict["epi_id"] = epi_id
    retrait_obj = RetraitEPI(**retrait_dict)
    
    retrait_data = retrait_obj.dict()
    retrait_data["created_at"] = retrait_obj.created_at.isoformat()
    
    await db.retraits_epi.insert_one(retrait_data)
    
    # Mettre Ã  jour statut EPI
    await db.epis.update_one(
        {"id": epi_id, "tenant_id": tenant.id},
        {"$set": {"statut": "RetirÃ©"}}
    )
    
    return retrait_obj

@api_router.get("/{tenant_slug}/epi/{epi_id}/retrait", response_model=RetraitEPI)
async def get_retrait_epi(
    tenant_slug: str,
    epi_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re les informations de retrait d'un EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    retrait = await db.retraits_epi.find_one({
        "epi_id": epi_id,
        "tenant_id": tenant.id
    })
    
    if not retrait:
        raise HTTPException(status_code=404, detail="Aucun retrait enregistrÃ© pour cet EPI")
    
    cleaned = clean_mongo_doc(retrait)
    if isinstance(cleaned.get("created_at"), str):
        cleaned["created_at"] = datetime.fromisoformat(cleaned["created_at"].replace('Z', '+00:00'))
    
    return RetraitEPI(**cleaned)

# ========== RAPPORTS PHASE 2 ==========

@api_router.get("/{tenant_slug}/epi/rapports/retraits-prevus")
async def get_rapport_retraits_prevus(
    tenant_slug: str,
    mois: int = 12,
    current_user: User = Depends(get_current_user)
):
    """Rapport des EPI approchant de leur limite de 10 ans"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    epis = await db.epis.find({"tenant_id": tenant.id}).to_list(1000)
    
    aujourd_hui = datetime.now(timezone.utc)
    limite_jours = mois * 30
    
    retraits_prevus = []
    
    for epi in epis:
        if epi.get("statut") == "RetirÃ©":
            continue
        
        # Gestion sÃ©curisÃ©e de la date avec ou sans timezone
        date_service_str = epi.get("date_mise_en_service")
        if not date_service_str:
            continue
        
        try:
            date_mise_service = datetime.fromisoformat(date_service_str.replace('Z', '+00:00'))
            # S'assurer que la date a une timezone
            if date_mise_service.tzinfo is None:
                date_mise_service = date_mise_service.replace(tzinfo=timezone.utc)
        except (ValueError, AttributeError):
            continue
        
        age_jours = (aujourd_hui - date_mise_service).days
        age_limite_jours = 365 * 10  # 10 ans
        
        jours_restants = age_limite_jours - age_jours
        
        if 0 <= jours_restants <= limite_jours:
            cleaned_epi = clean_mongo_doc(epi)
            cleaned_epi["age_annees"] = round(age_jours / 365, 1)
            cleaned_epi["jours_avant_limite"] = jours_restants
            cleaned_epi["date_limite_prevue"] = (date_mise_service + timedelta(days=age_limite_jours)).isoformat()
            retraits_prevus.append(cleaned_epi)
    
    retraits_prevus.sort(key=lambda x: x["jours_avant_limite"])
    
    return {
        "total": len(retraits_prevus),
        "periode_mois": mois,
        "epis": retraits_prevus
    }

@api_router.get("/{tenant_slug}/epi/rapports/cout-total")
async def get_rapport_cout_total(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Rapport du coÃ»t total de possession (TCO) par EPI"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    epis = await db.epis.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = []
    
    for epi in epis:
        # CoÃ»t d'achat
        cout_achat = epi.get("cout_achat", 0)
        
        # CoÃ»ts de nettoyage (fictif, Ã  amÃ©liorer si prix stockÃ©s)
        nettoyages = await db.nettoyages_epi.find({
            "epi_id": epi["id"],
            "tenant_id": tenant.id
        }).to_list(1000)
        cout_nettoyages = len([n for n in nettoyages if n.get("type_nettoyage") == "avance"]) * 50  # Ex: 50$ par nettoyage avancÃ©
        
        # CoÃ»ts de rÃ©paration
        reparations = await db.reparations_epi.find({
            "epi_id": epi["id"],
            "tenant_id": tenant.id
        }).to_list(1000)
        cout_reparations = sum([r.get("cout_reparation", 0) for r in reparations])
        
        # CoÃ»t de retrait
        retrait = await db.retraits_epi.find_one({
            "epi_id": epi["id"],
            "tenant_id": tenant.id
        })
        cout_retrait = retrait.get("cout_disposition", 0) if retrait else 0
        
        cout_total = cout_achat + cout_nettoyages + cout_reparations + cout_retrait
        
        cleaned_epi = clean_mongo_doc(epi)
        cleaned_epi["cout_achat"] = cout_achat
        cleaned_epi["cout_nettoyages"] = cout_nettoyages
        cleaned_epi["nombre_nettoyages"] = len(nettoyages)
        cleaned_epi["cout_reparations"] = cout_reparations
        cleaned_epi["nombre_reparations"] = len(reparations)
        cleaned_epi["cout_retrait"] = cout_retrait
        cleaned_epi["cout_total"] = cout_total
        
        rapport.append(cleaned_epi)
    
    # Trier par coÃ»t total dÃ©croissant
    rapport.sort(key=lambda x: x["cout_total"], reverse=True)
    
    return {
        "total_epis": len(rapport),
        "cout_total_flotte": sum([e["cout_total"] for e in rapport]),
        "cout_moyen_par_epi": sum([e["cout_total"] for e in rapport]) / len(rapport) if len(rapport) > 0 else 0,
        "epis": rapport
    }

# Alias pour compatibilitÃ© frontend
@api_router.get("/{tenant_slug}/epi/rapports/tco")
async def get_rapport_tco_alias(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Alias pour /cout-total (compatibilitÃ© frontend)"""
    return await get_rapport_cout_total(tenant_slug, current_user)


# ==================== MES EPI (Module EmployÃ©) ====================

@api_router.get("/{tenant_slug}/mes-epi")
async def get_mes_epi(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re les EPI de l'utilisateur connectÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # RÃ©cupÃ©rer tous les EPI assignÃ©s Ã  cet utilisateur
    mes_epis = await db.epis.find({
        "tenant_id": tenant.id,
        "user_id": current_user.id
    }).to_list(1000)
    
    # Nettoyer les documents MongoDB et rÃ©cupÃ©rer la derniÃ¨re inspection
    cleaned_epis = []
    for epi in mes_epis:
        cleaned_epi = clean_mongo_doc(epi)
        
        # RÃ©cupÃ©rer la derniÃ¨re inspection aprÃ¨s usage
        derniereInspection = await db.inspections_apres_usage.find_one(
            {"epi_id": epi["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        if derniereInspection:
            cleaned_epi["derniere_inspection"] = clean_mongo_doc(derniereInspection)
        else:
            cleaned_epi["derniere_inspection"] = None
            
        cleaned_epis.append(cleaned_epi)
    
    return cleaned_epis

@api_router.post("/{tenant_slug}/mes-epi/{epi_id}/inspection")
async def creer_inspection_apres_usage(
    tenant_slug: str,
    epi_id: str,
    inspection: InspectionApresUsageCreate,
    current_user: User = Depends(get_current_user)
):
    """Enregistre une inspection aprÃ¨s usage par l'employÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'EPI appartient Ã  l'utilisateur
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id, "user_id": current_user.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ© ou non assignÃ© Ã  vous")
    
    # CrÃ©er l'inspection
    inspection_obj = InspectionApresUsage(
        tenant_id=tenant.id,
        epi_id=epi_id,
        user_id=current_user.id,
        statut=inspection.statut,
        defauts_constates=inspection.defauts_constates or "",
        notes=inspection.notes or "",
        photo_url=inspection.photo_url or "",
        criteres_inspection=inspection.criteres_inspection or {}
    )
    
    await db.inspections_apres_usage.insert_one(inspection_obj.dict())
    
    # Si dÃ©faut signalÃ©, envoyer notification aux admins/superviseurs
    if inspection.statut == "defaut":
        # RÃ©cupÃ©rer tous les admins/superviseurs
        admins = await db.users.find({
            "tenant_id": tenant.id,
            "role": {"$in": ["admin", "superviseur"]}
        }).to_list(1000)
        
        for admin in admins:
            await creer_notification(
                tenant_id=tenant.id,
                destinataire_id=admin["id"],
                type="epi_defaut",
                titre="âš ï¸ DÃ©faut EPI signalÃ©",
                message=f"{current_user.prenom} {current_user.nom} a signalÃ© un dÃ©faut sur {epi['type_epi']} - {epi.get('marque', '')} {epi.get('modele', '')}",
                lien=f"/gestion-epi",
                data={"epi_id": epi_id, "user_id": current_user.id}
            )
    
    return {"message": "Inspection enregistrÃ©e avec succÃ¨s", "defaut_signale": inspection.statut == "defaut"}

@api_router.get("/{tenant_slug}/mes-epi/{epi_id}/historique")
async def get_historique_inspections(
    tenant_slug: str,
    epi_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re l'historique des inspections aprÃ¨s usage d'un EPI"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'EPI appartient Ã  l'utilisateur (ou que c'est un admin/superviseur)
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ©")
    
    if epi.get("user_id") != current_user.id and current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # RÃ©cupÃ©rer toutes les inspections
    inspections = await db.inspections_apres_usage.find({
        "epi_id": epi_id,
        "tenant_id": tenant.id
    }).sort("date_inspection", -1).to_list(1000)
    
    # Nettoyer les documents MongoDB et ajouter les infos utilisateur
    cleaned_inspections = []
    for inspection in inspections:
        cleaned_inspection = clean_mongo_doc(inspection)
        
        # Ajouter les infos utilisateur
        user = await db.users.find_one({"id": inspection["user_id"], "tenant_id": tenant.id})
        if user:
            cleaned_inspection["user_nom"] = f"{user.get('prenom', '')} {user.get('nom', '')}"
        
        cleaned_inspections.append(cleaned_inspection)
    
    return cleaned_inspections

@api_router.get("/{tenant_slug}/mes-epi/{epi_id}/demande-en-attente")
async def verifier_demande_remplacement_en_attente(
    tenant_slug: str,
    epi_id: str,
    current_user: User = Depends(get_current_user)
):
    """VÃ©rifier s'il existe une demande de remplacement en attente pour cet EPI"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier s'il y a une demande en attente
    demande_existante = await db.demandes_remplacement_epi.find_one({
        "epi_id": epi_id,
        "tenant_id": tenant.id,
        "user_id": current_user.id,
        "statut": "En attente"
    })
    
    if demande_existante:
        return {
            "existe": True,
            "demande": {
                "id": demande_existante["id"],
                "date_demande": demande_existante["date_demande"],
                "raison": demande_existante["raison"],
                "notes_employe": demande_existante.get("notes_employe", "")
            }
        }
    
    return {"existe": False}

@api_router.post("/{tenant_slug}/mes-epi/{epi_id}/demander-remplacement")
async def demander_remplacement_epi(
    tenant_slug: str,
    epi_id: str,
    demande: DemandeRemplacementEPICreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une demande de remplacement d'EPI"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'EPI appartient Ã  l'utilisateur
    epi = await db.epis.find_one({"id": epi_id, "tenant_id": tenant.id, "user_id": current_user.id})
    if not epi:
        raise HTTPException(status_code=404, detail="EPI non trouvÃ© ou non assignÃ© Ã  vous")
    
    # VÃ©rifier s'il n'y a pas dÃ©jÃ  une demande en attente pour cet EPI
    demande_existante = await db.demandes_remplacement_epi.find_one({
        "epi_id": epi_id,
        "tenant_id": tenant.id,
        "statut": "En attente"
    })
    
    if demande_existante:
        raise HTTPException(status_code=400, detail="Une demande de remplacement est dÃ©jÃ  en attente pour cet EPI")
    
    # CrÃ©er la demande
    demande_obj = DemandeRemplacementEPI(
        tenant_id=tenant.id,
        epi_id=epi_id,
        user_id=current_user.id,
        raison=demande.raison,
        notes_employe=demande.notes_employe
    )
    
    await db.demandes_remplacement_epi.insert_one(demande_obj.dict())
    
    # Envoyer notification aux admins/superviseurs
    admins = await db.users.find({
        "tenant_id": tenant.id,
        "role": {"$in": ["admin", "superviseur"]}
    }).to_list(1000)
    
    for admin in admins:
        await creer_notification(
            tenant_id=tenant.id,
            destinataire_id=admin["id"],
            type="demande_remplacement_epi",
            titre="ğŸ”„ Demande de remplacement EPI",
            message=f"{current_user.prenom} {current_user.nom} demande le remplacement de {epi['type_epi']} - Raison: {demande.raison}",
            lien=f"/gestion-epi",
            data={"epi_id": epi_id, "demande_id": demande_obj.id, "raison": demande.raison}
        )
    
    return {"message": "Demande de remplacement crÃ©Ã©e avec succÃ¨s", "demande_id": demande_obj.id}



# ==================== PRÃ‰VENTION ENDPOINTS ====================


@api_router.get("/{tenant_slug}/prevention/references")
async def get_prevention_references(tenant_slug: str):
    """RÃ©cupÃ¨re les catÃ©gories officielles (NR24-27) et risques (guide planification) pour le module prÃ©vention"""
    
    categories_nr24_27 = {
        "A": {
            "nom": "Ã‰tablissements de rÃ©union",
            "sous_groupes": {
                "A-1": "DestinÃ©s Ã  la production et Ã  la prÃ©sentation d'arts du spectacle",
                "A-2": "Qui ne figurent dans aucune autre division du groupe A",
                "A-3": "De type arÃ©na",
                "A-4": "OÃ¹ les occupants sont rassemblÃ©s en plein air"
            }
        },
        "B": {
            "nom": "Ã‰tablissements de dÃ©tention, soins, traitement et habitations supervisÃ©es",
            "sous_groupes": {
                "B-1": "Ã‰tablissements de dÃ©tention",
                "B-2": "Ã‰tablissements de traitement",
                "B-3": "Ã‰tablissements de soins",
                "B-4": "Ã‰tablissements de soins de type rÃ©sidentiel"
            }
        },
        "C": {
            "nom": "Habitations",
            "sous_groupes": {}
        },
        "D": {
            "nom": "Ã‰tablissements d'affaires",
            "sous_groupes": {}
        },
        "E": {
            "nom": "Ã‰tablissements commerciaux",
            "sous_groupes": {}
        },
        "F": {
            "nom": "Ã‰tablissements industriels",
            "sous_groupes": {
                "F-1": "Ã€ risques trÃ¨s Ã©levÃ©s",
                "F-2": "Ã€ risques moyens",
                "F-3": "Ã€ risques faibles"
            }
        },
        "G": {
            "nom": "Ã‰tablissements agricoles",
            "sous_groupes": {
                "G-1": "Ã€ risques trÃ¨s Ã©levÃ©s",
                "G-2": "Qui ne figurent dans aucune autre division du groupe G",
                "G-3": "Abritant des serres",
                "G-4": "Sans occupation humaine"
            }
        }
    }
    
    risques_guide_planification = {
        "incendies": [
            "Incendie",
            "Conflagration"
        ],
        "matieres": [
            "MatiÃ¨res dangereuses",
            "MatiÃ¨res hautement inflammables",
            "MatiÃ¨res trÃ¨s toxiques",
            "MatiÃ¨res combustibles",
            "Produits chimiques"
        ],
        "infrastructure": [
            "Explosion",
            "DÃ©faillances des systÃ¨mes de sÃ©curitÃ© incendie",
            "MatÃ©riaux de construction douteux"
        ],
        "occupants": [
            "Grand nombre d'occupants",
            "CapacitÃ© physique ou mentale insuffisante des occupants",
            "Personnes avec limitations compliquant l'Ã©vacuation",
            "DifficultÃ© d'Ã©vacuation",
            "Nombre Ã©levÃ© d'enfants"
        ],
        "usages_specifiques": [
            "Usage rÃ©sidentiel",
            "Usage commercial",
            "Usage industriel",
            "Atelier/entrepÃ´t",
            "Garage de rÃ©paration",
            "Imprimerie",
            "Station-service",
            "BÃ¢timent agricole",
            "HÃ´pital/centre d'accueil",
            "Ã‰tablissement de dÃ©tention",
            "Centre commercial",
            "HÃ´tel/motel",
            "Ã‰cole/garderie/Ã©glise",
            "Usine de peinture",
            "Usine de produits chimiques",
            "Meunerie",
            "Hangar"
        ],
        "environnement": [
            "Incendies de forÃªt",
            "Inondations",
            "Glissements de terrain"
        ],
        "transport": [
            "RÃ©seaux routiers",
            "RÃ©seaux ferroviaires",
            "Transport maritime",
            "Trafic aÃ©rien",
            "Transport de matiÃ¨res dangereuses",
            "Accidents routiers",
            "Accidents ferroviaires"
        ],
        "impact_societal": [
            "Impact majeur sur la sociÃ©tÃ©",
            "Importance pour la communautÃ©",
            "Pertes d'emplois potentielles",
            "Effets psychologiques"
        ]
    }
    
    return {
        "categories_nr24_27": categories_nr24_27,
        "risques_guide_planification": risques_guide_planification
    }


@api_router.get("/{tenant_slug}/prevention/batiments")
async def get_batiments(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ©rer tous les bÃ¢timents du tenant"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # OPTIMISATION: Pour la liste, inclure photo_url mais le frontend pourra charger les dÃ©tails complets au besoin
    # Note: Si photos base64 trop lourdes, migration vers stockage externe recommandÃ©e
    batiments = await db.batiments.find(
        {"tenant_id": tenant.id},
        {"_id": 0}
    ).to_list(1000)
    return [clean_mongo_doc(batiment) for batiment in batiments]

@api_router.post("/{tenant_slug}/prevention/batiments")
async def create_batiment(
    tenant_slug: str, 
    batiment: BatimentCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er un nouveau bÃ¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    try:
        batiment_dict = batiment.dict()
        print(f"ğŸ” DEBUG - DonnÃ©es reÃ§ues du frontend: {batiment_dict}")
        batiment_dict["tenant_id"] = tenant.id
        batiment_dict["id"] = str(uuid.uuid4())  # GÃ©nÃ©rer un UUID pour le nouveau bÃ¢timent
        print(f"ğŸ” DEBUG - DonnÃ©es avec tenant_id et id: {batiment_dict}")
        batiment_obj = Batiment(**batiment_dict)
        print(f"âœ… DEBUG - Objet Batiment crÃ©Ã© avec succÃ¨s")
    except Exception as e:
        print(f"âŒ DEBUG - Erreur crÃ©ation Batiment: {e}")
        raise HTTPException(status_code=422, detail=f"Erreur validation: {str(e)}")
    
    await db.batiments.insert_one(batiment_obj.dict())
    return clean_mongo_doc(batiment_obj.dict())

@api_router.get("/{tenant_slug}/prevention/batiments/{batiment_id}")
async def get_batiment(
    tenant_slug: str, 
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer un bÃ¢timent spÃ©cifique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    return clean_mongo_doc(batiment)

@api_router.put("/{tenant_slug}/prevention/batiments/{batiment_id}")
async def update_batiment(
    tenant_slug: str, 
    batiment_id: str,
    batiment_update: BatimentCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour un bÃ¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    update_data = batiment_update.dict()
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    return {"message": "BÃ¢timent mis Ã  jour avec succÃ¨s"}

@api_router.get("/{tenant_slug}/prevention/grilles-inspection")
async def get_grilles_inspection(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ©rer toutes les grilles d'inspection du tenant"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer les grilles spÃ©cifiques au tenant ET les grilles globales (templates)
    grilles = await db.grilles_inspection.find({
        "$or": [
            {"tenant_id": tenant.id},
            {"tenant_id": {"$exists": False}}  # Grilles globales/templates
        ]
    }).to_list(1000)
    return [clean_mongo_doc(grille) for grille in grilles]

@api_router.post("/{tenant_slug}/prevention/grilles-inspection")
async def create_grille_inspection(
    tenant_slug: str, 
    grille: GrilleInspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une nouvelle grille d'inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    grille_dict = grille.dict()
    grille_dict["tenant_id"] = tenant.id
    grille_obj = GrilleInspection(**grille_dict)
    
    await db.grilles_inspection.insert_one(grille_obj.dict())
    return clean_mongo_doc(grille_obj.dict())

@api_router.get("/{tenant_slug}/prevention/grilles-inspection/{grille_id}")
async def get_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer une grille d'inspection spÃ©cifique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    grille = await db.grilles_inspection.find_one({"id": grille_id, "tenant_id": tenant.id})
    if not grille:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouvÃ©e")
    
    return clean_mongo_doc(grille)

@api_router.put("/{tenant_slug}/prevention/grilles-inspection/{grille_id}")
async def update_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    grille_update: GrilleInspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour une grille d'inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    update_data = grille_update.dict()
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.grilles_inspection.update_one(
        {"id": grille_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouvÃ©e")
    
    return {"message": "Grille d'inspection mise Ã  jour avec succÃ¨s"}

@api_router.delete("/{tenant_slug}/prevention/grilles-inspection/{grille_id}")
async def delete_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une grille d'inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.grilles_inspection.delete_one({"id": grille_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouvÃ©e")
    
    return {"message": "Grille d'inspection supprimÃ©e avec succÃ¨s"}

@api_router.post("/{tenant_slug}/prevention/grilles-inspection/{grille_id}/dupliquer")
async def dupliquer_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    nouveau_nom: str = None,
    current_user: User = Depends(get_current_user)
):
    """Dupliquer une grille d'inspection pour crÃ©er une variante"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer la grille source
    grille_source = await db.grilles_inspection.find_one({"id": grille_id, "tenant_id": tenant.id}, {"_id": 0})
    
    if not grille_source:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouvÃ©e")
    
    # CrÃ©er la copie avec un nouvel ID
    grille_copie = grille_source.copy()
    grille_copie["id"] = str(uuid.uuid4())
    grille_copie["nom"] = nouveau_nom if nouveau_nom else f"{grille_source['nom']} (Copie)"
    grille_copie["version"] = "1.0"
    
    await db.grilles_inspection.insert_one(grille_copie)
    
    return clean_mongo_doc(grille_copie)

@api_router.post("/{tenant_slug}/prevention/initialiser")
async def initialiser_module_prevention(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Initialiser le module prÃ©vention avec les 7 grilles d'inspection standards"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier si des grilles existent dÃ©jÃ 
    existing_count = await db.grilles_inspection.count_documents({"tenant_id": tenant.id})
    if existing_count > 0:
        raise HTTPException(status_code=400, detail=f"{existing_count} grille(s) existent dÃ©jÃ . Supprimez-les d'abord si vous voulez rÃ©initialiser.")
    
    # Importer les grilles depuis insert_grilles.py
    import sys
    import os
    sys.path.insert(0, os.path.dirname(__file__))
    from insert_grilles import GRILLES
    
    # CrÃ©er les 7 grilles pour ce tenant
    grilles_creees = []
    for grille_template in GRILLES:
        grille = grille_template.copy()
        grille["id"] = str(uuid.uuid4())
        grille["tenant_id"] = tenant.id
        grille["actif"] = True
        grille["version"] = "1.0"
        
        await db.grilles_inspection.insert_one(grille)
        grilles_creees.append({"id": grille["id"], "nom": grille["nom"]})
    
    return {
        "message": f"{len(grilles_creees)} grilles d'inspection crÃ©Ã©es avec succÃ¨s",
        "grilles": grilles_creees
    }

@api_router.post("/{tenant_slug}/prevention/batiments/import-csv")
async def import_batiments_csv(
    tenant_slug: str,
    request: Dict[str, Any],  # Contient batiments: List[dict], required_fields: List[dict]
    current_user: User = Depends(get_current_user)
):
    """Import en masse de bÃ¢timents via CSV avec validation personnalisÃ©e"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    batiments_data = request.get('batiments', [])
    if not batiments_data:
        raise HTTPException(status_code=400, detail="Aucune donnÃ©e de bÃ¢timent fournie")
    
    # RÃ©cupÃ©rer les champs requis personnalisÃ©s (sinon utiliser les valeurs par dÃ©faut)
    required_fields = request.get('required_fields', [
        {'key': 'nom_etablissement', 'label': 'Nom Ã©tablissement'},
        {'key': 'adresse_civique', 'label': 'Adresse civique'}
    ])
    
    success_count = 0
    error_count = 0
    errors = []
    
    for idx, batiment_data in enumerate(batiments_data):
        try:
            # Validation dynamique selon les champs requis personnalisÃ©s
            for required_field in required_fields:
                field_key = required_field['key']
                field_label = required_field['label']
                
                if not batiment_data.get(field_key, '').strip():
                    errors.append({
                        "row": idx + 1,
                        "message": f"{field_label} requis"
                    })
                    error_count += 1
                    # Passer Ã  la ligne suivante si un champ requis est manquant
                    raise ValueError(f"{field_label} manquant")
            
            # Nettoyer et prÃ©parer les donnÃ©es
            batiment_dict = {}
            for field_key, value in batiment_data.items():
                if value and str(value).strip():  # Ignorer les valeurs vides
                    batiment_dict[field_key] = str(value).strip()
                else:
                    batiment_dict[field_key] = ""
            
            # Ajouter les mÃ©tadonnÃ©es
            batiment_dict["tenant_id"] = tenant.id
            batiment_dict["statut"] = "actif"
            
            # CrÃ©er l'objet Batiment et l'insÃ©rer
            batiment_obj = Batiment(**batiment_dict)
            await db.batiments.insert_one(batiment_obj.dict())
            success_count += 1
            
        except ValueError:
            # Erreur dÃ©jÃ  ajoutÃ©e dans la liste
            continue
        except Exception as e:
            errors.append({
                "row": idx + 1,
                "message": str(e)
            })
            error_count += 1
    
    # CrÃ©er une activitÃ©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="prevention_import_batiments",
        description=f"ğŸ“Š {current_user.prenom} {current_user.nom} a importÃ© {success_count} bÃ¢timents ({error_count} erreurs)",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return {
        "success_count": success_count,
        "error_count": error_count,
        "errors": errors[:10],  # Limiter Ã  10 erreurs pour Ã©viter une rÃ©ponse trop lourde
        "total_processed": len(batiments_data)
    }

@api_router.delete("/{tenant_slug}/prevention/batiments/{batiment_id}")
async def delete_batiment(
    tenant_slug: str, 
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un bÃ¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.batiments.delete_one({"id": batiment_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    return {"message": "BÃ¢timent supprimÃ© avec succÃ¨s"}


class BatimentPhotoUpload(BaseModel):
    photo_base64: str

@api_router.post("/{tenant_slug}/prevention/batiments/{batiment_id}/photo")
async def upload_batiment_photo(
    tenant_slug: str,
    batiment_id: str,
    photo_data: BatimentPhotoUpload,
    current_user: User = Depends(get_current_user)
):
    """Uploader/Mettre Ã  jour la photo d'un bÃ¢timent (en base64)"""
    # Admins, superviseurs et prÃ©ventionnistes peuvent uploader des photos
    if current_user.role not in ["admin", "superviseur"] and not current_user.est_preventionniste:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Permission insuffisante")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que le bÃ¢timent existe
    existing = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    # VÃ©rifier que la photo est au bon format base64
    if not photo_data.photo_base64.startswith('data:image/'):
        raise HTTPException(status_code=400, detail="Format de photo invalide (doit Ãªtre base64 data URL)")
    
    # Mettre Ã  jour la photo
    await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": {"photo_url": photo_data.photo_base64, "updated_at": datetime.now(timezone.utc)}}
    )
    
    return {"message": "Photo mise Ã  jour avec succÃ¨s", "photo_url": photo_data.photo_base64}

@api_router.delete("/{tenant_slug}/prevention/batiments/{batiment_id}/photo")
async def delete_batiment_photo(
    tenant_slug: str,
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer la photo d'un bÃ¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # Mettre Ã  jour pour retirer la photo
    result = await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": {"photo_url": "", "updated_at": datetime.now(timezone.utc)}}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    return {"message": "Photo supprimÃ©e avec succÃ¨s"}

# ==================== SYMBOLES PERSONNALISÃ‰S ====================

@api_router.get("/{tenant_slug}/prevention/symboles-personnalises")
async def get_symboles_personnalises(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer tous les symboles personnalisÃ©s du tenant"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    symboles = await db.symboles_personnalises.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(symbole) for symbole in symboles]

@api_router.post("/{tenant_slug}/prevention/symboles-personnalises")
async def create_symbole_personnalise(
    tenant_slug: str,
    symbole: SymbolePersonnaliseCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er un nouveau symbole personnalisÃ©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que l'image est au bon format base64
    if not symbole.image_base64.startswith('data:image/'):
        raise HTTPException(status_code=400, detail="Format d'image invalide (doit Ãªtre base64 data URL)")
    
    symbole_dict = symbole.dict()
    symbole_dict["tenant_id"] = tenant.id
    symbole_dict["id"] = str(uuid.uuid4())
    symbole_dict["created_at"] = datetime.now(timezone.utc)
    symbole_dict["created_by"] = current_user.id
    
    symbole_obj = SymbolePersonnalise(**symbole_dict)
    await db.symboles_personnalises.insert_one(symbole_obj.dict())
    
    return clean_mongo_doc(symbole_obj.dict())

@api_router.put("/{tenant_slug}/prevention/symboles-personnalises/{symbole_id}")
async def update_symbole_personnalise(
    tenant_slug: str,
    symbole_id: str,
    symbole: SymbolePersonnaliseCreate,
    current_user: User = Depends(get_current_user)
):
    """Modifier un symbole personnalisÃ©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que le symbole existe
    existing = await db.symboles_personnalises.find_one({"id": symbole_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Symbole non trouvÃ©")
    
    # VÃ©rifier que l'image est au bon format si elle est fournie
    if symbole.image_base64 and not symbole.image_base64.startswith('data:image/'):
        raise HTTPException(status_code=400, detail="Format d'image invalide (doit Ãªtre base64 data URL)")
    
    update_dict = symbole.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    await db.symboles_personnalises.update_one(
        {"id": symbole_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    updated = await db.symboles_personnalises.find_one({"id": symbole_id, "tenant_id": tenant.id})
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/symboles-personnalises/{symbole_id}")
async def delete_symbole_personnalise(
    tenant_slug: str,
    symbole_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un symbole personnalisÃ©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier si le symbole existe
    symbole = await db.symboles_personnalises.find_one({"id": symbole_id, "tenant_id": tenant.id})
    if not symbole:
        raise HTTPException(status_code=404, detail="Symbole non trouvÃ©")
    
    # VÃ©rifier si le symbole est utilisÃ© dans des plans d'intervention
    # Les plans peuvent stocker les symboles dans les layers (format GeoJSON)
    plans_utilisant = await db.plans_intervention.count_documents({
        "tenant_id": tenant.id,
        "$or": [
            {"layers.properties.symbolId": symbole_id},
            {"layers": {"$elemMatch": {"properties.symbolId": symbole_id}}}
        ]
    })
    
    if plans_utilisant > 0:
        raise HTTPException(
            status_code=409, 
            detail=f"Impossible de supprimer ce symbole. Il est utilisÃ© dans {plans_utilisant} plan(s) d'intervention."
        )
    
    result = await db.symboles_personnalises.delete_one({"id": symbole_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Symbole non trouvÃ©")
    
    return {"message": "Symbole supprimÃ© avec succÃ¨s"}



# ==================== SECTEURS GÃ‰OGRAPHIQUES ====================

@api_router.get("/{tenant_slug}/prevention/secteurs")
async def get_secteurs(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer tous les secteurs gÃ©ographiques"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    secteurs = await db.secteurs_geographiques.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(secteur) for secteur in secteurs]

@api_router.post("/{tenant_slug}/prevention/secteurs")
async def create_secteur(
    tenant_slug: str,
    secteur: SecteurGeographiqueCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er un nouveau secteur gÃ©ographique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    secteur_dict = secteur.dict()
    secteur_dict["tenant_id"] = tenant.id
    secteur_dict["id"] = str(uuid.uuid4())
    secteur_dict["created_at"] = datetime.now(timezone.utc)
    secteur_dict["updated_at"] = datetime.now(timezone.utc)
    
    secteur_obj = SecteurGeographique(**secteur_dict)
    await db.secteurs_geographiques.insert_one(secteur_obj.dict())
    
    return clean_mongo_doc(secteur_obj.dict())

@api_router.get("/{tenant_slug}/prevention/secteurs/{secteur_id}")
async def get_secteur(
    tenant_slug: str,
    secteur_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer un secteur gÃ©ographique spÃ©cifique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    secteur = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    if not secteur:
        raise HTTPException(status_code=404, detail="Secteur non trouvÃ©")
    
    return clean_mongo_doc(secteur)

@api_router.put("/{tenant_slug}/prevention/secteurs/{secteur_id}")
async def update_secteur(
    tenant_slug: str,
    secteur_id: str,
    secteur_update: SecteurGeographiqueCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour un secteur gÃ©ographique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    existing = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Secteur non trouvÃ©")
    
    update_dict = secteur_update.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    await db.secteurs_geographiques.update_one(
        {"id": secteur_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    updated = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/secteurs/{secteur_id}")
async def delete_secteur(
    tenant_slug: str,
    secteur_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un secteur gÃ©ographique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.secteurs_geographiques.delete_one({"id": secteur_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Secteur non trouvÃ©")
    
    return {"message": "Secteur supprimÃ© avec succÃ¨s"}



@api_router.get("/{tenant_slug}/prevention/meta/niveaux-risque")
async def get_niveaux_risque(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les niveaux de risque standardisÃ©s selon les documents officiels du QuÃ©bec"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # Niveaux de risque standardisÃ©s selon les documents officiels du QuÃ©bec
    # (Tableau A1: Classification des risques d'incendie)
    niveaux_risque = [
        {
            "valeur": "Faible",
            "description": "TrÃ¨s petits bÃ¢timents, trÃ¨s espacÃ©s. BÃ¢timents rÃ©sidentiels de 1 ou 2 logements, de 1 ou 2 Ã©tages, dÃ©tachÃ©s"
        },
        {
            "valeur": "Moyen",
            "description": "BÃ¢timents d'au plus 3 Ã©tages et dont l'aire au sol est d'au plus 600 mÂ²"
        },
        {
            "valeur": "Ã‰levÃ©",
            "description": "BÃ¢timents dont l'aire au sol est de plus de 600 mÂ². BÃ¢timents de 4 Ã  6 Ã©tages. Lieux oÃ¹ les occupants sont normalement aptes Ã  Ã©vacuer"
        },
        {
            "valeur": "TrÃ¨s Ã©levÃ©",
            "description": "BÃ¢timents de plus de 6 Ã©tages ou prÃ©sentant un risque Ã©levÃ© de conflagration. Lieux oÃ¹ les occupants ne peuvent Ã©vacuer d'eux-mÃªmes ou Ã©vacuation difficile"
        }
    ]
    
    return {
        "niveaux_risque": niveaux_risque,
        "source": "Documents officiels du QuÃ©bec (Tableau A1: Classification des risques d'incendie)"
    }

@api_router.get("/{tenant_slug}/prevention/meta/categories-batiments")
async def get_categories_batiments(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les catÃ©gories et sous-catÃ©gories de bÃ¢timents selon le Code national de prÃ©vention des incendies"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que le module prÃ©vention est activÃ©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # CatÃ©gories de bÃ¢timents selon le Code national de prÃ©vention des incendies - Canada 2020
    categories = [
        {
            "groupe": "A",
            "nom": "Habitation",
            "divisions": [
                {"code": "A-1", "description": "Usage principal pour habitation"},
                {"code": "A-2", "description": "Ã‰tablissements de soins ou de dÃ©tention supervisÃ©s"}
            ]
        },
        {
            "groupe": "B",
            "nom": "Soins et dÃ©tention",
            "divisions": [
                {"code": "B-1", "description": "Ã‰tablissements de soins"},
                {"code": "B-2", "description": "Ã‰tablissements de dÃ©tention"}
            ]
        },
        {
            "groupe": "C",
            "nom": "RÃ©sidentiel",
            "divisions": [
                {"code": "C-1", "description": "Habitations unifamiliales et bifamiliales"},
                {"code": "C-2", "description": "Habitations avec services communs"},
                {"code": "C-3", "description": "Ensembles rÃ©sidentiels"}
            ]
        },
        {
            "groupe": "D",
            "nom": "Affaires",
            "divisions": [
                {"code": "D-1", "description": "Ã‰tablissements d'affaires"},
                {"code": "D-2", "description": "Ã‰tablissements de services personnels"}
            ]
        },
        {
            "groupe": "E",
            "nom": "Commerce",
            "divisions": [
                {"code": "E-1", "description": "Ã‰tablissements mercantiles"},
                {"code": "E-2", "description": "Ã‰tablissements de vente au dÃ©tail"}
            ]
        },
        {
            "groupe": "F",
            "nom": "Industriel",
            "divisions": [
                {"code": "F-1", "description": "Ã‰tablissements industriels Ã  risques trÃ¨s Ã©levÃ©s (entrepÃ´ts de matiÃ¨res dangereuses, usines chimiques, meuneries)"},
                {"code": "F-2", "description": "Ã‰tablissements industriels Ã  risques moyens (ateliers, garages de rÃ©paration, imprimeries, stations-service)"},
                {"code": "F-3", "description": "Ã‰tablissements industriels Ã  risques faibles (ateliers, entrepÃ´ts, salles de vente)"}
            ]
        },
        {
            "groupe": "G",
            "nom": "Agricole",
            "divisions": [
                {"code": "G-1", "description": "Ã‰tablissements agricoles Ã  risques trÃ¨s Ã©levÃ©s"},
                {"code": "G-2", "description": "Ã‰tablissements agricoles Ã  risques moyens"},
                {"code": "G-3", "description": "Ã‰tablissements agricoles Ã  risques faibles"}
            ]
        },
        {
            "groupe": "I",
            "nom": "AssemblÃ©e",
            "divisions": [
                {"code": "I-1", "description": "Lieux de rassemblement (auditoriums, Ã©glises, salles de spectacle)"},
                {"code": "I-2", "description": "Ã‰tablissements de rÃ©union"}
            ]
        }
    ]
    
    return {
        "categories": categories,
        "source": "Code national de prÃ©vention des incendies - Canada 2020 (Division A)"
    }


# ==================== GÃ‰NÃ‰RATION RAPPORT PDF ====================# ==================== GÃ‰NÃ‰RATION RAPPORT PDF ====================

async def generer_rapport_inspection_pdf(inspection_id: str, tenant_id: str) -> BytesIO:
    """GÃ©nÃ©rer un rapport PDF pour une inspection"""
    # RÃ©cupÃ©rer le tenant
    tenant = await db.tenants.find_one({"id": tenant_id}, {"_id": 0})
    
    # RÃ©cupÃ©rer l'inspection
    inspection = await db.inspections.find_one({"id": inspection_id, "tenant_id": tenant_id})
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # RÃ©cupÃ©rer le bÃ¢timent
    batiment = await db.batiments.find_one({"id": inspection["batiment_id"], "tenant_id": tenant_id})
    
    # RÃ©cupÃ©rer la grille d'inspection
    grille = await db.grilles_inspection.find_one({"id": inspection["grille_inspection_id"], "tenant_id": tenant_id})
    
    # RÃ©cupÃ©rer le prÃ©ventionniste
    preventionniste = await db.users.find_one({"id": inspection["preventionniste_id"]})
    
    # RÃ©cupÃ©rer les non-conformitÃ©s
    non_conformites = await db.non_conformites.find({
        "inspection_id": inspection_id,
        "tenant_id": tenant_id
    }).to_list(1000)
    
    # CrÃ©er le PDF avec branding
    from types import SimpleNamespace
    tenant_obj = SimpleNamespace(**tenant) if tenant else None
    buffer, doc, story = create_branded_pdf(tenant_obj, pagesize=letter)
    styles = getSampleStyleSheet()
    
    # Style personnalisÃ©
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#374151'),
        spaceAfter=12,
        spaceBefore=20
    )
    
    # Titre
    story.append(Paragraph("RAPPORT D'INSPECTION INCENDIE", title_style))
    story.append(Spacer(1, 0.3*inch))
    
    # Informations gÃ©nÃ©rales
    story.append(Paragraph("INFORMATIONS GÃ‰NÃ‰RALES", heading_style))
    
    info_data = [
        ["Date d'inspection:", inspection.get("date_inspection", "N/A")],
        ["Type:", inspection.get("type_inspection", "rÃ©guliÃ¨re").upper()],
        ["PrÃ©ventionniste:", f"{preventionniste.get('prenom', '')} {preventionniste.get('nom', '')}" if preventionniste else "N/A"],
        ["Heure dÃ©but:", inspection.get("heure_debut", "N/A")],
        ["Heure fin:", inspection.get("heure_fin", "N/A")],
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb'))
    ]))
    story.append(info_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Informations bÃ¢timent
    if batiment:
        story.append(Paragraph("INFORMATIONS BÃ‚TIMENT", heading_style))
        
        bat_data = [
            ["Nom Ã©tablissement:", batiment.get("nom_etablissement", "N/A")],
            ["Adresse:", batiment.get("adresse_civique", "N/A")],
            ["Ville:", batiment.get("ville", "N/A")],
            ["Code postal:", batiment.get("code_postal", "N/A")],
            ["Groupe occupation:", batiment.get("groupe_occupation", "N/A")],
        ]
        
        bat_table = Table(bat_data, colWidths=[2*inch, 4*inch])
        bat_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb'))
        ]))
        story.append(bat_table)
        story.append(Spacer(1, 0.3*inch))
    
    # RÃ©sultat global
    story.append(Paragraph("RÃ‰SULTAT GLOBAL", heading_style))
    
    statut_color = colors.HexColor('#10b981') if inspection.get("statut_global") == "conforme" else colors.HexColor('#ef4444')
    statut_text = inspection.get("statut_global", "N/A").upper()
    score = inspection.get("score_conformite", 100)
    
    result_data = [
        ["Statut:", statut_text],
        ["Score de conformitÃ©:", f"{score}%"],
        ["Non-conformitÃ©s:", str(len(non_conformites))],
    ]
    
    result_table = Table(result_data, colWidths=[2*inch, 4*inch])
    result_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
        ('BACKGROUND', (1, 0), (1, 0), statut_color),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
        ('TEXTCOLOR', (1, 0), (1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTNAME', (1, 0), (1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb'))
    ]))
    story.append(result_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Non-conformitÃ©s
    if non_conformites:
        story.append(Paragraph("NON-CONFORMITÃ‰S IDENTIFIÃ‰ES", heading_style))
        
        for idx, nc in enumerate(non_conformites, 1):
            nc_data = [
                [f"#{idx}", ""],
                ["Titre:", nc.get("titre", "N/A")],
                ["Description:", nc.get("description", "N/A")],
                ["GravitÃ©:", nc.get("gravite", "N/A").upper()],
                ["Statut:", nc.get("statut", "N/A")],
                ["DÃ©lai correction:", nc.get("delai_correction", "N/A")],
            ]
            
            nc_table = Table(nc_data, colWidths=[2*inch, 4*inch])
            nc_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#fef2f2')),
                ('BACKGROUND', (0, 1), (0, -1), colors.HexColor('#f3f4f6')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb')),
                ('SPAN', (0, 0), (-1, 0)),
            ]))
            story.append(nc_table)
            story.append(Spacer(1, 0.2*inch))
    
    # Notes et recommandations
    if inspection.get("notes_inspection") or inspection.get("recommandations"):
        story.append(Paragraph("NOTES ET RECOMMANDATIONS", heading_style))
        
        if inspection.get("notes_inspection"):
            story.append(Paragraph(f"<b>Notes:</b> {inspection.get('notes_inspection')}", styles['Normal']))
            story.append(Spacer(1, 0.1*inch))
        
        if inspection.get("recommandations"):
            story.append(Paragraph(f"<b>Recommandations:</b> {inspection.get('recommandations')}", styles['Normal']))
            story.append(Spacer(1, 0.3*inch))
    
    # Signature
    story.append(Spacer(1, 0.5*inch))
    story.append(Paragraph("SIGNATURES", heading_style))
    
    sig_data = [
        ["PrÃ©ventionniste:", "_" * 40],
        ["Date:", "_" * 40],
        ["", ""],
        ["ReprÃ©sentant bÃ¢timent:", "_" * 40],
        ["Nom:", inspection.get("nom_representant", "_" * 40)],
        ["Date:", "_" * 40],
    ]
    
    sig_table = Table(sig_data, colWidths=[2*inch, 4*inch])
    sig_table.setStyle(TableStyle([
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
    ]))
    story.append(sig_table)
    
    # GÃ©nÃ©rer le PDF
    doc.build(story)
    buffer.seek(0)
    return buffer


@api_router.get("/{tenant_slug}/prevention/inspections/{inspection_id}/rapport-pdf")
async def get_inspection_rapport_pdf(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """GÃ©nÃ©rer et tÃ©lÃ©charger le rapport PDF d'une inspection"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que l'inspection existe
    inspection = await db.inspections.find_one({"id": inspection_id, "tenant_id": tenant.id})
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # GÃ©nÃ©rer le PDF
    pdf_buffer = await generer_rapport_inspection_pdf(inspection_id, tenant.id)
    
    # Retourner le PDF
    return StreamingResponse(
        pdf_buffer,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename=rapport_inspection_{inspection_id}.pdf"
        }
    )


# ==================== INSPECTIONS ====================

@api_router.post("/{tenant_slug}/prevention/inspections")
async def create_inspection(
    tenant_slug: str,
    inspection: InspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une nouvelle inspection"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    inspection_dict = inspection.dict()
    inspection_dict["tenant_id"] = tenant.id
    inspection_obj = Inspection(**inspection_dict)
    
    await db.inspections.insert_one(inspection_obj.dict())
    
    return clean_mongo_doc(inspection_obj.dict())

@api_router.get("/{tenant_slug}/prevention/inspections")
async def get_inspections(
    tenant_slug: str,
    batiment_id: Optional[str] = None,
    preventionniste_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer toutes les inspections avec filtres optionnels"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id}
    if batiment_id:
        query["batiment_id"] = batiment_id
    if preventionniste_id:
        query["preventionniste_id"] = preventionniste_id
    
    inspections = await db.inspections.find(query).sort("created_at", -1).to_list(1000)
    return [clean_mongo_doc(i) for i in inspections]

@api_router.get("/{tenant_slug}/prevention/inspections/{inspection_id}")
async def get_inspection(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer une inspection spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    inspection = await db.inspections.find_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    return clean_mongo_doc(inspection)

@api_router.put("/{tenant_slug}/prevention/inspections/{inspection_id}")
async def update_inspection(
    tenant_slug: str,
    inspection_id: str,
    inspection_data: InspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour une inspection"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    update_dict = inspection_data.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.inspections.update_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    updated_inspection = await db.inspections.find_one({"id": inspection_id})
    return clean_mongo_doc(updated_inspection)

@api_router.get("/{tenant_slug}/prevention/inspections-planifiees")
async def get_inspections_planifiees(
    tenant_slug: str,
    days: int = 7,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les inspections planifiÃ©es pour les X prochains jours (pour mode offline)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # Calculer la plage de dates
    from datetime import datetime, timedelta, timezone
    today = datetime.now(timezone.utc).date()
    end_date = today + timedelta(days=days)
    
    # Convertir en format ISO string YYYY-MM-DD pour comparaison
    today_str = today.isoformat()
    end_date_str = end_date.isoformat()
    
    # RÃ©cupÃ©rer les inspections planifiÃ©es (date_inspection entre aujourd'hui et end_date)
    inspections = await db.inspections.find({
        "tenant_id": tenant.id,
        "date_inspection": {
            "$gte": today_str,
            "$lte": end_date_str
        },
        "statut": {"$in": ["planifiee", "en_cours", "a_faire", None]}  # Exclure les terminÃ©es
    }).sort("date_inspection", 1).to_list(100)
    
    # Enrichir avec les infos du bÃ¢timent
    enriched = []
    for insp in inspections:
        batiment = await db.batiments.find_one(
            {"id": insp.get("batiment_id"), "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        enriched.append({
            **clean_mongo_doc(insp),
            "batiment": batiment
        })
    
    return enriched

@api_router.delete("/{tenant_slug}/prevention/inspections/{inspection_id}")
async def delete_inspection(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.inspections.delete_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # Supprimer aussi les non-conformitÃ©s associÃ©es
    await db.non_conformites.delete_many({"inspection_id": inspection_id, "tenant_id": tenant.id})
    
    return {"message": "Inspection supprimÃ©e avec succÃ¨s"}


# ==================== NON-CONFORMITÃ‰S ====================

@api_router.post("/{tenant_slug}/prevention/non-conformites")
async def create_non_conformite(
    tenant_slug: str,
    non_conformite: NonConformiteCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une nouvelle non-conformitÃ©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    nc_dict = non_conformite.dict()
    nc_dict["tenant_id"] = tenant.id
    nc_obj = NonConformite(**nc_dict)
    
    await db.non_conformites.insert_one(nc_obj.dict())
    
    return clean_mongo_doc(nc_obj.dict())

@api_router.get("/{tenant_slug}/prevention/non-conformites")
async def get_non_conformites(
    tenant_slug: str,
    inspection_id: Optional[str] = None,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer toutes les non-conformitÃ©s avec filtres optionnels"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id}
    if inspection_id:
        query["inspection_id"] = inspection_id
    if batiment_id:
        query["batiment_id"] = batiment_id
    if statut:
        query["statut"] = statut
    
    non_conformites = await db.non_conformites.find(query).sort("created_at", -1).to_list(1000)
    return [clean_mongo_doc(nc) for nc in non_conformites]

@api_router.get("/{tenant_slug}/prevention/non-conformites/{nc_id}")
async def get_non_conformite(
    tenant_slug: str,
    nc_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer une non-conformitÃ© spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    nc = await db.non_conformites.find_one({"id": nc_id, "tenant_id": tenant.id})
    
    if not nc:
        raise HTTPException(status_code=404, detail="Non-conformitÃ© non trouvÃ©e")
    
    return clean_mongo_doc(nc)

@api_router.put("/{tenant_slug}/prevention/non-conformites/{nc_id}")
async def update_non_conformite(
    tenant_slug: str,
    nc_id: str,
    nc_data: NonConformiteCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour une non-conformitÃ©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    update_dict = nc_data.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.non_conformites.update_one(
        {"id": nc_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformitÃ© non trouvÃ©e")
    
    updated_nc = await db.non_conformites.find_one({"id": nc_id})
    return clean_mongo_doc(updated_nc)

@api_router.patch("/{tenant_slug}/prevention/non-conformites/{nc_id}/statut")
async def update_non_conformite_statut(
    tenant_slug: str,
    nc_id: str,
    statut: str = Body(..., embed=True),
    notes_correction: str = Body("", embed=True),
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour le statut d'une non-conformitÃ©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    update_data = {
        "statut": statut,
        "notes_correction": notes_correction,
        "updated_at": datetime.now(timezone.utc)
    }
    
    if statut == "corrigee" or statut == "fermee":
        update_data["date_correction"] = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    
    result = await db.non_conformites.update_one(
        {"id": nc_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformitÃ© non trouvÃ©e")
    
    updated_nc = await db.non_conformites.find_one({"id": nc_id})
    return clean_mongo_doc(updated_nc)

@api_router.delete("/{tenant_slug}/prevention/non-conformites/{nc_id}")
async def delete_non_conformite(
    tenant_slug: str,
    nc_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une non-conformitÃ©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.non_conformites.delete_one({"id": nc_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformitÃ© non trouvÃ©e")
    
    return {"message": "Non-conformitÃ© supprimÃ©e avec succÃ¨s"}


# ==================== UPLOAD PHOTOS ====================

@api_router.post("/{tenant_slug}/prevention/upload-photo")
async def upload_photo(
    tenant_slug: str,
    photo_base64: str = Body(..., embed=True),
    filename: str = Body(..., embed=True),
    current_user: User = Depends(get_current_user)
):
    """Upload une photo en base64 et retourne l'URL"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    try:
        # GÃ©nÃ©rer un ID unique pour la photo
        photo_id = str(uuid.uuid4())
        
        # Stocker la photo dans la collection photos
        photo_doc = {
            "id": photo_id,
            "tenant_id": tenant.id,
            "filename": filename,
            "data": photo_base64,
            "uploaded_by": current_user.id,
            "uploaded_at": datetime.now(timezone.utc).isoformat()
        }
        
        await db.photos_prevention.insert_one(photo_doc)
        
        # Retourner l'ID de la photo (qui servira d'URL)
        return {
            "photo_id": photo_id,
            "url": f"/api/{tenant_slug}/prevention/photos/{photo_id}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur upload photo: {str(e)}")

@api_router.get("/{tenant_slug}/prevention/photos/{photo_id}")
async def get_photo(
    tenant_slug: str,
    photo_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer une photo par son ID"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    photo = await db.photos_prevention.find_one({"id": photo_id, "tenant_id": tenant.id})
    
    if not photo:
        raise HTTPException(status_code=404, detail="Photo non trouvÃ©e")
    
    return {
        "id": photo["id"],
        "filename": photo.get("filename", "photo.jpg"),
        "data": photo["data"],
        "uploaded_at": photo.get("uploaded_at")
    }

@api_router.delete("/{tenant_slug}/prevention/photos/{photo_id}")
async def delete_photo(
    tenant_slug: str,
    photo_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une photo"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.photos_prevention.delete_one({"id": photo_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Photo non trouvÃ©e")
    
    return {"message": "Photo supprimÃ©e avec succÃ¨s"}


# ==================== ICÃ”NES PERSONNALISÃ‰ES ====================

@api_router.post("/{tenant_slug}/prevention/icones-personnalisees")
async def create_icone_personnalisee(
    tenant_slug: str,
    icone: IconePersonnaliseeCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une icÃ´ne personnalisÃ©e"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    try:
        # CrÃ©er l'icÃ´ne
        icone_dict = icone.dict()
        icone_dict["id"] = str(uuid.uuid4())
        icone_dict["tenant_id"] = tenant.id
        icone_dict["created_by_id"] = current_user.id
        icone_dict["created_at"] = datetime.now(timezone.utc).isoformat()
        
        await db.icones_personnalisees.insert_one(icone_dict)
        
        return clean_mongo_doc(icone_dict)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur crÃ©ation icÃ´ne: {str(e)}")

@api_router.get("/{tenant_slug}/prevention/icones-personnalisees")
async def get_icones_personnalisees(
    tenant_slug: str,
    categorie: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer toutes les icÃ´nes personnalisÃ©es d'un tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id}
    if categorie:
        query["categorie"] = categorie
    
    icones = await db.icones_personnalisees.find(query).to_list(length=None)
    
    return [clean_mongo_doc(icone) for icone in icones]

@api_router.delete("/{tenant_slug}/prevention/icones-personnalisees/{icone_id}")
async def delete_icone_personnalisee(
    tenant_slug: str,
    icone_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une icÃ´ne personnalisÃ©e"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.icones_personnalisees.delete_one({"id": icone_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="IcÃ´ne non trouvÃ©e")
    
    return {"message": "IcÃ´ne supprimÃ©e avec succÃ¨s"}


# ==================== INSPECTIONS VISUELLES (NOUVEAU SYSTÃˆME) ====================

@api_router.post("/{tenant_slug}/prevention/inspections-visuelles")
async def create_inspection_visuelle(
    tenant_slug: str,
    inspection: InspectionVisuelleCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une nouvelle inspection visuelle (pompiers + prÃ©ventionnistes)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que le bÃ¢timent existe
    batiment = await db.batiments.find_one({"id": inspection.batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    inspection_dict = inspection.dict()
    inspection_dict["tenant_id"] = tenant.id
    
    # CrÃ©er l'objet InspectionVisuelle complet
    inspection_obj = InspectionVisuelle(**inspection_dict)
    
    await db.inspections_visuelles.insert_one(inspection_obj.dict())
    
    return clean_mongo_doc(inspection_obj.dict())

@api_router.get("/{tenant_slug}/prevention/inspections-visuelles")
async def get_inspections_visuelles(
    tenant_slug: str,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    date_debut: Optional[str] = None,
    date_fin: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer la liste des inspections visuelles avec filtres"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id}
    
    if batiment_id:
        query["batiment_id"] = batiment_id
    
    if statut:
        query["statut"] = statut
    
    if date_debut and date_fin:
        query["date_inspection"] = {"$gte": date_debut, "$lte": date_fin}
    
    inspections = await db.inspections_visuelles.find(query).sort("created_at", -1).to_list(length=None)
    
    return [clean_mongo_doc(insp) for insp in inspections]

@api_router.get("/{tenant_slug}/prevention/inspections-visuelles/{inspection_id}")
async def get_inspection_visuelle(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer une inspection visuelle spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    inspection = await db.inspections_visuelles.find_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    return clean_mongo_doc(inspection)

@api_router.put("/{tenant_slug}/prevention/inspections-visuelles/{inspection_id}")
async def update_inspection_visuelle(
    tenant_slug: str,
    inspection_id: str,
    inspection_update: InspectionVisuelleUpdate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour une inspection visuelle (toujours modifiable)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer l'inspection existante
    existing = await db.inspections_visuelles.find_one({"id": inspection_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # Mettre Ã  jour uniquement les champs fournis
    update_dict = {k: v for k, v in inspection_update.dict(exclude_unset=True).items() if v is not None}
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    # Calculer la durÃ©e si heure_fin est fournie
    if "heure_fin" in update_dict and existing.get("heure_debut"):
        try:
            debut = datetime.fromisoformat(f"{existing['date_inspection']}T{existing['heure_debut']}")
            fin = datetime.fromisoformat(f"{existing['date_inspection']}T{update_dict['heure_fin']}")
            update_dict["duree_minutes"] = int((fin - debut).total_seconds() / 60)
        except:
            pass
    
    result = await db.inspections_visuelles.update_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    updated = await db.inspections_visuelles.find_one({"id": inspection_id})
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/inspections-visuelles/{inspection_id}")
async def delete_inspection_visuelle(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une inspection visuelle (prÃ©ventionnistes uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que l'utilisateur est prÃ©ventionniste ou admin
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les prÃ©ventionnistes peuvent supprimer des inspections")
    
    result = await db.inspections_visuelles.delete_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # Supprimer aussi les non-conformitÃ©s associÃ©es
    await db.non_conformites_visuelles.delete_many({"inspection_id": inspection_id, "tenant_id": tenant.id})
    
    return {"message": "Inspection supprimÃ©e avec succÃ¨s"}


# ==================== NON-CONFORMITÃ‰S VISUELLES ====================

@api_router.post("/{tenant_slug}/prevention/non-conformites-visuelles")
async def create_non_conformite_visuelle(
    tenant_slug: str,
    nc: NonConformiteVisuelleCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une nouvelle non-conformitÃ© visuelle"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    nc_dict = nc.dict()
    nc_dict["tenant_id"] = tenant.id
    
    # Calculer la date limite si dÃ©lai fourni
    if nc_dict.get("delai_correction_jours"):
        from datetime import timedelta
        inspection = await db.inspections_visuelles.find_one({"id": nc.inspection_id})
        if inspection:
            date_insp = datetime.fromisoformat(inspection["date_inspection"])
            date_limite = date_insp + timedelta(days=nc_dict["delai_correction_jours"])
            nc_dict["date_limite"] = date_limite.strftime("%Y-%m-%d")
    
    nc_obj = NonConformiteVisuelle(**nc_dict)
    
    await db.non_conformites_visuelles.insert_one(nc_obj.dict())
    
    # Ajouter l'ID de la NC Ã  l'inspection
    await db.inspections_visuelles.update_one(
        {"id": nc.inspection_id, "tenant_id": tenant.id},
        {"$push": {"non_conformites_ids": nc_obj.id}}
    )
    
    return clean_mongo_doc(nc_obj.dict())

@api_router.get("/{tenant_slug}/prevention/non-conformites-visuelles")
async def get_non_conformites_visuelles(
    tenant_slug: str,
    inspection_id: Optional[str] = None,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    gravite: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les non-conformitÃ©s visuelles avec filtres"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id}
    
    if inspection_id:
        query["inspection_id"] = inspection_id
    if batiment_id:
        query["batiment_id"] = batiment_id
    if statut:
        query["statut"] = statut
    if gravite:
        query["gravite"] = gravite
    
    ncs = await db.non_conformites_visuelles.find(query).sort("created_at", -1).to_list(length=None)
    
    return [clean_mongo_doc(nc) for nc in ncs]

@api_router.put("/{tenant_slug}/prevention/non-conformites-visuelles/{nc_id}")
async def update_non_conformite_visuelle(
    tenant_slug: str,
    nc_id: str,
    statut: Optional[str] = Body(None),
    photos_resolution: Optional[List[PhotoInspection]] = Body(None),
    notes_resolution: Optional[str] = Body(None),
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour le statut d'une non-conformitÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    update_dict = {"updated_at": datetime.now(timezone.utc)}
    
    if statut:
        update_dict["statut"] = statut
        if statut == "resolue":
            update_dict["date_resolution"] = datetime.now(timezone.utc)
    
    if photos_resolution:
        update_dict["photos_resolution"] = [p.dict() for p in photos_resolution]
    
    if notes_resolution:
        update_dict["notes_resolution"] = notes_resolution
    
    result = await db.non_conformites_visuelles.update_one(
        {"id": nc_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformitÃ© non trouvÃ©e")
    
    updated = await db.non_conformites_visuelles.find_one({"id": nc_id})
    return clean_mongo_doc(updated)


# ==================== CARTE INTERACTIVE & GÃ‰OCODAGE ====================

@api_router.get("/{tenant_slug}/prevention/batiments/map")
async def get_batiments_for_map(
    tenant_slug: str,
    niveau_risque: Optional[str] = None,
    statut_inspection: Optional[str] = None,
    secteur: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les bÃ¢timents formatÃ©s pour affichage sur carte"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer tous les bÃ¢timents
    query = {"tenant_id": tenant.id, "statut": "actif"}
    
    if niveau_risque:
        query["niveau_risque"] = niveau_risque
    
    batiments = await db.batiments.find(query).to_list(length=None)
    
    # Pour chaque bÃ¢timent, dÃ©terminer le statut d'inspection
    map_data = []
    for bat in batiments:
        # Chercher la derniÃ¨re inspection
        derniere_inspection = await db.inspections_visuelles.find_one(
            {"batiment_id": bat["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        
        # DÃ©terminer le statut
        if not derniere_inspection:
            statut_insp = "a_faire"
        elif derniere_inspection["statut"] == "en_cours":
            statut_insp = "en_cours"
        elif derniere_inspection["statut_conformite"] == "non_conforme":
            statut_insp = "non_conforme"
        else:
            statut_insp = "fait_conforme"
        
        # Filtrer par statut si demandÃ©
        if statut_inspection and statut_insp != statut_inspection:
            continue
        
        # GÃ©ocoder l'adresse si pas dÃ©jÃ  fait (latitude/longitude manquants)
        latitude = bat.get("latitude")
        longitude = bat.get("longitude")
        
        map_item = BatimentMapView(
            id=bat["id"],
            nom_etablissement=bat.get("nom_etablissement", ""),
            adresse_civique=bat.get("adresse_civique", ""),
            ville=bat.get("ville", ""),
            latitude=latitude,
            longitude=longitude,
            niveau_risque=bat.get("niveau_risque", ""),
            statut_inspection=statut_insp,
            derniere_inspection=derniere_inspection["date_inspection"] if derniere_inspection else None,
            groupe_occupation=bat.get("groupe_occupation", ""),
            sous_groupe=bat.get("sous_groupe", "")
        )
        
        map_data.append(map_item.dict())
    
    return map_data

@api_router.post("/{tenant_slug}/prevention/geocode")
async def geocode_address(
    tenant_slug: str,
    request: GeocodeRequest,
    current_user: User = Depends(get_current_user)
):
    """GÃ©ocoder une adresse en latitude/longitude avec Google Maps API"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    try:
        import requests
        import os
        
        api_key = os.getenv("GOOGLE_MAPS_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="ClÃ© API Google Maps non configurÃ©e")
        
        # Appeler l'API Google Geocoding
        url = "https://maps.googleapis.com/maps/api/geocode/json"
        params = {
            "address": request.adresse_complete,
            "key": api_key
        }
        
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        if data["status"] == "OK" and len(data["results"]) > 0:
            result = data["results"][0]
            location = result["geometry"]["location"]
            
            # DÃ©terminer la prÃ©cision
            location_type = result["geometry"]["location_type"]
            if location_type == "ROOFTOP":
                precision = "building"
            elif location_type in ["RANGE_INTERPOLATED", "GEOMETRIC_CENTER"]:
                precision = "street"
            else:
                precision = "city"
            
            return GeocodeResponse(
                latitude=location["lat"],
                longitude=location["lng"],
                adresse_formatee=result["formatted_address"],
                precision=precision
            )
        else:
            raise HTTPException(status_code=404, detail="Adresse non trouvÃ©e")
    
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du gÃ©ocodage: {str(e)}")

@api_router.put("/{tenant_slug}/prevention/batiments/{batiment_id}/coordinates")
async def update_batiment_coordinates(
    tenant_slug: str,
    batiment_id: str,
    latitude: float = Body(...),
    longitude: float = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour les coordonnÃ©es GPS d'un bÃ¢timent"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": {
            "latitude": latitude,
            "longitude": longitude,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    return {"message": "CoordonnÃ©es mises Ã  jour avec succÃ¨s"}


# ==================== GESTION DES PRÃ‰VENTIONNISTES ====================

@api_router.put("/{tenant_slug}/users/{user_id}/toggle-preventionniste")
async def toggle_preventionniste(
    tenant_slug: str,
    user_id: str,
    current_user: User = Depends(get_current_user)
):
    """Activer/dÃ©sactiver le statut de prÃ©ventionniste pour un utilisateur (admin uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Seuls les admins et superviseurs peuvent modifier ce statut
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # RÃ©cupÃ©rer l'utilisateur
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvÃ©")
    
    # Toggle le statut
    new_status = not user.get('est_preventionniste', False)
    
    await db.users.update_one(
        {"id": user_id, "tenant_id": tenant.id},
        {"$set": {"est_preventionniste": new_status}}
    )
    
    return {
        "message": "Statut de prÃ©ventionniste mis Ã  jour",
        "user_id": user_id,
        "est_preventionniste": new_status
    }


@api_router.get("/{tenant_slug}/prevention/preventionnistes")
async def get_preventionnistes(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer la liste de tous les prÃ©ventionnistes actifs"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer tous les utilisateurs avec est_preventionniste = true et statut actif
    preventionnistes_cursor = db.users.find({
        "tenant_id": tenant.id,
        "est_preventionniste": True,
        "statut": "Actif"
    })
    
    preventionnistes = await preventionnistes_cursor.to_list(length=None)
    
    # Pour chaque prÃ©ventionniste, ajouter des statistiques
    result = []
    for prev in preventionnistes:
        # Compter les bÃ¢timents assignÃ©s
        nb_batiments = await db.batiments.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_assigne_id": prev["id"]
        })
        
        # Compter les secteurs assignÃ©s
        nb_secteurs = await db.secteurs_geographiques.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_assigne_id": prev["id"]
        })
        
        # Compter les inspections ce mois
        start_of_month = datetime.now(timezone.utc).replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        nb_inspections_mois = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_id": prev["id"],
            "date_inspection": {"$gte": start_of_month.isoformat()}
        })
        
        result.append({
            "id": prev["id"],
            "nom": prev["nom"],
            "prenom": prev["prenom"],
            "email": prev["email"],
            "telephone": prev.get("telephone", ""),
            "grade": prev.get("grade", ""),
            "nb_batiments": nb_batiments,
            "nb_secteurs": nb_secteurs,
            "nb_inspections_mois": nb_inspections_mois
        })
    
    return result


@api_router.get("/{tenant_slug}/prevention/preventionnistes/{preventionniste_id}/stats")
async def get_preventionniste_stats(
    tenant_slug: str,
    preventionniste_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les statistiques dÃ©taillÃ©es d'un prÃ©ventionniste"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que le prÃ©ventionniste existe
    preventionniste = await db.users.find_one({
        "id": preventionniste_id,
        "tenant_id": tenant.id,
        "est_preventionniste": True
    })
    
    if not preventionniste:
        raise HTTPException(status_code=404, detail="PrÃ©ventionniste non trouvÃ©")
    
    # Statistiques globales
    nb_batiments = await db.batiments.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    nb_secteurs = await db.secteurs_geographiques.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    # Inspections par pÃ©riode
    start_of_month = datetime.now(timezone.utc).replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    start_of_year = datetime.now(timezone.utc).replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
    
    nb_inspections_mois = await db.inspections.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_id": preventionniste_id,
        "date_inspection": {"$gte": start_of_month.isoformat()}
    })
    
    nb_inspections_annee = await db.inspections.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_id": preventionniste_id,
        "date_inspection": {"$gte": start_of_year.isoformat()}
    })
    
    # Plans d'intervention crÃ©Ã©s
    nb_plans = await db.plans_intervention.count_documents({
        "tenant_id": tenant.id,
        "created_by": preventionniste_id
    })
    
    return {
        "preventionniste": {
            "id": preventionniste["id"],
            "nom": preventionniste["nom"],
            "prenom": preventionniste["prenom"],
            "email": preventionniste["email"],
            "telephone": preventionniste.get("telephone", ""),
            "grade": preventionniste.get("grade", "")
        },
        "stats": {
            "nb_batiments": nb_batiments,
            "nb_secteurs": nb_secteurs,
            "nb_inspections_mois": nb_inspections_mois,
            "nb_inspections_annee": nb_inspections_annee,
            "nb_plans": nb_plans
        }
    }


@api_router.get("/{tenant_slug}/prevention/preventionnistes/{preventionniste_id}/batiments")
async def get_preventionniste_batiments(
    tenant_slug: str,
    preventionniste_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer tous les bÃ¢timents assignÃ©s Ã  un prÃ©ventionniste"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    batiments_cursor = db.batiments.find({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    batiments = await batiments_cursor.to_list(length=None)
    
    # Nettoyer les ObjectIds pour sÃ©rialisation JSON
    for batiment in batiments:
        if "_id" in batiment:
            del batiment["_id"]
    
    return batiments


@api_router.get("/{tenant_slug}/prevention/preventionnistes/{preventionniste_id}/secteurs")
async def get_preventionniste_secteurs(
    tenant_slug: str,
    preventionniste_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer tous les secteurs assignÃ©s Ã  un prÃ©ventionniste"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    secteurs_cursor = db.secteurs_geographiques.find({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    secteurs = await secteurs_cursor.to_list(length=None)
    
    # Nettoyer les ObjectIds pour sÃ©rialisation JSON
    for secteur in secteurs:
        if "_id" in secteur:
            del secteur["_id"]
    
    return secteurs


@api_router.put("/{tenant_slug}/prevention/batiments/{batiment_id}/assigner")
async def assigner_batiment_preventionniste(
    tenant_slug: str,
    batiment_id: str,
    preventionniste_id: Optional[str] = Body(None),
    raison: Optional[str] = Body(""),
    current_user: User = Depends(get_current_user)
):
    """Assigner un prÃ©ventionniste Ã  un bÃ¢timent (avec historique)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier permissions
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # RÃ©cupÃ©rer le bÃ¢timent
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    # Si preventionniste_id fourni, vÃ©rifier qu'il existe et est actif
    if preventionniste_id:
        preventionniste = await db.users.find_one({
            "id": preventionniste_id,
            "tenant_id": tenant.id,
            "est_preventionniste": True,
            "statut": "Actif"
        })
        if not preventionniste:
            raise HTTPException(status_code=404, detail="PrÃ©ventionniste non trouvÃ© ou inactif")
    
    # CrÃ©er l'entrÃ©e d'historique
    ancien_preventionniste_id = batiment.get("preventionniste_assigne_id")
    historique_entry = {
        "date": datetime.now(timezone.utc).isoformat(),
        "ancien_preventionniste_id": ancien_preventionniste_id,
        "nouveau_preventionniste_id": preventionniste_id,
        "modifie_par": current_user.id,
        "modifie_par_nom": f"{current_user.prenom} {current_user.nom}",
        "raison": raison
    }
    
    # Mettre Ã  jour le bÃ¢timent
    await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {
            "$set": {
                "preventionniste_assigne_id": preventionniste_id,
                "updated_at": datetime.now(timezone.utc)
            },
            "$push": {"historique_assignations": historique_entry}
        }
    )
    
    # CrÃ©er notification pour le prÃ©ventionniste
    if preventionniste_id:
        notification = {
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "user_id": preventionniste_id,
            "type": "assignation_batiment",
            "titre": "Nouveau bÃ¢timent assignÃ©",
            "message": f"Le bÃ¢timent '{batiment.get('nom_etablissement') or batiment.get('adresse_civique')}' vous a Ã©tÃ© assignÃ©.",
            "lue": False,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "data": {
                "batiment_id": batiment_id,
                "batiment_nom": batiment.get('nom_etablissement') or batiment.get('adresse_civique')
            }
        }
        await db.notifications.insert_one(notification)
    
    return {
        "message": "BÃ¢timent assignÃ© avec succÃ¨s",
        "batiment_id": batiment_id,
        "preventionniste_id": preventionniste_id
    }


@api_router.put("/{tenant_slug}/prevention/secteurs/{secteur_id}/assigner")
async def assigner_secteur_preventionniste(
    tenant_slug: str,
    secteur_id: str,
    preventionniste_id: Optional[str] = Body(None),
    assigner_batiments: bool = Body(True),
    current_user: User = Depends(get_current_user)
):
    """Assigner un prÃ©ventionniste Ã  un secteur (et optionnellement tous ses bÃ¢timents)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier permissions
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # RÃ©cupÃ©rer le secteur
    secteur = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    if not secteur:
        raise HTTPException(status_code=404, detail="Secteur non trouvÃ©")
    
    # Si preventionniste_id fourni, vÃ©rifier qu'il existe
    if preventionniste_id:
        preventionniste = await db.users.find_one({
            "id": preventionniste_id,
            "tenant_id": tenant.id,
            "est_preventionniste": True,
            "statut": "Actif"
        })
        if not preventionniste:
            raise HTTPException(status_code=404, detail="PrÃ©ventionniste non trouvÃ© ou inactif")
    
    # Mettre Ã  jour le secteur
    await db.secteurs_geographiques.update_one(
        {"id": secteur_id, "tenant_id": tenant.id},
        {
            "$set": {
                "preventionniste_assigne_id": preventionniste_id,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    nb_batiments_assignes = 0
    
    # Si demandÃ©, assigner tous les bÃ¢timents du secteur
    if assigner_batiments:
        # Trouver tous les bÃ¢timents dans ce secteur (gÃ©omÃ©triquement)
        # Pour simplifier, on va assigner tous les bÃ¢timents sans preventionniste ou avec autre preventionniste
        batiments_cursor = db.batiments.find({
            "tenant_id": tenant.id,
            "latitude": {"$ne": None},
            "longitude": {"$ne": None}
        })
        
        batiments = await batiments_cursor.to_list(length=None)
        
        # Pour chaque bÃ¢timent, vÃ©rifier s'il est dans le polygone du secteur
        from shapely.geometry import Point, shape
        
        secteur_polygon = shape(secteur["geometry"])
        
        for batiment in batiments:
            if batiment.get("latitude") and batiment.get("longitude"):
                point = Point(batiment["longitude"], batiment["latitude"])
                
                if secteur_polygon.contains(point):
                    # CrÃ©er l'entrÃ©e d'historique
                    ancien_preventionniste_id = batiment.get("preventionniste_assigne_id")
                    historique_entry = {
                        "date": datetime.now(timezone.utc).isoformat(),
                        "ancien_preventionniste_id": ancien_preventionniste_id,
                        "nouveau_preventionniste_id": preventionniste_id,
                        "modifie_par": current_user.id,
                        "modifie_par_nom": f"{current_user.prenom} {current_user.nom}",
                        "raison": f"Assignation automatique via secteur '{secteur['nom']}'"
                    }
                    
                    # Mettre Ã  jour le bÃ¢timent
                    await db.batiments.update_one(
                        {"id": batiment["id"]},
                        {
                            "$set": {
                                "preventionniste_assigne_id": preventionniste_id,
                                "updated_at": datetime.now(timezone.utc)
                            },
                            "$push": {"historique_assignations": historique_entry}
                        }
                    )
                    nb_batiments_assignes += 1
    
    # CrÃ©er notification pour le prÃ©ventionniste
    if preventionniste_id:
        notification = {
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "user_id": preventionniste_id,
            "type": "assignation_secteur",
            "titre": "Nouveau secteur assignÃ©",
            "message": f"Le secteur '{secteur['nom']}' vous a Ã©tÃ© assignÃ©" + (f" avec {nb_batiments_assignes} bÃ¢timents." if assigner_batiments else "."),
            "lue": False,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "data": {
                "secteur_id": secteur_id,
                "secteur_nom": secteur['nom'],
                "nb_batiments": nb_batiments_assignes
            }
        }
        await db.notifications.insert_one(notification)
    
    return {
        "message": "Secteur assignÃ© avec succÃ¨s",
        "secteur_id": secteur_id,
        "preventionniste_id": preventionniste_id,
        "nb_batiments_assignes": nb_batiments_assignes
    }


# ==================== PARAMÃˆTRES PRÃ‰VENTION ====================

@api_router.put("/{tenant_slug}/prevention/parametres")
async def update_parametres_prevention(
    tenant_slug: str,
    recurrence_inspections: int = Body(...),
    nombre_visites_requises: int = Body(...),
    superviseur_prevention_id: Optional[str] = Body(None),
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour les paramÃ¨tres de prÃ©vention (admin uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier permissions (admin seulement)
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Seuls les administrateurs peuvent modifier les paramÃ¨tres")
    
    # Valider les valeurs
    if recurrence_inspections not in [1, 2, 3, 4, 5]:
        raise HTTPException(status_code=400, detail="La rÃ©currence doit Ãªtre entre 1 et 5 ans")
    
    if nombre_visites_requises not in [1, 2, 3]:
        raise HTTPException(status_code=400, detail="Le nombre de visites doit Ãªtre entre 1 et 3")
    
    # Si superviseur fourni, vÃ©rifier qu'il existe
    if superviseur_prevention_id:
        superviseur = await db.users.find_one({
            "id": superviseur_prevention_id,
            "tenant_id": tenant.id
        })
        if not superviseur:
            raise HTTPException(status_code=404, detail="Superviseur non trouvÃ©")
    
    # Mettre Ã  jour les paramÃ¨tres du tenant
    parametres_update = {
        "parametres.recurrence_inspections": recurrence_inspections,
        "parametres.nombre_visites_requises": nombre_visites_requises,
        "parametres.superviseur_prevention_id": superviseur_prevention_id,
        "updated_at": datetime.now(timezone.utc)
    }
    
    await db.tenants.update_one(
        {"id": tenant.id},
        {"$set": parametres_update}
    )
    
    logging.info(f"ParamÃ¨tres prÃ©vention mis Ã  jour pour {tenant_slug} par {current_user.prenom} {current_user.nom}")
    
    return {
        "message": "ParamÃ¨tres mis Ã  jour avec succÃ¨s",
        "parametres": {
            "recurrence_inspections": recurrence_inspections,
            "nombre_visites_requises": nombre_visites_requises,
            "superviseur_prevention_id": superviseur_prevention_id
        }
    }


# ==================== PLANS D'INTERVENTION ====================

@api_router.post("/{tenant_slug}/prevention/plans-intervention")
async def create_plan_intervention(
    tenant_slug: str,
    plan: PlanInterventionCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er un nouveau plan d'intervention (prÃ©ventionnistes uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier que l'utilisateur est prÃ©ventionniste ou admin
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les prÃ©ventionnistes peuvent crÃ©er des plans")
    
    # VÃ©rifier que le bÃ¢timent existe
    batiment = await db.batiments.find_one({"id": plan.batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    # GÃ©nÃ©rer le numÃ©ro de plan unique
    current_year = datetime.now().year
    count = await db.plans_intervention.count_documents({"tenant_id": tenant.id})
    numero_plan = f"PI-{current_year}-{str(count + 1).zfill(3)}"
    
    plan_dict = plan.dict()
    
    # Debug logs
    import logging
    logger = logging.getLogger(__name__)
    logger.info(f"ğŸ“¥ Layers reÃ§us dans plan_dict: {len(plan_dict.get('layers', []))} layers")
    logger.info(f"ğŸ“¥ DÃ©tails layers reÃ§us: {plan_dict.get('layers', [])}")
    
    plan_dict["tenant_id"] = tenant.id
    plan_dict["numero_plan"] = numero_plan
    plan_dict["created_by_id"] = current_user.id
    plan_dict["statut"] = "brouillon"
    
    plan_obj = PlanIntervention(**plan_dict)
    
    logger.info(f"ğŸ“¤ Layers dans plan_obj aprÃ¨s conversion: {len(plan_obj.layers)} layers")
    
    plan_to_insert = plan_obj.dict()
    logger.info(f"ğŸ’¾ Layers avant insertion MongoDB: {len(plan_to_insert.get('layers', []))} layers")
    
    await db.plans_intervention.insert_one(plan_to_insert)
    
    # CrÃ©er une activitÃ©
    batiment_nom = batiment.get('nom') or batiment.get('nom_batiment') or batiment.get('adresse_civique') or 'BÃ¢timent'
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="prevention_plan_creation",
        description=f"ğŸ¢ {current_user.prenom} {current_user.nom} a crÃ©Ã© le plan d'intervention #{numero_plan} pour '{batiment_nom}'",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    result = clean_mongo_doc(plan_to_insert)
    logger.info(f"âœ… Layers dans rÃ©sultat final: {len(result.get('layers', []))} layers")
    
    return result

@api_router.get("/{tenant_slug}/prevention/plans-intervention")
async def get_plans_intervention(
    tenant_slug: str,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    created_by_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer la liste des plans d'intervention avec filtres"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id}
    
    if batiment_id:
        query["batiment_id"] = batiment_id
    if statut:
        query["statut"] = statut
    if created_by_id:
        query["created_by_id"] = created_by_id
    
    plans = await db.plans_intervention.find(query).sort("created_at", -1).to_list(length=None)
    
    return [clean_mongo_doc(plan) for plan in plans]

@api_router.get("/{tenant_slug}/prevention/plans-intervention/{plan_id}")
async def get_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer un plan d'intervention spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    
    if not plan:
        raise HTTPException(status_code=404, detail="Plan d'intervention non trouvÃ©")
    
    return clean_mongo_doc(plan)

@api_router.put("/{tenant_slug}/prevention/plans-intervention/{plan_id}")
async def update_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    plan_update: PlanInterventionUpdate,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour un plan d'intervention (seulement si brouillon ou en_attente)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer le plan existant
    existing = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    # VÃ©rifier que le plan est modifiable
    if existing["statut"] not in ["brouillon", "en_attente_validation", "rejete"]:
        raise HTTPException(status_code=403, detail="Plan validÃ© non modifiable - crÃ©er une nouvelle version")
    
    # VÃ©rifier que l'utilisateur est le crÃ©ateur ou admin
    if existing["created_by_id"] != current_user.id and current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Seul le crÃ©ateur ou un admin peut modifier ce plan")
    
    # Mettre Ã  jour les champs fournis
    update_dict = {k: v for k, v in plan_update.dict(exclude_unset=True).items() if v is not None}
    
    # Debug logs
    import logging
    logger = logging.getLogger(__name__)
    if 'layers' in update_dict:
        logger.info(f"ğŸ“¥ UPDATE - Layers reÃ§us: {len(update_dict.get('layers', []))} layers")
        logger.info(f"ğŸ“¥ UPDATE - DÃ©tails layers: {update_dict.get('layers', [])}")
    
    update_dict["updated_at"] = datetime.now(timezone.utc)
    update_dict["date_derniere_maj"] = datetime.now(timezone.utc)
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    updated = await db.plans_intervention.find_one({"id": plan_id})
    
    if updated and 'layers' in updated:
        logger.info(f"âœ… UPDATE - Layers dans rÃ©sultat: {len(updated.get('layers', []))} layers")
    
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/plans-intervention/{plan_id}")
async def delete_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un plan d'intervention (admin uniquement)"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    result = await db.plans_intervention.delete_one({"id": plan_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    return {"message": "Plan d'intervention supprimÃ© avec succÃ¨s"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/valider")
async def soumettre_plan_validation(
    tenant_slug: str,
    plan_id: str,
    request: ValidationRequest,
    current_user: User = Depends(get_current_user)
):
    """Soumettre un plan pour validation (prÃ©ventionniste crÃ©ateur)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    # VÃ©rifier que l'utilisateur est le crÃ©ateur
    if plan["created_by_id"] != current_user.id and current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Seul le crÃ©ateur peut soumettre le plan")
    
    # VÃ©rifier que le plan est en brouillon
    if plan["statut"] != "brouillon":
        raise HTTPException(status_code=400, detail="Le plan n'est pas en brouillon")
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "en_attente_validation",
            "commentaires_validation": request.commentaires,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {"message": "Plan soumis pour validation"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/approuver")
async def approuver_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    request: ValidationRequest,
    current_user: User = Depends(get_current_user)
):
    """Approuver un plan d'intervention (admin/superviseur uniquement)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Seuls les admin/superviseurs peuvent approuver")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    if plan["statut"] != "en_attente_validation":
        raise HTTPException(status_code=400, detail="Le plan n'est pas en attente de validation")
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "valide",
            "validated_by_id": current_user.id,
            "date_validation": datetime.now(timezone.utc),
            "commentaires_validation": request.commentaires,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {"message": "Plan d'intervention approuvÃ©"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/rejeter")
async def rejeter_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    request: RejectionRequest,
    current_user: User = Depends(get_current_user)
):
    """Rejeter un plan d'intervention (admin/superviseur uniquement)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Seuls les admin/superviseurs peuvent rejeter")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    if plan["statut"] != "en_attente_validation":
        raise HTTPException(status_code=400, detail="Le plan n'est pas en attente de validation")
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "rejete",
            "validated_by_id": current_user.id,
            "commentaires_rejet": request.commentaires_rejet,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {"message": "Plan d'intervention rejetÃ©"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/nouvelle-version")
async def creer_nouvelle_version_plan(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er une nouvelle version d'un plan validÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les prÃ©ventionnistes peuvent crÃ©er des versions")
    
    # RÃ©cupÃ©rer le plan existant
    plan_actuel = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan_actuel:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    if plan_actuel["statut"] != "valide":
        raise HTTPException(status_code=400, detail="Seul un plan validÃ© peut avoir une nouvelle version")
    
    # Archiver l'ancien plan
    await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {"statut": "archive"}}
    )
    
    # CrÃ©er la nouvelle version
    nouveau_plan = plan_actuel.copy()
    nouveau_plan["id"] = str(uuid.uuid4())
    nouveau_plan["version_precedente_id"] = plan_id
    nouveau_plan["statut"] = "brouillon"
    nouveau_plan["created_by_id"] = current_user.id
    nouveau_plan["validated_by_id"] = None
    nouveau_plan["date_validation"] = None
    nouveau_plan["commentaires_validation"] = ""
    nouveau_plan["commentaires_rejet"] = ""
    nouveau_plan["created_at"] = datetime.now(timezone.utc)
    nouveau_plan["updated_at"] = datetime.now(timezone.utc)
    
    # IncrÃ©menter la version
    version_parts = nouveau_plan["version"].split(".")
    version_parts[-1] = str(int(version_parts[-1]) + 1)
    nouveau_plan["version"] = ".".join(version_parts)
    
    # Supprimer _id MongoDB du dict avant insertion
    if "_id" in nouveau_plan:
        del nouveau_plan["_id"]
    
    await db.plans_intervention.insert_one(nouveau_plan)
    
    return clean_mongo_doc(nouveau_plan)


@api_router.get("/{tenant_slug}/prevention/plans-intervention/{plan_id}/export-pdf")
async def export_plan_intervention_pdf(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """Exporter un plan d'intervention en PDF"""
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image as RLImage, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    from io import BytesIO
    import base64
    from PIL import Image as PILImage
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer le plan
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    # RÃ©cupÃ©rer le bÃ¢timent associÃ©
    batiment = None
    if plan.get("batiment_id"):
        batiment = await db.batiments.find_one({"id": plan["batiment_id"], "tenant_id": tenant.id})
    
    # CrÃ©er le buffer PDF avec branding
    buffer, doc, elements = create_branded_pdf(
        tenant, 
        pagesize=A4, 
        rightMargin=40, 
        leftMargin=40, 
        topMargin=60, 
        bottomMargin=40
    )
    
    # Styles
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        textColor=colors.HexColor('#DC2626'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=16,
        textColor=colors.HexColor('#1F2937'),
        spaceAfter=12,
        spaceBefore=12
    )
    normal_style = styles['Normal']
    
    # En-tÃªte avec titre du plan
    elements.append(Paragraph(f"ğŸ”¥ Plan d'Intervention", title_style))
    plan_title = plan.get('titre') or plan.get('nom_plan') or f"Plan - {batiment.get('nom_etablissement', 'Sans titre') if batiment else 'Sans titre'}"
    elements.append(Paragraph(f"<b>{plan_title}</b>", heading_style))
    elements.append(Spacer(1, 0.2*inch))
    
    # Informations gÃ©nÃ©rales
    info_data = [
        ['NumÃ©ro de plan:', plan.get('numero_plan', 'N/A')],
        ['Statut:', plan.get('statut', 'brouillon').replace('_', ' ').capitalize()],
        ['Date de crÃ©ation:', plan.get('created_at').strftime('%Y-%m-%d') if plan.get('created_at') and hasattr(plan.get('created_at'), 'strftime') else (str(plan.get('created_at', 'N/A'))[:10] if plan.get('created_at') else 'N/A')],
    ]
    
    if plan.get('date_validation'):
        date_val = plan['date_validation']
        if hasattr(date_val, 'strftime'):
            info_data.append(['Date de validation:', date_val.strftime('%Y-%m-%d')])
        elif isinstance(date_val, str):
            info_data.append(['Date de validation:', date_val[:10]])
        else:
            info_data.append(['Date de validation:', 'N/A'])
    
    if batiment:
        info_data.append(['BÃ¢timent:', f"{batiment.get('nom_etablissement', 'N/A')}"])
        info_data.append(['Adresse complÃ¨te:', f"{batiment.get('adresse_civique', '')} {batiment.get('ville', '')} {batiment.get('province', '')} {batiment.get('code_postal', '')}".strip() or 'N/A'])
        
        if batiment.get('type_batiment'):
            info_data.append(['Type de bÃ¢timent:', batiment['type_batiment']])
        if batiment.get('sous_type_batiment'):
            info_data.append(['Sous-type:', batiment['sous_type_batiment']])
        if batiment.get('groupe_occupation'):
            info_data.append(['Groupe d\'occupation:', batiment['groupe_occupation']])
        if batiment.get('sous_groupe'):
            info_data.append(['Sous-groupe:', batiment['sous_groupe']])
        if batiment.get('niveau_risque'):
            info_data.append(['Niveau de risque:', batiment['niveau_risque']])
        if batiment.get('annee_construction'):
            info_data.append(['AnnÃ©e construction:', batiment['annee_construction']])
        if batiment.get('nombre_etages'):
            info_data.append(['Nombre d\'Ã©tages:', batiment['nombre_etages']])
        if batiment.get('superficie_totale_m2'):
            info_data.append(['Superficie totale:', f"{batiment['superficie_totale_m2']} mÂ²"])
        if batiment.get('cadastre_matricule'):
            info_data.append(['Cadastre/Matricule:', batiment['cadastre_matricule']])
        if batiment.get('description_activite'):
            info_data.append(['Description activitÃ©:', batiment['description_activite']])
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F3F4F6')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
    ]))
    elements.append(info_table)
    elements.append(Spacer(1, 0.3*inch))
    
    # Section Contacts (si bÃ¢timent disponible)
    if batiment:
        has_contacts = False
        contact_data = []
        
        # PropriÃ©taire
        if batiment.get('proprietaire_nom') or batiment.get('proprietaire_prenom'):
            contact_data.append(['ğŸ‘¤ PropriÃ©taire:', f"{batiment.get('proprietaire_prenom', '')} {batiment.get('proprietaire_nom', '')}".strip()])
            if batiment.get('proprietaire_telephone'):
                contact_data.append(['TÃ©lÃ©phone:', batiment.get('proprietaire_telephone')])
            if batiment.get('proprietaire_courriel'):
                contact_data.append(['Courriel:', batiment.get('proprietaire_courriel')])
            has_contacts = True
        
        # Gestionnaire
        if batiment.get('gestionnaire_nom') or batiment.get('gestionnaire_prenom') or batiment.get('gerant_nom'):
            nom = batiment.get('gestionnaire_nom') or batiment.get('gerant_nom', '')
            prenom = batiment.get('gestionnaire_prenom', '')
            contact_data.append(['ğŸ‘¨â€ğŸ’¼ Gestionnaire:', f"{prenom} {nom}".strip()])
            tel = batiment.get('gestionnaire_telephone') or batiment.get('gerant_telephone')
            if tel:
                contact_data.append(['TÃ©lÃ©phone:', tel])
            email = batiment.get('gestionnaire_courriel') or batiment.get('gerant_courriel')
            if email:
                contact_data.append(['Courriel:', email])
            has_contacts = True
        
        # Locataire
        if batiment.get('locataire_nom') or batiment.get('locataire_prenom') or batiment.get('localaire_nom'):
            nom = batiment.get('locataire_nom') or batiment.get('localaire_nom', '')
            prenom = batiment.get('locataire_prenom') or batiment.get('localaire_prenom', '')
            contact_data.append(['ğŸ  Locataire:', f"{prenom} {nom}".strip()])
            tel = batiment.get('locataire_telephone') or batiment.get('localaire_telephone')
            if tel:
                contact_data.append(['TÃ©lÃ©phone:', tel])
            email = batiment.get('locataire_courriel') or batiment.get('localaire_courriel')
            if email:
                contact_data.append(['Courriel:', email])
            has_contacts = True
        
        # Responsable sÃ©curitÃ©
        if batiment.get('responsable_securite_nom'):
            contact_data.append(['ğŸ”’ Responsable sÃ©curitÃ©:', batiment.get('responsable_securite_nom')])
            if batiment.get('responsable_securite_telephone'):
                contact_data.append(['TÃ©lÃ©phone:', batiment.get('responsable_securite_telephone')])
            if batiment.get('responsable_securite_courriel'):
                contact_data.append(['Courriel:', batiment.get('responsable_securite_courriel')])
            has_contacts = True
        
        if has_contacts:
            elements.append(Paragraph("<b>ğŸ“ Contacts</b>", heading_style))
            contact_table = Table(contact_data, colWidths=[2*inch, 4*inch])
            contact_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F3F4F6')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ]))
            elements.append(contact_table)
            elements.append(Spacer(1, 0.3*inch))
    
    # Description
    description = plan.get('description') or plan.get('notes_generales')
    if description:
        elements.append(Paragraph("<b>ğŸ“‹ Description</b>", heading_style))
        elements.append(Paragraph(description, normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Notes Tactiques
    notes_tactiques = plan.get('notes_tactiques') or plan.get('instructions_particulieres')
    if notes_tactiques:
        elements.append(Paragraph("<b>âš ï¸ Notes Tactiques</b>", heading_style))
        elements.append(Paragraph(notes_tactiques, normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Section Carte et LÃ©gendes (affichage visuel des symboles)
    layers = plan.get('layers', [])
    if layers and len(layers) > 0:
        elements.append(PageBreak())
        elements.append(Paragraph("<b>ğŸ—ºï¸ Carte et LÃ©gendes</b>", title_style))
        elements.append(Spacer(1, 0.2*inch))
        
        # Informations de la carte
        carte_info = f"""
        <b>Centre de la carte:</b><br/>
        Latitude: {plan.get('centre_lat', 'N/A')}<br/>
        Longitude: {plan.get('centre_lng', 'N/A')}<br/>
        <br/>
        <b>Ã‰lÃ©ments placÃ©s sur la carte:</b> {len(layers)} symbole(s)
        """
        elements.append(Paragraph(carte_info, normal_style))
        elements.append(Spacer(1, 0.2*inch))
        
        # Image de la carte (si disponible)
        carte_image = plan.get('carte_image')
        if carte_image:
            try:
                # DÃ©coder l'image base64
                if carte_image.startswith('data:image'):
                    image_data = carte_image.split(',')[1]
                    image_bytes = base64.b64decode(image_data)
                    
                    # CrÃ©er une image PIL pour optimiser
                    img = PILImage.open(BytesIO(image_bytes))
                    if img.mode in ('RGBA', 'LA', 'P'):
                        img = img.convert('RGB')
                    
                    # Redimensionner pour le PDF (largeur max 6.5 inches)
                    max_width = 6.5 * inch
                    aspect_ratio = img.height / img.width
                    img_width = max_width
                    img_height = img_width * aspect_ratio
                    
                    # Limiter la hauteur maximale Ã  4 inches
                    if img_height > 4 * inch:
                        img_height = 4 * inch
                        img_width = img_height / aspect_ratio
                    
                    # Compresser l'image
                    img_buffer = BytesIO()
                    img.save(img_buffer, format='JPEG', quality=80, optimize=True)
                    img_buffer.seek(0)
                    
                    # CrÃ©er l'image ReportLab
                    carte_rl_image = RLImage(img_buffer, width=img_width, height=img_height)
                    
                    # Centrer l'image
                    elements.append(Paragraph("<b>ğŸ“ Vue de la Carte</b>", heading_style))
                    elements.append(Spacer(1, 0.1*inch))
                    elements.append(carte_rl_image)
                    elements.append(Spacer(1, 0.3*inch))
            except Exception as e:
                print(f"Erreur lors de l'ajout de l'image de la carte: {e}")
                elements.append(Paragraph("<i>Erreur lors du chargement de l'image de la carte</i>", normal_style))
                elements.append(Spacer(1, 0.2*inch))
        else:
            elements.append(Paragraph("<i>ğŸ’¡ Astuce: L'image de la carte sera capturÃ©e automatiquement Ã  la prochaine sauvegarde du plan.</i>", normal_style))
            elements.append(Spacer(1, 0.3*inch))
        
        # LÃ©gendes des symboles avec icÃ´nes
        elements.append(Paragraph("<b>ğŸ“Œ LÃ©gende des Symboles</b>", heading_style))
        elements.append(Spacer(1, 0.1*inch))
        
        # Grouper les symboles par type pour Ã©viter les rÃ©pÃ©titions
        symbol_types = {}
        for layer in layers:
            if layer.get('type') == 'symbol':
                props = layer.get('properties', {})
                label = props.get('label', 'Symbole')
                if label not in symbol_types:
                    symbol_types[label] = {
                        'symbol': props.get('symbol', 'ğŸ“'),
                        'image': props.get('image'),
                        'color': props.get('color', '#6B7280'),
                        'count': 0
                    }
                symbol_types[label]['count'] += 1
        
        # CrÃ©er un tableau de lÃ©gendes avec icÃ´nes
        legend_data = [['IcÃ´ne', 'Type', 'QuantitÃ©']]
        for label, info in symbol_types.items():
            # Si c'est une image, essayer de l'afficher
            if info['image']:
                try:
                    # DÃ©coder l'image base64
                    if info['image'].startswith('data:image'):
                        image_data = info['image'].split(',')[1]
                        image_bytes = base64.b64decode(image_data)
                        
                        # CrÃ©er une image PIL
                        img = PILImage.open(BytesIO(image_bytes))
                        if img.mode in ('RGBA', 'LA', 'P'):
                            img = img.convert('RGB')
                        
                        # Redimensionner pour la lÃ©gende
                        img.thumbnail((24, 24))
                        img_buffer = BytesIO()
                        img.save(img_buffer, format='PNG')
                        img_buffer.seek(0)
                        
                        # CrÃ©er une image ReportLab
                        icon_display = RLImage(img_buffer, width=24, height=24)
                        legend_data.append([icon_display, label, f"{info['count']}x"])
                    else:
                        legend_data.append([Paragraph(info['symbol'], normal_style), label, f"{info['count']}x"])
                except Exception as e:
                    print(f"Erreur affichage icÃ´ne: {e}")
                    legend_data.append([Paragraph(info['symbol'], normal_style), label, f"{info['count']}x"])
            else:
                # Afficher l'emoji
                legend_data.append([Paragraph(info['symbol'], normal_style), label, f"{info['count']}x"])
        
        legend_table = Table(legend_data, colWidths=[0.8*inch, 3*inch, 1*inch])
        legend_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3B82F6')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F3F4F6')])
        ]))
        elements.append(legend_table)
        elements.append(Spacer(1, 0.4*inch))
    
    # Points d'accÃ¨s
    points_acces = plan.get('points_acces', [])
    if points_acces and len(points_acces) > 0:
        elements.append(Paragraph(f"<b>ğŸ“ Points d'AccÃ¨s ({len(points_acces)})</b>", heading_style))
        for idx, point in enumerate(points_acces, 1):
            elements.append(Paragraph(f"{idx}. {point.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    else:
        elements.append(Paragraph("<b>ğŸ“ Points d'AccÃ¨s</b>", heading_style))
        elements.append(Paragraph("Aucun point d'accÃ¨s dÃ©fini", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Zones dangereuses
    zones_danger = plan.get('zones_dangereuses', []) or plan.get('zones_danger', [])
    if zones_danger and len(zones_danger) > 0:
        elements.append(Paragraph(f"<b>âš ï¸ Zones Dangereuses ({len(zones_danger)})</b>", heading_style))
        for idx, zone in enumerate(zones_danger, 1):
            elements.append(Paragraph(f"{idx}. {zone.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    else:
        elements.append(Paragraph("<b>âš ï¸ Zones Dangereuses</b>", heading_style))
        elements.append(Paragraph("Aucune zone dangereuse identifiÃ©e", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Ã‰quipements
    equipements = plan.get('equipements', [])
    if equipements and len(equipements) > 0:
        elements.append(Paragraph(f"<b>ğŸ”§ Ã‰quipements ({len(equipements)})</b>", heading_style))
        for idx, equip in enumerate(equipements, 1):
            elements.append(Paragraph(f"{idx}. {equip.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    else:
        elements.append(Paragraph("<b>ğŸ”§ Ã‰quipements</b>", heading_style))
        elements.append(Paragraph("Aucun Ã©quipement spÃ©cifique", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Risques identifiÃ©s
    risques = plan.get('risques_identifies', [])
    if risques and len(risques) > 0:
        elements.append(Paragraph(f"<b>ğŸ”¥ Risques IdentifiÃ©s ({len(risques)})</b>", heading_style))
        for idx, risque in enumerate(risques, 1):
            elements.append(Paragraph(f"{idx}. {risque.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Commentaires de validation
    if plan.get('commentaires_validation'):
        elements.append(Paragraph("<b>âœ… Commentaires de Validation</b>", heading_style))
        elements.append(Paragraph(plan['commentaires_validation'], normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Galerie Photos (nouvelle section)
    photos = plan.get('photos', [])
    if photos and len(photos) > 0:
        try:
            elements.append(PageBreak())
            elements.append(Paragraph(f"<b>ğŸ“· Galerie Photos ({len(photos)})</b>", title_style))
            elements.append(Spacer(1, 0.3*inch))
        except Exception as e:
            print(f"Erreur lors de l'ajout du titre galerie photos: {e}")
        
        for idx, photo in enumerate(photos, 1):
            try:
                # En-tÃªte de la photo
                photo_title = photo.get('titre', f'Photo {idx}')
                elements.append(Paragraph(f"<b>{idx}. {photo_title}</b>", heading_style))
                
                # Informations de la photo
                photo_info = []
                if photo.get('categorie'):
                    categorie_labels = {
                        'facade': 'ğŸ¢ FaÃ§ade',
                        'entree': 'ğŸšª EntrÃ©e',
                        'systeme_alarme': "ğŸš¨ SystÃ¨me d'alarme",
                        'points_eau': "ğŸ’§ Points d'eau",
                        'risques': 'âš ï¸ Risques',
                        'autre': 'ğŸ“· Autre'
                    }
                    categorie = categorie_labels.get(photo.get('categorie'), photo.get('categorie'))
                    photo_info.append(f"<b>CatÃ©gorie:</b> {categorie}")
                
                if photo.get('localisation'):
                    photo_info.append(f"<b>Localisation:</b> {photo.get('localisation')}")
                
                if photo.get('description'):
                    photo_info.append(f"<b>Description:</b> {photo.get('description')}")
                
                if photo_info:
                    info_text = ' | '.join(photo_info)
                    elements.append(Paragraph(info_text, normal_style))
                    elements.append(Spacer(1, 0.1*inch))
                
                # Image (si disponible)
                if photo.get('url'):
                    try:
                        # GÃ©rer les images base64
                        if photo['url'].startswith('data:image'):
                            # Extraire les donnÃ©es base64
                            image_data = photo['url'].split(',')[1]
                            image_bytes = base64.b64decode(image_data)
                            
                            # Ouvrir l'image avec PIL pour la compresser
                            img = PILImage.open(BytesIO(image_bytes))
                            
                            # Convertir en RGB si nÃ©cessaire
                            if img.mode in ('RGBA', 'LA', 'P'):
                                img = img.convert('RGB')
                            
                            # Compresser l'image (qualitÃ© optimisÃ©e 70-80%)
                            img_buffer = BytesIO()
                            img.save(img_buffer, format='JPEG', quality=75, optimize=True)
                            img_buffer.seek(0)
                            
                            # CrÃ©er l'image ReportLab avec une largeur maximale de 5 inches
                            rl_image = RLImage(img_buffer, width=5*inch, height=3.5*inch, kind='proportional')
                            elements.append(rl_image)
                    except Exception as img_error:
                        print(f"Erreur chargement image {idx}: {img_error}")
                        elements.append(Paragraph(f"<i>Image non disponible</i>", normal_style))
                
                elements.append(Spacer(1, 0.4*inch))
                
                # Saut de page aprÃ¨s 2 photos pour Ã©viter la surcharge
                if idx % 2 == 0 and idx < len(photos):
                    elements.append(PageBreak())
                    
            except Exception as e:
                print(f"Erreur traitement photo {idx}: {e}")
                elements.append(Paragraph(f"<i>Erreur lors du traitement de la photo {idx}</i>", normal_style))
                elements.append(Spacer(1, 0.2*inch))
    
    # Pied de page
    elements.append(Spacer(1, 0.5*inch))
    footer_style = ParagraphStyle(
        'Footer',
        parent=styles['Normal'],
        fontSize=8,
        textColor=colors.grey,
        alignment=TA_CENTER
    )
    elements.append(Paragraph(f"<i>Document gÃ©nÃ©rÃ© le {datetime.now(timezone.utc).strftime('%d/%m/%Y Ã  %H:%M')} - {tenant.nom}</i>", footer_style))
    
    # Construire le PDF
    doc.build(elements)
    
    # Retourner le PDF
    buffer.seek(0)
    
    # GÃ©nÃ©rer un nom de fichier avec le nom du bÃ¢timent ou l'adresse
    print(f"DEBUG - batiment: {batiment}")
    if batiment:
        print(f"DEBUG - batiment keys: {batiment.keys()}")
        batiment_info = batiment.get('nom') or batiment.get('nom_batiment') or batiment.get('adresse_civique') or batiment.get('adresse') or 'batiment'
    else:
        batiment_info = 'batiment'
    
    print(f"DEBUG - batiment_info: {batiment_info}")
    
    # Nettoyer le nom pour le rendre compatible avec les noms de fichiers
    batiment_safe = batiment_info.replace(' ', '_').replace('/', '-').replace('\\', '-').replace(',', '')
    numero_plan = plan.get('numero_plan', plan_id[:8])
    filename = f"plan_intervention_{numero_plan}_{batiment_safe}.pdf"
    
    print(f"DEBUG - filename gÃ©nÃ©rÃ©: {filename}")
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/pdf",
        headers={"Content-Disposition": f'attachment; filename="{filename}"'}
    )

@api_router.get("/{tenant_slug}/prevention/plans-intervention/{plan_id}/versions")
async def get_versions_plan(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer l'historique des versions d'un plan"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # Trouver toutes les versions liÃ©es
    versions = []
    
    # Chercher la version actuelle
    plan_actuel = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan_actuel:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    versions.append(clean_mongo_doc(plan_actuel))
    
    # Chercher les versions prÃ©cÃ©dentes
    version_precedente_id = plan_actuel.get("version_precedente_id")
    while version_precedente_id:
        plan_prec = await db.plans_intervention.find_one({"id": version_precedente_id, "tenant_id": tenant.id})
        if plan_prec:
            versions.append(clean_mongo_doc(plan_prec))
            version_precedente_id = plan_prec.get("version_precedente_id")
        else:
            break
    
    # Chercher les versions suivantes
    versions_suivantes = await db.plans_intervention.find({
        "version_precedente_id": plan_id,
        "tenant_id": tenant.id
    }).to_list(length=None)
    
    for v in versions_suivantes:
        versions.append(clean_mongo_doc(v))
    
    return sorted(versions, key=lambda x: x["version"], reverse=True)

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/calculer-distance")
async def calculer_distance_caserne(
    tenant_slug: str,
    plan_id: str,
    caserne_lat: float = Body(...),
    caserne_lng: float = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Calculer la distance entre la caserne et le bÃ¢timent"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    # Calculer la distance en utilisant l'API Google Distance Matrix
    try:
        import requests
        import os
        
        api_key = os.getenv("GOOGLE_MAPS_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="ClÃ© API Google Maps non configurÃ©e")
        
        url = "https://maps.googleapis.com/maps/api/distancematrix/json"
        params = {
            "origins": f"{caserne_lat},{caserne_lng}",
            "destinations": f"{plan['centre_lat']},{plan['centre_lng']}",
            "key": api_key,
            "mode": "driving"
        }
        
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        if data["status"] == "OK" and len(data["rows"]) > 0:
            element = data["rows"][0]["elements"][0]
            if element["status"] == "OK":
                distance_m = element["distance"]["value"]
                duree_s = element["duration"]["value"]
                
                distance_km = distance_m / 1000.0
                temps_minutes = duree_s // 60
                
                # Mettre Ã  jour le plan
                await db.plans_intervention.update_one(
                    {"id": plan_id, "tenant_id": tenant.id},
                    {"$set": {
                        "distance_caserne_km": distance_km,
                        "distance_caserne_unite": "km",
                        "temps_acces_minutes": temps_minutes,
                        "updated_at": datetime.now(timezone.utc)
                    }}
                )
                
                return {
                    "distance_km": distance_km,
                    "distance_m": distance_m,
                    "temps_acces_minutes": temps_minutes,
                    "message": "Distance calculÃ©e avec succÃ¨s"
                }
        
        raise HTTPException(status_code=404, detail="Impossible de calculer la distance")
    
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du calcul de distance: {str(e)}")

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/generer-pdf")
async def generer_pdf_plan(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """GÃ©nÃ©rer le PDF d'un plan d'intervention"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouvÃ©")
    
    # TODO: ImplÃ©menter la gÃ©nÃ©ration PDF complÃ¨te avec ReportLab/WeasyPrint
    # Pour l'instant, retourner un placeholder
    
    pdf_url = f"/api/{tenant_slug}/prevention/plans-intervention/{plan_id}/pdf"
    
    await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "pdf_url": pdf_url,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {
        "pdf_url": pdf_url,
        "message": "GÃ©nÃ©ration PDF programmÃ©e (fonctionnalitÃ© Ã  complÃ©ter)"
    }


# ==================== TEMPLATES PLANS D'INTERVENTION ====================

@api_router.get("/{tenant_slug}/prevention/plans-intervention/templates")
async def get_templates_plans(
    tenant_slug: str,
    type_batiment: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les templates de plans d'intervention"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    query = {"tenant_id": tenant.id, "actif": True}
    
    if type_batiment:
        query["type_batiment"] = type_batiment
    
    templates = await db.templates_plans_intervention.find(query).to_list(length=None)
    
    return [clean_mongo_doc(t) for t in templates]

@api_router.post("/{tenant_slug}/prevention/plans-intervention/from-template/{template_id}")
async def creer_plan_depuis_template(
    tenant_slug: str,
    template_id: str,
    batiment_id: str = Body(...),
    current_user: User = Depends(get_current_user)
):
    """CrÃ©er un nouveau plan Ã  partir d'un template"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # VÃ©rifier permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les prÃ©ventionnistes peuvent crÃ©er des plans")
    
    # RÃ©cupÃ©rer le template
    template = await db.templates_plans_intervention.find_one({"id": template_id, "tenant_id": tenant.id})
    if not template:
        raise HTTPException(status_code=404, detail="Template non trouvÃ©")
    
    # VÃ©rifier que le bÃ¢timent existe
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    # CrÃ©er le plan basÃ© sur le template
    current_year = datetime.now().year
    count = await db.plans_intervention.count_documents({"tenant_id": tenant.id})
    numero_plan = f"PI-{current_year}-{str(count + 1).zfill(3)}"
    
    # Utiliser les coordonnÃ©es du bÃ¢timent si disponibles
    centre_lat = batiment.get("latitude", 45.5017)  # Default Montreal
    centre_lng = batiment.get("longitude", -73.5673)
    
    nouveau_plan = PlanIntervention(
        tenant_id=tenant.id,
        batiment_id=batiment_id,
        numero_plan=numero_plan,
        nom=f"Plan {batiment.get('nom_etablissement', '')}",
        created_by_id=current_user.id,
        centre_lat=centre_lat,
        centre_lng=centre_lng,
        notes_generales=template.get("instructions_utilisation", "")
    )
    
    # Appliquer les Ã©lÃ©ments par dÃ©faut du template
    # TODO: Adapter les positions relatives du template aux coordonnÃ©es du bÃ¢timent
    
    await db.plans_intervention.insert_one(nouveau_plan.dict())
    
    return clean_mongo_doc(nouveau_plan.dict())


# ==================== STATISTIQUES PRÃ‰VENTION ====================

@api_router.get("/{tenant_slug}/prevention/statistiques")
async def get_prevention_statistics(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les statistiques du module prÃ©vention"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # Compter les bÃ¢timents
    total_batiments = await db.batiments.count_documents({"tenant_id": tenant.id})
    batiments_avec_preventionniste = await db.batiments.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": {"$exists": True, "$ne": None}
    })
    
    # Compter les inspections
    total_inspections = await db.inspections.count_documents({"tenant_id": tenant.id})
    inspections_conformes = await db.inspections.count_documents({
        "tenant_id": tenant.id,
        "statut_global": "conforme"
    })
    
    # Compter les non-conformitÃ©s
    total_non_conformites = await db.non_conformites.count_documents({"tenant_id": tenant.id})
    nc_ouvertes = await db.non_conformites.count_documents({
        "tenant_id": tenant.id,
        "statut": {"$in": ["ouverte", "en_cours"]}
    })
    nc_corrigees = await db.non_conformites.count_documents({
        "tenant_id": tenant.id,
        "statut": {"$in": ["corrigee", "fermee"]}
    })
    
    # RÃ©cupÃ©rer les prÃ©ventionnistes actifs
    preventionnistes = await db.users.find({
        "tenant_slug": tenant.slug,
        "role": {"$in": ["admin", "superviseur"]}
    }).to_list(100)
    
    preventionnistes_stats = []
    for prev in preventionnistes:
        batiments_assignes = await db.batiments.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_assigne_id": prev["id"]
        })
        inspections_realisees = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_id": prev["id"]
        })
        
        preventionnistes_stats.append({
            "id": prev["id"],
            "nom": f"{prev.get('prenom', '')} {prev.get('nom', '')}",
            "batiments_assignes": batiments_assignes,
            "inspections_realisees": inspections_realisees
        })
    
    return {
        "batiments": {
            "total": total_batiments,
            "avec_preventionniste": batiments_avec_preventionniste,
            "sans_preventionniste": total_batiments - batiments_avec_preventionniste
        },
        "inspections": {
            "total": total_inspections,
            "conformes": inspections_conformes,
            "non_conformes": total_inspections - inspections_conformes,
            "taux_conformite": round((inspections_conformes / total_inspections * 100) if total_inspections > 0 else 100, 1)
        },
        "non_conformites": {
            "total": total_non_conformites,
            "ouvertes": nc_ouvertes,
            "corrigees": nc_corrigees,
            "taux_resolution": round((nc_corrigees / total_non_conformites * 100) if total_non_conformites > 0 else 100, 1)
        },
        "preventionnistes": preventionnistes_stats
    }


# ==================== RAPPORT BÃ‚TIMENT PDF ====================

@api_router.get("/{tenant_slug}/prevention/batiments/{batiment_id}/rapport-pdf")
async def export_rapport_batiment_pdf(
    tenant_slug: str,
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """GÃ©nÃ©rer un rapport complet PDF pour un bÃ¢timent"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # RÃ©cupÃ©rer le bÃ¢timent
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="BÃ¢timent non trouvÃ©")
    
    # RÃ©cupÃ©rer les inspections du bÃ¢timent
    inspections_cursor = db.inspections.find({
        "tenant_id": tenant.id,
        "batiment_id": batiment_id
    }).sort("date_inspection", -1)
    inspections = await inspections_cursor.to_list(length=None)
    
    # RÃ©cupÃ©rer le plan d'intervention validÃ©
    plan = await db.plans_intervention.find_one({
        "tenant_id": tenant.id,
        "batiment_id": batiment_id,
        "statut": "valide"
    })
    
    # RÃ©cupÃ©rer le prÃ©ventionniste assignÃ©
    preventionniste = None
    if batiment.get("preventionniste_assigne_id"):
        preventionniste = await db.users.find_one({
            "id": batiment["preventionniste_assigne_id"],
            "tenant_id": tenant.id
        })
    
    # CrÃ©er le PDF
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image as RLImage, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    import io
    from PIL import Image as PILImage
    import base64
    
    buffer, doc, story = create_branded_pdf(
        tenant, 
        pagesize=letter, 
        topMargin=0.5*inch, 
        bottomMargin=0.5*inch
    )
    styles = getSampleStyleSheet()
    
    # Style personnalisÃ©
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        textColor=colors.HexColor('#1a1a1a'),
        spaceAfter=12,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#2563eb'),
        spaceAfter=10,
        spaceBefore=15
    )
    
    # Titre principal
    story.append(Paragraph(f"RAPPORT DE PRÃ‰VENTION", title_style))
    story.append(Paragraph(f"{batiment.get('nom_etablissement') or batiment.get('adresse_civique')}", styles['Heading2']))
    story.append(Spacer(1, 0.3*inch))
    
    # Section A : Informations du BÃ¢timent
    story.append(Paragraph("ğŸ“‹ INFORMATIONS DU BÃ‚TIMENT", heading_style))
    
    info_data = [
        ["Adresse", f"{batiment.get('adresse_civique', '')}, {batiment.get('ville', '')}, {batiment.get('province', 'QC')}"],
        ["Type de bÃ¢timent", batiment.get('type_batiment', 'N/A')],
        ["CatÃ©gorie", batiment.get('categorie', 'N/A')],
        ["Niveau de risque", batiment.get('niveau_risque', 'N/A')],
        ["Nombre d'occupants", str(batiment.get('nombre_occupants', 'N/A'))],
        ["Valeur fonciÃ¨re", f"{batiment.get('valeur_fonciere', 0):,.2f} $" if batiment.get('valeur_fonciere') else 'N/A'],
        ["PrÃ©ventionniste assignÃ©", f"{preventionniste['prenom']} {preventionniste['nom']}" if preventionniste else "Non assignÃ©"]
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4.5*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)
    ]))
    story.append(info_table)
    story.append(Spacer(1, 0.2*inch))
    
    # Photo du bÃ¢timent si disponible
    if batiment.get('photo_url'):
        try:
            photo_data = batiment['photo_url']
            if photo_data.startswith('data:image'):
                photo_data = photo_data.split(',')[1]
            
            img_data = base64.b64decode(photo_data)
            img = PILImage.open(io.BytesIO(img_data))
            
            # Redimensionner
            max_width = 4 * inch
            max_height = 3 * inch
            img.thumbnail((int(max_width * 2), int(max_height * 2)), PILImage.Resampling.LANCZOS)
            
            img_buffer = io.BytesIO()
            img.save(img_buffer, format='JPEG', quality=85)
            img_buffer.seek(0)
            
            rl_img = RLImage(img_buffer, width=max_width, height=max_height)
            story.append(rl_img)
            story.append(Spacer(1, 0.2*inch))
        except Exception as e:
            print(f"Erreur chargement photo: {e}")
    
    # Section B : Historique des Inspections
    story.append(Paragraph("ğŸ“œ HISTORIQUE DES INSPECTIONS", heading_style))
    
    if inspections:
        insp_data = [["Date", "Statut", "Non-conformitÃ©s", "Inspecteur"]]
        
        for insp in inspections[:10]:  # Limiter Ã  10 derniÃ¨res
            date_str = insp.get('date_inspection', 'N/A')
            if isinstance(date_str, str):
                try:
                    date_obj = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    date_str = date_obj.strftime('%Y-%m-%d')
                except:
                    pass
            
            statut = insp.get('statut_conformite', 'N/A')
            nb_nc = len(insp.get('non_conformites', []))
            inspecteur = insp.get('inspecteur_nom', 'N/A')
            
            insp_data.append([date_str, statut, str(nb_nc), inspecteur])
        
        insp_table = Table(insp_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 2*inch])
        insp_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2563eb')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f9fafb')])
        ]))
        story.append(insp_table)
        
        # Statistiques
        story.append(Spacer(1, 0.15*inch))
        conformes = len([i for i in inspections if i.get('statut_conformite') == 'Conforme'])
        taux = (conformes / len(inspections) * 100) if inspections else 0
        
        stats_text = f"<b>Statistiques :</b> {len(inspections)} inspections | Taux de conformitÃ© : {taux:.1f}%"
        story.append(Paragraph(stats_text, styles['Normal']))
    else:
        story.append(Paragraph("Aucune inspection enregistrÃ©e pour ce bÃ¢timent.", styles['Normal']))
    
    story.append(Spacer(1, 0.2*inch))
    
    # Section C : Plan d'Intervention
    story.append(Paragraph("ğŸ—ºï¸ PLAN D'INTERVENTION", heading_style))
    
    if plan:
        plan_text = f"Plan validÃ© : <b>{plan.get('numero_plan', 'N/A')}</b><br/>"
        plan_text += f"Points d'accÃ¨s : {len(plan.get('points_acces', []))}<br/>"
        plan_text += f"Zones dangereuses : {len(plan.get('zones_dangereuses', []))}<br/>"
        plan_text += f"Ã‰quipements : {len(plan.get('equipements_disponibles', []))}"
        story.append(Paragraph(plan_text, styles['Normal']))
    else:
        story.append(Paragraph("Aucun plan d'intervention validÃ©.", styles['Normal']))
    
    story.append(Spacer(1, 0.2*inch))
    
    # Section D : Recommandations
    story.append(Paragraph("ğŸ’¡ RECOMMANDATIONS", heading_style))
    
    recommandations = []
    
    # Analyse des derniÃ¨res inspections
    if inspections:
        derniere_insp = inspections[0]
        date_derniere = derniere_insp.get('date_inspection')
        if date_derniere:
            try:
                date_obj = datetime.fromisoformat(date_derniere.replace('Z', '+00:00'))
                jours_depuis = (datetime.now(timezone.utc) - date_obj).days
                
                if jours_depuis > 365:
                    recommandations.append(f"âš ï¸ DerniÃ¨re inspection il y a {jours_depuis} jours - PrÃ©voir une nouvelle inspection")
            except:
                pass
        
        if derniere_insp.get('statut_conformite') == 'Non conforme':
            nb_nc = len(derniere_insp.get('non_conformites', []))
            recommandations.append(f"ğŸ”´ {nb_nc} non-conformitÃ©(s) Ã  corriger en prioritÃ©")
    
    if not plan:
        recommandations.append("ğŸ“‹ CrÃ©er un plan d'intervention pour ce bÃ¢timent")
    
    if batiment.get('niveau_risque') in ['Ã‰levÃ©', 'TrÃ¨s Ã©levÃ©'] and not preventionniste:
        recommandations.append("ğŸ‘¤ Assigner un prÃ©ventionniste pour le suivi rÃ©gulier")
    
    if not recommandations:
        recommandations.append("âœ… BÃ¢timent en bon Ã©tat, poursuivre le suivi rÃ©gulier")
    
    for reco in recommandations:
        story.append(Paragraph(f"â€¢ {reco}", styles['Normal']))
    
    # Footer
    story.append(Spacer(1, 0.3*inch))
    footer_text = f"<i>Rapport gÃ©nÃ©rÃ© le {datetime.now().strftime('%Y-%m-%d %H:%M')} par {current_user.prenom} {current_user.nom}</i>"
    story.append(Paragraph(footer_text, styles['Normal']))
    
    # Construire le PDF
    doc.build(story)
    buffer.seek(0)
    
    # Nom du fichier
    filename = f"rapport_{batiment.get('nom_etablissement', 'batiment').replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.pdf"
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/pdf",
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )


# ==================== EXPORT EXCEL ====================

@api_router.get("/{tenant_slug}/prevention/export-excel")
async def export_excel_prevention(
    tenant_slug: str,
    type_export: str = "inspections",  # inspections, batiments, non_conformites
    current_user: User = Depends(get_current_user)
):
    """Exporter les donnÃ©es en Excel"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    try:
        from io import BytesIO
        import openpyxl
        from openpyxl.styles import Font, PatternFill, Alignment
        
        wb = openpyxl.Workbook()
        ws = wb.active
        
        if type_export == "inspections":
            ws.title = "Inspections"
            
            # En-tÃªtes
            headers = ["Date", "BÃ¢timent", "PrÃ©ventionniste", "Type", "Statut", "Score (%)", "Non-conformitÃ©s"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True, color="FFFFFF")
                cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
                cell.alignment = Alignment(horizontal="center")
            
            # DonnÃ©es
            inspections = await db.inspections.find({"tenant_id": tenant.id}).to_list(10000)
            batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
            users = await db.users.find({"tenant_slug": tenant.slug}).to_list(10000)
            
            batiments_dict = {b["id"]: b for b in batiments}
            users_dict = {u["id"]: u for u in users}
            
            for idx, insp in enumerate(inspections, 2):
                batiment = batiments_dict.get(insp.get("batiment_id"), {})
                preventionniste = users_dict.get(insp.get("preventionniste_id"), {})
                
                nc_count = await db.non_conformites.count_documents({
                    "inspection_id": insp["id"],
                    "tenant_id": tenant.id
                })
                
                ws.cell(row=idx, column=1, value=insp.get("date_inspection", ""))
                ws.cell(row=idx, column=2, value=batiment.get("nom_etablissement", ""))
                ws.cell(row=idx, column=3, value=f"{preventionniste.get('prenom', '')} {preventionniste.get('nom', '')}")
                ws.cell(row=idx, column=4, value=insp.get("type_inspection", ""))
                ws.cell(row=idx, column=5, value=insp.get("statut_global", ""))
                ws.cell(row=idx, column=6, value=insp.get("score_conformite", 0))
                ws.cell(row=idx, column=7, value=nc_count)
        
        elif type_export == "batiments":
            ws.title = "BÃ¢timents"
            
            headers = ["Nom", "Adresse", "Ville", "Code Postal", "Groupe Occ.", "PrÃ©ventionniste", "Nb Inspections"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True, color="FFFFFF")
                cell.fill = PatternFill(start_color="70AD47", end_color="70AD47", fill_type="solid")
                cell.alignment = Alignment(horizontal="center")
            
            batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
            users = await db.users.find({"tenant_slug": tenant.slug}).to_list(10000)
            users_dict = {u["id"]: u for u in users}
            
            for idx, bat in enumerate(batiments, 2):
                preventionniste = users_dict.get(bat.get("preventionniste_assigne_id"), {})
                insp_count = await db.inspections.count_documents({
                    "batiment_id": bat["id"],
                    "tenant_id": tenant.id
                })
                
                ws.cell(row=idx, column=1, value=bat.get("nom_etablissement", ""))
                ws.cell(row=idx, column=2, value=bat.get("adresse_civique", ""))
                ws.cell(row=idx, column=3, value=bat.get("ville", ""))
                ws.cell(row=idx, column=4, value=bat.get("code_postal", ""))
                ws.cell(row=idx, column=5, value=bat.get("groupe_occupation", ""))
                ws.cell(row=idx, column=6, value=f"{preventionniste.get('prenom', '')} {preventionniste.get('nom', '')}")
                ws.cell(row=idx, column=7, value=insp_count)
        
        elif type_export == "non_conformites":
            ws.title = "Non-ConformitÃ©s"
            
            headers = ["Date DÃ©tection", "BÃ¢timent", "Titre", "Description", "GravitÃ©", "Statut", "DÃ©lai Correction"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True, color="FFFFFF")
                cell.fill = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")
                cell.alignment = Alignment(horizontal="center")
            
            non_conformites = await db.non_conformites.find({"tenant_id": tenant.id}).to_list(10000)
            batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
            batiments_dict = {b["id"]: b for b in batiments}
            
            for idx, nc in enumerate(non_conformites, 2):
                batiment = batiments_dict.get(nc.get("batiment_id"), {})
                
                ws.cell(row=idx, column=1, value=nc.get("created_at", "")[:10])
                ws.cell(row=idx, column=2, value=batiment.get("nom_etablissement", ""))
                ws.cell(row=idx, column=3, value=nc.get("titre", ""))
                ws.cell(row=idx, column=4, value=nc.get("description", ""))
                ws.cell(row=idx, column=5, value=nc.get("gravite", ""))
                ws.cell(row=idx, column=6, value=nc.get("statut", ""))
                ws.cell(row=idx, column=7, value=nc.get("delai_correction", ""))
        
        # Ajuster la largeur des colonnes
        for column in ws.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column_letter].width = adjusted_width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename=export_{type_export}_{datetime.now(timezone.utc).strftime('%Y%m%d')}.xlsx"
            }
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export: {str(e)}")


# ==================== NOTIFICATIONS ====================

@api_router.get("/{tenant_slug}/prevention/notifications")
async def get_notifications(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les notifications pour l'utilisateur"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    notifications = []
    today = datetime.now(timezone.utc).date()
    
    # 1. Non-conformitÃ©s en retard
    non_conformites = await db.non_conformites.find({
        "tenant_id": tenant.id,
        "statut": {"$in": ["ouverte", "en_cours"]}
    }).to_list(1000)
    
    batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
    batiments_dict = {b["id"]: b for b in batiments}
    
    for nc in non_conformites:
        if nc.get("delai_correction"):
            try:
                delai_date = datetime.strptime(nc["delai_correction"], "%Y-%m-%d").date()
                days_remaining = (delai_date - today).days
                
                if days_remaining < 0:
                    notifications.append({
                        "id": f"nc_late_{nc['id']}",
                        "type": "nc_retard",
                        "priority": "urgent",
                        "titre": f"Non-conformitÃ© en retard",
                        "description": f"{nc.get('titre', 'NC')} au {batiments_dict.get(nc.get('batiment_id'), {}).get('nom_etablissement', 'bÃ¢timent')}",
                        "jours_retard": abs(days_remaining),
                        "link": f"/prevention/non-conformites/{nc['id']}",
                        "date": nc.get("created_at", "")
                    })
                elif days_remaining <= 7:
                    notifications.append({
                        "id": f"nc_soon_{nc['id']}",
                        "type": "nc_echeance_proche",
                        "priority": "high",
                        "titre": f"Ã‰chÃ©ance proche ({days_remaining}j)",
                        "description": f"{nc.get('titre', 'NC')} au {batiments_dict.get(nc.get('batiment_id'), {}).get('nom_etablissement', 'bÃ¢timent')}",
                        "jours_restants": days_remaining,
                        "link": f"/prevention/non-conformites/{nc['id']}",
                        "date": nc.get("created_at", "")
                    })
            except:
                pass
    
    # 2. BÃ¢timents sans inspection depuis 6 mois
    six_months_ago = (datetime.now(timezone.utc) - timedelta(days=180)).date().isoformat()
    
    for batiment in batiments:
        last_inspection = await db.inspections.find_one(
            {"batiment_id": batiment["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        
        # GÃ©rer le cas oÃ¹ date_inspection peut Ãªtre datetime ou string
        last_inspection_date = None
        if last_inspection:
            date_insp = last_inspection.get("date_inspection")
            if isinstance(date_insp, datetime):
                last_inspection_date = date_insp.date().isoformat()
            elif isinstance(date_insp, str):
                last_inspection_date = date_insp
        
        if not last_inspection_date or last_inspection_date < six_months_ago:
            notifications.append({
                "id": f"bat_inspection_{batiment['id']}",
                "type": "inspection_requise",
                "priority": "medium",
                "titre": "Inspection requise",
                "description": f"{batiment.get('nom_etablissement', 'BÃ¢timent')} - DerniÃ¨re inspection il y a >6 mois",
                "link": f"/prevention/batiments/{batiment['id']}",
                "date": last_inspection.get("date_inspection", "") if last_inspection else None
            })
    
    # 3. Inspections non-conformes rÃ©centes (< 30 jours)
    thirty_days_ago = (datetime.now(timezone.utc) - timedelta(days=30)).date().isoformat()
    
    recent_non_conformes = await db.inspections.find({
        "tenant_id": tenant.id,
        "statut_global": {"$ne": "conforme"},
        "date_inspection": {"$gte": thirty_days_ago}
    }).to_list(100)
    
    for inspection in recent_non_conformes:
        nc_count = await db.non_conformites.count_documents({
            "inspection_id": inspection["id"],
            "statut": {"$in": ["ouverte", "en_cours"]}
        })
        
        if nc_count > 0:
            notifications.append({
                "id": f"insp_nc_{inspection['id']}",
                "type": "inspection_nc",
                "priority": "medium",
                "titre": f"{nc_count} NC non rÃ©solues",
                "description": f"Inspection du {inspection.get('date_inspection', '')} au {batiments_dict.get(inspection.get('batiment_id'), {}).get('nom_etablissement', 'bÃ¢timent')}",
                "link": f"/prevention/inspections/{inspection['id']}",
                "date": inspection.get("date_inspection", "")
            })
    
    # Trier par prioritÃ©
    priority_order = {"urgent": 0, "high": 1, "medium": 2, "low": 3}
    notifications.sort(key=lambda x: priority_order.get(x["priority"], 999))
    
    return {
        "notifications": notifications,
        "count": len(notifications),
        "urgent_count": len([n for n in notifications if n["priority"] == "urgent"]),
        "high_count": len([n for n in notifications if n["priority"] == "high"])
    }


# ==================== RAPPORTS AVANCÃ‰S ====================

@api_router.get("/{tenant_slug}/prevention/rapports/tendances")
async def get_tendances(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer les tendances sur les 6 derniers mois"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module prÃ©vention non activÃ©")
    
    # Calculer les 6 derniers mois
    today = datetime.now(timezone.utc)
    months_data = []
    
    for i in range(6):
        month_date = today - timedelta(days=30 * i)
        month_start = month_date.replace(day=1).strftime("%Y-%m-%d")
        
        if month_date.month == 12:
            next_month = month_date.replace(year=month_date.year + 1, month=1, day=1)
        else:
            next_month = month_date.replace(month=month_date.month + 1, day=1)
        month_end = next_month.strftime("%Y-%m-%d")
        
        # Inspections du mois
        inspections_count = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "date_inspection": {"$gte": month_start, "$lt": month_end}
        })
        
        conformes_count = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "date_inspection": {"$gte": month_start, "$lt": month_end},
            "statut_global": "conforme"
        })
        
        # Non-conformitÃ©s du mois
        nc_ouvertes = await db.non_conformites.count_documents({
            "tenant_id": tenant.id,
            "created_at": {"$gte": month_start, "$lt": month_end}
        })
        
        months_data.append({
            "mois": month_date.strftime("%B %Y"),
            "inspections_total": inspections_count,
            "inspections_conformes": conformes_count,
            "taux_conformite": round((conformes_count / inspections_count * 100) if inspections_count > 0 else 0, 1),
            "non_conformites_nouvelles": nc_ouvertes
        })
    
    return {
        "tendances": list(reversed(months_data))
    }


# ==================== HEALTH CHECK ====================

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Test MongoDB connection
        await db.command('ping')
        db_status = "connected"
    except:
        db_status = "disconnected"
    
    return {
        "status": "healthy" if db_status == "connected" else "degraded",
        "service": "ProFireManager API",
        "version": "2.0",
        "database": db_status,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

# Endpoint d'initialisation (Ã  appeler une fois aprÃ¨s dÃ©ploiement)
@app.post("/api/admin/initialize-production")
async def initialize_production_data():
    """
    Endpoint pour initialiser les donnÃ©es de production
    Ã€ appeler UNE SEULE FOIS aprÃ¨s le premier dÃ©ploiement
    """
    try:
        # VÃ©rifier si dÃ©jÃ  initialisÃ©
        existing_super_admin = await db.super_admins.find_one({"email": SUPER_ADMIN_EMAIL})
        existing_tenant = await db.tenants.find_one({"slug": "shefford"})
        
        if existing_super_admin and existing_tenant:
            return {
                "status": "already_initialized",
                "message": "Les donnÃ©es sont dÃ©jÃ  initialisÃ©es",
                "super_admin_email": SUPER_ADMIN_EMAIL,
                "tenants_count": await db.tenants.count_documents({})
            }
        
        # Initialiser via la fonction existante
        await initialize_multi_tenant()
        
        return {
            "status": "success",
            "message": "DonnÃ©es de production initialisÃ©es avec succÃ¨s",
            "super_admin_email": SUPER_ADMIN_EMAIL,
            "tenants_created": 1,
            "instructions": "Connectez-vous en super-admin pour crÃ©er vos casernes"
        }
    except Exception as e:
        logging.error(f"Erreur initialisation production: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Erreur lors de l'initialisation: {str(e)}"
        )


# ==================== GESTION DES ACTIFS - VÃ‰HICULES ENDPOINTS ====================

@api_router.get("/{tenant_slug}/actifs/vehicules", response_model=List[Vehicule])
async def get_vehicules(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re la liste de tous les vÃ©hicules du tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    vehicules = await db.vehicules.find(
        {"tenant_id": tenant.id},
        {"_id": 0}
    ).to_list(length=None)
    
    return vehicules

@api_router.get("/{tenant_slug}/actifs/vehicules/{vehicule_id}/public")
async def get_vehicule_public(tenant_slug: str, vehicule_id: str):
    """RÃ©cupÃ¨re les informations publiques d'un vÃ©hicule (pour QR code) - Sans authentification"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id},
        {"_id": 0, "nom": 1, "type_vehicule": 1, "marque": 1, "modele": 1, "numero_plaque": 1, "id": 1}
    )
    
    if not vehicule:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    return vehicule

@api_router.get("/{tenant_slug}/actifs/vehicules/{vehicule_id}", response_model=Vehicule)
async def get_vehicule(
    tenant_slug: str,
    vehicule_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re un vÃ©hicule spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not vehicule:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    return vehicule

@api_router.post("/{tenant_slug}/actifs/vehicules", response_model=Vehicule)
async def create_vehicule(
    tenant_slug: str,
    vehicule_data: VehiculeCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©e un nouveau vÃ©hicule"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant et a les permissions
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # CrÃ©er le vÃ©hicule
    vehicule = Vehicule(
        tenant_id=tenant.id,
        **vehicule_data.dict()
    )
    
    # Ajouter une entrÃ©e dans la fiche de vie
    log_entry = {
        "date": datetime.now(timezone.utc).isoformat(),
        "user_id": current_user.id,
        "user_name": f"{current_user.prenom} {current_user.nom}",
        "action": "created",
        "details": f"VÃ©hicule {vehicule.nom} crÃ©Ã©",
        "gps": None
    }
    vehicule.logs = [log_entry]
    
    await db.vehicules.insert_one(vehicule.dict())
    
    return vehicule

@api_router.put("/{tenant_slug}/actifs/vehicules/{vehicule_id}", response_model=Vehicule)
async def update_vehicule(
    tenant_slug: str,
    vehicule_id: str,
    vehicule_data: VehiculeUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour un vÃ©hicule"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant et a les permissions
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id}
    )
    if not vehicule:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # PrÃ©parer les donnÃ©es Ã  mettre Ã  jour (seulement les champs fournis)
    update_data = {k: v for k, v in vehicule_data.dict(exclude_unset=True).items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    # Mettre Ã  jour
    await db.vehicules.update_one(
        {"id": vehicule_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    # RÃ©cupÃ©rer et retourner le vÃ©hicule mis Ã  jour
    updated_vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    return updated_vehicule

@api_router.delete("/{tenant_slug}/actifs/vehicules/{vehicule_id}")
async def delete_vehicule(
    tenant_slug: str,
    vehicule_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprime un vÃ©hicule"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant et a les permissions
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id}
    )
    if not vehicule:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # TODO: VÃ©rifier si le vÃ©hicule est utilisÃ© dans des inspections/inventaires
    # Pour l'instant, on permet la suppression
    
    await db.vehicules.delete_one({"id": vehicule_id, "tenant_id": tenant.id})
    
    return {"message": "VÃ©hicule supprimÃ© avec succÃ¨s"}

# ==================== GESTION DES ACTIFS - BORNES D'INCENDIE ENDPOINTS ====================

@api_router.get("/{tenant_slug}/actifs/bornes", response_model=List[BorneIncendie])
async def get_bornes(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re la liste de toutes les bornes d'incendie du tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    bornes = await db.bornes_incendie.find(
        {"tenant_id": tenant.id},
        {"_id": 0}
    ).to_list(length=None)
    
    return bornes

@api_router.get("/{tenant_slug}/actifs/bornes/{borne_id}", response_model=BorneIncendie)
async def get_borne(
    tenant_slug: str,
    borne_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re une borne d'incendie spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    borne = await db.bornes_incendie.find_one(
        {"id": borne_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not borne:
        raise HTTPException(status_code=404, detail="Borne d'incendie non trouvÃ©e")
    
    return borne

@api_router.post("/{tenant_slug}/actifs/bornes", response_model=BorneIncendie)
async def create_borne(
    tenant_slug: str,
    borne_data: BorneIncendieCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©e une nouvelle borne d'incendie"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant et a les permissions
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # CrÃ©er la borne
    borne = BorneIncendie(
        tenant_id=tenant.id,
        **borne_data.dict()
    )
    
    # Ajouter une entrÃ©e dans la fiche de vie
    log_entry = {
        "date": datetime.now(timezone.utc).isoformat(),
        "user_id": current_user.id,
        "user_name": f"{current_user.prenom} {current_user.nom}",
        "action": "created",
        "details": f"Borne {borne.nom} crÃ©Ã©e",
        "gps": borne.localisation_gps.dict() if borne.localisation_gps else None
    }
    borne.logs = [log_entry]
    
    await db.bornes_incendie.insert_one(borne.dict())
    
    return borne

@api_router.put("/{tenant_slug}/actifs/bornes/{borne_id}", response_model=BorneIncendie)
async def update_borne(
    tenant_slug: str,
    borne_id: str,
    borne_data: BorneIncendieUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour une borne d'incendie"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant et a les permissions
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # VÃ©rifier que la borne existe
    borne = await db.bornes_incendie.find_one(
        {"id": borne_id, "tenant_id": tenant.id}
    )
    if not borne:
        raise HTTPException(status_code=404, detail="Borne d'incendie non trouvÃ©e")
    
    # PrÃ©parer les donnÃ©es Ã  mettre Ã  jour (seulement les champs fournis)
    update_data = {k: v for k, v in borne_data.dict(exclude_unset=True).items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    # Mettre Ã  jour
    await db.bornes_incendie.update_one(
        {"id": borne_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    # RÃ©cupÃ©rer et retourner la borne mise Ã  jour
    updated_borne = await db.bornes_incendie.find_one(
        {"id": borne_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    return updated_borne

@api_router.delete("/{tenant_slug}/actifs/bornes/{borne_id}")
async def delete_borne(
    tenant_slug: str,
    borne_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprime une borne d'incendie"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant et a les permissions
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # VÃ©rifier que la borne existe
    borne = await db.bornes_incendie.find_one(
        {"id": borne_id, "tenant_id": tenant.id}
    )
    if not borne:
        raise HTTPException(status_code=404, detail="Borne d'incendie non trouvÃ©e")
    
    # TODO: VÃ©rifier si la borne est utilisÃ©e dans des inspections
    # Pour l'instant, on permet la suppression
    
    await db.bornes_incendie.delete_one({"id": borne_id, "tenant_id": tenant.id})
    
    return {"message": "Borne d'incendie supprimÃ©e avec succÃ¨s"}


# ==================== INVENTAIRES VÃ‰HICULES ENDPOINTS ====================

@api_router.get("/{tenant_slug}/actifs/inventaires/modeles", response_model=List[ModeleInventaire])
async def get_modeles_inventaire(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """RÃ©cupÃ¨re la liste des modÃ¨les d'inventaire du tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    modeles = await db.modeles_inventaire.find(
        {"tenant_id": tenant.id},
        {"_id": 0}
    ).to_list(length=None)
    
    return modeles

@api_router.get("/{tenant_slug}/actifs/inventaires/modeles/{modele_id}", response_model=ModeleInventaire)
async def get_modele_inventaire(
    tenant_slug: str,
    modele_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re un modÃ¨le d'inventaire spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    modele = await db.modeles_inventaire.find_one(
        {"id": modele_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not modele:
        raise HTTPException(status_code=404, detail="ModÃ¨le d'inventaire non trouvÃ©")
    
    return modele

@api_router.post("/{tenant_slug}/actifs/inventaires/modeles", response_model=ModeleInventaire)
async def create_modele_inventaire(
    tenant_slug: str,
    modele_data: ModeleInventaireCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©e un nouveau modÃ¨le d'inventaire"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    modele = ModeleInventaire(
        tenant_id=tenant.id,
        **modele_data.dict()
    )
    
    await db.modeles_inventaire.insert_one(modele.dict())
    
    return modele

@api_router.put("/{tenant_slug}/actifs/inventaires/modeles/{modele_id}", response_model=ModeleInventaire)
async def update_modele_inventaire(
    tenant_slug: str,
    modele_id: str,
    modele_data: ModeleInventaireUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour un modÃ¨le d'inventaire"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    modele = await db.modeles_inventaire.find_one(
        {"id": modele_id, "tenant_id": tenant.id}
    )
    if not modele:
        raise HTTPException(status_code=404, detail="ModÃ¨le d'inventaire non trouvÃ©")
    
    update_data = {k: v for k, v in modele_data.dict(exclude_unset=True).items() if v is not None}
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    await db.modeles_inventaire.update_one(
        {"id": modele_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    updated_modele = await db.modeles_inventaire.find_one(
        {"id": modele_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    return updated_modele

@api_router.delete("/{tenant_slug}/actifs/inventaires/modeles/{modele_id}")
async def delete_modele_inventaire(
    tenant_slug: str,
    modele_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprime un modÃ¨le d'inventaire"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    modele = await db.modeles_inventaire.find_one(
        {"id": modele_id, "tenant_id": tenant.id}
    )
    if not modele:
        raise HTTPException(status_code=404, detail="ModÃ¨le d'inventaire non trouvÃ©")
    
    # VÃ©rifier si le modÃ¨le est utilisÃ© par des vÃ©hicules
    vehicules_utilisant = await db.vehicules.count_documents({
        "tenant_id": tenant.id,
        "modele_inventaire_id": modele_id
    })
    
    if vehicules_utilisant > 0:
        raise HTTPException(
            status_code=409,
            detail=f"Ce modÃ¨le est utilisÃ© par {vehicules_utilisant} vÃ©hicule(s) et ne peut pas Ãªtre supprimÃ©"
        )
    
    await db.modeles_inventaire.delete_one({"id": modele_id, "tenant_id": tenant.id})
    
    return {"message": "ModÃ¨le d'inventaire supprimÃ© avec succÃ¨s"}

# ==================== INSPECTIONS INVENTAIRE ENDPOINTS ====================

@api_router.get("/{tenant_slug}/actifs/inventaires/inspections", response_model=List[InspectionInventaire])
async def get_inspections_inventaire(
    tenant_slug: str,
    vehicule_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re la liste des inspections d'inventaire"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    query = {"tenant_id": tenant.id}
    
    # Filtrer par vÃ©hicule si spÃ©cifiÃ©
    if vehicule_id:
        query["vehicule_id"] = vehicule_id
    
    # Les employÃ©s ne voient que leurs propres inspections
    if current_user.role == "employe":
        query["inspecteur_id"] = current_user.id
    
    inspections = await db.inspections_inventaire.find(
        query,
        {"_id": 0}
    ).sort("date_inspection", -1).to_list(length=None)
    
    return inspections

@api_router.get("/{tenant_slug}/actifs/inventaires/inspections/{inspection_id}", response_model=InspectionInventaire)
async def get_inspection_inventaire(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re une inspection d'inventaire spÃ©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    inspection = await db.inspections_inventaire.find_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # Les employÃ©s ne peuvent voir que leurs propres inspections
    if current_user.role == "employe" and inspection["inspecteur_id"] != current_user.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    return inspection

@api_router.post("/{tenant_slug}/actifs/inventaires/inspections", response_model=InspectionInventaire)
async def create_inspection_inventaire(
    tenant_slug: str,
    inspection_data: InspectionInventaireCreate,
    current_user: User = Depends(get_current_user)
):
    """CrÃ©e une nouvelle inspection d'inventaire"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicule = await db.vehicules.find_one({
        "id": inspection_data.vehicule_id,
        "tenant_id": tenant.id
    })
    if not vehicule:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # VÃ©rifier que le modÃ¨le d'inventaire existe
    modele = await db.modeles_inventaire.find_one({
        "id": inspection_data.modele_inventaire_id,
        "tenant_id": tenant.id
    })
    if not modele:
        raise HTTPException(status_code=404, detail="ModÃ¨le d'inventaire non trouvÃ©")
    
    # RÃ©cupÃ©rer le nom de l'inspecteur
    inspecteur = await db.users.find_one({"id": inspection_data.inspecteur_id})
    inspecteur_nom = f"{inspecteur.get('prenom', '')} {inspecteur.get('nom', '')}".strip() if inspecteur else None
    
    inspection = InspectionInventaire(
        tenant_id=tenant.id,
        inspecteur_nom=inspecteur_nom,
        **inspection_data.dict()
    )
    
    await db.inspections_inventaire.insert_one(inspection.dict())
    
    return inspection

@api_router.put("/{tenant_slug}/actifs/inventaires/inspections/{inspection_id}", response_model=InspectionInventaire)
async def update_inspection_inventaire(
    tenant_slug: str,
    inspection_id: str,
    inspection_data: InspectionInventaireUpdate,
    current_user: User = Depends(get_current_user)
):
    """Met Ã  jour une inspection d'inventaire (progression ou complÃ©tion)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    inspection = await db.inspections_inventaire.find_one(
        {"id": inspection_id, "tenant_id": tenant.id}
    )
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    # Les employÃ©s ne peuvent modifier que leurs propres inspections
    if current_user.role == "employe" and inspection["inspecteur_id"] != current_user.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    update_data = {k: v for k, v in inspection_data.dict(exclude_unset=True).items() if v is not None}
    
    # Si le statut passe Ã  "complete", enregistrer la date de complÃ©tion
    if inspection_data.statut == "complete" and inspection.get("statut") != "complete":
        update_data["completed_at"] = datetime.now(timezone.utc)
    
    await db.inspections_inventaire.update_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    updated_inspection = await db.inspections_inventaire.find_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    return updated_inspection

@api_router.delete("/{tenant_slug}/actifs/inventaires/inspections/{inspection_id}")
async def delete_inspection_inventaire(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprime une inspection d'inventaire"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    inspection = await db.inspections_inventaire.find_one(
        {"id": inspection_id, "tenant_id": tenant.id}
    )
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouvÃ©e")
    
    await db.inspections_inventaire.delete_one({"id": inspection_id, "tenant_id": tenant.id})
    
    return {"message": "Inspection supprimÃ©e avec succÃ¨s"}


# ==================== GESTION DES ACTIFS - INSPECTIONS SAAQ MODELS ====================

class DefectDetail(BaseModel):
    """DÃ©tail d'une dÃ©fectuositÃ© identifiÃ©e"""
    item: str  # Ex: "Freins avant", "Pneu avant gauche"
    severity: str  # "mineure" ou "majeure"
    description: str
    photo_url: Optional[str] = None
    reported_by: str
    reported_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    resolved_by: Optional[str] = None

class InspectionSAAQ(BaseModel):
    """Inspection de sÃ©curitÃ© SAAQ (Ronde prÃ©-dÃ©part)"""
    id: str = Field(default_factory=lambda: f"insp_{str(uuid.uuid4())[:8]}")
    tenant_id: str
    vehicle_id: str
    
    # Inspecteur
    inspector_id: str
    inspector_name: str
    inspector_matricule: Optional[str] = None
    
    # Signature Ã©lectronique
    signature_certify: bool = False  # "Je certifie avoir effectuÃ© cette inspection"
    signature_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    signature_gps: Optional[List[float]] = None  # [longitude, latitude]
    
    # Date/Heure inspection
    inspection_date: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Checklist (Structure flexible pour diffÃ©rents types de vÃ©hicules)
    checklist: Dict[str, Any] = Field(default_factory=dict)
    
    # DÃ©fectuositÃ©s
    defects: List[DefectDetail] = []
    has_major_defect: bool = False  # Flag pour hors service
    
    # Photos
    photo_urls: List[str] = []
    
    # RÃ©sultat
    passed: bool = True
    comments: Optional[str] = None
    
    # Offline sync (pour Atlas Device Sync)
    synced: bool = False
    created_offline: bool = False
    device_id: Optional[str] = None
    
    # MÃ©tadonnÃ©es
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionSAAQCreate(BaseModel):
    vehicle_id: str
    inspector_id: str
    inspector_name: str
    inspector_matricule: Optional[str] = None
    signature_certify: bool
    signature_gps: Optional[List[float]] = None
    checklist: Dict[str, Any]
    defects: List[DefectDetail] = []
    photo_urls: List[str] = []
    comments: Optional[str] = None
    device_id: Optional[str] = None

class AuditLogEntry(BaseModel):
    """EntrÃ©e dans la fiche de vie d'un actif"""
    date: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    user_id: str
    user_name: str
    action: str  # Ex: "created", "updated", "inspected", "repaired", "status_changed"
    details: Optional[str] = None
    gps: Optional[List[float]] = None  # Position GPS si applicable

# ==================== GESTION DES ACTIFS - INSPECTIONS SAAQ ENDPOINTS ====================

@api_router.post("/{tenant_slug}/actifs/vehicules/{vehicle_id}/inspection-saaq")
async def create_inspection_saaq(
    tenant_slug: str,
    vehicle_id: str,
    inspection_data: InspectionSAAQCreate,
    current_user: User = Depends(get_current_user)
):
    """
    CrÃ©er une nouvelle inspection SAAQ (Ronde de sÃ©curitÃ©)
    Conforme aux exigences SAAQ et Loi 430
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicle = await db.vehicules.find_one(
        {"id": vehicle_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    if not vehicle:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # CrÃ©er l'inspection
    inspection = InspectionSAAQ(
        tenant_id=tenant.id,
        vehicle_id=vehicle_id,
        inspector_id=inspection_data.inspector_id,
        inspector_name=inspection_data.inspector_name,
        inspector_matricule=inspection_data.inspector_matricule,
        signature_certify=inspection_data.signature_certify,
        signature_gps=inspection_data.signature_gps,
        checklist=inspection_data.checklist,
        defects=inspection_data.defects,
        photo_urls=inspection_data.photo_urls,
        comments=inspection_data.comments,
        device_id=inspection_data.device_id
    )
    
    # Analyser les dÃ©fectuositÃ©s
    has_major = False
    for defect in inspection.defects:
        if defect.severity == "majeure":
            has_major = True
            break
    
    inspection.has_major_defect = has_major
    inspection.passed = not has_major
    
    # Sauvegarder l'inspection
    await db.inspections_saaq.insert_one(inspection.dict())
    
    # Si dÃ©faut majeur, mettre le vÃ©hicule hors service
    if has_major:
        await db.vehicules.update_one(
            {"id": vehicle_id},
            {"$set": {
                "statut": "maintenance",
                "updated_at": datetime.now(timezone.utc)
            }}
        )
        
        # Ajouter une entrÃ©e dans la fiche de vie du vÃ©hicule
        log_entry = AuditLogEntry(
            user_id=current_user.id,
            user_name=f"{current_user.prenom} {current_user.nom}",
            action="inspection_defaut_majeur",
            details=f"Inspection SAAQ - DÃ©faut majeur dÃ©tectÃ©. VÃ©hicule mis hors service.",
            gps=inspection_data.signature_gps
        )
        
        await db.vehicules.update_one(
            {"id": vehicle_id},
            {"$push": {"logs": log_entry.dict()}}
        )
    else:
        # Ajouter une entrÃ©e positive dans la fiche de vie
        log_entry = AuditLogEntry(
            user_id=current_user.id,
            user_name=f"{current_user.prenom} {current_user.nom}",
            action="inspection_passed",
            details=f"Inspection SAAQ rÃ©ussie - Aucun dÃ©faut majeur",
            gps=inspection_data.signature_gps
        )
        
        await db.vehicules.update_one(
            {"id": vehicle_id},
            {"$push": {"logs": log_entry.dict()}}
        )
    
    # Mettre Ã  jour la date de derniÃ¨re inspection
    await db.vehicules.update_one(
        {"id": vehicle_id},
        {"$set": {
            "derniere_inspection_id": inspection.id,
            "derniere_inspection_date": inspection.inspection_date.isoformat()
        }}
    )
    
    return {
        "message": "Inspection crÃ©Ã©e avec succÃ¨s",
        "inspection_id": inspection.id,
        "vehicle_status": "maintenance" if has_major else "actif",
        "passed": inspection.passed
    }

@api_router.get("/{tenant_slug}/actifs/vehicules/{vehicle_id}/inspections")
async def get_vehicle_inspections(
    tenant_slug: str,
    vehicle_id: str,
    limit: int = 50,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re l'historique des inspections d'un vÃ©hicule"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicle = await db.vehicules.find_one(
        {"id": vehicle_id, "tenant_id": tenant.id}
    )
    if not vehicle:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # RÃ©cupÃ©rer les inspections
    inspections = await db.inspections_saaq.find(
        {"vehicle_id": vehicle_id, "tenant_id": tenant.id},
        {"_id": 0}
    ).sort("inspection_date", -1).limit(limit).to_list(limit)
    
    return inspections

@api_router.get("/{tenant_slug}/actifs/vehicules/{vehicle_id}/fiche-vie")
async def get_vehicle_lifecycle(
    tenant_slug: str,
    vehicle_id: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ¨re la fiche de vie complÃ¨te d'un vÃ©hicule (audit trail)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # RÃ©cupÃ©rer le vÃ©hicule avec ses logs
    vehicle = await db.vehicules.find_one(
        {"id": vehicle_id, "tenant_id": tenant.id},
        {"_id": 0, "logs": 1, "nom": 1, "type_vehicule": 1, "created_at": 1}
    )
    if not vehicle:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    return {
        "vehicle_id": vehicle_id,
        "vehicle_name": vehicle.get("nom", ""),
        "vehicle_type": vehicle.get("type_vehicule", ""),
        "created_at": vehicle.get("created_at"),
        "logs": vehicle.get("logs", [])
    }

@api_router.post("/{tenant_slug}/actifs/vehicules/{vehicle_id}/qr-code")
async def generate_vehicle_qr_code(
    tenant_slug: str,
    vehicle_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    GÃ©nÃ¨re un QR code pour un vÃ©hicule
    Le QR code pointe vers l'URL complÃ¨te de la fiche du vÃ©hicule
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicle = await db.vehicules.find_one(
        {"id": vehicle_id, "tenant_id": tenant.id}
    )
    if not vehicle:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # GÃ©nÃ©rer l'URL complÃ¨te vers la page d'action du vÃ©hicule
    frontend_url = os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')
    vehicle_url = f"{frontend_url}/qr/{tenant_slug}/vehicule/{vehicle_id}"
    
    # GÃ©nÃ©rer le QR code
    qr = qrcode.QRCode(version=1, box_size=10, border=4)
    qr.add_data(vehicle_url)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    buffer = BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    # Encoder en base64
    img_base64 = base64.b64encode(buffer.getvalue()).decode()
    qr_code_data_url = f"data:image/png;base64,{img_base64}"
    
    # Sauvegarder le QR code dans le vÃ©hicule
    await db.vehicules.update_one(
        {"id": vehicle_id},
        {"$set": {
            "qr_code": qr_code_data_url,
            "qr_code_url": vehicle_url,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {
        "qr_code": qr_code_data_url,
        "qr_code_url": vehicle_url,
        "message": "QR code gÃ©nÃ©rÃ© avec succÃ¨s"
    }

@api_router.post("/{tenant_slug}/actifs/bornes/{borne_id}/qr-code")
async def generate_borne_qr_code(
    tenant_slug: str,
    borne_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    GÃ©nÃ¨re un QR code pour une borne d'incendie
    Le QR code pointe vers l'URL complÃ¨te de la fiche de la borne
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # VÃ©rifier que l'utilisateur appartient au tenant
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier que la borne existe
    borne = await db.bornes_incendie.find_one(
        {"id": borne_id, "tenant_id": tenant.id}
    )
    if not borne:
        raise HTTPException(status_code=404, detail="Borne non trouvÃ©e")
    
    # GÃ©nÃ©rer l'URL complÃ¨te vers la fiche de la borne
    frontend_url = os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')
    borne_url = f"{frontend_url}/{tenant_slug}/actifs/bornes/{borne_id}"
    
    # GÃ©nÃ©rer le QR code
    qr = qrcode.QRCode(version=1, box_size=10, border=4)
    qr.add_data(borne_url)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    buffer = BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    # Encoder en base64
    img_base64 = base64.b64encode(buffer.getvalue()).decode()
    qr_code_data_url = f"data:image/png;base64,{img_base64}"
    
    # Sauvegarder le QR code dans la borne
    await db.bornes_incendie.update_one(
        {"id": borne_id},
        {"$set": {
            "qr_code": qr_code_data_url,
            "qr_code_url": borne_url,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {
        "qr_code": qr_code_data_url,
        "qr_code_url": borne_url,
        "message": "QR code gÃ©nÃ©rÃ© avec succÃ¨s"
    }

# ==================== RONDES DE SÃ‰CURITÃ‰ ====================

class ContreSignature(BaseModel):
    """Contre-signature d'une ronde par un 2e conducteur"""
    nom_conducteur: str
    prenom_conducteur: str
    signature: str  # Base64 data URL
    date_contre_signature: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    user_id: Optional[str] = None

class RondeSecuriteCreate(BaseModel):
    vehicule_id: str
    date: str
    heure: str
    lieu: str
    position_gps: Optional[List[float]] = None  # [latitude, longitude]
    km: int
    personne_mandatee: str  # Nom complet de la personne qui effectue la ronde
    defectuosites: Optional[str] = ""
    points_verification: Dict[str, str]  # { "attelage": "conforme", "chassis_carrosserie": "defectueux", ... }
    signature_mandatee: str  # Base64 data URL

class RondeSecurite(BaseModel):
    id: str = Field(default_factory=lambda: f"ronde_{str(uuid.uuid4())[:12]}")
    tenant_id: str
    vehicule_id: str
    date: str
    heure: str
    lieu: str
    position_gps: Optional[List[float]] = None
    km: int
    personne_mandatee: str
    defectuosites: Optional[str] = ""
    points_verification: Dict[str, str]
    signature_mandatee: str
    contre_signatures: List[ContreSignature] = []  # Liste des contre-signatures
    created_by: str  # User ID
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ContreSignatureCreate(BaseModel):
    nom_conducteur: str
    prenom_conducteur: str
    signature: str
    raison_refus: Optional[str] = None  # Si la personne refuse la ronde

async def send_ronde_email_background(tenant, ronde_id: str, vehicle: dict, recipient_emails: list):
    """
    Fonction helper pour envoyer l'email de ronde en arriÃ¨re-plan via Resend
    """
    try:
        import os
        import resend
        
        # RÃ©cupÃ©rer la ronde
        ronde = await db.rondes_securite.find_one(
            {"id": ronde_id, "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        if not ronde:
            logger.error(f"âŒ Ronde {ronde_id} non trouvÃ©e pour envoi email")
            return
        
        # Configurer Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        if not resend_api_key:
            logger.error("âŒ RESEND_API_KEY non configurÃ©e")
            return
        
        resend.api_key = resend_api_key
        
        nom_service = tenant.nom_service if hasattr(tenant, 'nom_service') and tenant.nom_service else tenant.nom
        date_ronde_str = ronde["date"]
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        subject = f"ğŸ”§ Nouvelle Ronde de SÃ©curitÃ© - {vehicle.get('nom', 'VÃ©hicule')} - {date_ronde_str}"
        
        html_content = f"""
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #DC2626;">ğŸ”§ Nouvelle Ronde de SÃ©curitÃ© SAAQ</h2>
            
            <p><strong>Service:</strong> {nom_service}</p>
            <p><strong>VÃ©hicule:</strong> {vehicle.get('type_vehicule', 'N/A')} - {vehicle.get('nom', 'N/A')}</p>
            <p><strong>Date:</strong> {date_ronde_str}</p>
            <p><strong>Heure:</strong> {ronde.get('heure', 'N/A')}</p>
            <p><strong>Lieu:</strong> {ronde.get('lieu', 'N/A')}</p>
            <p><strong>KilomÃ©trage:</strong> {ronde.get('km', 'N/A')} km</p>
            <p><strong>Personne mandatÃ©e:</strong> {ronde.get('personne_mandatee', 'N/A')}</p>
            
            <p style="margin-top: 20px;">
                Une nouvelle ronde de sÃ©curitÃ© a Ã©tÃ© complÃ©tÃ©e. Vous pouvez consulter les dÃ©tails dans l'application.
            </p>
            
            <hr style="margin: 30px 0; border: none; border-top: 1px solid #E5E7EB;">
            
            <p style="color: #6B7280; font-size: 12px;">
                Cet email a Ã©tÃ© envoyÃ© automatiquement par ProFireManager.<br>
                Pour consulter et gÃ©rer vos rondes de sÃ©curitÃ©, connectez-vous Ã  l'application.
            </p>
        </div>
        """
        
        # Envoyer l'email Ã  tous les destinataires
        for email in recipient_emails:
            try:
                params = {
                    "from": sender_email,
                    "to": [email],
                    "subject": subject,
                    "html": html_content,
                }
                
                response = resend.Emails.send(params)
                logger.info(f"âœ… Email envoyÃ© Ã  {email} via Resend - ID: {response.get('id', 'N/A')}")
                
            except Exception as e:
                logger.error(f"âŒ Erreur envoi email Ã  {email}: {e}")
        
    except Exception as e:
        logger.error(f"âŒ Erreur globale envoi email ronde: {e}")

@api_router.post("/{tenant_slug}/actifs/rondes-securite", response_model=RondeSecurite)
async def create_ronde_securite(
    tenant_slug: str,
    ronde_data: RondeSecuriteCreate,
    current_user: User = Depends(get_current_user)
):
    """
    CrÃ©er une nouvelle ronde de sÃ©curitÃ© SAAQ pour un vÃ©hicule
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # VÃ©rifier que le vÃ©hicule existe
    vehicle = await db.vehicules.find_one(
        {"id": ronde_data.vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    if not vehicle:
        raise HTTPException(status_code=404, detail="VÃ©hicule non trouvÃ©")
    
    # CrÃ©er la ronde
    ronde = RondeSecurite(
        tenant_id=tenant.id,
        vehicule_id=ronde_data.vehicule_id,
        date=ronde_data.date,
        heure=ronde_data.heure,
        lieu=ronde_data.lieu,
        position_gps=ronde_data.position_gps,
        km=ronde_data.km,
        personne_mandatee=ronde_data.personne_mandatee,
        defectuosites=ronde_data.defectuosites,
        points_verification=ronde_data.points_verification,
        signature_mandatee=ronde_data.signature_mandatee,
        contre_signatures=[],
        created_by=current_user.id
    )
    
    # Sauvegarder la ronde
    await db.rondes_securite.insert_one(ronde.dict())
    
    # Mettre Ã  jour la date de derniÃ¨re inspection du vÃ©hicule
    await db.vehicules.update_one(
        {"id": ronde_data.vehicule_id},
        {"$set": {"derniere_inspection_date": ronde_data.date}}
    )
    
    # Envoyer automatiquement les emails configurÃ©s
    try:
        user_ids_config = tenant.parametres.get('user_ids_rondes_securite', [])
        if user_ids_config and len(user_ids_config) > 0:
            # RÃ©cupÃ©rer les emails des utilisateurs
            users = await db.users.find({
                "id": {"$in": user_ids_config},
                "tenant_id": tenant.id
            }, {"_id": 0, "email": 1, "nom": 1, "prenom": 1}).to_list(100)
            
            recipient_emails = [u['email'] for u in users]
            
            if recipient_emails:
                # Envoyer l'email en arriÃ¨re-plan (fire and forget)
                import asyncio
                asyncio.create_task(
                    send_ronde_email_background(tenant, ronde.id, vehicle, recipient_emails)
                )
                logger.info(f"ğŸ“§ Email de ronde programmÃ© pour {len(recipient_emails)} destinataire(s)")
    except Exception as e:
        logger.error(f"âŒ Erreur programmation email ronde: {e}")
        # Ne pas bloquer la crÃ©ation de la ronde si l'email Ã©choue
    
    return ronde

@api_router.get("/{tenant_slug}/actifs/rondes-securite", response_model=List[RondeSecurite])
async def get_rondes_securite(
    tenant_slug: str,
    vehicule_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """
    RÃ©cupÃ©rer l'historique des rondes de sÃ©curitÃ©
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    query = {"tenant_id": tenant.id}
    if vehicule_id:
        query["vehicule_id"] = vehicule_id
    
    rondes = await db.rondes_securite.find(query, {"_id": 0}).sort("created_at", -1).to_list(1000)
    return rondes

@api_router.get("/{tenant_slug}/actifs/rondes-securite/{ronde_id}", response_model=RondeSecurite)
async def get_ronde_securite_by_id(
    tenant_slug: str,
    ronde_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    RÃ©cupÃ©rer une ronde de sÃ©curitÃ© spÃ©cifique par son ID
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    ronde = await db.rondes_securite.find_one(
        {"id": ronde_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not ronde:
        raise HTTPException(status_code=404, detail="Ronde de sÃ©curitÃ© non trouvÃ©e")
    
    return ronde

@api_router.get("/{tenant_slug}/actifs/rondes-securite/{ronde_id}/export-pdf")
async def export_ronde_securite_pdf(
    tenant_slug: str,
    ronde_id: str,
    current_user: User = Depends(get_current_user)
):
    """Exporter une ronde de sÃ©curitÃ© en PDF (style rapport de temps)"""
    try:
        logger.info(f"ğŸ“„ Export PDF demandÃ© - tenant: {tenant_slug}, ronde_id: {ronde_id}, user: {current_user.email}")
        
        tenant = await get_tenant_from_slug(tenant_slug)
        logger.info(f"âœ… Tenant trouvÃ©: {tenant.nom} (id: {tenant.id})")
        
        if current_user.tenant_id != tenant.id:
            logger.error(f"âŒ Tenant mismatch - user.tenant_id: {current_user.tenant_id}, tenant.id: {tenant.id}")
            raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
        
        # RÃ©cupÃ©rer la ronde
        ronde = await db.rondes_securite.find_one(
            {"id": ronde_id, "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        if not ronde:
            logger.error(f"âŒ Ronde non trouvÃ©e - id: {ronde_id}, tenant_id: {tenant.id}")
            raise HTTPException(status_code=404, detail="Ronde de sÃ©curitÃ© non trouvÃ©e")
        
        logger.info(f"âœ… Ronde trouvÃ©e - vÃ©hicule_id: {ronde.get('vehicule_id')}")
        
        # RÃ©cupÃ©rer le vÃ©hicule
        vehicule = await db.vehicules.find_one(
            {"id": ronde["vehicule_id"], "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        from io import BytesIO
        from reportlab.lib.pagesizes import A4
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import Table, TableStyle, Paragraph, Spacer, PageBreak, Image as RLImage
        from reportlab.lib.styles import ParagraphStyle
        from reportlab.lib.enums import TA_CENTER, TA_LEFT
        import base64
        
        # CrÃ©er le PDF manuellement avec header compact
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
        elements = []
        
        # Header compact avec logo (si prÃ©sent)
        if hasattr(tenant, 'logo_url') and tenant.logo_url:
            try:
                if tenant.logo_url.startswith('data:image/'):
                    header_logo, encoded = tenant.logo_url.split(',', 1)
                    logo_data = base64.b64decode(encoded)
                    logo_buffer = BytesIO(logo_data)
                    
                    from PIL import Image as PILImage
                    pil_image = PILImage.open(logo_buffer)
                    img_width, img_height = pil_image.size
                    
                    # Logo plus petit pour le PDF compact
                    target_width = 1 * inch
                    aspect_ratio = img_height / img_width
                    target_height = target_width * aspect_ratio
                    
                    logo_buffer.seek(0)
                    logo = RLImage(logo_buffer, width=target_width, height=target_height)
                    logo.hAlign = 'CENTER'
                    elements.append(logo)
                    elements.append(Spacer(1, 0.05*inch))
            except Exception as e:
                logger.error(f"Erreur chargement logo: {e}")
        
        # Nom du service compact
        nom_service = tenant.nom_service if hasattr(tenant, 'nom_service') and tenant.nom_service else tenant.nom
        header_style_compact = ParagraphStyle(
            'ServiceHeaderCompact',
            fontSize=10,
            textColor=colors.HexColor('#1f2937'),
            spaceAfter=6,
            alignment=TA_CENTER
        )
        elements.append(Paragraph(nom_service, header_style_compact))
        elements.append(Spacer(1, 0.05*inch))
        from reportlab.lib.styles import getSampleStyleSheet
        styles = getSampleStyleSheet()
        
        # Styles personnalisÃ©s - ultra-optimisÃ©s pour une page
        title_style = ParagraphStyle(
            'CustomTitle',
            fontSize=13,
            textColor=colors.HexColor('#DC2626'),
            spaceAfter=4,
            alignment=TA_CENTER
        )
        
        subtitle_style = ParagraphStyle(
            'Subtitle',
            fontSize=8,
            textColor=colors.HexColor('#6B7280'),
            spaceAfter=6,
            alignment=TA_CENTER
        )
        
        section_style = ParagraphStyle(
            'Section',
            fontSize=9,
            textColor=colors.HexColor('#DC2626'),
            spaceBefore=4,
            spaceAfter=3
        )
    
        # Titre
        elements.append(Paragraph("ğŸ”§ Ronde de SÃ©curitÃ© SAAQ", title_style))
        
        # Date et lieu
        from datetime import datetime
        date_ronde = datetime.strptime(ronde["date"], "%Y-%m-%d")
        info_text = f"Date: {date_ronde.strftime('%d/%m/%Y')} â€¢ Heure: {ronde['heure']} â€¢ Lieu: {ronde['lieu']}"
        elements.append(Paragraph(info_text, subtitle_style))
        
        # Informations du vÃ©hicule
        elements.append(Paragraph("ğŸ“‹ Informations du vÃ©hicule", section_style))
        vehicule_data = [
            ['Type', 'NÂ° Plaque', 'Marque', 'AnnÃ©e', 'KM'],
            [
                vehicule.get('type_vehicule', 'N/A'),
                vehicule.get('nom', 'N/A'),
                vehicule.get('marque', 'N/A'),
                str(vehicule.get('annee', 'N/A')),
                f"{ronde['km']} km"
            ]
        ]
        
        vehicule_table = Table(vehicule_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1*inch, 1*inch])
        vehicule_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#DC2626')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('FONTSIZE', (0, 1), (-1, -1), 7),
        ]))
        elements.append(vehicule_table)
        elements.append(Spacer(1, 0.06*inch))
        
        # Personne mandatÃ©e
        elements.append(Paragraph("ğŸ‘¤ Personne mandatÃ©e", section_style))
        mandatee_text = f"<b>{ronde['personne_mandatee']}</b>"
        mandatee_para = ParagraphStyle('MandateeText', fontSize=7.5)
        elements.append(Paragraph(mandatee_text, mandatee_para))
        elements.append(Spacer(1, 0.05*inch))
        
        # Points de vÃ©rification
        elements.append(Paragraph("âœ… Points de vÃ©rification (19 points SAAQ)", section_style))
        
        points_labels = {
            'attelage': '1 - Attelage',
            'chassis_carrosserie': '2 - ChÃ¢ssis et carrosserie',
            'chauffage_degivrage': '3 - Chauffage et dÃ©givrage',
            'commandes_conducteur_sirene': '4 - Commandes du conducteur et sirÃ¨ne',
            'direction': '5 - Direction',
            'essuie_glaces_lave_glace': '6 - Essuie-glaces/lave-glace',
            'materiel_urgence': '7 - MatÃ©riel d\'urgence',
            'phares_feux_gyrophares': '8 - Phares, feux et gyrophares',
            'pneus': '9 - Pneus',
            'portieres_autres_issues': '10 - PortiÃ¨res et autres issues',
            'retroviseurs_vitrage': '11 - RÃ©troviseurs/Vitrage',
            'roues_moyeux_fixation': '12 - Roues, Moyeux et piÃ¨ces de fixation',
            'siege': '13 - SiÃ¨ge',
            'suspension': '14 - Suspension',
            'systeme_alimentation_carburant': '15 - SystÃ¨me d\'alimentation en carburant',
            'systeme_echappement': '16 - SystÃ¨me d\'Ã©chappement',
            'systeme_freins_hydrauliques': '18 - SystÃ¨me de freins hydrauliques',
            'systeme_freins_pneumatiques': '19 - SystÃ¨me de freins pneumatiques'
        }
        
        points_data = [['Point de vÃ©rification', 'Statut']]
        
        nb_conformes = 0
        nb_defectueux = 0
        
        for key, label in points_labels.items():
            statut = ronde['points_verification'].get(key, 'conforme')
            statut_display = 'âœ… Conforme' if statut == 'conforme' else 'âŒ DÃ©fectueux'
            if statut == 'conforme':
                nb_conformes += 1
            else:
                nb_defectueux += 1
            points_data.append([label, statut_display])
        
        points_table = Table(points_data, colWidths=[4.2*inch, 1.8*inch])
        points_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#DC2626')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('ALIGN', (1, 0), (1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 7),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('FONTSIZE', (0, 1), (-1, -1), 6.5),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F9FAFB')]),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2)
        ]))
        elements.append(points_table)
        
        # RÃ©sumÃ©
        elements.append(Spacer(1, 0.05*inch))
        resume_text = f"<b>RÃ©sumÃ©:</b> {nb_conformes} point(s) conforme(s) â€¢ {nb_defectueux} point(s) dÃ©fectueux"
        resume_para = ParagraphStyle('ResumeText', fontSize=7.5)
        elements.append(Paragraph(resume_text, resume_para))
        
        # DÃ©fectuositÃ©s
        if ronde.get('defectuosites'):
            elements.append(Spacer(1, 0.05*inch))
            elements.append(Paragraph("ğŸ“ DÃ©fectuositÃ©s constatÃ©es", section_style))
            defects_text = ronde['defectuosites'].replace('\n', '<br/>')
            defects_para = ParagraphStyle('DefectsText', fontSize=6.5)
            elements.append(Paragraph(defects_text, defects_para))
        
        # Contre-signatures
        if ronde.get('contre_signatures') and len(ronde['contre_signatures']) > 0:
            elements.append(Spacer(1, 0.05*inch))
            elements.append(Paragraph("âœï¸ Contre-signatures", section_style))
            
            cs_para = ParagraphStyle('CSText', fontSize=6.5)
            for cs in ronde['contre_signatures']:
                cs_date = datetime.fromisoformat(cs['date_contre_signature'])
                cs_text = f"â€¢ {cs['prenom_conducteur']} {cs['nom_conducteur']} - {cs_date.strftime('%d/%m/%Y Ã  %H:%M')}"
                elements.append(Paragraph(cs_text, cs_para))
        
        # Signature (image base64)
        elements.append(Spacer(1, 0.06*inch))
        elements.append(Paragraph("âœï¸ Signature de la personne mandatÃ©e", section_style))
        
        try:
            # Extraire les donnÃ©es de la signature (base64)
            sig_data = ronde['signature_mandatee']
            if sig_data and sig_data.startswith('data:image'):
                # Retirer le prÃ©fixe data:image/png;base64,
                sig_base64 = sig_data.split(',')[1]
                sig_bytes = base64.b64decode(sig_base64)
                
                # CrÃ©er une image temporaire - version compacte
                sig_buffer = BytesIO(sig_bytes)
                sig_image = RLImage(sig_buffer, width=2*inch, height=0.65*inch)
                elements.append(sig_image)
        except Exception as e:
            sig_error = ParagraphStyle('SigError', parent=styles['Normal'], fontSize=7)
            elements.append(Paragraph(f"<i>Signature non disponible</i>", sig_error))
        
        # Footer ultra-compact
        elements.append(Spacer(1, 0.05*inch))
        footer_style = ParagraphStyle(
            'Footer',
            fontSize=5,
            textColor=colors.grey,
            alignment=TA_CENTER,
            spaceAfter=0
        )
        footer_text = create_pdf_footer_text(tenant)
        if footer_text:
            elements.append(Paragraph(footer_text, footer_style))
        
            # GÃ©nÃ©rer le PDF
            logger.info("ğŸ“„ GÃ©nÃ©ration du PDF...")
            doc.build(elements)
            buffer.seek(0)
            
            filename = f"ronde_securite_{vehicule.get('nom', 'vehicule')}_{ronde['date']}.pdf"
            logger.info(f"âœ… PDF gÃ©nÃ©rÃ© avec succÃ¨s - filename: {filename}")
            
            return StreamingResponse(
                buffer,
                media_type="application/pdf",
                headers={"Content-Disposition": f"attachment; filename={filename}"}
            )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"âŒ Erreur gÃ©nÃ©ration PDF: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Erreur lors de la gÃ©nÃ©ration du PDF: {str(e)}")

@api_router.get("/{tenant_slug}/actifs/configuration-emails-rondes")
async def get_configuration_emails_rondes(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """RÃ©cupÃ©rer la configuration des emails automatiques pour les rondes de sÃ©curitÃ©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # RÃ©cupÃ©rer la configuration depuis les paramÃ¨tres du tenant
    user_ids_config = tenant.parametres.get('user_ids_rondes_securite', [])
    
    return {"user_ids_rondes_securite": user_ids_config}

@api_router.put("/{tenant_slug}/actifs/configuration-emails-rondes")
async def update_configuration_emails_rondes(
    tenant_slug: str,
    config: dict,
    current_user: User = Depends(get_current_user)
):
    """Mettre Ã  jour la configuration des emails automatiques pour les rondes de sÃ©curitÃ©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ© - Admin ou superviseur uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # Valider les IDs utilisateurs
    user_ids = config.get('user_ids_rondes_securite', [])
    if not isinstance(user_ids, list):
        raise HTTPException(status_code=400, detail="Le format des IDs utilisateurs est invalide")
    
    # Mettre Ã  jour dans MongoDB
    tenant_doc = await db.tenants.find_one({"id": tenant.id})
    if not tenant_doc:
        raise HTTPException(status_code=404, detail="Tenant non trouvÃ©")
    
    current_parametres = tenant_doc.get('parametres', {})
    current_parametres['user_ids_rondes_securite'] = user_ids
    
    await db.tenants.update_one(
        {"id": tenant.id},
        {"$set": {"parametres": current_parametres}}
    )
    
    return {"message": "Configuration mise Ã  jour", "user_ids_rondes_securite": user_ids}

@api_router.post("/{tenant_slug}/actifs/rondes-securite/{ronde_id}/contre-signer")
async def contre_signer_ronde(
    tenant_slug: str,
    ronde_id: str,
    contre_signature_data: ContreSignatureCreate,
    current_user: User = Depends(get_current_user)
):
    """
    Contre-signer une ronde de sÃ©curitÃ© existante (dans les 24h)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="AccÃ¨s refusÃ©")
    
    # RÃ©cupÃ©rer la ronde
    ronde = await db.rondes_securite.find_one(
        {"id": ronde_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not ronde:
        raise HTTPException(status_code=404, detail="Ronde de sÃ©curitÃ© non trouvÃ©e")
    
    # VÃ©rifier que la ronde est encore valide (< 24h)
    from datetime import datetime, timedelta
    ronde_datetime = datetime.fromisoformat(f"{ronde['date']}T{ronde['heure']}")
    now = datetime.now()
    time_elapsed = now - ronde_datetime
    
    if time_elapsed > timedelta(hours=24):
        raise HTTPException(
            status_code=400, 
            detail=f"Cette ronde a expirÃ© (effectuÃ©e il y a {int(time_elapsed.total_seconds() / 3600)}h). Vous devez crÃ©er une nouvelle ronde."
        )
    
    # VÃ©rifier si c'est la mÃªme personne qui a fait la ronde
    nom_complet_actuel = f"{contre_signature_data.prenom_conducteur} {contre_signature_data.nom_conducteur}"
    if nom_complet_actuel.lower().strip() == ronde['personne_mandatee'].lower().strip():
        raise HTTPException(
            status_code=400,
            detail="Vous Ãªtes la personne qui a effectuÃ© cette ronde. Pas besoin de contre-signer."
        )
    
    # CrÃ©er la contre-signature
    contre_signature = ContreSignature(
        nom_conducteur=contre_signature_data.nom_conducteur,
        prenom_conducteur=contre_signature_data.prenom_conducteur,
        signature=contre_signature_data.signature,
        user_id=current_user.id
    )
    
    # Ajouter la contre-signature Ã  la ronde
    await db.rondes_securite.update_one(
        {"id": ronde_id},
        {"$push": {"contre_signatures": contre_signature.dict()}}
    )
    
    return {
        "message": "Contre-signature ajoutÃ©e avec succÃ¨s",
        "ronde_id": ronde_id,
        "temps_restant_heures": int((timedelta(hours=24) - time_elapsed).total_seconds() / 3600)
    }


# Include the router in the main app

# Endpoint public pour lister les tenants (pour l'app mobile)
@app.get("/api/tenants")
async def get_all_tenants():
    """RÃ©cupÃ¨re la liste de tous les tenants actifs (casernes) pour la sÃ©lection dans l'app mobile"""
    try:
        tenants = await db.tenants.find(
            {"actif": True},
            {"_id": 0, "id": 1, "slug": 1, "nom": 1}
        ).to_list(length=None)
        return tenants
    except Exception as e:
        return []


app.include_router(api_router)
app.include_router(pwa_router, prefix="/api")

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()