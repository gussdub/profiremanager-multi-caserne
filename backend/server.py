from fastapi import FastAPI, APIRouter, HTTPException, Depends, status, Body, UploadFile, File, Request
from fastapi.responses import Response, StreamingResponse, RedirectResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
import asyncio
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import uuid
from datetime import datetime, timezone, timedelta, date
import jwt
import json
import hashlib
import re
import bcrypt
import time
import stripe
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER, TA_LEFT
import base64
from io import BytesIO as IOBytesIO
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment
from io import BytesIO
import base64
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
import resend
import firebase_admin
from firebase_admin import credentials, messaging
import qrcode
from pwa_manifest import pwa_router
from routes.dsi import router as dsi_router
from routes.dsi_transmissions import router as dsi_transmissions_router
from routes.personnel import router as personnel_router
from routes.actifs import router as actifs_router
from routes.formations import router as formations_router
from routes.equipements import router as equipements_router
from routes.prevention import router as prevention_router
from routes.planning import router as planning_router
from routes.sftp import router as sftp_router
from routes.billing import router as billing_router
from routes.admin import router as admin_router
from routes.debogage import router as debogage_router
from routes.paie_complet import router as paie_complet_router
from routes.interventions import router as interventions_router
from routes.apria import router as apria_router
from routes.epi import router as epi_router
from routes.competences_grades import router as competences_grades_router
from routes.types_garde import router as types_garde_router
from routes.dashboard_messages import router as dashboard_messages_router
from routes.conges import router as conges_router
from routes.notifications import router as notifications_router
from routes.personnalisation import router as personnalisation_router
from routes.materiel import router as materiel_router
from routes.bornes_seches import router as bornes_seches_router
from routes.points_eau import router as points_eau_router
# from routes.disponibilites import router as disponibilites_router  # D√©sactiv√© - routes server.py plus compl√®tes
from io import BytesIO
import base64
from PIL import Image as PILImage

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Configuration Stripe
stripe.api_key = os.environ.get('STRIPE_API_KEY', 'sk_test_emergent')

# MongoDB connection avec configuration SSL pour production
mongo_url = os.environ['MONGO_URL']

# Configuration SSL/TLS pour MongoDB Atlas et production
# tlsAllowInvalidCertificates=true peut √™tre n√©cessaire pour certains environnements
if 'mongodb+srv' in mongo_url or 'ssl=true' in mongo_url.lower():
    # Pour MongoDB Atlas, s'assurer que les param√®tres SSL sont corrects
    if '?' in mongo_url:
        # Ajouter/forcer les param√®tres SSL si n√©cessaire
        if 'ssl=' not in mongo_url.lower() and 'tls=' not in mongo_url.lower():
            mongo_url += '&tls=true&tlsAllowInvalidCertificates=false'
    else:
        mongo_url += '?tls=true&tlsAllowInvalidCertificates=false'

client = AsyncIOMotorClient(
    mongo_url,
    serverSelectionTimeoutMS=30000,  # 30 secondes pour s√©lection serveur (distance Oregon-Virginie)
    connectTimeoutMS=30000,          # 30 secondes pour connexion initiale
    socketTimeoutMS=60000,           # 60 secondes pour op√©rations (documents avec photos base64)
    maxPoolSize=50,                  # Pool de connexions pour r√©utilisation
    minPoolSize=10,                  # Connexions permanentes
    maxIdleTimeMS=45000,             # Garder connexions inactives 45s
    retryWrites=True,                # Retry automatique en cas d'√©chec
    retryReads=True                  # Retry automatique en lecture
)

# Extraire le nom de la base de donn√©es depuis MONGO_URL ou utiliser un d√©faut
db_name = os.environ.get('DB_NAME', 'profiremanager')
db = client[db_name]

# Create the main app without a prefix
app = FastAPI(title="ProFireManager API", version="2.0")

# Health check endpoint pour Render (root path)
@app.get("/")
@app.head("/")
async def root_health_check():
    """Health check endpoint pour les services de monitoring (Render, etc.)"""
    return {"status": "healthy", "service": "ProFireManager API", "version": "2.0"}

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")

# ==================== HELPERS ====================

def clean_mongo_doc(doc):
    """Remove MongoDB ObjectId and other non-serializable fields"""
    if doc and "_id" in doc:
        doc.pop("_id", None)
    return doc

def is_temps_partiel(user: dict) -> bool:
    """V√©rifie si un employ√© est temps partiel ou temporaire (trait√©s de la m√™me fa√ßon)"""
    type_emploi = user.get("type_emploi", "temps_plein")
    return type_emploi in ("temps_partiel", "temporaire")

def is_temps_plein(user: dict) -> bool:
    """V√©rifie si un employ√© est temps plein"""
    return user.get("type_emploi", "temps_plein") == "temps_plein"

# ==================== FIREBASE INITIALIZATION ====================

# Initialiser Firebase Admin
# Option 1: Via variable d'environnement FIREBASE_CREDENTIALS (JSON en base64)
# Option 2: Via fichier firebase-credentials.json (pour d√©veloppement local)
firebase_credentials_env = os.environ.get('FIREBASE_CREDENTIALS')
firebase_cred_path = ROOT_DIR / 'firebase-credentials.json'

if firebase_credentials_env:
    try:
        import base64
        import json
        # D√©coder les credentials depuis la variable d'environnement (base64)
        cred_json = base64.b64decode(firebase_credentials_env).decode('utf-8')
        cred_dict = json.loads(cred_json)
        cred = credentials.Certificate(cred_dict)
        firebase_admin.initialize_app(cred)
        print("‚úÖ Firebase Admin SDK initialized from environment variable")
    except Exception as e:
        print(f"‚ö†Ô∏è Firebase initialization error (env): {e}")
elif firebase_cred_path.exists():
    try:
        cred = credentials.Certificate(str(firebase_cred_path))
        firebase_admin.initialize_app(cred)
        print("‚úÖ Firebase Admin SDK initialized from file")
    except Exception as e:
        print(f"‚ö†Ô∏è Firebase initialization error (file): {e}")
else:
    print("‚ÑπÔ∏è Firebase credentials not configured - Push notifications disabled (optional feature)")

# ==================== INITIALIZATION ====================

async def create_database_indexes():
    """Cr√©er les index MongoDB pour optimiser les performances"""
    async def safe_create_index(collection, keys, **kwargs):
        """Cr√©er un index en ignorant les erreurs si l'index existe d√©j√†"""
        try:
            await collection.create_index(keys, background=True, **kwargs)
        except Exception as e:
            # Ignorer l'erreur si l'index existe d√©j√† (code 85 ou 86)
            if "IndexKeySpecsConflict" not in str(e) and "index already exists" not in str(e).lower():
                print(f"‚ö†Ô∏è Index creation warning: {e}")
    
    try:
        # Index pour les tenants (CRITIQUE - appel√© √† chaque requ√™te)
        await safe_create_index(db.tenants, [("slug", 1)])
        await safe_create_index(db.tenants, [("slug", 1), ("actif", 1)])
        
        # Index pour les notifications (CRITIQUE pour la performance)
        await safe_create_index(db.notifications, [
            ("tenant_id", 1),
            ("destinataire_id", 1),
            ("statut", 1)
        ])
        await safe_create_index(db.notifications, [("date_creation", -1)])
        
        # Index pour les utilisateurs (CRITIQUE - chargement dashboard)
        await safe_create_index(db.users, [("tenant_id", 1)])
        await safe_create_index(db.users, [("tenant_id", 1), ("email", 1)])
        await safe_create_index(db.users, [("tenant_id", 1), ("statut", 1)])
        
        # Index pour les types de garde (chargement dashboard)
        await safe_create_index(db.types_garde, [("tenant_id", 1)])
        
        # Index pour les assignations (planning)
        await safe_create_index(db.assignations, [("tenant_id", 1), ("user_id", 1)])
        await safe_create_index(db.assignations, [("tenant_id", 1), ("semaine_debut", 1)])
        await safe_create_index(db.assignations, [("semaine_debut", 1)])
        
        # Index pour le planning
        await safe_create_index(db.planning, [("tenant_id", 1), ("semaine_debut", 1)])
        
        # Index pour les disponibilit√©s
        await safe_create_index(db.disponibilites, [("tenant_id", 1), ("user_id", 1)])
        await safe_create_index(db.disponibilites, [("tenant_id", 1), ("date", 1)])
        
        # Index pour les b√¢timents (pr√©vention)
        await safe_create_index(db.batiments, [("tenant_id", 1)])
        await safe_create_index(db.batiments, [("tenant_id", 1), ("niveau_risque", 1)])
        
        # Index pour les formations
        await safe_create_index(db.formations, [("tenant_id", 1)])
        
        # Index pour pr√©vention - pr√©ventionnistes
        await safe_create_index(db.batiments, [("tenant_id", 1), ("preventionniste_assigne_id", 1)])
        await safe_create_index(db.secteurs_geographiques, [("tenant_id", 1), ("preventionniste_assigne_id", 1)])
        await safe_create_index(db.inspections, [("tenant_id", 1), ("preventionniste_id", 1)])
        await safe_create_index(db.inspections, [("tenant_id", 1), ("date_inspection", 1)])
        await safe_create_index(db.plans_intervention, [("tenant_id", 1), ("created_by", 1)])
        
        # Index pour rapports externes - budgets
        await safe_create_index(db.budgets, [("tenant_id", 1), ("annee", 1)])
        await safe_create_index(db.immobilisations, [("tenant_id", 1)])
        await safe_create_index(db.immobilisations, [("tenant_id", 1), ("type", 1)])
        
        # Index pour dashboard - CRITIQUE pour performance
        await safe_create_index(db.assignations, [("tenant_id", 1), ("user_id", 1), ("date", 1)])
        await safe_create_index(db.inscriptions_formations, [("tenant_id", 1), ("user_id", 1)])
        await safe_create_index(db.inscriptions_formations, [("formation_id", 1)])
        await safe_create_index(db.formations, [("tenant_id", 1), ("date_debut", 1)])
        await safe_create_index(db.activites, [("tenant_id", 1), ("created_at", -1)])
        await safe_create_index(db.activites, [("tenant_id", 1), ("user_id", 1)])
        await safe_create_index(db.activites, [("tenant_id", 1), ("type_activite", 1)])
        
        print("‚úÖ Index MongoDB cr√©√©s avec succ√®s (optimisations compl√®tes)")
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur cr√©ation index: {e}")

async def initialize_multi_tenant():
    """Initialize super admin and default tenant on first run"""
    # Cr√©er les index MongoDB pour les performances
    await create_database_indexes()
    
    # 1. Cr√©er le super admin s'il n'existe pas
    super_admin_exists = await db.super_admins.find_one({"email": SUPER_ADMIN_EMAIL})
    
    if not super_admin_exists:
        super_admin = SuperAdmin(
            email=SUPER_ADMIN_EMAIL,
            nom="Super Admin",
            mot_de_passe_hash=get_password_hash("230685Juin+")
        )
        await db.super_admins.insert_one(super_admin.dict())
        print(f"‚úÖ Super admin cr√©√©: {SUPER_ADMIN_EMAIL}")
    
    # 2. Cr√©er le tenant Shefford s'il n'existe pas
    shefford_exists = await db.tenants.find_one({"slug": "shefford"})
    
    if not shefford_exists:
        shefford_tenant = Tenant(
            slug="shefford",
            nom="Service Incendie de Shefford",
            ville="Shefford",
            province="QC"
        )
        await db.tenants.insert_one(shefford_tenant.dict())
        print(f"‚úÖ Tenant Shefford cr√©√©: {shefford_tenant.id}")
        
        # 3. Migrer toutes les donn√©es existantes vers Shefford
        # Ajouter tenant_id aux collections qui n'en ont pas
        collections_to_migrate = [
            "users", "types_garde", "assignations", "demandes_remplacement",
            "formations", "disponibilites", "sessions_formation", 
            "inscriptions_formation", "demandes_conge", "notifications",
            "notifications_remplacement", "employee_epis", "parametres_remplacements"
        ]
        
        for collection_name in collections_to_migrate:
            collection = db[collection_name]
            # Mise √† jour des documents sans tenant_id
            result = await collection.update_many(
                {"tenant_id": {"$exists": False}},
                {"$set": {"tenant_id": shefford_tenant.id}}
            )
            if result.modified_count > 0:
                print(f"‚úÖ {result.modified_count} documents migr√©s dans {collection_name}")

async def initialize_default_grades():
    """Initialise les grades par d√©faut pour chaque tenant s'ils n'existent pas"""
    try:
        tenants = await db.tenants.find({}).to_list(1000)
        
        default_grades = [
            {"nom": "Pompier", "niveau_hierarchique": 1},
            {"nom": "Lieutenant", "niveau_hierarchique": 2},
            {"nom": "Capitaine", "niveau_hierarchique": 3},
            {"nom": "Directeur", "niveau_hierarchique": 4}
        ]
        
        for tenant in tenants:
            tenant_id = tenant.get('id')
            if not tenant_id:
                continue
            
            # V√©rifier si des grades existent d√©j√† pour ce tenant
            existing_count = await db.grades.count_documents({"tenant_id": tenant_id})
            
            if existing_count == 0:
                # Cr√©er les grades par d√©faut
                for grade_data in default_grades:
                    grade = Grade(
                        tenant_id=tenant_id,
                        nom=grade_data["nom"],
                        niveau_hierarchique=grade_data["niveau_hierarchique"]
                    )
                    grade_dict = grade.dict()
                    grade_dict["created_at"] = grade.created_at.isoformat()
                    grade_dict["updated_at"] = grade.updated_at.isoformat()
                    await db.grades.insert_one(grade_dict)
                
                print(f"‚úÖ {len(default_grades)} grades par d√©faut cr√©√©s pour le tenant {tenant.get('nom', tenant_id)}")
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors de l'initialisation des grades: {str(e)}")

@app.on_event("startup")
async def startup_event():
    """√âv√©nement de d√©marrage de l'application"""
    await initialize_multi_tenant()
    
    # Initialiser les grades par d√©faut
    await initialize_default_grades()
    
    # Initialiser le service SFTP
    from services.sftp_service import init_sftp_service
    from services.websocket_manager import get_websocket_manager
    ws_manager = get_websocket_manager()
    init_sftp_service(db, ws_manager)
    logger.info("Service SFTP initialis√©")
    
    # D√©marrer le polling SFTP pour les tenants actifs
    asyncio.create_task(start_sftp_polling_for_active_tenants())
    
    # D√©marrer le job p√©riodique pour v√©rifier les timeouts de remplacement
    asyncio.create_task(job_verifier_timeouts_remplacements())
    
    # D√©marrer le nettoyage p√©riodique des t√¢ches SSE expir√©es
    asyncio.create_task(cleanup_expired_tasks())


async def start_sftp_polling_for_active_tenants():
    """D√©marre le polling SFTP pour tous les tenants avec une config active"""
    await asyncio.sleep(5)  # Attendre que l'app soit pr√™te
    
    from services.sftp_service import get_sftp_service
    sftp_service = get_sftp_service()
    
    # R√©cup√©rer tous les configs SFTP actives
    configs = await db.sftp_configs.find({"actif": True}, {"_id": 0}).to_list(100)
    
    for config in configs:
        tenant_id = config["tenant_id"]
        tenant = await db.tenants.find_one({"id": tenant_id}, {"_id": 0})
        if tenant:
            await sftp_service.start_polling(
                tenant_id,
                tenant.get("slug", tenant_id),
                interval=config.get("polling_interval", 30)
            )
            logger.info(f"Polling SFTP d√©marr√© pour tenant {tenant.get('slug', tenant_id)}")

# ==================== SYST√àME DE PROGRESSION TEMPS R√âEL ====================
# Dictionnaire global pour stocker les progressions des attributions auto
attribution_progress_store: Dict[str, Dict[str, Any]] = {}

class AttributionProgress:
    """Classe pour g√©rer la progression d'une attribution automatique"""
    
    def __init__(self, task_id: str):
        self.task_id = task_id
        self.start_time = time.time()
        self.current_step = ""
        self.progress_percentage = 0
        self.total_gardes = 0
        self.gardes_traitees = 0
        self.assignations_creees = 0
        self.status = "en_cours"  # en_cours, termine, erreur
        self.error_message = None
        self.expires_at = time.time() + 3600  # Expire apr√®s 1 heure
        
    def update(self, step: str, progress: int, gardes_traitees: int = 0, assignations: int = 0):
        """Met √† jour la progression"""
        self.current_step = step
        self.progress_percentage = min(progress, 100)
        self.gardes_traitees = gardes_traitees
        if assignations > 0:
            self.assignations_creees = assignations
        attribution_progress_store[self.task_id] = self.to_dict()
    
    def complete(self, assignations_totales: int):
        """Marque la t√¢che comme termin√©e"""
        self.status = "termine"
        self.progress_percentage = 100
        self.assignations_creees = assignations_totales
        elapsed_time = time.time() - self.start_time
        self.current_step = f"‚úÖ Termin√© en {elapsed_time:.1f}s - {assignations_totales} assignations cr√©√©es"
        attribution_progress_store[self.task_id] = self.to_dict()
    
    def error(self, message: str):
        """Marque la t√¢che en erreur"""
        self.status = "erreur"
        self.error_message = message
        self.current_step = f"‚ùå Erreur: {message}"
        attribution_progress_store[self.task_id] = self.to_dict()
    
    def to_dict(self):
        """Convertit en dictionnaire pour JSON"""
        elapsed = time.time() - self.start_time
        return {
            "task_id": self.task_id,
            "status": self.status,
            "current_step": self.current_step,
            "progress_percentage": self.progress_percentage,
            "total_gardes": self.total_gardes,
            "gardes_traitees": self.gardes_traitees,
            "assignations_creees": self.assignations_creees,
            "elapsed_time": f"{elapsed:.1f}s",
            "error_message": self.error_message
        }

async def progress_event_generator(task_id: str):
    """G√©n√©rateur SSE pour streamer les mises √† jour de progression"""
    try:
        # Attendre que la t√¢che soit cr√©√©e
        for _ in range(50):  # Attendre max 5 secondes
            if task_id in attribution_progress_store:
                break
            await asyncio.sleep(0.1)
        
        # Streamer les mises √† jour
        last_data = None
        while True:
            if task_id in attribution_progress_store:
                current_data = attribution_progress_store[task_id]
                
                # Envoyer seulement si les donn√©es ont chang√©
                if current_data != last_data:
                    yield f"data: {json.dumps(current_data)}\n\n"
                    last_data = current_data.copy()
                
                # Si termin√© ou en erreur, arr√™ter le stream
                if current_data.get("status") in ["termine", "erreur"]:
                    break
            
            await asyncio.sleep(0.5)  # Mise √† jour toutes les 500ms
            
    except asyncio.CancelledError:
        pass

async def cleanup_expired_tasks():
    """Nettoie p√©riodiquement les t√¢ches expir√©es du store"""
    while True:
        try:
            current_time = time.time()
            expired_keys = []
            
            for task_id, data in list(attribution_progress_store.items()):
                # Supprimer les t√¢ches termin√©es depuis plus de 5 minutes
                if data.get("status") in ["termine", "erreur"]:
                    # V√©rifier si la t√¢che est vieille de plus de 5 minutes
                    if "elapsed_time" in data:
                        try:
                            elapsed_seconds = float(data["elapsed_time"].replace("s", ""))
                            task_age = current_time - (data.get("start_time", current_time) - elapsed_seconds)
                            if task_age > 300:  # 5 minutes
                                expired_keys.append(task_id)
                        except:
                            pass
            
            # Supprimer les t√¢ches expir√©es
            for key in expired_keys:
                del attribution_progress_store[key]
            
            if expired_keys:
                logging.info(f"üßπ Nettoyage: {len(expired_keys)} t√¢ches expir√©es supprim√©es")
            
        except Exception as e:
            logging.error(f"Erreur nettoyage t√¢ches: {e}")
        
        await asyncio.sleep(300)  # Nettoyer toutes les 5 minutes
    
    # D√©marrer le scheduler APScheduler pour les notifications automatiques
    asyncio.create_task(start_notification_scheduler())
    
    print("üöÄ ProFireManager API Multi-Tenant d√©marr√©")

# ==================== SCHEDULER NOTIFICATIONS AUTOMATIQUES ====================

async def start_notification_scheduler():
    """D√©marre le scheduler pour les notifications automatiques de planning, √©quipements et disponibilit√©s"""
    scheduler = AsyncIOScheduler()
    
    # Cr√©er un job qui v√©rifie toutes les heures si une notification doit √™tre envoy√©e
    # On v√©rifie √† chaque heure au lieu de programmer des jobs dynamiques
    scheduler.add_job(
        job_verifier_notifications_planning,
        CronTrigger(minute=0),  # Toutes les heures √† la minute 0
        id='check_planning_notifications',
        replace_existing=True
    )
    
    # Job pour v√©rifier les alertes d'√©quipements (une fois par jour √† 8h00 du matin)
    scheduler.add_job(
        job_verifier_alertes_equipements,
        CronTrigger(hour=8, minute=0),  # Tous les jours √† 8h00
        id='check_equipment_alerts',
        replace_existing=True
    )
    
    # Job pour v√©rifier les rappels de disponibilit√©s (une fois par jour √† 9h00 du matin)
    scheduler.add_job(
        job_verifier_rappels_disponibilites,
        CronTrigger(hour=9, minute=0),  # Tous les jours √† 9h00
        id='check_availability_reminders',
        replace_existing=True
    )
    
    # Job pour v√©rifier les paiements en retard et suspendre apr√®s 5 jours
    scheduler.add_job(
        job_check_overdue_payments,
        CronTrigger(hour=8, minute=0),  # Tous les jours √† 8h00
        id='check_overdue_payments',
        replace_existing=True
    )
    
    scheduler.start()
    logging.info("‚úÖ Scheduler de notifications automatiques d√©marr√© (planning + √©quipements + disponibilit√©s + paiements)")


async def job_check_overdue_payments():
    """
    Job qui v√©rifie les paiements en retard et suspend les tenants apr√®s 5 jours d'impay√©.
    S'ex√©cute tous les jours √† 8h00.
    """
    try:
        logging.info("üí∞ V√©rification des paiements en retard...")
        
        # R√©cup√©rer tous les tenants avec paiement en retard
        tenants_past_due = await db.tenants.find({
            "billing_status": "past_due",
            "is_gratuit": {"$ne": True},
            "payment_failed_date": {"$ne": None}
        }).to_list(None)
        
        suspended_count = 0
        reminder_count = 0
        
        for tenant in tenants_past_due:
            try:
                payment_failed_date = datetime.strptime(
                    tenant["payment_failed_date"], "%Y-%m-%d"
                ).replace(tzinfo=timezone.utc)
                
                days_overdue = (datetime.now(timezone.utc) - payment_failed_date).days
                
                if days_overdue >= 5:
                    # Suspendre le tenant apr√®s 5 jours
                    await db.tenants.update_one(
                        {"id": tenant["id"]},
                        {"$set": {"actif": False, "billing_status": "suspended"}}
                    )
                    logging.warning(f"‚õî Tenant {tenant['slug']} suspendu (impay√© depuis {days_overdue} jours)")
                    suspended_count += 1
                    
                    # Envoyer email de suspension
                    if tenant.get("email_contact") and os.environ.get("RESEND_API_KEY"):
                        try:
                            resend.api_key = os.environ.get("RESEND_API_KEY")
                            resend.Emails.send({
                                "from": "ProFireManager <noreply@profiremanager.com>",
                                "to": [tenant["email_contact"]],
                                "subject": "‚ö†Ô∏è Compte suspendu - ProFireManager",
                                "html": f"""
                                <h2>Votre compte a √©t√© suspendu</h2>
                                <p>Bonjour,</p>
                                <p>Suite √† un paiement non re√ßu depuis plus de 5 jours, votre compte ProFireManager pour <strong>{tenant.get('nom')}</strong> a √©t√© temporairement suspendu.</p>
                                <p>Pour r√©activer votre compte, veuillez r√©gulariser votre paiement dans votre espace de facturation.</p>
                                <p>Cordialement,<br>L'√©quipe ProFireManager</p>
                                """
                            })
                        except Exception as e:
                            logging.error(f"Erreur envoi email suspension: {e}")
                            
                elif days_overdue >= 3:
                    # Envoyer rappel apr√®s 3 jours
                    if tenant.get("email_contact") and os.environ.get("RESEND_API_KEY"):
                        try:
                            resend.api_key = os.environ.get("RESEND_API_KEY")
                            resend.Emails.send({
                                "from": "ProFireManager <noreply@profiremanager.com>",
                                "to": [tenant["email_contact"]],
                                "subject": "Dernier rappel de paiement - ProFireManager",
                                "html": f"""
                                <h2>Dernier rappel avant suspension</h2>
                                <p>Bonjour,</p>
                                <p>Votre paiement pour ProFireManager ({tenant.get('nom')}) est en retard depuis {days_overdue} jours.</p>
                                <p><strong>Attention:</strong> Sans r√®glement dans les 2 prochains jours, votre compte sera automatiquement suspendu.</p>
                                <p>Cordialement,<br>L'√©quipe ProFireManager</p>
                                """
                            })
                            reminder_count += 1
                        except Exception as e:
                            logging.error(f"Erreur envoi rappel: {e}")
                            
            except Exception as e:
                logging.error(f"Erreur traitement tenant {tenant.get('slug')}: {e}")
                continue
        
        logging.info(f"üí∞ V√©rification termin√©e: {suspended_count} suspendus, {reminder_count} rappels envoy√©s")
        
    except Exception as e:
        logging.error(f"‚ùå Erreur job_check_overdue_payments: {e}")


async def job_verifier_notifications_planning():
    """
    Job qui v√©rifie si des notifications de planning doivent √™tre envoy√©es
    S'ex√©cute toutes les heures
    """
    try:
        now = datetime.now(timezone.utc)
        current_hour = now.hour
        current_day = now.day
        
        logging.info(f"üîç V√©rification des notifications planning - Jour {current_day}, Heure {current_hour}h")
        
        # R√©cup√©rer tous les tenants
        tenants = await db.tenants.find().to_list(None)
        
        for tenant in tenants:
            try:
                # R√©cup√©rer les param√®tres de notification de ce tenant
                params = await db.parametres_validation_planning.find_one({"tenant_id": tenant["id"]})
                
                if not params:
                    continue
                
                # V√©rifier si notifications automatiques activ√©es
                if not params.get("envoi_automatique", False):
                    continue
                
                # V√©rifier si c'est le bon jour
                jour_envoi = params.get("jour_envoi", 25)
                if current_day != jour_envoi:
                    continue
                
                # V√©rifier si c'est la bonne heure
                heure_envoi = params.get("heure_envoi", "17:00")
                heure_cible = int(heure_envoi.split(":")[0])
                
                if current_hour != heure_cible:
                    continue
                
                # V√©rifier si d√©j√† envoy√© aujourd'hui
                derniere_notif = params.get("derniere_notification")
                if derniere_notif:
                    derniere_date = datetime.fromisoformat(derniere_notif).date()
                    if derniere_date == now.date():
                        logging.info(f"‚è≠Ô∏è Notifications d√©j√† envoy√©es aujourd'hui pour {tenant['nom']}")
                        continue
                
                # C'est le moment d'envoyer !
                logging.info(f"üìß Envoi des notifications automatiques pour {tenant['nom']}")
                
                # Calculer la p√©riode √† notifier
                periode_couverte = params.get("periode_couverte", "mois_suivant")
                
                if periode_couverte == "mois_suivant":
                    # Mois suivant
                    next_month = now + timedelta(days=30)
                    periode_debut = next_month.replace(day=1).strftime("%Y-%m-%d")
                    
                    # Dernier jour du mois suivant
                    if next_month.month == 12:
                        last_day = next_month.replace(year=next_month.year + 1, month=1, day=1) - timedelta(days=1)
                    else:
                        last_day = next_month.replace(month=next_month.month + 1, day=1) - timedelta(days=1)
                    periode_fin = last_day.strftime("%Y-%m-%d")
                else:
                    # Mois en cours
                    periode_debut = now.replace(day=1).strftime("%Y-%m-%d")
                    if now.month == 12:
                        last_day = now.replace(year=now.year + 1, month=1, day=1) - timedelta(days=1)
                    else:
                        last_day = now.replace(month=now.month + 1, day=1) - timedelta(days=1)
                    periode_fin = last_day.strftime("%Y-%m-%d")
                
                # Envoyer les notifications
                await envoyer_notifications_planning_automatique(
                    tenant=tenant,
                    periode_debut=periode_debut,
                    periode_fin=periode_fin
                )
                
                # Mettre √† jour la date de derni√®re notification
                await db.parametres_validation_planning.update_one(
                    {"tenant_id": tenant["id"]},
                    {"$set": {"derniere_notification": now.isoformat()}}
                )
                
                logging.info(f"‚úÖ Notifications envoy√©es avec succ√®s pour {tenant['nom']}")
                
            except Exception as e:
                logging.error(f"‚ùå Erreur envoi notifications pour {tenant.get('nom', 'Unknown')}: {str(e)}", exc_info=True)
        
    except Exception as e:
        logging.error(f"‚ùå Erreur dans job_verifier_notifications_planning: {str(e)}", exc_info=True)


def parse_frequence_inspection_to_days(frequence: str) -> int:
    """
    Convertit une fr√©quence d'inspection en nombre de jours
    Ex: "1 an" -> 365, "6 mois" -> 180, "5 ans" -> 1825
    """
    if not frequence:
        return 365  # Par d√©faut: 1 an
    
    frequence = frequence.lower().strip()
    
    # Extraire le nombre
    import re
    match = re.search(r'(\d+)', frequence)
    if not match:
        return 365
    
    nombre = int(match.group(1))
    
    # D√©terminer l'unit√©
    if 'an' in frequence or 'year' in frequence:
        return nombre * 365
    elif 'mois' in frequence or 'month' in frequence:
        return nombre * 30
    elif 'semaine' in frequence or 'week' in frequence:
        return nombre * 7
    elif 'jour' in frequence or 'day' in frequence:
        return nombre
    else:
        return nombre * 365  # Par d√©faut en ann√©es


async def job_verifier_alertes_equipements():
    """
    Job qui v√©rifie les alertes d'√©quipements et envoie des notifications par email
    S'ex√©cute tous les jours √† 8h00 du matin
    """
    try:
        logging.info("üîç V√©rification des alertes d'√©quipements pour tous les tenants")
        
        # R√©cup√©rer tous les tenants
        tenants = await db.tenants.find({"actif": True}).to_list(None)
        
        for tenant in tenants:
            try:
                tenant_id = tenant.get("id")
                tenant_nom = tenant.get("nom", "Unknown")
                
                # R√©cup√©rer les param√®tres d'alertes pour ce tenant
                parametres = await db.parametres_equipements.find_one(
                    {"tenant_id": tenant_id},
                    {"_id": 0}
                )
                
                # Si pas de param√®tres ou alertes email d√©sactiv√©es, passer au suivant
                if not parametres or not parametres.get("activer_alertes_email", True):
                    logging.info(f"‚è≠Ô∏è Alertes email d√©sactiv√©es pour {tenant_nom}")
                    continue
                
                # R√©cup√©rer la liste des emails destinataires
                emails_destinataires = parametres.get("emails_notifications_equipements", [])
                if not emails_destinataires:
                    logging.info(f"‚è≠Ô∏è Aucun destinataire configur√© pour {tenant_nom}")
                    continue
                
                # R√©cup√©rer les seuils d'alertes
                jours_maintenance = parametres.get("jours_alerte_maintenance", 30)
                jours_expiration = parametres.get("jours_alerte_expiration", 30)
                jours_fin_vie = parametres.get("jours_alerte_fin_vie", 90)
                
                today = datetime.now(timezone.utc).date()
                date_limite_maintenance = (today + timedelta(days=jours_maintenance)).isoformat()
                date_limite_expiration = (today + timedelta(days=jours_expiration)).isoformat()
                date_limite_fin_vie = (today + timedelta(days=jours_fin_vie)).isoformat()
                
                # Compter les alertes
                alertes_count = {
                    "maintenance": 0,
                    "expiration": 0,
                    "fin_vie": 0,
                    "reparation": 0
                }
                
                # Alertes maintenance
                equipements_maintenance = await db.equipements.find({
                    "tenant_id": tenant_id,
                    "date_prochaine_maintenance": {"$lte": date_limite_maintenance, "$ne": ""}
                }).to_list(1000)
                alertes_count["maintenance"] = len(equipements_maintenance)
                
                # Alertes fin de vie
                equipements_fin_vie = await db.equipements.find({
                    "tenant_id": tenant_id,
                    "date_fin_vie": {"$lte": date_limite_fin_vie, "$ne": ""}
                }).to_list(1000)
                alertes_count["fin_vie"] = len(equipements_fin_vie)
                
                # Alertes r√©paration
                equipements_reparation = await db.equipements.find({
                    "tenant_id": tenant_id,
                    "etat": {"$in": ["a_reparer", "en_reparation"]}
                }).to_list(1000)
                alertes_count["reparation"] = len(equipements_reparation)
                
                # Alertes expiration (champs personnalis√©s)
                all_equipements = await db.equipements.find(
                    {"tenant_id": tenant_id}
                ).to_list(10000)
                
                expiration_count = 0
                for eq in all_equipements:
                    champs = eq.get("champs_personnalises", {})
                    for key, value in champs.items():
                        if value and ("expiration" in key.lower() or "expir" in key.lower()):
                            try:
                                date_exp = datetime.fromisoformat(str(value)).date()
                                if date_exp <= (today + timedelta(days=jours_expiration)):
                                    expiration_count += 1
                                    break  # Compter chaque √©quipement une seule fois
                            except:
                                pass
                
                alertes_count["expiration"] = expiration_count
                
                # =============================================
                # NOUVEAU: Alertes inspections dues par cat√©gorie
                # =============================================
                alertes_count["inspections_dues"] = 0
                alertes_par_categorie = {}  # {categorie_id: {nom, count, personne_ressource_email, equipements}}
                
                # R√©cup√©rer toutes les cat√©gories avec leur fr√©quence d'inspection
                categories = await db.categories_equipements.find(
                    {"tenant_id": tenant_id},
                    {"_id": 0}
                ).to_list(1000)
                
                categories_map = {cat.get("id"): cat for cat in categories}
                
                for eq in all_equipements:
                    categorie_id = eq.get("categorie_id")
                    if not categorie_id or categorie_id not in categories_map:
                        continue
                    
                    categorie = categories_map[categorie_id]
                    frequence = categorie.get("frequence_inspection", "")
                    if not frequence:
                        continue  # Pas de fr√©quence d√©finie, pas d'alerte
                    
                    jours_frequence = parse_frequence_inspection_to_days(frequence)
                    
                    # Trouver la derni√®re inspection unifi√©e pour cet √©quipement
                    derniere_inspection = await db.inspections_unifiees.find_one(
                        {
                            "tenant_id": tenant_id,
                            "asset_id": eq.get("id"),
                            "asset_type": "equipement"
                        },
                        {"_id": 0},
                        sort=[("date_inspection", -1)]
                    )
                    
                    # Si pas d'inspection unifi√©e, chercher dans les anciennes collections
                    if not derniere_inspection:
                        derniere_inspection = await db.inspections_equipements.find_one(
                            {
                                "tenant_id": tenant_id,
                                "equipement_id": eq.get("id")
                            },
                            {"_id": 0},
                            sort=[("date_inspection", -1)]
                        )
                    
                    # Calculer si l'inspection est due
                    inspection_due = False
                    jours_depuis_derniere = None
                    
                    if derniere_inspection:
                        date_derniere = derniere_inspection.get("date_inspection") or derniere_inspection.get("created_at")
                        if date_derniere:
                            try:
                                if isinstance(date_derniere, str):
                                    date_derniere = datetime.fromisoformat(date_derniere.replace("Z", "+00:00"))
                                elif isinstance(date_derniere, datetime):
                                    pass
                                else:
                                    date_derniere = None
                                
                                if date_derniere:
                                    jours_depuis_derniere = (datetime.now(timezone.utc) - date_derniere).days
                                    if jours_depuis_derniere >= jours_frequence:
                                        inspection_due = True
                            except:
                                pass
                    else:
                        # Aucune inspection jamais faite - v√©rifier la date de cr√©ation de l'√©quipement
                        date_creation = eq.get("created_at") or eq.get("date_ajout")
                        if date_creation:
                            try:
                                if isinstance(date_creation, str):
                                    date_creation = datetime.fromisoformat(date_creation.replace("Z", "+00:00"))
                                if isinstance(date_creation, datetime):
                                    jours_depuis_creation = (datetime.now(timezone.utc) - date_creation).days
                                    if jours_depuis_creation >= jours_frequence:
                                        inspection_due = True
                                        jours_depuis_derniere = jours_depuis_creation
                            except:
                                pass
                    
                    if inspection_due:
                        alertes_count["inspections_dues"] += 1
                        
                        if categorie_id not in alertes_par_categorie:
                            alertes_par_categorie[categorie_id] = {
                                "nom": categorie.get("nom", "Cat√©gorie inconnue"),
                                "icone": categorie.get("icone", "üì¶"),
                                "frequence": frequence,
                                "count": 0,
                                # Support pour plusieurs personnes ressources
                                "personnes_ressources": categorie.get("personnes_ressources", []),
                                # Anciens champs pour compatibilit√©
                                "personne_ressource_email": categorie.get("personne_ressource_email", ""),
                                "personne_ressource_id": categorie.get("personne_ressource_id", ""),
                                "equipements": []
                            }
                        
                        alertes_par_categorie[categorie_id]["count"] += 1
                        alertes_par_categorie[categorie_id]["equipements"].append({
                            "nom": eq.get("nom", eq.get("numero_serie", "√âquipement")),
                            "jours_retard": jours_depuis_derniere
                        })
                
                # Calculer le total des alertes
                total_alertes = sum(alertes_count.values())
                
                # Si aucune alerte, ne pas envoyer d'email
                if total_alertes == 0:
                    logging.info(f"‚úÖ Aucune alerte pour {tenant_nom}")
                    continue
                
                logging.info(f"üìä {tenant_nom}: {total_alertes} alertes trouv√©es - Maintenance: {alertes_count['maintenance']}, Expiration: {alertes_count['expiration']}, Fin de vie: {alertes_count['fin_vie']}, R√©paration: {alertes_count['reparation']}, Inspections dues: {alertes_count['inspections_dues']}")
                
                # G√©n√©rer le HTML pour les inspections dues par cat√©gorie
                inspections_dues_html = ""
                if alertes_count["inspections_dues"] > 0:
                    inspections_dues_html = f'''
                        <div class="alert-box" style="border-left-color: #F59E0B; background-color: #FEF3C7;">
                            <div class="alert-title" style="color: #B45309;">üìã Inspections √† effectuer</div>
                            <div class="alert-count" style="color: #92400E;">{alertes_count["inspections_dues"]} √©quipement(s)</div>
                            <p>Selon la fr√©quence d'inspection de leur cat√©gorie</p>
                            <div style="margin-top: 15px;">
                    '''
                    for cat_id, cat_data in alertes_par_categorie.items():
                        inspections_dues_html += f'''
                                <div style="background: white; padding: 10px; border-radius: 8px; margin: 8px 0;">
                                    <strong>{cat_data["icone"]} {cat_data["nom"]}</strong> - {cat_data["count"]} √©quipement(s)
                                    <br><small style="color: #666;">Fr√©quence: {cat_data["frequence"]}</small>
                                    <ul style="margin: 5px 0; padding-left: 20px; font-size: 0.9em;">
                        '''
                        for eq in cat_data["equipements"][:5]:  # Limiter √† 5 √©quipements par cat√©gorie
                            retard_text = f" ({eq['jours_retard']} jours de retard)" if eq.get('jours_retard') else ""
                            inspections_dues_html += f"<li>{eq['nom']}{retard_text}</li>"
                        if len(cat_data["equipements"]) > 5:
                            inspections_dues_html += f"<li><em>... et {len(cat_data['equipements']) - 5} autre(s)</em></li>"
                        inspections_dues_html += "</ul></div>"
                    inspections_dues_html += "</div></div>"
                
                # Pr√©parer le contenu de l'email
                subject = f"‚ö†Ô∏è Alertes √âquipements - {tenant_nom}"
                
                html_content = f"""
                <html>
                <head>
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                        .header {{ background-color: #EF4444; color: white; padding: 20px; text-align: center; }}
                        .content {{ padding: 20px; }}
                        .alert-box {{ 
                            border-left: 4px solid #EF4444;
                            background-color: #FEE2E2;
                            padding: 15px;
                            margin: 15px 0;
                        }}
                        .alert-title {{ font-weight: bold; color: #DC2626; margin-bottom: 10px; }}
                        .alert-count {{ font-size: 24px; font-weight: bold; color: #991B1B; }}
                        .footer {{ margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 12px; }}
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>‚ö†Ô∏è Rapport d'Alertes √âquipements</h1>
                        <p>{tenant_nom}</p>
                        <p>{today.strftime("%d/%m/%Y")}</p>
                    </div>
                    <div class="content">
                        <p>Bonjour,</p>
                        <p>Voici le rapport quotidien des alertes pour vos √©quipements :</p>
                        
                        {f'''
                        <div class="alert-box">
                            <div class="alert-title">üîß Maintenance √† venir</div>
                            <div class="alert-count">{alertes_count["maintenance"]} √©quipement(s)</div>
                            <p>Maintenance requise dans les {jours_maintenance} prochains jours</p>
                        </div>
                        ''' if alertes_count["maintenance"] > 0 else ''}
                        
                        {f'''
                        <div class="alert-box">
                            <div class="alert-title">‚è∞ Expirations √† venir</div>
                            <div class="alert-count">{alertes_count["expiration"]} √©quipement(s)</div>
                            <p>Expiration dans les {jours_expiration} prochains jours</p>
                        </div>
                        ''' if alertes_count["expiration"] > 0 else ''}
                        
                        {f'''
                        <div class="alert-box">
                            <div class="alert-title">üö® Fin de vie approche</div>
                            <div class="alert-count">{alertes_count["fin_vie"]} √©quipement(s)</div>
                            <p>Fin de vie dans les {jours_fin_vie} prochains jours</p>
                        </div>
                        ''' if alertes_count["fin_vie"] > 0 else ''}
                        
                        {f'''
                        <div class="alert-box">
                            <div class="alert-title">üî® R√©parations n√©cessaires</div>
                            <div class="alert-count">{alertes_count["reparation"]} √©quipement(s)</div>
                            <p>√âquipements en attente de r√©paration</p>
                        </div>
                        ''' if alertes_count["reparation"] > 0 else ''}
                        
                        {inspections_dues_html}
                        
                        <p style="margin-top: 30px;">
                            <strong>Total des alertes : {total_alertes}</strong>
                        </p>
                        
                        <p style="margin-top: 20px;">
                            Connectez-vous √† votre tableau de bord pour plus de d√©tails et pour g√©rer ces √©quipements.
                        </p>
                    </div>
                    <div class="footer">
                        <p>Cet email a √©t√© envoy√© automatiquement par le syst√®me ProFireManager.</p>
                        <p>Pour modifier vos pr√©f√©rences de notifications, acc√©dez aux param√®tres du module Mat√©riel & √âquipements.</p>
                    </div>
                </body>
                </html>
                """
                
                # Envoyer l'email au r√©sum√© g√©n√©ral (si des destinataires configur√©s)
                resend.api_key = os.environ.get("RESEND_API_KEY")
                sender_email = os.environ.get("SENDER_EMAIL", "noreply@profiremanager.ca")
                
                for email in emails_destinataires:
                    try:
                        params = {
                            "from": sender_email,
                            "to": [email],
                            "subject": subject,
                            "html": html_content
                        }
                        
                        email_response = resend.Emails.send(params)
                        logging.info(f"üìß Email envoy√© √† {email} pour {tenant_nom} - ID: {email_response.get('id', 'N/A')}")
                    
                    except Exception as e:
                        logging.error(f"‚ùå Erreur envoi email √† {email} pour {tenant_nom}: {str(e)}")
                
                # =============================================
                # Envoyer emails √† TOUTES les personnes ressources de chaque cat√©gorie
                # =============================================
                emails_deja_envoyes = set(emails_destinataires)  # √âviter les doublons
                
                for cat_id, cat_data in alertes_par_categorie.items():
                    # Collecter tous les emails des personnes ressources
                    emails_pr = []
                    
                    # Nouveau format: tableau personnes_ressources
                    for pr in cat_data.get("personnes_ressources", []):
                        if pr.get("email") and pr.get("email") not in emails_deja_envoyes:
                            emails_pr.append(pr.get("email"))
                    
                    # Ancien format: personne_ressource_email (pour compatibilit√©)
                    ancien_email = cat_data.get("personne_ressource_email", "")
                    if ancien_email and ancien_email not in emails_deja_envoyes and ancien_email not in emails_pr:
                        emails_pr.append(ancien_email)
                    
                    if not emails_pr:
                        continue
                    
                    # Pr√©parer l'email pour les personnes ressources
                    subject_pr = f"üìã Inspections dues - {cat_data['nom']} - {tenant_nom}"
                    
                    equipements_list_html = "".join([
                        f"<li><strong>{eq['nom']}</strong> - {eq.get('jours_retard', 'N/A')} jours depuis derni√®re inspection</li>"
                        for eq in cat_data["equipements"]
                    ])
                    
                    html_pr = f"""
                    <html>
                    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                        <div style="background: linear-gradient(135deg, #F59E0B, #D97706); color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0;">
                            <h2>{cat_data['icone']} Inspections dues - {cat_data['nom']}</h2>
                        </div>
                        <div style="padding: 20px; background: #FFFBEB; border: 1px solid #F59E0B; border-radius: 0 0 8px 8px;">
                            <p>Bonjour,</p>
                            <p>En tant que personne ressource pour la cat√©gorie <strong>{cat_data['nom']}</strong>, vous √™tes notifi√©(e) que <strong>{cat_data['count']} √©quipement(s)</strong> n√©cessitent une inspection.</p>
                            
                            <p><strong>Fr√©quence d'inspection :</strong> {cat_data['frequence']}</p>
                            
                            <h4>√âquipements concern√©s :</h4>
                            <ul style="background: white; padding: 15px 30px; border-radius: 8px; border: 1px solid #E5E7EB;">
                                {equipements_list_html}
                            </ul>
                            
                            <p style="margin-top: 20px;">
                                Connectez-vous √† ProFireManager pour effectuer ces inspections.
                            </p>
                        </div>
                        <p style="color: #666; font-size: 12px; margin-top: 20px;">
                            Cet email a √©t√© envoy√© automatiquement. Vous recevez ce message car vous √™tes d√©sign√© comme personne ressource.
                        </p>
                    </body>
                    </html>
                    """
                    
                    # Envoyer √† chaque personne ressource
                    for email_pr in emails_pr:
                        try:
                            params_pr = {
                                "from": sender_email,
                                "to": [email_pr],
                                "subject": subject_pr,
                                "html": html_pr
                            }
                            
                            email_response_pr = resend.Emails.send(params_pr)
                            logging.info(f"üìß Email personne ressource envoy√© √† {email_pr} pour {cat_data['nom']} - ID: {email_response_pr.get('id', 'N/A')}")
                            emails_deja_envoyes.add(email_pr)  # Marquer comme envoy√©
                        
                        except Exception as e:
                            logging.error(f"‚ùå Erreur envoi email personne ressource {email_pr}: {str(e)}")
                
                logging.info(f"‚úÖ Notifications d'alertes envoy√©es pour {tenant_nom}")
                
            except Exception as e:
                logging.error(f"‚ùå Erreur traitement alertes pour {tenant.get('nom', 'Unknown')}: {str(e)}", exc_info=True)
        
        logging.info("‚úÖ V√©rification des alertes d'√©quipements termin√©e")
        
    except Exception as e:
        logging.error(f"‚ùå Erreur dans job_verifier_alertes_equipements: {str(e)}", exc_info=True)


async def job_verifier_rappels_disponibilites():
    """
    Job qui v√©rifie les rappels de disponibilit√©s pour les employ√©s temps partiel
    S'ex√©cute tous les jours √† 9h00 du matin
    
    Logique:
    - Pour chaque tenant, lire les param√®tres de disponibilit√©s
    - Si notifications actives, v√©rifier si on est X jours avant la date de blocage
    - Identifier les employ√©s temps partiel qui n'ont pas soumis leurs disponibilit√©s pour le mois suivant
    - Envoyer des notifications (in-app, push, email) de rappel
    """
    try:
        logging.info("üîç V√©rification des rappels de disponibilit√©s pour tous les tenants")
        
        # Date du jour
        today = datetime.now(timezone.utc).date()
        current_day = today.day
        current_month = today.month
        current_year = today.year
        
        # Calculer le mois suivant
        if current_month == 12:
            next_month = 1
            next_month_year = current_year + 1
        else:
            next_month = current_month + 1
            next_month_year = current_year
        
        # R√©cup√©rer tous les tenants actifs
        tenants = await db.tenants.find({"actif": True}).to_list(None)
        
        for tenant in tenants:
            try:
                tenant_id = tenant.get("id")
                tenant_nom = tenant.get("nom", "Unknown")
                
                # R√©cup√©rer les param√®tres de disponibilit√©s
                params = await db.parametres_disponibilites.find_one({"tenant_id": tenant_id})
                
                if not params:
                    logging.info(f"‚è≠Ô∏è Pas de param√®tres de disponibilit√©s pour {tenant_nom}")
                    continue
                
                # V√©rifier si le blocage et les notifications sont actifs
                blocage_actif = params.get("blocage_dispos_active", False)
                notifications_actives = params.get("notifications_dispos_actives", True)
                
                if not blocage_actif:
                    logging.info(f"‚è≠Ô∏è Blocage des disponibilit√©s d√©sactiv√© pour {tenant_nom}")
                    continue
                
                if not notifications_actives:
                    logging.info(f"‚è≠Ô∏è Notifications de disponibilit√©s d√©sactiv√©es pour {tenant_nom}")
                    continue
                
                # R√©cup√©rer les seuils
                jour_blocage = params.get("jour_blocage_dispos", 15)
                jours_avance = params.get("jours_avance_notification", 3)
                
                # Calculer la date de blocage (jour X du mois courant pour le mois suivant)
                date_blocage = date(current_year, current_month, jour_blocage)
                
                # Calculer si on est dans la p√©riode de rappel (X jours avant le blocage)
                jours_restants = (date_blocage - today).days
                
                if jours_restants > jours_avance or jours_restants < 0:
                    logging.info(f"‚è≠Ô∏è Pas dans la p√©riode de rappel pour {tenant_nom} (jours restants: {jours_restants})")
                    continue
                
                logging.info(f"üìß P√©riode de rappel active pour {tenant_nom} - {jours_restants} jour(s) avant blocage")
                
                # V√©rifier si un rappel a d√©j√† √©t√© envoy√© aujourd'hui
                dernier_rappel = params.get("dernier_rappel_disponibilites")
                if dernier_rappel:
                    try:
                        derniere_date = datetime.fromisoformat(dernier_rappel).date()
                        if derniere_date == today:
                            logging.info(f"‚è≠Ô∏è Rappel d√©j√† envoy√© aujourd'hui pour {tenant_nom}")
                            continue
                    except:
                        pass
                
                # R√©cup√©rer les employ√©s temps partiel actifs
                users_temps_partiel = await db.users.find({
                    "tenant_id": tenant_id,
                    "type_emploi": "temps_partiel",
                    "statut": "actif"
                }).to_list(None)
                
                if not users_temps_partiel:
                    logging.info(f"‚è≠Ô∏è Aucun employ√© temps partiel pour {tenant_nom}")
                    continue
                
                # P√©riode du mois suivant pour v√©rifier les disponibilit√©s
                periode_debut = f"{next_month_year}-{str(next_month).zfill(2)}-01"
                # Dernier jour du mois suivant
                if next_month == 12:
                    dernier_jour = date(next_month_year + 1, 1, 1) - timedelta(days=1)
                else:
                    dernier_jour = date(next_month_year, next_month + 1, 1) - timedelta(days=1)
                periode_fin = dernier_jour.isoformat()
                
                # Identifier les employ√©s qui n'ont pas soumis de disponibilit√©s pour le mois suivant
                users_a_notifier = []
                
                for user in users_temps_partiel:
                    user_id = user.get("id")
                    
                    # V√©rifier s'il a des disponibilit√©s pour le mois suivant
                    disponibilites_count = await db.disponibilites.count_documents({
                        "user_id": user_id,
                        "tenant_id": tenant_id,
                        "date": {
                            "$gte": periode_debut,
                            "$lte": periode_fin
                        }
                    })
                    
                    if disponibilites_count == 0:
                        users_a_notifier.append(user)
                
                if not users_a_notifier:
                    logging.info(f"‚úÖ Tous les employ√©s de {tenant_nom} ont soumis leurs disponibilit√©s")
                    # Mettre √† jour la date du dernier rappel
                    await db.parametres_disponibilites.update_one(
                        {"tenant_id": tenant_id},
                        {"$set": {"dernier_rappel_disponibilites": datetime.now(timezone.utc).isoformat()}}
                    )
                    continue
                
                logging.info(f"üì§ {len(users_a_notifier)} employ√©(s) √† notifier pour {tenant_nom}")
                
                # Pr√©parer le message de rappel
                mois_suivant_texte = ["janvier", "f√©vrier", "mars", "avril", "mai", "juin", 
                                      "juillet", "ao√ªt", "septembre", "octobre", "novembre", "d√©cembre"][next_month - 1]
                
                titre_notification = "üìÖ Rappel: Saisissez vos disponibilit√©s"
                message_notification = f"Vous avez jusqu'au {jour_blocage} {['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'][current_month - 1]} pour saisir vos disponibilit√©s de {mois_suivant_texte}. Il vous reste {jours_restants} jour(s)."
                
                # R√©cup√©rer la config Resend pour les emails
                resend_api_key = os.environ.get("RESEND_API_KEY")
                sender_email = os.environ.get("RESEND_FROM_EMAIL", "noreply@resend.dev")
                app_url = os.environ.get("FRONTEND_URL", os.environ.get("REACT_APP_BACKEND_URL", ""))
                
                for user in users_a_notifier:
                    user_id = user.get("id")
                    user_email = user.get("email")
                    user_prenom = user.get("prenom", "")
                    user_nom = user.get("nom", "")
                    
                    # 1. Cr√©er notification in-app
                    await db.notifications.insert_one({
                        "id": str(uuid.uuid4()),
                        "tenant_id": tenant_id,
                        "user_id": user_id,
                        "type": "rappel_disponibilites",
                        "titre": titre_notification,
                        "message": message_notification,
                        "lu": False,
                        "urgent": jours_restants <= 1,  # Urgent si dernier jour
                        "data": {
                            "lien": "/disponibilites",
                            "mois_cible": f"{next_month_year}-{str(next_month).zfill(2)}"
                        },
                        "created_at": datetime.now(timezone.utc).isoformat()
                    })
                    
                    # 2. Envoyer notification push
                    try:
                        await send_push_notification_to_users(
                            user_ids=[user_id],
                            title=titre_notification,
                            body=message_notification,
                            data={
                                "type": "rappel_disponibilites",
                                "lien": "/disponibilites",
                                "sound": "default" if jours_restants > 1 else "urgent"
                            }
                        )
                    except Exception as e:
                        logging.warning(f"‚ö†Ô∏è Erreur push pour {user_prenom} {user_nom}: {str(e)}")
                    
                    # 3. Envoyer email si configur√©
                    if resend_api_key and user_email:
                        try:
                            resend.api_key = resend_api_key
                            
                            html_content = f"""
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <meta charset="utf-8">
                                <style>
                                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                                    .header {{ background-color: #1E40AF; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }}
                                    .content {{ background-color: #f8f9fa; padding: 30px; border-radius: 0 0 8px 8px; }}
                                    .alert {{ background-color: {'#FEF3C7' if jours_restants > 1 else '#FEE2E2'}; border-left: 4px solid {'#F59E0B' if jours_restants > 1 else '#EF4444'}; padding: 15px; margin: 20px 0; }}
                                    .btn {{ display: inline-block; background-color: #1E40AF; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin-top: 20px; }}
                                    .footer {{ text-align: center; padding: 20px; color: #666; font-size: 12px; }}
                                </style>
                            </head>
                            <body>
                                <div class="container">
                                    <div class="header">
                                        <h1>üìÖ Rappel Disponibilit√©s</h1>
                                    </div>
                                    <div class="content">
                                        <p>Bonjour {user_prenom},</p>
                                        
                                        <div class="alert">
                                            <strong>{'‚ö†Ô∏è Attention' if jours_restants <= 1 else 'üì¢ Rappel'}</strong><br>
                                            Vous n'avez pas encore saisi vos disponibilit√©s pour le mois de <strong>{mois_suivant_texte} {next_month_year}</strong>.
                                        </div>
                                        
                                        <p>La date limite de saisie est le <strong>{jour_blocage} {['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'][current_month - 1]}</strong>.</p>
                                        
                                        <p>Il vous reste <strong>{jours_restants} jour(s)</strong> pour soumettre vos disponibilit√©s. Pass√© cette date, vous ne pourrez plus modifier vos disponibilit√©s pour {mois_suivant_texte}.</p>
                                        
                                        <center>
                                            <a href="{app_url}/disponibilites" class="btn">Saisir mes disponibilit√©s</a>
                                        </center>
                                        
                                        <p style="margin-top: 30px;">Cordialement,<br>L'√©quipe {tenant_nom}</p>
                                    </div>
                                    <div class="footer">
                                        <p>Ceci est un message automatique. Merci de ne pas y r√©pondre.</p>
                                    </div>
                                </div>
                            </body>
                            </html>
                            """
                            
                            params = {
                                "from": f"{tenant_nom} <{sender_email}>",
                                "to": [user_email],
                                "subject": f"{'‚ö†Ô∏è URGENT: ' if jours_restants <= 1 else ''}Rappel - Saisissez vos disponibilit√©s pour {mois_suivant_texte}",
                                "html": html_content
                            }
                            
                            resend.Emails.send(params)
                            logging.info(f"‚úÖ Email de rappel envoy√© √† {user_email}")
                            
                        except Exception as e:
                            logging.warning(f"‚ö†Ô∏è Erreur email pour {user_email}: {str(e)}")
                
                # Mettre √† jour la date du dernier rappel
                await db.parametres_disponibilites.update_one(
                    {"tenant_id": tenant_id},
                    {"$set": {"dernier_rappel_disponibilites": datetime.now(timezone.utc).isoformat()}}
                )
                
                logging.info(f"‚úÖ Rappels de disponibilit√©s envoy√©s pour {tenant_nom} ({len(users_a_notifier)} employ√©(s))")
                
            except Exception as e:
                logging.error(f"‚ùå Erreur traitement rappels pour {tenant.get('nom', 'Unknown')}: {str(e)}", exc_info=True)
        
        logging.info("‚úÖ V√©rification des rappels de disponibilit√©s termin√©e")
        
    except Exception as e:
        logging.error(f"‚ùå Erreur dans job_verifier_rappels_disponibilites: {str(e)}", exc_info=True)


async def envoyer_notifications_planning_automatique(tenant: dict, periode_debut: str, periode_fin: str):
    """Envoie les notifications de planning (version automatique sans auth)"""
    try:
        # R√©cup√©rer les assignations de la p√©riode
        assignations = await db.assignations.find({
            "tenant_id": tenant["id"],
            "date": {
                "$gte": periode_debut,
                "$lte": periode_fin
            }
        }).to_list(None)
        
        if not assignations:
            logging.info(f"Aucune assignation trouv√©e pour {tenant['nom']} p√©riode {periode_debut} - {periode_fin}")
            return
        
        # Grouper par pompier
        gardes_par_pompier = {}
        for assignation in assignations:
            user_id = assignation["user_id"]
            if user_id not in gardes_par_pompier:
                gardes_par_pompier[user_id] = []
            gardes_par_pompier[user_id].append(assignation)
        
        # R√©cup√©rer infos users et types garde
        users = await db.users.find({"tenant_id": tenant["id"]}).to_list(None)
        types_garde = await db.types_garde.find({"tenant_id": tenant["id"]}).to_list(None)
        
        user_map = {u["id"]: u for u in users}
        type_garde_map = {t["id"]: t for t in types_garde}
        
        # Envoyer email √† chaque pompier
        emails_envoyes = 0
        for user_id, gardes in gardes_par_pompier.items():
            user = user_map.get(user_id)
            if not user or not user.get("email"):
                continue
            
            # Pr√©parer liste des gardes avec d√©tails
            gardes_list = []
            for garde in gardes:
                type_g = type_garde_map.get(garde["type_garde_id"], {})
                
                # Trouver coll√®gues sur m√™me garde
                collegues_meme_garde = [
                    a for a in assignations 
                    if a["date"] == garde["date"] 
                    and a["type_garde_id"] == garde["type_garde_id"]
                    and a["user_id"] != user_id
                ]
                
                collegues_noms = []
                for coll in collegues_meme_garde:
                    coll_user = user_map.get(coll["user_id"])
                    if coll_user:
                        collegues_noms.append(f"{coll_user.get('prenom', '')} {coll_user.get('nom', '')}")
                
                gardes_list.append({
                    "date": garde["date"],
                    "type_garde": type_g.get("nom", "Garde"),
                    "collegues": collegues_noms
                })
            
            # Trier par date
            gardes_list.sort(key=lambda x: x["date"])
            
            # Envoyer email
            try:
                send_gardes_notification_email(
                    user_email=user["email"],
                    user_name=f"{user.get('prenom', '')} {user.get('nom', '')}",
                    gardes_list=gardes_list,
                    tenant_slug=tenant["slug"],
                    periode=f"{periode_debut} au {periode_fin}"
                )
                emails_envoyes += 1
            except Exception as e:
                logging.error(f"Erreur envoi email √† {user.get('email')}: {str(e)}")
        
        logging.info(f"‚úÖ {emails_envoyes} emails envoy√©s pour {tenant['nom']}")
        
    except Exception as e:
        logging.error(f"Erreur dans envoyer_notifications_planning_automatique: {str(e)}", exc_info=True)
        raise

async def job_verifier_timeouts_remplacements():
    """
    Job p√©riodique qui v√©rifie les timeouts des demandes de remplacement
    S'ex√©cute toutes les minutes
    """
    while True:
        try:
            await asyncio.sleep(60)  # Attendre 60 secondes
            await verifier_et_traiter_timeouts()
        except Exception as e:
            logging.error(f"‚ùå Erreur dans le job de v√©rification des timeouts: {e}", exc_info=True)
            await asyncio.sleep(60)  # Attendre avant de r√©essayer m√™me en cas d'erreur

# JWT and Password configuration
SECRET_KEY = os.environ.get("JWT_SECRET", "your-secret-key-here")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 24 * 60  # 24 hours pour utilisateurs normaux
SUPER_ADMIN_TOKEN_EXPIRE_MINUTES = 2 * 60  # 2 heures pour super-admins (s√©curit√©)

# Super Admin credentials
SUPER_ADMIN_EMAIL = "gussdub@icloud.com"
SUPER_ADMIN_PASSWORD_HASH = ""  # Will be set on first run

# Simplified password hashing

# ==================== HELPER FUNCTIONS ====================

# Helper functions
def validate_complex_password(password: str) -> bool:
    """
    Valide qu'un mot de passe respecte les crit√®res de complexit√© :
    - 8 caract√®res minimum
    - 1 majuscule
    - 1 chiffre  
    - 1 caract√®re sp√©cial (!@#$%^&*+-?())
    """
    if len(password) < 8:
        return False
    
    has_uppercase = bool(re.search(r'[A-Z]', password))
    has_digit = bool(re.search(r'\d', password))
    has_special = bool(re.search(r'[!@#$%^&*+\-?()]', password))
    
    return has_uppercase and has_digit and has_special


def normalize_string_for_matching(s: str) -> str:
    """
    Normalise une cha√Æne pour le matching intelligent :
    - Enl√®ve les accents (√© ‚Üí e, √† ‚Üí a, etc.)
    - Convertit en minuscules
    - Strip les espaces
    - Remplace les tirets par des espaces (Jean-Pierre ‚Üí Jean Pierre)
    - Normalise les espaces multiples en un seul espace
    
    Utilis√© pour matcher des noms/pr√©noms de fa√ßon flexible dans les imports CSV.
    
    Exemple:
        "S√©bastien BERNARD" ‚Üí "sebastien bernard"
        "Dupont Jean-Pierre" ‚Üí "dupont jean pierre"
        "Jean  Fran√ßois" ‚Üí "jean francois"
    """
    import unicodedata
    import re
    
    # Enlever les accents (NFD = d√©compose, puis filtre les marques diacritiques)
    s = ''.join(c for c in unicodedata.normalize('NFD', s) 
                if unicodedata.category(c) != 'Mn')
    
    # Minuscules
    s = s.lower()
    
    # Remplacer les tirets par des espaces pour le matching flexible
    s = s.replace('-', ' ')
    
    # Normaliser les espaces multiples en un seul espace
    s = re.sub(r'\s+', ' ', s)
    
    # Strip
    return s.strip()


def create_user_matching_index(users_list: list) -> dict:
    """
    Cr√©e un index de matching pour recherche rapide d'utilisateurs.
    
    G√®re automatiquement :
    - Ordre normal (Pr√©nom Nom)
    - Ordre invers√© (Nom Pr√©nom)
    - Normalisation (accents, casse)
    
    Args:
        users_list: Liste d'utilisateurs avec 'prenom' et 'nom'
    
    Returns:
        dict: Index {nom_normalis√©: user_object}
        
    Exemple:
        users = [{"prenom": "S√©bastien", "nom": "Bernard"}]
        index = create_user_matching_index(users)
        # index["sebastien bernard"] ‚Üí user
        # index["bernard sebastien"] ‚Üí user (ordre invers√© aussi)
    """
    index = {}
    for user in users_list:
        prenom = user.get('prenom', '').strip()
        nom = user.get('nom', '').strip()
        
        if prenom and nom:
            # Index 1: Pr√©nom Nom (ordre normal)
            key1 = normalize_string_for_matching(f"{prenom} {nom}")
            index[key1] = user
            
            # Index 2: Nom Pr√©nom (ordre invers√©)
            key2 = normalize_string_for_matching(f"{nom} {prenom}")
            index[key2] = user
    
    return index


def calculate_name_similarity(str1: str, str2: str) -> float:
    """
    Calcule un score de similarit√© entre deux cha√Ænes normalis√©es.
    Retourne un score entre 0 (pas de correspondance) et 1 (match parfait).
    
    Prend en compte :
    - Mots en commun
    - Ordre des mots
    - Longueur relative
    """
    words1 = set(str1.split())
    words2 = set(str2.split())
    
    if not words1 or not words2:
        return 0.0
    
    # Intersection : mots en commun
    common_words = words1.intersection(words2)
    
    # Score bas√© sur le ratio de mots en commun
    score = len(common_words) / max(len(words1), len(words2))
    
    # Bonus si tous les mots de la recherche sont dans le nom DB
    if words1.issubset(words2):
        score += 0.3
    elif words2.issubset(words1):
        score += 0.2
    
    return min(score, 1.0)


def find_user_intelligent(
    search_string: str, 
    users_by_name: dict, 
    users_by_num: dict = None,
    numero_field: str = "numero_employe"
) -> dict:
    """
    Recherche intelligente d'un utilisateur avec matching flexible et "best fit".
    
    Strat√©gie de recherche (par ordre de priorit√©) :
    1. Par num√©ro d'employ√© (si pr√©sent entre parenth√®ses et fiable)
    2. Par nom normalis√© exact (ordre normal ou invers√©)
    3. Par parsing approfondi (noms compos√©s)
    4. Par similarit√© (best fit) si aucun match exact
    
    Args:
        search_string: Cha√Æne de recherche (ex: "Bernard S√©bastien (981)")
        users_by_name: Index cr√©√© par create_user_matching_index()
        users_by_num: Index optionnel {numero: user}
        numero_field: Nom du champ contenant le num√©ro (d√©faut: "numero_employe")
    
    Returns:
        dict: User object si trouv√©, None sinon
        
    Exemples:
        find_user_intelligent("Bernard S√©bastien (981)", index)
        find_user_intelligent("BERNARD Sebastien", index)
        find_user_intelligent("Jean-Pierre Dubois", index)
        find_user_intelligent("William Falardeau Roy", index) ‚Üí trouve "William Falardeau-Roy"
    """
    if not search_string:
        return None
    
    # Extraire le nom sans le num√©ro entre parenth√®ses
    nom_complet = search_string.split("(")[0].strip()
    
    # Tentative 1: Par num√©ro d'employ√©
    if users_by_num and "(" in search_string and ")" in search_string:
        try:
            num = search_string.split("(")[1].split(")")[0].strip()
            if num and num in users_by_num:
                return users_by_num[num]
        except:
            pass
    
    # Tentative 2: Matching flexible par nom normalis√© EXACT
    if nom_complet:
        normalized = normalize_string_for_matching(nom_complet)
        if normalized in users_by_name:
            return users_by_name[normalized]
    
    # Tentative 3: Parsing approfondi pour noms compos√©s (essayer toutes les combinaisons)
    if nom_complet:
        parts = nom_complet.split()
        if len(parts) >= 2:
            # Essayer toutes les combinaisons de d√©coupage
            for i in range(len(parts)):
                possible_prenom = " ".join(parts[:i+1])
                possible_nom = " ".join(parts[i+1:])
                
                if possible_nom:
                    # Ordre normal
                    test_key = normalize_string_for_matching(f"{possible_prenom} {possible_nom}")
                    if test_key in users_by_name:
                        return users_by_name[test_key]
                    
                    # Ordre invers√©
                    test_key2 = normalize_string_for_matching(f"{possible_nom} {possible_prenom}")
                    if test_key2 in users_by_name:
                        return users_by_name[test_key2]
    
    # Tentative 4: BEST FIT - Recherche par similarit√© si aucun match exact
    # Calculer la similarit√© avec tous les utilisateurs et prendre le meilleur
    normalized = normalize_string_for_matching(nom_complet)
    
    best_match = None
    best_score = 0.6  # Seuil minimum de similarit√© (60%)
    
    for db_name_normalized, user in users_by_name.items():
        similarity = calculate_name_similarity(normalized, db_name_normalized)
        
        if similarity > best_score:
            best_score = similarity
            best_match = user
    
    if best_match:
        # Log pour debugging
        logging.info(f"‚ú® Best fit trouv√© pour '{nom_complet}': {best_match.get('prenom')} {best_match.get('nom')} (score: {best_score:.2f})")
        return best_match
    
    return None


def send_welcome_email(user_email: str, user_name: str, user_role: str, temp_password: str, tenant_slug: str = ""):
    """
    Envoie un email de bienvenue avec les informations de connexion
    tenant_slug: slug de la caserne pour construire l'URL d'acc√®s directe
    """
    try:
        # D√©finir les modules selon le r√¥le
        modules_by_role = {
            'admin': [
                "üìä Tableau de bord - Vue d'ensemble et statistiques",
                "üë• Personnel - Gestion compl√®te des pompiers", 
                "üìÖ Planning - Attribution automatique et manuelle",
                "üîÑ Remplacements - Validation des demandes",
                "üìö Formations - Inscription et gestion",
                "üìà Rapports - Analyses et exports",
                "‚öôÔ∏è Param√®tres - Configuration syst√®me",
                "üë§ Mon profil - Informations personnelles"
            ],
            'superviseur': [
                "üìä Tableau de bord - Vue d'ensemble et statistiques",
                "üë• Personnel - Consultation des pompiers",
                "üìÖ Planning - Gestion et validation", 
                "üîÑ Remplacements - Approbation des demandes",
                "üìö Formations - Inscription et gestion",
                "üë§ Mon profil - Informations personnelles"
            ],
            'employe': [
                "üìä Tableau de bord - Vue d'ensemble personnalis√©e",
                "üìÖ Planning - Consultation de votre planning",
                "üîÑ Remplacements - Demandes de remplacement",
                "üìö Formations - Inscription aux formations",
                "üë§ Mon profil - Informations et disponibilit√©s"
            ]
        }
        
        role_name = {
            'admin': 'Administrateur',
            'superviseur': 'Superviseur', 
            'employe': 'Employ√©'
        }.get(user_role, 'Utilisateur')
        
        user_modules = modules_by_role.get(user_role, modules_by_role['employe'])
        modules_html = ''.join([f'<li style="margin-bottom: 8px;">{module}</li>' for module in user_modules])
        
        subject = f"Bienvenue dans ProFireManager v2.0 - Votre compte {role_name}"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">Syst√®me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Votre compte <strong>{role_name}</strong> a √©t√© cr√©√© avec succ√®s dans ProFireManager v2.0, le syst√®me de gestion des horaires et remplacements automatis√©s pour les services d'incendie du Canada.</p>
                
                <p style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 12px; margin: 15px 0;">
                    üè¢ <strong>Votre caserne :</strong> {tenant_slug.title() if tenant_slug else 'Non sp√©cifi√©e'}
                </p>
                
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #dc2626; margin-top: 0;">üîë Informations de connexion :</h3>
                    <p><strong>Email :</strong> {user_email}</p>
                    <p><strong>Mot de passe temporaire :</strong> {temp_password}</p>
                    <p style="color: #dc2626; font-weight: bold;">‚ö†Ô∏è Veuillez modifier votre mot de passe lors de votre premi√®re connexion</p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="https://www.profiremanager.ca/{tenant_slug}" 
                       style="background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
                        üöí Acc√©der √† ProFireManager
                    </a>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        üí° Conseil : Ajoutez ce lien √† vos favoris pour un acc√®s rapide √† votre caserne
                    </p>
                </div>
                
                <h3 style="color: #1e293b;">üìã Modules disponibles pour votre r√¥le ({role_name}) :</h3>
                <ul style="background: #f0fdf4; border-left: 4px solid #10b981; padding: 15px 20px; margin: 15px 0;">
                    {modules_html}
                </ul>
                
                <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #92400e; margin-top: 0;">üîí S√©curit√© de votre compte :</h4>
                    <p style="color: #92400e; font-weight: bold; margin: 10px 0;">
                        ‚ö†Ô∏è IMPORTANT : Changez votre mot de passe temporaire d√®s maintenant !
                    </p>
                    <p style="color: #78350f; margin: 10px 0;">
                        <strong>üìç Comment changer votre mot de passe :</strong>
                    </p>
                    <ol style="color: #78350f; margin: 10px 0;">
                        <li>Connectez-vous √† ProFireManager avec le mot de passe temporaire ci-dessus</li>
                        <li>Cliquez sur <strong>"Mon Profil"</strong> dans le menu de gauche</li>
                        <li>Descendez en <strong>bas de la page</strong></li>
                        <li>Trouvez la section <strong>"Modifier le mot de passe"</strong></li>
                        <li>Entrez votre nouveau mot de passe (8 caract√®res min, 1 majuscule, 1 chiffre, 1 caract√®re sp√©cial)</li>
                        <li>Cliquez sur <strong>"Enregistrer"</strong></li>
                    </ol>
                    <p style="color: #78350f; margin: 10px 0;">
                        üí° <strong>Conseils de s√©curit√© :</strong>
                    </p>
                    <ul style="color: #78350f; margin: 10px 0;">
                        <li>Utilisez un mot de passe unique et complexe</li>
                        <li>Ne partagez jamais vos identifiants</li>
                        <li>D√©connectez-vous apr√®s chaque session</li>
                    </ul>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a √©t√© envoy√© automatiquement par ProFireManager v2.0.<br>
                    Si vous avez des questions, contactez votre administrateur syst√®me.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - Syst√®me de gestion des services d'incendie du Canada<br>
                        D√©velopp√© pour optimiser la gestion des horaires et remplacements automatis√©s
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configur√©e - Email non envoy√© √† {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"‚úÖ Email de bienvenue envoy√© avec succ√®s √† {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"‚ö†Ô∏è Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi de l'email √† {user_email}: {str(e)}")
        return False


def send_temporary_password_email(user_email: str, user_name: str, temp_password: str, tenant_slug: str = ""):
    """
    Envoie un email avec le mot de passe temporaire suite √† une r√©initialisation par l'administrateur
    """
    try:
        subject = "R√©initialisation de votre mot de passe - ProFireManager"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">Syst√®me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Suite √† votre demande, votre mot de passe a √©t√© r√©initialis√© par un administrateur.</p>
                
                <div style="background: #fef3c7; border: 2px solid #fcd34d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #92400e; margin-top: 0;">‚ö†Ô∏è IMPORTANT - S√©curit√© de votre compte</h3>
                    <p style="color: #92400e; font-weight: bold; margin: 10px 0;">
                        Si vous n'avez jamais demand√© ce changement, veuillez communiquer avec votre administrateur le plus rapidement possible.
                    </p>
                </div>
                
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #dc2626; margin-top: 0;">üîë Votre nouveau mot de passe temporaire :</h3>
                    <p style="background: white; padding: 12px; border: 2px dashed #dc2626; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; text-align: center;">
                        {temp_password}
                    </p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="https://www.profiremanager.ca/{tenant_slug}" 
                       style="background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
                        üöí Se connecter √† ProFireManager
                    </a>
                </div>
                
                <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #1e3a8a; margin-top: 0;">üìç Proc√©dure pour changer votre mot de passe :</h4>
                    <ol style="color: #1e3a8a; margin: 10px 0;">
                        <li>Connectez-vous √† ProFireManager avec le mot de passe temporaire ci-dessus</li>
                        <li>Cliquez sur <strong>"Mon Profil"</strong> dans le menu de gauche</li>
                        <li>Descendez en <strong>bas de la page</strong></li>
                        <li>Trouvez la section <strong>"Modifier le mot de passe"</strong></li>
                        <li>Entrez votre <strong>mot de passe actuel</strong> (le mot de passe temporaire)</li>
                        <li>Entrez votre <strong>nouveau mot de passe</strong> (8 caract√®res min, 1 majuscule, 1 chiffre, 1 caract√®re sp√©cial)</li>
                        <li>Confirmez votre nouveau mot de passe</li>
                        <li>Cliquez sur <strong>"Enregistrer les modifications"</strong></li>
                    </ol>
                    <p style="color: #1e3a8a; margin: 10px 0;">
                        üí° <strong>Conseils de s√©curit√© :</strong>
                    </p>
                    <ul style="color: #1e3a8a; margin: 10px 0;">
                        <li>Utilisez un mot de passe unique et complexe</li>
                        <li>Ne partagez jamais vos identifiants</li>
                        <li>D√©connectez-vous apr√®s chaque session</li>
                        <li>Changez votre mot de passe imm√©diatement</li>
                    </ul>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a √©t√© envoy√© automatiquement par ProFireManager v2.0.<br>
                    Si vous avez des questions, contactez votre administrateur syst√®me.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - Syst√®me de gestion des services d'incendie du Canada<br>
                        D√©velopp√© pour optimiser la gestion des horaires et remplacements automatis√©s
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configur√©e - Email non envoy√© √† {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"‚úÖ Email de r√©initialisation envoy√© avec succ√®s √† {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"‚ö†Ô∏è Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi de l'email de r√©initialisation √† {user_email}: {str(e)}")
        return False


def send_password_reset_email(user_email: str, user_name: str, reset_token: str, tenant_slug: str = ""):
    """
    Envoie un email avec un lien pour r√©initialiser le mot de passe
    """
    try:
        frontend_url = os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')
        reset_link = f"{frontend_url}/{tenant_slug}/reset-password?token={reset_token}"
        
        subject = "R√©initialisation de votre mot de passe - ProFireManager"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">Syst√®me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Nous avons re√ßu une demande de r√©initialisation de mot de passe pour votre compte ProFireManager.</p>
                
                <div style="background: #fef3c7; border: 2px solid #fcd34d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #92400e; margin-top: 0;">‚ö†Ô∏è IMPORTANT - S√©curit√©</h3>
                    <p style="color: #92400e; font-weight: bold; margin: 10px 0;">
                        Si vous n'avez pas demand√© cette r√©initialisation, ignorez cet email. Votre mot de passe actuel reste inchang√©.
                    </p>
                    <p style="color: #78350f; margin: 10px 0;">
                        Ce lien est valide pendant <strong>1 heure</strong> seulement.
                    </p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{reset_link}" 
                       style="background: #dc2626; color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block; font-size: 16px;">
                        üîê R√©initialiser mon mot de passe
                    </a>
                </div>
                
                <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                    <p style="color: #1e3a8a; margin: 0; font-size: 14px;">
                        üí° <strong>Le lien ne fonctionne pas?</strong><br>
                        Copiez et collez cette adresse dans votre navigateur :<br>
                        <span style="font-family: 'Courier New', monospace; font-size: 12px; word-break: break-all;">{reset_link}</span>
                    </p>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a √©t√© envoy√© automatiquement par ProFireManager v2.0.<br>
                    Pour des questions de s√©curit√©, contactez votre administrateur.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - Syst√®me de gestion des services d'incendie du Canada
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configur√©e - Email non envoy√© √† {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"‚úÖ Email de r√©initialisation de mot de passe envoy√© avec succ√®s √† {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"‚ö†Ô∏è Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi de l'email de r√©initialisation √† {user_email}: {str(e)}")
        return False
        

def send_super_admin_welcome_email(user_email: str, user_name: str, temp_password: str):
    """
    Envoie un email de bienvenue √† un nouveau super admin
    """
    try:
        frontend_url = os.environ.get('FRONTEND_URL', 'https://www.profiremanager.ca')
        admin_url = f"{frontend_url}/admin"
        
        subject = "Bienvenue en tant que Super Admin - ProFireManager"
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <img src="https://customer-assets.emergentagent.com/job_fireshift-manager/artifacts/6vh2i9cz_05_Icone_Flamme_Rouge_Bordure_D9072B_VISIBLE.png" 
                         alt="ProFireManager" 
                         width="60" 
                         height="60"
                         style="width: 60px; height: 60px; margin-bottom: 15px; display: block; margin-left: auto; margin-right: auto;">
                    <h1 style="color: #dc2626; margin: 0;">ProFireManager v2.0</h1>
                    <p style="color: #666; margin: 5px 0;">Syst√®me de gestion des services d'incendie</p>
                </div>
                
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Votre compte <strong>Super Administrateur</strong> a √©t√© cr√©√© avec succ√®s dans ProFireManager v2.0.</p>
                
                <div style="background: #fef3c7; border: 2px solid #fcd34d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #92400e; margin-top: 0;">üëë Privil√®ges de Super Admin</h3>
                    <p style="color: #92400e; margin: 10px 0;">
                        En tant que Super Admin, vous avez acc√®s √†:
                    </p>
                    <ul style="color: #78350f; margin: 10px 0;">
                        <li><strong>Tous les tenants/casernes</strong> de la plateforme</li>
                        <li><strong>Interface d'administration</strong> globale</li>
                        <li><strong>Gestion des autres super admins</strong></li>
                        <li><strong>Cr√©ation et configuration</strong> des tenants</li>
                        <li><strong>Statistiques</strong> multi-tenant</li>
                    </ul>
                </div>
                
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #dc2626; margin-top: 0;">üîë Informations de connexion :</h3>
                    <p><strong>Email :</strong> {user_email}</p>
                    <p><strong>Mot de passe temporaire :</strong> {temp_password}</p>
                    <p style="color: #dc2626; font-weight: bold;">‚ö†Ô∏è Veuillez modifier votre mot de passe lors de votre premi√®re connexion</p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{admin_url}" 
                       style="background: #dc2626; color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block; font-size: 16px;">
                        üëë Acc√©der √† l'interface Super Admin
                    </a>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        üí° Ajoutez ce lien √† vos favoris pour un acc√®s rapide
                    </p>
                </div>
                
                <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #1e40af; margin-top: 0;">üìã Fonctionnalit√©s disponibles :</h4>
                    <ul style="color: #1e40af; margin: 0;">
                        <li>Gestion multi-tenant (cr√©ation, √©dition, suppression)</li>
                        <li>Statistiques globales de la plateforme</li>
                        <li>Gestion des super administrateurs</li>
                        <li>Configuration des tenants</li>
                        <li>Surveillance des performances</li>
                    </ul>
                </div>
                
                <div style="background: #fee2e2; border: 2px solid #dc2626; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #991b1b; margin-top: 0;">üîí IMPORTANT - S√©curit√© :</h4>
                    <p style="color: #991b1b; font-weight: bold; margin: 10px 0;">
                        ‚ö†Ô∏è Changez votre mot de passe temporaire IMM√âDIATEMENT !
                    </p>
                    <p style="color: #7f1d1d; margin: 10px 0;">
                        En tant que Super Admin, vous avez un acc√®s complet au syst√®me. Utilisez des mots de passe forts et ne partagez jamais vos identifiants.
                    </p>
                </div>
                
                <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 30px 0;">
                
                <p style="color: #666; font-size: 14px; text-align: center;">
                    Cet email a √©t√© envoy√© automatiquement par ProFireManager v2.0.<br>
                    Si vous n'avez pas demand√© ce compte, contactez imm√©diatement l'administrateur syst√®me.
                </p>
                
                <div style="text-align: center; margin-top: 20px;">
                    <p style="color: #999; font-size: 12px;">
                        ProFireManager v2.0 - Syst√®me de gestion des services d'incendie du Canada
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Envoyer l'email via Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configur√©e - Email non envoy√© √† {user_email}")
            return False
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        try:
            params = {
                "from": f"ProFireManager <{sender_email}>",
                "to": [user_email],
                "subject": subject,
                "html": html_content
            }
            
            response = resend.Emails.send(params)
            print(f"‚úÖ Email de bienvenue super admin envoy√© avec succ√®s √† {user_email} via Resend (ID: {response.get('id', 'N/A')})")
            return True
        except Exception as resend_error:
            print(f"‚ö†Ô∏è Erreur Resend pour {user_email}: {str(resend_error)}")
            return False
                
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi de l'email super admin √† {user_email}: {str(e)}")
        return False


def send_gardes_notification_email(user_email: str, user_name: str, gardes_list: list, tenant_slug: str, periode: str):
    """
    Envoie un email d√©taill√© avec les gardes assign√©es pour le mois
    
    Args:
        user_email: Email du pompier
        user_name: Nom complet du pompier
        gardes_list: Liste des gardes [{date, type_garde, horaire, collegues}]
        tenant_slug: Slug de la caserne
        periode: P√©riode concern√©e (ex: "janvier 2025")
    """
    resend_api_key = os.environ.get('RESEND_API_KEY')
    
    if not resend_api_key:
        print(f"[WARNING] RESEND_API_KEY non configur√©e - Email NON envoy√© √† {user_email}")
        return False
    
    try:
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        subject = f"Vos gardes assign√©es - {periode}"
        
        # Construction de la liste des gardes en HTML
        gardes_html = ''
        for garde in gardes_list:
            collegues_str = ', '.join(garde.get('collegues', [])) if garde.get('collegues') else 'Non sp√©cifi√©s'
            
            gardes_html += f"""
                <div style="background: #f8fafc; border-left: 4px solid #3b82f6; padding: 15px; margin: 15px 0; border-radius: 4px;">
                    <h4 style="color: #1e293b; margin: 0 0 10px 0;">
                        üìÖ {garde['jour']} {garde['date']}
                    </h4>
                    <p style="margin: 5px 0; color: #475569;">
                        <strong>{garde['type_garde']}</strong> ({garde['horaire']})
                    </p>
                    <p style="margin: 5px 0; color: #64748b; font-size: 0.9rem;">
                        üë• Avec: {collegues_str}
                    </p>
                    <p style="margin: 5px 0; color: #64748b; font-size: 0.9rem;">
                        üìç Lieu: Caserne {tenant_slug.title()}
                    </p>
                </div>
            """
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="color: white; margin: 0; font-size: 24px;">üöí ProFireManager</h1>
                <p style="color: #fecaca; margin: 10px 0 0 0;">Planning valid√©</p>
            </div>
            
            <div style="background: white; padding: 30px; border: 1px solid #e2e8f0; border-top: none; border-radius: 0 0 10px 10px;">
                <h2 style="color: #1e293b;">Bonjour {user_name},</h2>
                
                <p>Voici vos gardes assign√©es pour <strong>{periode}</strong>.</p>
                
                <p style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 12px; margin: 15px 0;">
                    üè¢ <strong>Caserne:</strong> {tenant_slug.title()}
                </p>
                
                <h3 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px;">
                    üìã Vos gardes
                </h3>
                
                {gardes_html}
                
                <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <h4 style="color: #92400e; margin-top: 0;">üì¢ Important :</h4>
                    <ul style="color: #78350f; margin: 10px 0;">
                        <li>Ce planning a √©t√© valid√© par votre administrateur</li>
                        <li>Des ajustements peuvent encore survenir en cas de remplacements</li>
                        <li>Consultez r√©guli√®rement le planning en ligne pour les mises √† jour</li>
                        <li>En cas d'absence, signalez-le imm√©diatement via l'application</li>
                    </ul>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="https://www.profiremanager.ca/{tenant_slug}" 
                       style="background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
                        üöí Consulter le planning
                    </a>
                </div>
                
                <div style="border-top: 2px solid #e2e8f0; margin-top: 30px; padding-top: 20px; text-align: center; color: #64748b; font-size: 0.875rem;">
                    <p>ProFireManager v2.0 - Gestion des horaires et remplacements</p>
                    <p>Services d'incendie du Canada</p>
                    <p style="margin-top: 10px;">
                        Cet email a √©t√© envoy√© automatiquement. Ne pas r√©pondre.
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        params = {
            "from": f"ProFireManager <{sender_email}>",
            "to": [user_email],
            "subject": subject,
            "html": html_content
        }
        
        response = resend.Emails.send(params)
        print(f"‚úÖ Email de gardes envoy√© avec succ√®s √† {user_email} via Resend (ID: {response.get('id', 'N/A')})")
        return True
            
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi de l'email de gardes √† {user_email}: {str(e)}")
        return False

# ==================== HELPERS PDF PERSONNALIS√âS ====================

def create_pdf_header_elements(tenant, styles):
    """
    Cr√©e les √©l√©ments de header personnalis√©s pour les PDFs
    Retourne une liste d'√©l√©ments √† ajouter au document
    """
    elements = []
    
    # Logo (si pr√©sent)
    if hasattr(tenant, 'logo_url') and tenant.logo_url:
        try:
            if tenant.logo_url.startswith('data:image/'):
                # Extraire les donn√©es base64
                header, encoded = tenant.logo_url.split(',', 1)
                logo_data = base64.b64decode(encoded)
                logo_buffer = IOBytesIO(logo_data)
                
                # Utiliser PIL pour obtenir les dimensions de l'image
                from PIL import Image as PILImage
                pil_image = PILImage.open(logo_buffer)
                img_width, img_height = pil_image.size
                
                # Calculer les dimensions avec limites max pour √©viter le d√©passement
                max_width = 1.2 * inch
                max_height = 1.0 * inch  # Limite maximale de hauteur
                
                aspect_ratio = img_height / img_width
                
                # Calculer en fonction de la largeur
                target_width = max_width
                target_height = target_width * aspect_ratio
                
                # Si la hauteur d√©passe la limite, recalculer en fonction de la hauteur
                if target_height > max_height:
                    target_height = max_height
                    target_width = target_height / aspect_ratio
                
                # R√©initialiser le buffer pour ReportLab
                logo_buffer.seek(0)
                
                # Ajouter le logo avec largeur et hauteur explicites
                logo = Image(logo_buffer, width=target_width, height=target_height)
                logo.hAlign = 'LEFT'
                elements.append(logo)
                elements.append(Spacer(1, 0.1 * inch))
        except Exception as e:
            print(f"Erreur chargement logo PDF: {e}")
    
    # Nom du service
    nom_service = tenant.nom_service if hasattr(tenant, 'nom_service') and tenant.nom_service else tenant.nom
    
    header_style = ParagraphStyle(
        'ServiceHeader',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=10,
        alignment=TA_CENTER
    )
    
    elements.append(Paragraph(nom_service, header_style))
    elements.append(Spacer(1, 0.2 * inch))
    
    return elements

def create_pdf_footer_text(tenant):
    """
    Cr√©e le texte du footer pour les PDFs
    """
    footer_parts = []
    
    # Toujours afficher ProFireManager (sauf si explicitement d√©sactiv√©)
    if not hasattr(tenant, 'afficher_profiremanager') or tenant.afficher_profiremanager:
        footer_parts.append("G√©n√©r√© par ProFireManager ‚Ä¢ www.profiremanager.com")
    
    return " | ".join(footer_parts) if footer_parts else ""

# Classe CustomDocTemplate avec branding automatique
from reportlab.platypus import BaseDocTemplate, PageTemplate, Frame
from reportlab.pdfgen import canvas as pdf_canvas

class BrandedDocTemplate(SimpleDocTemplate):
    """
    Template de document PDF personnalis√© avec branding tenant automatique
    H√©rite de SimpleDocTemplate pour la simplicit√©
    """
    def __init__(self, filename, tenant=None, **kwargs):
        self.tenant = tenant
        # Appeler le constructeur de SimpleDocTemplate
        SimpleDocTemplate.__init__(self, filename, **kwargs)
    
    def afterPage(self, canvas=None, doc=None):
        """
        M√©thode appel√©e apr√®s chaque page pour ajouter le branding
        Compatible avec ReportLab 4.x - peut √™tre appel√©e avec ou sans arguments
        Args:
            canvas: Le canvas de la page (optionnel)
            doc: Le document (optionnel)
        """
        # Cette m√©thode peut √™tre √©tendue pour ajouter des √©l√©ments de branding
        # comme des footers, logos, etc.
        pass



def create_branded_pdf(tenant, pagesize=A4, **kwargs):
    """
    Fonction helper pour cr√©er un PDF brand√© avec logo et footer
    
    Args:
        tenant: L'objet tenant
        pagesize: Taille de la page (A4, letter, etc.)
        **kwargs: Arguments additionnels pour SimpleDocTemplate
        
    Returns:
        tuple: (buffer, doc, elements_with_header)
        - buffer: BytesIO object
        - doc: SimpleDocTemplate instance avec branding
        - elements_with_header: Liste avec logo et header d√©j√† ajout√©s
    """
    from io import BytesIO
    from reportlab.lib.styles import getSampleStyleSheet
    
    buffer = BytesIO()
    
    # Utiliser les marges par d√©faut si non sp√©cifi√©es
    if 'topMargin' not in kwargs:
        kwargs['topMargin'] = 0.75 * inch
    if 'bottomMargin' not in kwargs:
        kwargs['bottomMargin'] = 0.75 * inch
    
    # Utiliser SimpleDocTemplate directement pour la simplicit√©
    doc = SimpleDocTemplate(buffer, pagesize=pagesize, **kwargs)
    styles = getSampleStyleSheet()
    
    # Cr√©er les √©l√©ments de base avec logo et header
    elements = create_pdf_header_elements(tenant, styles)
    
    # Ajouter le footer √† la fin du document
    footer_text = create_pdf_footer_text(tenant)
    if footer_text:
        from reportlab.platypus import Paragraph
        from reportlab.lib.enums import TA_CENTER
        from reportlab.lib.styles import ParagraphStyle
        
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            alignment=TA_CENTER,
            spaceAfter=0
        )
        # Note: Le footer sera ajout√© √† la fin du document par l'appelant si n√©cessaire
    
    return buffer, doc, elements


def get_modern_pdf_styles(styles):
    """
    Retourne les styles modernes standardis√©s pour tous les PDFs
    Bas√© sur le design du rapport d'inspection (Ronde de s√©curit√©)
    """
    title_style = ParagraphStyle(
        'ModernTitle',
        parent=styles['Heading1'],
        fontSize=20,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'ModernHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#374151'),
        spaceAfter=12,
        spaceBefore=20
    )
    
    subheading_style = ParagraphStyle(
        'ModernSubheading',
        parent=styles['Normal'],
        fontSize=12,
        textColor=colors.HexColor('#374151'),
        spaceAfter=10,
        alignment=TA_CENTER
    )
    
    return {
        'title': title_style,
        'heading': heading_style,
        'subheading': subheading_style,
        'primary_color': colors.HexColor('#1f2937'),
        'secondary_color': colors.HexColor('#374151'),
        'bg_light': colors.HexColor('#f3f4f6'),
        'success': colors.HexColor('#10b981'),
        'error': colors.HexColor('#ef4444'),
        'grid': colors.HexColor('#e5e7eb'),
        'warning_bg': colors.HexColor('#fef2f2')
    }

# ==================== FIN HELPERS PDF ====================

def get_password_hash(password: str) -> str:
    """
    Cr√©e un hash bcrypt du mot de passe (s√©curis√© et standard).
    """
    password_bytes = password.encode('utf-8')
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password_bytes, salt).decode('utf-8')

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    V√©rifie un mot de passe contre son hash bcrypt.
    Syst√®me simplifi√©: UNIQUEMENT bcrypt pour stabilit√© maximale.
    
    Retourne True si le mot de passe correspond, False sinon.
    """
    try:
        password_bytes = plain_password.encode('utf-8')
        
        # V√©rifier si c'est un hash bcrypt valide
        if not hashed_password or not hashed_password.startswith('$2'):
            logging.error(f"‚ùå Hash invalide ou non-bcrypt d√©tect√©")
            return False
        
        if isinstance(hashed_password, str):
            hash_bytes = hashed_password.encode('utf-8')
        else:
            hash_bytes = hashed_password
        
        result = bcrypt.checkpw(password_bytes, hash_bytes)
        logging.info(f"‚úÖ V√©rification bcrypt: {result}")
        return result
        
    except Exception as e:
        logging.error(f"‚ùå Erreur v√©rification mot de passe: {e}")
        return False



def send_debogage_notification_email(super_admins_emails: List[str], type_notification: str, titre: str, description: str, priorite: str, created_by: str, item_id: str):
    """
    Envoie un email aux super-admins pour les notifier d'un nouveau bug ou feature request
    
    Args:
        super_admins_emails: Liste des emails des super-admins
        type_notification: "bug" ou "feature"
        titre: Titre du bug/feature
        description: Description
        priorite: Priorit√© (critique, haute, moyenne, basse)
        created_by: Nom de la personne qui a cr√©√©
        item_id: ID du bug/feature
    """
    try:
        resend_api_key = os.environ.get('RESEND_API_KEY')
        
        if not resend_api_key:
            print(f"[WARNING] RESEND_API_KEY non configur√©e - Email NON envoy√©")
            return
        
        # Configurer Resend
        resend.api_key = resend_api_key
        
        # D√©terminer le type et l'emoji
        if type_notification == "bug":
            type_label = "üêõ Nouveau Bug Signal√©"
            color = "#dc2626"  # rouge
        else:
            type_label = "‚ú® Nouvelle Fonctionnalit√© Demand√©e"
            color = "#2563eb"  # bleu
        
        # D√©terminer la couleur de priorit√©
        priorite_colors = {
            "critique": "#dc2626",
            "haute": "#f97316",
            "moyenne": "#eab308",
            "basse": "#22c55e"
        }
        priorite_color = priorite_colors.get(priorite, "#6b7280")
        
        # Cr√©er l'URL de l'interface admin
        admin_url = f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/admin"
        
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
    <div style="max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f8fafc;">
        <!-- Header -->
        <div style="background: linear-gradient(135deg, {color} 0%, {color}dd 100%); padding: 30px; border-radius: 16px 16px 0 0; text-align: center;">
            <h1 style="margin: 0; color: white; font-size: 24px; font-weight: 600;">
                {type_label}
            </h1>
        </div>
        
        <!-- Content -->
        <div style="background-color: white; padding: 30px; border-radius: 0 0 16px 16px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <!-- Titre -->
            <div style="margin-bottom: 20px;">
                <h2 style="margin: 0 0 10px 0; color: #1e293b; font-size: 20px; font-weight: 600;">
                    {titre}
                </h2>
                <div style="display: inline-block; padding: 4px 12px; background-color: {priorite_color}; color: white; border-radius: 12px; font-size: 12px; font-weight: 600; text-transform: uppercase;">
                    Priorit√©: {priorite}
                </div>
            </div>
            
            <!-- Description -->
            <div style="background-color: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid {color};">
                <p style="margin: 0; color: #475569; line-height: 1.6;">
                    {description[:200]}{'...' if len(description) > 200 else ''}
                </p>
            </div>
            
            <!-- Info suppl√©mentaires -->
            <div style="margin-bottom: 25px; padding: 15px; background-color: #eff6ff; border-radius: 8px;">
                <p style="margin: 0 0 8px 0; color: #64748b; font-size: 14px;">
                    <strong>Cr√©√© par:</strong> {created_by}
                </p>
                <p style="margin: 0; color: #64748b; font-size: 14px;">
                    <strong>ID:</strong> {item_id[:8]}...
                </p>
            </div>
            
            <!-- Call to Action -->
            <div style="text-align: center; margin-top: 30px;">
                <a href="{admin_url}" style="display: inline-block; padding: 14px 32px; background: linear-gradient(135deg, {color} 0%, {color}dd 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    Voir dans l'Interface Admin
                </a>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="text-align: center; padding: 20px; color: #94a3b8; font-size: 12px;">
            <p style="margin: 0;">ProFireManager - Syst√®me de Gestion de S√©curit√© Incendie</p>
            <p style="margin: 5px 0 0 0;">Cet email a √©t√© envoy√© automatiquement, merci de ne pas y r√©pondre.</p>
        </div>
    </div>
</body>
</html>
"""
        
        # Envoyer l'email √† tous les super-admins avec Resend
        for admin_email in super_admins_emails:
            try:
                params = {
                    "from": "ProFireManager <noreply@profiremanager.ca>",
                    "to": [admin_email],
                    "subject": f"{type_label}: {titre}",
                    "html": html_content
                }
                
                response = resend.Emails.send(params)
                print(f"[INFO] Email de notification envoy√© √† {admin_email} via Resend (ID: {response.get('id', 'N/A')})")
            except Exception as e:
                print(f"[ERROR] Erreur lors de l'envoi de l'email √† {admin_email}: {e}")
                
    except Exception as e:
        print(f"[ERROR] Erreur g√©n√©rale lors de l'envoi des emails de d√©bogage: {e}")

security = HTTPBearer()

# Define Models
# ==================== MULTI-TENANT MODELS ====================

class Tenant(BaseModel):
    """Mod√®le pour une caserne (tenant)"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    slug: str  # URL slug (shefford, bromont, etc.)
    nom: str  # Nom complet de la caserne
    adresse: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    telephone: str = ""
    email_contact: str = ""
    actif: bool = True
    date_creation: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    parametres: Dict[str, Any] = {}
    # Personnalisation
    logo_url: str = ""  # URL ou base64 du logo
    nom_service: str = ""  # Nom complet du service (ex: "Service Incendie de Ville-X")
    afficher_profiremanager: bool = True  # Afficher le branding ProFireManager
    # Centrale 911 associ√©e
    centrale_911_id: Optional[str] = None  # FK vers centrales_911
    # Facturation Stripe
    is_gratuit: bool = False  # Tenant gratuit (pas de facturation)
    stripe_customer_id: Optional[str] = None
    stripe_subscription_id: Optional[str] = None
    billing_status: str = "inactive"  # inactive, active, past_due, cancelled, trial
    billing_cycle: str = "monthly"  # monthly ou annual
    last_payment_date: Optional[str] = None
    last_payment_amount: Optional[float] = None
    next_billing_date: Optional[str] = None
    payment_failed_date: Optional[str] = None  # Date du premier √©chec de paiement
    launch_offer_applied: bool = False  # Offre de lancement appliqu√©e

class TenantCreate(BaseModel):
    slug: str
    nom: str
    adresse: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    telephone: str = ""
    email_contact: str = ""
    date_creation: Optional[str] = None  # Date optionnelle
    centrale_911_id: Optional[str] = None  # Centrale 911 associ√©e

class SuperAdmin(BaseModel):
    """Super administrateur g√©rant toutes les casernes"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    email: str
    nom: str = "Super Admin"
    mot_de_passe_hash: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SuperAdminLogin(BaseModel):
    email: str
    mot_de_passe: str

# ==================== AUDIT LOG MODELS ====================

class AuditLog(BaseModel):
    """Journal d'audit pour les actions super-admin"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    admin_id: str  # ID du super-admin
    admin_email: str  # Email du super-admin
    admin_nom: str  # Nom du super-admin
    action: str  # Type d'action (login, tenant_access, tenant_create, etc.)
    details: Dict[str, Any] = {}  # D√©tails sp√©cifiques √† l'action
    tenant_id: Optional[str] = None  # Tenant concern√© (si applicable)
    tenant_slug: Optional[str] = None  # Slug du tenant (si applicable)
    tenant_nom: Optional[str] = None  # Nom du tenant (si applicable)
    ip_address: Optional[str] = None  # Adresse IP (si disponible)
    user_agent: Optional[str] = None  # User agent (si disponible)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


async def log_super_admin_action(
    admin: "SuperAdmin",
    action: str,
    details: Dict[str, Any] = None,
    tenant_id: str = None,
    tenant_slug: str = None,
    tenant_nom: str = None,
    ip_address: str = None,
    user_agent: str = None
):
    """
    Enregistre une action super-admin dans le journal d'audit
    
    Actions possibles:
    - login: Connexion au dashboard super-admin
    - tenant_access: Connexion √† un tenant sp√©cifique
    - tenant_create: Cr√©ation d'un nouveau tenant
    - tenant_update: Modification d'un tenant
    - tenant_delete: Suppression d'un tenant
    - admin_create: Cr√©ation d'un admin pour un tenant
    - view_stats: Consultation des statistiques globales
    """
    try:
        audit_entry = AuditLog(
            admin_id=admin.id,
            admin_email=admin.email,
            admin_nom=admin.nom,
            action=action,
            details=details or {},
            tenant_id=tenant_id,
            tenant_slug=tenant_slug,
            tenant_nom=tenant_nom,
            ip_address=ip_address,
            user_agent=user_agent
        )
        await db.audit_logs.insert_one(audit_entry.dict())
        logging.info(f"üìù [AUDIT] {admin.email} - {action}" + (f" - Tenant: {tenant_slug}" if tenant_slug else ""))
    except Exception as e:
        logging.error(f"‚ùå Erreur enregistrement audit: {e}")
        # Ne pas bloquer l'action principale si l'audit √©choue

# ==================== USER MODELS ====================

class User(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str  # ID de la caserne
    nom: str
    prenom: str
    email: str
    telephone: str = ""
    adresse: str = ""  # Adresse du pompier
    contact_urgence: str = ""
    grade: str = "Pompier"  # Capitaine, Directeur, Pompier, Lieutenant (default pour anciens users)
    fonction_superieur: bool = False  # Pour pompiers pouvant agir comme lieutenant
    type_emploi: str = "temps_plein"  # temps_plein, temps_partiel (default pour anciens users)
    heures_max_semaine: int = 40  # Heures max par semaine (pour temps partiel)
    role: str = "employe"  # admin, superviseur, employe (default pour anciens users)
    statut: str = "Actif"  # Actif, Inactif
    numero_employe: str = ""
    date_embauche: str = ""
    taux_horaire: float = 0.0  # Taux horaire en $/h
    heures_internes: float = 0.0  # Heures de garde internes (travail physique)
    heures_externes: float = 0.0  # Heures de garde externes (astreinte √† domicile)
    formations: List[str] = []  # Liste des UUIDs de formations suivies (pour module Formation)
    competences: List[str] = []  # Liste des UUIDs de comp√©tences acquises/certifi√©es (pour auto-attribution)
    accepte_gardes_externes: bool = True  # Accepte d'√™tre assign√© aux gardes externes
    est_preventionniste: bool = False  # D√©sign√© comme pr√©ventionniste (module Pr√©vention)
    equipe_garde: Optional[int] = None  # √âquipe de garde (1, 2, 3, 4, 5 selon config du tenant)
    photo_profil: Optional[str] = None  # Photo de profil en base64 (redimensionn√©e 200x200)
    tailles_epi: Dict[str, str] = {}  # Tailles EPI de l'employ√© {type_epi: taille}
    mot_de_passe_hash: str = ""
    is_super_admin: bool = False  # Flag pour identifier les super-admins connect√©s sur un tenant
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class UserCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    nom: str
    prenom: str
    email: str
    telephone: str = ""
    adresse: str = ""
    contact_urgence: str = ""
    grade: str = "Pompier"
    fonction_superieur: bool = False
    type_emploi: str = "temps_plein"
    heures_max_semaine: int = 40
    role: str = "employe"
    numero_employe: str = ""
    date_embauche: str = ""
    taux_horaire: float = 0.0
    formations: List[str] = []  # Liste des formations suivies
    competences: List[str] = []  # Liste des comp√©tences acquises
    accepte_gardes_externes: bool = True  # Accepte d'√™tre assign√© aux gardes externes
    est_preventionniste: bool = False  # D√©sign√© comme pr√©ventionniste
    equipe_garde: Optional[int] = None  # √âquipe de garde (1, 2, 3, 4, 5 selon config)
    mot_de_passe: str = "TempPass123!"

class UserUpdate(BaseModel):
    nom: Optional[str] = None
    prenom: Optional[str] = None
    email: Optional[str] = None
    telephone: Optional[str] = None
    adresse: Optional[str] = None
    contact_urgence: Optional[str] = None
    grade: Optional[str] = None
    fonction_superieur: Optional[bool] = None
    type_emploi: Optional[str] = None
    heures_max_semaine: Optional[int] = None
    role: Optional[str] = None
    numero_employe: Optional[str] = None
    date_embauche: Optional[str] = None
    taux_horaire: Optional[float] = None
    formations: Optional[List[str]] = None
    competences: Optional[List[str]] = None
    accepte_gardes_externes: Optional[bool] = None
    est_preventionniste: Optional[bool] = None
    equipe_garde: Optional[int] = None  # √âquipe de garde (1, 2, 3, 4, 5 selon config)
    photo_profil: Optional[str] = None  # Photo de profil en base64
    tailles_epi: Optional[Dict[str, str]] = None  # Tailles EPI de l'employ√©
    mot_de_passe: Optional[str] = None  # Optionnel pour les mises √† jour

class UserLogin(BaseModel):
    email: str
    mot_de_passe: str

class ForgotPasswordRequest(BaseModel):
    email: str

class ResetPasswordRequest(BaseModel):
    token: str
    nouveau_mot_de_passe: str

class BillingRequest(BaseModel):
    return_url: str

class PasswordResetToken(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    email: str
    token: str
    expires_at: datetime
    used: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class TypeGarde(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    heure_debut: str
    heure_fin: str
    personnel_requis: int
    duree_heures: int
    couleur: str
    jours_application: List[str] = []  # monday, tuesday, etc.
    officier_obligatoire: bool = False
    competences_requises: List[str] = []  # Liste des formations/comp√©tences requises pour cette garde
    est_garde_externe: bool = False  # True si c'est une garde externe (astreinte √† domicile)
    taux_horaire_externe: Optional[float] = None  # Taux horaire sp√©cifique pour garde externe
    montant_garde: Optional[float] = None  # Montant fixe de la garde (prime)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class TypeGardeCreate(BaseModel):
    nom: str
    heure_debut: str
    heure_fin: str
    personnel_requis: int
    duree_heures: int
    couleur: str
    jours_application: List[str] = []
    officier_obligatoire: bool = False
    competences_requises: List[str] = []
    est_garde_externe: bool = False
    taux_horaire_externe: Optional[float] = None
    montant_garde: Optional[float] = None  # Montant fixe de la garde (prime)

class Planning(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    semaine_debut: str  # Format: YYYY-MM-DD
    semaine_fin: str
    assignations: Dict[str, Any] = {}  # jour -> type_garde -> assignation
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class PlanningCreate(BaseModel):
    semaine_debut: str
    semaine_fin: str
    assignations: Dict[str, Any] = {}

class Assignation(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    type_garde_id: str
    date: str
    statut: str = "planifie"  # planifie, confirme, remplacement_demande
    assignation_type: str = "auto"  # auto, manuel, manuel_avance
    justification: Optional[Dict[str, Any]] = None  # Justification d√©taill√©e pour assignations auto
    notes_admin: Optional[str] = None  # Notes manuelles de l'admin
    justification_historique: Optional[List[Dict[str, Any]]] = None  # Historique des justifications

class AssignationCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    user_id: str
    type_garde_id: str
    date: str
    assignation_type: str = "manuel"

class TentativeRemplacement(BaseModel):
    """Historique des tentatives de remplacement"""
    user_id: str
    nom_complet: str
    date_contact: datetime
    statut: str  # contacted, accepted, refused, expired
    date_reponse: Optional[datetime] = None

class DemandeRemplacement(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    demandeur_id: str
    type_garde_id: str
    date: str  # Date de la garde √† remplacer (format: YYYY-MM-DD)
    raison: str
    statut: str = "en_attente"  # en_attente, en_cours, accepte, expiree, annulee
    priorite: str = "normal"  # urgent (‚â§24h), normal (>24h) - calcul√© automatiquement
    remplacant_id: Optional[str] = None
    tentatives_historique: List[Dict[str, Any]] = []  # Historique des personnes contact√©es
    remplacants_contactes_ids: List[str] = []  # IDs des rempla√ßants actuellement en attente de r√©ponse
    date_prochaine_tentative: Optional[datetime] = None
    nombre_tentatives: int = 0
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DemandeRemplacementCreate(BaseModel):
    type_garde_id: str
    date: str
    raison: str

class Formation(BaseModel):
    """Formation planifi√©e avec gestion inscriptions NFPA 1500"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    competence_id: str = ""  # Optionnel pour r√©trocompatibilit√©
    description: str = ""
    date_debut: str = ""
    date_fin: str = ""
    heure_debut: str = ""
    heure_fin: str = ""
    duree_heures: float = 0
    lieu: str = ""
    instructeur: str = ""
    places_max: int = 20
    places_restantes: int = 20
    statut: str = "planifiee"
    obligatoire: bool = False
    annee: int = 0
    validite_mois: int = 12  # Pour anciennes formations
    user_inscrit: bool = False  # Si l'utilisateur actuel est inscrit
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class FormationCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    competence_id: str
    description: str = ""
    date_debut: str
    date_fin: str
    heure_debut: str
    heure_fin: str
    duree_heures: float
    lieu: str = ""
    instructeur: str = ""
    places_max: int
    obligatoire: bool = False
    annee: int

class FormationUpdate(BaseModel):
    nom: Optional[str] = None
    competence_id: Optional[str] = None
    description: Optional[str] = None
    date_debut: Optional[str] = None
    date_fin: Optional[str] = None
    heure_debut: Optional[str] = None
    heure_fin: Optional[str] = None
    duree_heures: Optional[float] = None
    lieu: Optional[str] = None
    instructeur: Optional[str] = None
    places_max: Optional[int] = None
    obligatoire: Optional[bool] = None
    statut: Optional[str] = None

class InscriptionFormation(BaseModel):
    """Inscription d'un pompier √† une formation"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    formation_id: str
    user_id: str
    date_inscription: str
    statut: str = "inscrit"  # inscrit, en_attente, present, absent, complete
    heures_creditees: float = 0.0
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InscriptionFormationCreate(BaseModel):
    tenant_id: Optional[str] = None
    formation_id: str
    user_id: str

class InscriptionFormationUpdate(BaseModel):
    statut: Optional[str] = None
    heures_creditees: Optional[float] = None
    notes: Optional[str] = None

class Competence(BaseModel):
    """Comp√©tence avec exigences NFPA 1500"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    description: str = ""
    heures_requises_annuelles: float = 0.0
    obligatoire: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CompetenceCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    description: str = ""
    heures_requises_annuelles: float = 0.0
    obligatoire: bool = False

class CompetenceUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    heures_requises_annuelles: Optional[float] = None
    obligatoire: Optional[bool] = None

class Grade(BaseModel):
    """Grade hi√©rarchique pour les pompiers"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    niveau_hierarchique: int  # 1 = niveau le plus bas, 10 = niveau le plus haut
    est_officier: bool = False  # True si ce grade est consid√©r√© comme un officier
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class GradeCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    niveau_hierarchique: int
    est_officier: bool = False

class GradeUpdate(BaseModel):
    nom: Optional[str] = None
    niveau_hierarchique: Optional[int] = None
    est_officier: Optional[bool] = None

class ParametresFormations(BaseModel):
    """Param√®tres globaux formations pour NFPA 1500"""
    tenant_id: str
    heures_minimales_annuelles: float = 100.0
    pourcentage_presence_minimum: float = 80.0
    delai_notification_liste_attente: int = 7  # jours
    email_notifications_actif: bool = True
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ValidationCompetence(BaseModel):
    """Validation manuelle d'une comp√©tence pour un employ√©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    competence_id: str
    justification: str
    date_validation: str  # Date au format ISO
    validee_par: str  # ID de l'administrateur qui a valid√©
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ValidationCompetenceCreate(BaseModel):
    user_id: str
    competence_id: str
    justification: str
    date_validation: str

# Alias pour compatibilit√© avec anciennes routes
SessionFormation = Formation
SessionFormationCreate = FormationCreate

class Disponibilite(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str
    date: str  # Date exacte YYYY-MM-DD
    type_garde_id: Optional[str] = None  # Sp√©cifier pour quel type de garde
    heure_debut: str
    heure_fin: str
    statut: str = "disponible"  # disponible, indisponible, preference
    origine: str = "manuelle"  # manuelle, montreal_7_24, quebec_10_14, personnalisee
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DisponibiliteCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    user_id: str
    date: str  # Date exacte YYYY-MM-DD
    type_garde_id: Optional[str] = None
    heure_debut: str
    heure_fin: str
    statut: str = "disponible"
    origine: str = "manuelle"  # manuelle, montreal_7_24, quebec_10_14, longueuil_7_24, personnalisee

class IndisponibiliteGenerate(BaseModel):
    user_id: str
    horaire_type: str  # "montreal", "quebec" ou "longueuil"
    equipe: str  # "Rouge", "Jaune", "Bleu", "Vert"
    date_debut: str  # Date de d√©but (YYYY-MM-DD)
    date_fin: str  # Date de fin (YYYY-MM-DD)
    date_jour_1: Optional[str] = None  # Pour Quebec 10/14, date du Jour 1 du cycle (YYYY-MM-DD)
    conserver_manuelles: bool = True  # Conserver les modifications manuelles lors de la r√©g√©n√©ration

class DisponibiliteReinitialiser(BaseModel):
    user_id: str
    periode: str  # "semaine", "mois", "annee", "personnalisee"
    mode: str  # "tout" ou "generees_seulement"
    type_entree: str = "les_deux"  # "disponibilites", "indisponibilites", "les_deux"
    date_debut: Optional[str] = None  # Pour p√©riode personnalis√©e (YYYY-MM-DD)
    date_fin: Optional[str] = None  # Pour p√©riode personnalis√©e (YYYY-MM-DD)

class ConflictResolution(BaseModel):
    """Historique des r√©solutions de conflits disponibilit√©/indisponibilit√©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    user_id: str  # Utilisateur qui a cr√©√© et r√©solu le conflit
    affected_user_id: str  # Utilisateur dont les dispos/indispos sont affect√©es
    action: str  # "supprimer_conflits", "creer_quand_meme", "annuler"
    type_created: str  # "disponibilite" ou "indisponibilite"
    conflicts_deleted: List[Dict[str, Any]] = []  # Liste des √©l√©ments supprim√©s
    created_item: Optional[Dict[str, Any]] = None  # L'√©l√©ment cr√©√©
    resolved_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ConflictDetail(BaseModel):
    """D√©tails d'un conflit d√©tect√©"""
    conflict_id: str
    conflict_type: str  # "disponibilite" ou "indisponibilite"
    date: str
    heure_debut: str
    heure_fin: str
    type_garde_id: Optional[str] = None
    type_garde_nom: Optional[str] = None
    statut: str
    overlap_start: str  # D√©but du chevauchement
    overlap_end: str  # Fin du chevauchement

class DeviceToken(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    device_token: str
    platform: str  # "ios" ou "android"
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DeviceTokenRegister(BaseModel):
    user_id: str
    device_token: str
    platform: str

class PushNotificationSend(BaseModel):
    user_ids: List[str]
    title: str
    body: str
    data: Optional[dict] = None

class Statistiques(BaseModel):
    personnel_actif: int
    gardes_cette_semaine: int
    formations_planifiees: int
    taux_couverture: float
    heures_travaillees: int
    remplacements_effectues: int

# ==================== GESTION DES ACTIFS MODELS ====================

class LocalisationGPS(BaseModel):
    lat: float
    lng: float

class Vehicule(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Nom/Identifiant du v√©hicule (ex: "391", "Autopompe 1")
    type_vehicule: Optional[str] = None  # ex: Autopompe, Citerne, Pick-up, √âchelle
    marque: Optional[str] = None
    modele: Optional[str] = None
    annee: Optional[int] = None
    kilometrage: Optional[float] = None
    vin: Optional[str] = None  # Num√©ro d'identification du v√©hicule
    statut: str = "actif"  # actif, maintenance, retraite
    date_mise_service: Optional[str] = None  # Date format YYYY-MM-DD
    modele_inventaire_id: Optional[str] = None  # Mod√®le d'inventaire assign√©
    photos: List[str] = []  # URLs ou base64 des photos
    documents: List[Dict[str, str]] = []  # [{nom: "doc.pdf", url: "..."}]
    notes: Optional[str] = None
    # Inspection SAAQ
    derniere_inspection_id: Optional[str] = None
    derniere_inspection_date: Optional[str] = None
    # QR Code
    qr_code: Optional[str] = None  # QR code en base64
    qr_code_url: Optional[str] = None  # URL encod√©e dans le QR code
    # Fiche de vie (audit trail)
    logs: List[Dict[str, Any]] = []  # Historique complet des actions
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class VehiculeCreate(BaseModel):
    nom: str
    type_vehicule: Optional[str] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    annee: Optional[int] = None
    kilometrage: Optional[float] = None
    vin: Optional[str] = None
    statut: str = "actif"
    date_mise_service: Optional[str] = None
    photos: List[str] = []
    documents: List[Dict[str, str]] = []
    notes: Optional[str] = None

class VehiculeUpdate(BaseModel):
    nom: Optional[str] = None
    type_vehicule: Optional[str] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    annee: Optional[int] = None
    kilometrage: Optional[float] = None
    vin: Optional[str] = None
    statut: Optional[str] = None
    date_mise_service: Optional[str] = None
    modele_inventaire_id: Optional[str] = None
    photos: Optional[List[str]] = None
    documents: Optional[List[Dict[str, str]]] = None
    notes: Optional[str] = None

class BorneIncendie(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Nom de la borne (ex: "Allen", "Borne Wallace")
    type_borne: str  # "seche" ou "fontaine"
    localisation_gps: Optional[LocalisationGPS] = None
    adresse: Optional[str] = None
    transversale: Optional[str] = None  # Chemin transversal
    municipalite: Optional[str] = None
    debit: Optional[str] = None  # D√©bit en GPM ou autre
    statut: str = "operationnelle"  # operationnelle, hors_service, a_verifier
    date_derniere_inspection: Optional[str] = None  # Date format YYYY-MM-DD
    lien_maps: Optional[str] = None  # Lien Google Maps
    photos: List[str] = []  # URLs ou base64 des photos
    schemas: List[str] = []  # Sch√©mas techniques
    notes_importantes: Optional[str] = None
    # QR Code
    qr_code: Optional[str] = None  # QR code en base64
    qr_code_url: Optional[str] = None  # URL encod√©e dans le QR code
    # Fiche de vie (audit trail)
    logs: List[Dict[str, Any]] = []  # Historique complet des actions
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BorneIncendieCreate(BaseModel):
    nom: str
    type_borne: str  # "seche" ou "fontaine"
    localisation_gps: Optional[LocalisationGPS] = None
    adresse: Optional[str] = None
    transversale: Optional[str] = None
    municipalite: Optional[str] = None
    debit: Optional[str] = None
    statut: str = "operationnelle"
    date_derniere_inspection: Optional[str] = None
    lien_maps: Optional[str] = None
    photos: List[str] = []
    schemas: List[str] = []
    notes_importantes: Optional[str] = None

class BorneIncendieUpdate(BaseModel):
    nom: Optional[str] = None
    type_borne: Optional[str] = None
    localisation_gps: Optional[LocalisationGPS] = None
    adresse: Optional[str] = None
    transversale: Optional[str] = None
    municipalite: Optional[str] = None
    debit: Optional[str] = None
    statut: Optional[str] = None
    date_derniere_inspection: Optional[str] = None
    lien_maps: Optional[str] = None
    photos: Optional[List[str]] = None
    schemas: Optional[List[str]] = None
    notes_importantes: Optional[str] = None

# ==================== INVENTAIRES V√âHICULES MODELS ====================

class ItemInventaire(BaseModel):
    """Un item dans une section d'inventaire"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str  # Ex: "Masque bleu chirurgical"
    type_item: str = "checkbox"  # checkbox, text, number
    obligatoire: bool = False
    ordre: int = 0  # Pour l'affichage

class SectionInventaire(BaseModel):
    """Une section dans un mod√®le d'inventaire"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str  # Ex: "Cabine"
    description: Optional[str] = None
    photos_reference: List[str] = []  # Photos du compartiment pour guider
    items: List[ItemInventaire] = []
    ordre: int = 0

class ModeleInventaire(BaseModel):
    """Template d'inventaire pour un type de v√©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Inventaire Autopompe 391"
    description: Optional[str] = None
    type_vehicule: Optional[str] = None  # Pour filtrer
    sections: List[SectionInventaire] = []
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ModeleInventaireCreate(BaseModel):
    nom: str
    description: Optional[str] = None
    type_vehicule: Optional[str] = None
    sections: List[SectionInventaire] = []

class ModeleInventaireUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    type_vehicule: Optional[str] = None
    sections: Optional[List[SectionInventaire]] = None

class ResultatItemInspection(BaseModel):
    """R√©sultat pour un item lors d'une inspection"""
    item_id: str
    section_id: str
    statut: str  # "present", "absent", "non_applicable"
    notes: Optional[str] = None
    photo_url: Optional[str] = None  # Photo de l'item si probl√®me

class InspectionInventaire(BaseModel):
    """Inspection d'inventaire d'un v√©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    vehicule_id: str
    modele_inventaire_id: str
    inspecteur_id: str  # User qui fait l'inspection
    inspecteur_nom: Optional[str] = None
    date_inspection: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    statut: str = "en_cours"  # en_cours, complete
    resultats: List[ResultatItemInspection] = []
    notes_generales: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    completed_at: Optional[datetime] = None

class InspectionInventaireCreate(BaseModel):
    vehicule_id: str
    modele_inventaire_id: str
    inspecteur_id: str

class InspectionInventaireUpdate(BaseModel):
    statut: Optional[str] = None
    resultats: Optional[List[ResultatItemInspection]] = None
    notes_generales: Optional[str] = None

# Helper functions

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), tenant_slug: str = None):
    """
    Authentifie l'utilisateur et v√©rifie qu'il appartient au tenant
    tenant_slug est optionnel pour compatibilit√© avec les routes qui ne l'utilisent pas encore
    Supporte aussi les super-admins qui peuvent acc√©der √† tous les tenants
    """
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        tenant_id: str = payload.get("tenant_id")  # Tenant ID stock√© dans le token
        is_super_admin: bool = payload.get("is_super_admin", False)  # Flag super-admin
        
        if user_id is None:
            raise HTTPException(status_code=401, detail="Token invalide")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token invalide")
    
    # Si c'est un super-admin, cr√©er un User virtuel avec droits admin
    if is_super_admin:
        super_admin_data = await db.super_admins.find_one({"id": user_id})
        if super_admin_data is None:
            raise HTTPException(status_code=401, detail="Super-admin non trouv√©")
        
        # Cr√©er un User virtuel pour le super-admin avec le tenant_id du token
        virtual_user = {
            "id": super_admin_data["id"],
            "tenant_id": tenant_id,
            "email": super_admin_data["email"],
            "nom": super_admin_data["nom"],
            "prenom": "Super-Admin",
            "role": "admin",  # Super-admin a tous les droits admin
            "grade": "Super-Administrateur",
            "type_emploi": "temps_plein",
            "statut": "Actif",
            "numero_employe": "SUPER-ADMIN",
            "telephone": "",
            "date_embauche": "",
            "photo_profil": None,
            "est_preventionniste": True,  # Acc√®s √† tous les modules
            "is_super_admin": True  # Flag pour identifier
        }
        return User(**virtual_user)
    
    # Sinon, chercher l'utilisateur normal
    user = await db.users.find_one({"id": user_id})
    if user is None:
        raise HTTPException(status_code=401, detail="Utilisateur non trouv√©")
    
    # V√©rifier que l'utilisateur appartient au tenant si tenant_slug est fourni
    if tenant_slug:
        tenant = await get_tenant_from_slug(tenant_slug)
        user_tenant_id = user.get("tenant_id")
        if user_tenant_id != tenant.id:
            logging.warning(f"‚ùå Acc√®s refus√© - User tenant_id={user_tenant_id} != tenant.id={tenant.id}")
            raise HTTPException(status_code=403, detail="Acc√®s interdit √† cette caserne")
    
    return User(**user)

# Version optionnelle qui retourne None au lieu de lever une exception
security_optional = HTTPBearer(auto_error=False)

async def get_current_user_optional(credentials: HTTPAuthorizationCredentials = Depends(security_optional), tenant_slug: str = None):
    """
    Version optionnelle de get_current_user - retourne None si pas de token valide.
    Utilis√© pour les endpoints qui supportent aussi l'authentification via param√®tre URL (mobile).
    Supporte aussi les super-admins.
    """
    if credentials is None:
        return None
    
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        tenant_id: str = payload.get("tenant_id")
        is_super_admin: bool = payload.get("is_super_admin", False)
        
        if user_id is None:
            return None
    except jwt.PyJWTError:
        return None
    
    # Si c'est un super-admin, cr√©er un User virtuel
    if is_super_admin:
        super_admin_data = await db.super_admins.find_one({"id": user_id})
        if super_admin_data is None:
            return None
        
        virtual_user = {
            "id": super_admin_data["id"],
            "tenant_id": tenant_id,
            "email": super_admin_data["email"],
            "nom": super_admin_data["nom"],
            "prenom": "Super-Admin",
            "role": "admin",
            "grade": "Super-Administrateur",
            "type_emploi": "temps_plein",
            "statut": "Actif",
            "numero_employe": "SUPER-ADMIN",
            "telephone": "",
            "date_embauche": "",
            "photo_profil": None,
            "est_preventionniste": True,
            "is_super_admin": True
        }
        return User(**virtual_user)
    
    user = await db.users.find_one({"id": user_id})
    if user is None:
        return None
    
    return User(**user)

async def trouver_opportunites_regroupement(
    date_str: str,
    types_garde: list,
    existing_assignations: list,
    duree_max: int,
    tenant_id: str
):
    """
    Trouve les opportunit√©s de regroupement de gardes pour une date donn√©e
    
    Returns:
        List de tuples (type_garde_1, type_garde_2_or_None, date_2_or_None) repr√©sentant les regroupements possibles
    """
    opportunites = []
    date_obj = datetime.strptime(date_str, "%Y-%m-%d")
    date_suivante_str = (date_obj + timedelta(days=1)).strftime("%Y-%m-%d")
    
    # 1. M√äME JOURN√âE: Chercher des gardes qui peuvent se regrouper dans la m√™me journ√©e
    gardes_date = [tg for tg in types_garde]
    
    for i, tg1 in enumerate(gardes_date):
        # Chercher dans les gardes suivantes
        for tg2 in gardes_date[i+1:]:
            duree_totale = tg1.get("duree_heures", 8) + tg2.get("duree_heures", 8)
            
            if duree_totale <= duree_max:
                # V√©rifier qu'elles ne sont pas d√©j√† assign√©es
                assignations_tg1 = [a for a in existing_assignations 
                                   if a["date"] == date_str and a["type_garde_id"] == tg1["id"]]
                assignations_tg2 = [a for a in existing_assignations 
                                   if a["date"] == date_str and a["type_garde_id"] == tg2["id"]]
                
                places_tg1 = tg1.get("nombre_pompiers_requis", 1) - len(assignations_tg1)
                places_tg2 = tg2.get("nombre_pompiers_requis", 1) - len(assignations_tg2)
                
                if places_tg1 > 0 and places_tg2 > 0:
                    # Opportunit√© de regroupement m√™me journ√©e
                    opportunites.append({
                        "type": "meme_journee",
                        "garde1": tg1,
                        "garde2": tg2,
                        "date1": date_str,
                        "date2": date_str,
                        "duree_totale": duree_totale
                    })
    
    # 2. JOURS CONS√âCUTIFS: Chercher des gardes sur jour J et J+1
    for tg1 in types_garde:
        for tg2 in types_garde:
            duree_totale = tg1.get("duree_heures", 8) + tg2.get("duree_heures", 8)
            
            if duree_totale <= duree_max:
                # V√©rifier qu'elles ne sont pas d√©j√† assign√©es
                assignations_tg1 = [a for a in existing_assignations 
                                   if a["date"] == date_str and a["type_garde_id"] == tg1["id"]]
                assignations_tg2 = [a for a in existing_assignations 
                                   if a["date"] == date_suivante_str and a["type_garde_id"] == tg2["id"]]
                
                places_tg1 = tg1.get("nombre_pompiers_requis", 1) - len(assignations_tg1)
                places_tg2 = tg2.get("nombre_pompiers_requis", 1) - len(assignations_tg2)
                
                if places_tg1 > 0 and places_tg2 > 0:
                    # Opportunit√© de regroupement jours cons√©cutifs
                    opportunites.append({
                        "type": "jours_consecutifs",
                        "garde1": tg1,
                        "garde2": tg2,
                        "date1": date_str,
                        "date2": date_suivante_str,
                        "duree_totale": duree_totale
                    })
    
    return opportunites

async def calculer_heures_employe_periode(user_id: str, tenant_id: str, date_reference: str, periode: str, jours_personnalises: int = 7):
    """
    Calcule les heures travaill√©es par un employ√© sur une p√©riode donn√©e
    
    Args:
        user_id: ID de l'employ√©
        tenant_id: ID du tenant
        date_reference: Date de r√©f√©rence (format YYYY-MM-DD)
        periode: Type de p√©riode ("semaine", "mois", "personnalise")
        jours_personnalises: Nombre de jours si p√©riode personnalis√©e
    
    Returns:
        Nombre d'heures travaill√©es sur la p√©riode
    """
    date_ref = datetime.strptime(date_reference, "%Y-%m-%d")
    
    # Calculer date_debut et date_fin selon la p√©riode
    if periode == "semaine":
        # Du lundi au dimanche de la semaine en cours
        date_debut = date_ref - timedelta(days=date_ref.weekday())
        date_fin = date_debut + timedelta(days=6)
    elif periode == "mois":
        # Du 1er au dernier jour du mois
        date_debut = date_ref.replace(day=1)
        # Dernier jour du mois
        if date_ref.month == 12:
            date_fin = date_ref.replace(day=31)
        else:
            date_fin = (date_ref.replace(month=date_ref.month + 1, day=1) - timedelta(days=1))
    else:  # personnalise
        # X jours glissants avant la date de r√©f√©rence
        date_debut = date_ref - timedelta(days=jours_personnalises - 1)
        date_fin = date_ref
    
    date_debut_str = date_debut.strftime("%Y-%m-%d")
    date_fin_str = date_fin.strftime("%Y-%m-%d")
    
    # R√©cup√©rer toutes les assignations de l'employ√© sur cette p√©riode
    assignations = await db.assignations.find({
        "user_id": user_id,
        "tenant_id": tenant_id,
        "date": {
            "$gte": date_debut_str,
            "$lte": date_fin_str
        }
    }).to_list(1000)
    
    # Calculer le total des heures
    total_heures = 0
    for assignation in assignations:
        # R√©cup√©rer le type de garde pour obtenir la dur√©e
        type_garde = await db.types_garde.find_one({"id": assignation["type_garde_id"]})
        if type_garde:
            total_heures += type_garde.get("duree_heures", 8)
    
    return total_heures

# Root route
@api_router.get("/")
async def root():
    return {"message": "ProFireManager API v2.0 - Multi-Tenant", "status": "running"}


# ==================== D√âBOGAGE MODELS ====================

class CommentaireDebogage(BaseModel):
    user_id: str
    user_name: str
    texte: str
    date: datetime

class HistoriqueStatut(BaseModel):
    ancien_statut: str
    nouveau_statut: str
    user_id: str
    user_name: str
    date: datetime

class BugReport(BaseModel):
    id: str
    titre: str
    description: str
    module: str  # Planning, Mes Disponibilit√©s, Personnel, etc.
    priorite: str  # critique, haute, moyenne, basse
    etapes_reproduction: str
    resultat_attendu: str
    resultat_observe: str
    navigateur: Optional[str] = None
    os: Optional[str] = None
    role_utilisateur: Optional[str] = None
    console_logs: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []  # URLs des images
    statut: str = "nouveau"  # nouveau, en_cours, test, resolu, ferme
    commentaires: Optional[List[dict]] = []
    historique_statuts: Optional[List[dict]] = []
    created_by: str
    created_by_name: str
    created_at: datetime
    updated_at: datetime
    tenant_slug: Optional[str] = None  # Si bug li√© √† un tenant sp√©cifique

class BugReportCreate(BaseModel):
    titre: str
    description: str
    module: str
    priorite: str
    etapes_reproduction: str
    resultat_attendu: str
    resultat_observe: str
    navigateur: Optional[str] = None
    os: Optional[str] = None
    role_utilisateur: Optional[str] = None
    console_logs: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []
    tenant_slug: Optional[str] = None

class FeatureRequest(BaseModel):
    id: str
    titre: str
    description: str
    probleme_a_resoudre: str
    solution_proposee: str
    alternatives: Optional[str] = None
    module: str
    priorite: str
    utilisateurs_concernes: List[str] = []  # admin, superviseur, employe, tous
    cas_usage: str
    dependances: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []
    statut: str = "nouveau"
    commentaires: Optional[List[dict]] = []
    historique_statuts: Optional[List[dict]] = []
    created_by: str
    created_by_name: str
    created_at: datetime
    updated_at: datetime

class FeatureRequestCreate(BaseModel):
    titre: str
    description: str
    probleme_a_resoudre: str
    solution_proposee: str
    alternatives: Optional[str] = None
    module: str
    priorite: str
    utilisateurs_concernes: List[str] = []
    cas_usage: str
    dependances: Optional[str] = None
    infos_supplementaires: Optional[str] = None
    images: Optional[List[str]] = []

class CommentaireDeDebogageCreate(BaseModel):
    texte: str

class ChangementStatut(BaseModel):
    nouveau_statut: str

# ==================== SUPER ADMIN DEPENDENCIES ====================

async def get_super_admin(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Authentifie et retourne le super admin"""
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        admin_id: str = payload.get("sub")
        role: str = payload.get("role")
        
        if role != "super_admin":
            raise HTTPException(status_code=403, detail="Acc√®s super admin requis")
            
        admin = await db.super_admins.find_one({"id": admin_id})
        if not admin:
            raise HTTPException(status_code=401, detail="Super admin non trouv√©")
        return SuperAdmin(**admin)
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token invalide")

# ==================== SUPER ADMIN ROUTES ====================
# Note: Super Admin routes MUST be defined before tenant routes to avoid conflicts

@api_router.post("/admin/auth/login")
async def super_admin_login(login: SuperAdminLogin):
    """Authentification du super admin avec migration automatique SHA256 -> bcrypt"""
    try:
        logging.info(f"üîë Tentative de connexion Super Admin: {login.email}")
        
        admin_data = await db.super_admins.find_one({"email": login.email})
        
        if not admin_data:
            logging.warning(f"‚ùå Super Admin non trouv√©: {login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"‚úÖ Super Admin trouv√©: {admin_data.get('nom')} (id: {admin_data.get('id')})")
        
        current_hash = admin_data.get("mot_de_passe_hash", "")
        hash_type = "bcrypt" if current_hash.startswith('$2') else "SHA256"
        logging.info(f"üîê Type de hash d√©tect√©: {hash_type}")
        
        if not verify_password(login.mot_de_passe, current_hash):
            logging.warning(f"‚ùå Mot de passe incorrect pour Super Admin {login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"‚úÖ Mot de passe v√©rifi√© avec succ√®s pour Super Admin {login.email}")
        
        admin = SuperAdmin(**admin_data)
        # Token avec expiration de 2h pour les super-admins (s√©curit√©)
        access_token = create_access_token(
            data={"sub": admin.id, "role": "super_admin"},
            expires_delta=timedelta(minutes=SUPER_ADMIN_TOKEN_EXPIRE_MINUTES)
        )
        
        logging.info(f"‚úÖ Token JWT cr√©√© pour Super Admin {login.email}")
        
        # Enregistrer l'action dans le journal d'audit
        await log_super_admin_action(
            admin=admin,
            action="login",
            details={"method": "password"}
        )
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "admin": {
                "id": admin.id,
                "email": admin.email,
                "nom": admin.nom
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur inattendue lors du login Super Admin pour {login.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

@api_router.get("/admin/auth/me")
async def get_super_admin_me(admin: SuperAdmin = Depends(get_super_admin)):
    """R√©cup√®re les informations du super admin authentifi√©"""
    return {
        "id": admin.id,
        "email": admin.email,
        "nom": admin.nom,
        "role": "super_admin"
    }

@api_router.get("/admin/tenants")
async def list_tenants(admin: SuperAdmin = Depends(get_super_admin)):
    """Liste toutes les casernes (actives et inactives) avec compteur de personnel"""
    # R√©cup√©rer TOUTES les casernes (pas de filtre) pour que le Super Admin puisse tout voir
    tenants_data = await db.tenants.find({}).to_list(100)
    
    # Ajouter le compteur d'employ√©s pour chaque tenant
    tenants_with_counts = []
    for tenant_data in tenants_data:
        # Supprimer _id (ObjectId non s√©rialisable)
        if '_id' in tenant_data:
            del tenant_data['_id']
        
        # Compter le nombre d'employ√©s
        nombre_employes = await db.users.count_documents({"tenant_id": tenant_data['id']})
        tenant_data['nombre_employes'] = nombre_employes
        
        # Normaliser le statut actif (g√©rer les deux champs actif et is_active)
        # Pour compatibilit√© avec anciennes et nouvelles donn√©es
        if 'is_active' not in tenant_data and 'actif' in tenant_data:
            tenant_data['is_active'] = tenant_data['actif']
        elif 'is_active' in tenant_data and 'actif' not in tenant_data:
            tenant_data['actif'] = tenant_data['is_active']
        
        tenants_with_counts.append(tenant_data)
    
    return tenants_with_counts

@api_router.get("/admin/stats")
async def get_global_stats(admin: SuperAdmin = Depends(get_super_admin)):
    """Statistiques globales avec calcul des revenus mensuels"""
    # R√©cup√©rer tous les tenants pour g√©rer les deux champs actif et is_active
    tous_tenants = await db.tenants.find({}).to_list(100)
    
    total_casernes_actives = 0
    total_casernes_inactives = 0
    tenants_actifs = []
    
    # Analyser chaque tenant pour d√©terminer son statut
    for tenant in tous_tenants:
        # Un tenant est actif si actif=True OU is_active=True
        is_active = tenant.get('actif', False) or tenant.get('is_active', False)
        
        if is_active:
            total_casernes_actives += 1
            tenants_actifs.append(tenant)
        else:
            total_casernes_inactives += 1
    
    # Calculer les revenus mensuels
    revenus_mensuels = 0
    total_pompiers = 0
    details_revenus = []
    
    for tenant in tenants_actifs:
        # Exclure la caserne "d√©monstration" du calcul des revenus (compte d√©mo client)
        tenant_slug = tenant.get('slug', '').lower()
        tenant_nom = tenant.get('nom', '').lower()
        
        is_demo = 'demonstration' in tenant_slug or 'demonstration' in tenant_nom or 'demo' in tenant_slug
        
        # Compter les pompiers de cette caserne
        user_count = await db.users.count_documents({"tenant_id": tenant["id"]})
        
        # Ajouter au total uniquement si ce n'est pas une caserne de d√©mo
        if not is_demo:
            total_pompiers += user_count
        
        # D√©terminer le prix par pompier selon le palier
        if user_count <= 30:
            prix_par_pompier = 12
        elif user_count <= 50:
            prix_par_pompier = 20
        else:
            prix_par_pompier = 27
        
        # Calculer le revenu pour cette caserne (0 si d√©mo)
        revenu_caserne = 0 if is_demo else (user_count * prix_par_pompier)
        revenus_mensuels += revenu_caserne
        
        details_revenus.append({
            "caserne": tenant["nom"],
            "pompiers": user_count,
            "prix_par_pompier": prix_par_pompier if not is_demo else 0,
            "revenu_mensuel": revenu_caserne,
            "is_demo": is_demo
        })
    
    return {
        "casernes_actives": total_casernes_actives,
        "casernes_inactives": total_casernes_inactives,
        "total_pompiers": total_pompiers,
        "revenus_mensuels": revenus_mensuels,
        "details_par_caserne": details_revenus
    }


@api_router.get("/admin/tenants/by-slug/{tenant_slug}")
async def get_tenant_by_slug(tenant_slug: str):
    """R√©cup√©rer un tenant par son slug (pour r√©cup√©rer les param√®tres)"""
    tenant = await db.tenants.find_one({"slug": tenant_slug})
    if not tenant:
        raise HTTPException(status_code=404, detail="Tenant non trouv√©")
    
    return clean_mongo_doc(tenant)

@api_router.post("/admin/tenants")
async def create_tenant(tenant_create: TenantCreate, admin: SuperAdmin = Depends(get_super_admin)):
    """Cr√©er une nouvelle caserne"""
    # V√©rifier que le slug est unique
    existing = await db.tenants.find_one({"slug": tenant_create.slug})
    if existing:
        raise HTTPException(status_code=400, detail="Ce slug est d√©j√† utilis√©")
    
    # Cr√©er le tenant avec date personnalis√©e si fournie
    tenant_data = tenant_create.dict()
    if tenant_data.get('date_creation'):
        # Convertir la date string en datetime
        from datetime import datetime as dt
        tenant_data['date_creation'] = dt.fromisoformat(tenant_data['date_creation']).replace(tzinfo=timezone.utc)
    else:
        tenant_data['date_creation'] = datetime.now(timezone.utc)
    
    tenant = Tenant(**tenant_data)
    await db.tenants.insert_one(tenant.dict())
    
    # Enregistrer l'action dans le journal d'audit
    await log_super_admin_action(
        admin=admin,
        action="tenant_create",
        details={"tenant_slug": tenant.slug, "tenant_nom": tenant.nom},
        tenant_id=tenant.id,
        tenant_slug=tenant.slug,
        tenant_nom=tenant.nom
    )
    
    return {"message": f"Caserne '{tenant.nom}' cr√©√©e avec succ√®s", "tenant": tenant}

@api_router.put("/admin/tenants/{tenant_id}")
async def update_tenant(
    tenant_id: str, 
    tenant_update: dict,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Modifier une caserne"""
    update_data = tenant_update.copy()
    
    # R√©cup√©rer le tenant avant modification pour l'audit
    tenant_before = await db.tenants.find_one({"id": tenant_id})
    
    # Supprimer les champs calcul√©s qui ne doivent pas √™tre sauvegard√©s
    if 'nombre_employes' in update_data:
        del update_data['nombre_employes']
    if '_id' in update_data:
        del update_data['_id']
    
    # G√©rer la date_creation si modifi√©e
    if update_data.get('date_creation') and isinstance(update_data['date_creation'], str):
        from datetime import datetime as dt
        update_data['date_creation'] = dt.fromisoformat(update_data['date_creation']).replace(tzinfo=timezone.utc)
    
    result = await db.tenants.update_one(
        {"id": tenant_id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Caserne non trouv√©e")
    
    # Enregistrer l'action dans le journal d'audit
    if tenant_before:
        await log_super_admin_action(
            admin=admin,
            action="tenant_update",
            details={"fields_updated": list(update_data.keys())},
            tenant_id=tenant_id,
            tenant_slug=tenant_before.get("slug"),
            tenant_nom=tenant_before.get("nom")
        )
    
    return {"message": "Caserne mise √† jour avec succ√®s"}

@api_router.post("/admin/tenants/{tenant_id}/create-admin")
async def create_tenant_admin(tenant_id: str, user_data: dict, admin: SuperAdmin = Depends(get_super_admin)):
    """Cr√©er un administrateur pour une caserne"""
    # V√©rifier que la caserne existe
    tenant = await db.tenants.find_one({"id": tenant_id})
    if not tenant:
        raise HTTPException(status_code=404, detail="Caserne non trouv√©e")
    
    # V√©rifier que l'email n'existe pas d√©j√†
    existing_user = await db.users.find_one({"email": user_data["email"]})
    if existing_user:
        raise HTTPException(status_code=400, detail="Un utilisateur avec cet email existe d√©j√†")
    
    # Cr√©er l'utilisateur administrateur
    new_user = User(
        id=str(uuid.uuid4()),
        tenant_id=tenant_id,
        email=user_data["email"],
        prenom=user_data["prenom"],
        nom=user_data["nom"],
        mot_de_passe_hash=get_password_hash(user_data["mot_de_passe"]),
        role="admin",
        grade="Directeur",
        type_emploi="temps_plein",
        statut="Actif",
        numero_employe="ADMIN-" + str(uuid.uuid4())[:8].upper(),
        date_embauche=datetime.now(timezone.utc).strftime("%Y-%m-%d")
    )
    
    await db.users.insert_one(new_user.dict())
    
    # Envoyer l'email de bienvenue (sans bloquer si √ßa √©choue)
    try:
        send_welcome_email(
            user_email=new_user.email,
            user_name=f"{new_user.prenom} {new_user.nom}",
            user_role=new_user.role,
            temp_password=user_data["mot_de_passe"],
            tenant_slug=tenant['slug']
        )
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur envoi email de bienvenue: {e}")
        # Continue m√™me si l'email √©choue
    
    return {
        "message": "Administrateur cr√©√© avec succ√®s",
        "user": {
            "id": new_user.id,
            "email": new_user.email,
            "nom": new_user.nom,
            "prenom": new_user.prenom,
            "role": new_user.role
        }
    }

@api_router.get("/admin/tenants/{tenant_id}/deletion-impact")
async def get_deletion_impact(tenant_id: str, admin: SuperAdmin = Depends(get_super_admin)):
    """Obtenir l'impact de la suppression d'une caserne (nombre de donn√©es affect√©es)"""
    tenant = await db.tenants.find_one({"id": tenant_id})
    if not tenant:
        raise HTTPException(status_code=404, detail="Caserne non trouv√©e")
    
    # Compter toutes les donn√©es qui seront supprim√©es
    users_count = await db.users.count_documents({"tenant_id": tenant_id})
    assignations_count = await db.assignations.count_documents({"tenant_id": tenant_id})
    formations_count = await db.formations.count_documents({"tenant_id": tenant_id})
    epi_count = await db.epi_employes.count_documents({"tenant_id": tenant_id})
    gardes_count = await db.types_garde.count_documents({"tenant_id": tenant_id})
    disponibilites_count = await db.disponibilites.count_documents({"tenant_id": tenant_id})
    conges_count = await db.demandes_conge.count_documents({"tenant_id": tenant_id})
    
    return {
        "tenant": {
            "id": tenant["id"],
            "nom": tenant["nom"],
            "slug": tenant["slug"]
        },
        "impact": {
            "utilisateurs": users_count,
            "assignations": assignations_count,
            "formations": formations_count,
            "epi": epi_count,
            "gardes": gardes_count,
            "disponibilites": disponibilites_count,
            "conges": conges_count
        }
    }

@api_router.delete("/admin/tenants/{tenant_id}")
async def delete_tenant_permanently(tenant_id: str, admin: SuperAdmin = Depends(get_super_admin)):
    """Supprimer d√©finitivement une caserne et toutes ses donn√©es"""
    tenant = await db.tenants.find_one({"id": tenant_id})
    if not tenant:
        raise HTTPException(status_code=404, detail="Caserne non trouv√©e")
    
    # Supprimer toutes les donn√©es associ√©es
    users_result = await db.users.delete_many({"tenant_id": tenant_id})
    await db.assignations.delete_many({"tenant_id": tenant_id})
    await db.formations.delete_many({"tenant_id": tenant_id})
    await db.epi_employes.delete_many({"tenant_id": tenant_id})
    await db.types_garde.delete_many({"tenant_id": tenant_id})
    await db.disponibilites.delete_many({"tenant_id": tenant_id})
    await db.demandes_conge.delete_many({"tenant_id": tenant_id})
    await db.demandes_remplacement.delete_many({"tenant_id": tenant_id})
    await db.notifications.delete_many({"tenant_id": tenant_id})
    await db.parametres.delete_many({"tenant_id": tenant_id})
    await db.sessions_formation.delete_many({"tenant_id": tenant_id})
    
    # Supprimer le tenant
    await db.tenants.delete_one({"id": tenant_id})
    
    return {
        "message": f"Caserne '{tenant['nom']}' et toutes ses donn√©es ont √©t√© supprim√©es d√©finitivement",
        "deleted": {
            "tenant": tenant["nom"],
            "users": users_result.deleted_count
        }
    }


# ==================== TENANT-SPECIFIC ROUTES ====================
# Note: Tenant routes are defined after Super Admin routes to avoid conflicts

# Route de compatibilit√© (OLD - sans tenant dans URL)
@api_router.post("/auth/login")
async def login_legacy(user_login: UserLogin):
    """Login legacy - redirige automatiquement vers le tenant de l'utilisateur avec migration automatique SHA256 -> bcrypt"""
    try:
        logging.info(f"üîë Tentative de connexion legacy pour {user_login.email}")
        
        user_data = await db.users.find_one({"email": user_login.email})
        
        if not user_data:
            logging.warning(f"‚ùå Utilisateur non trouv√© (legacy): {user_login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"‚úÖ Utilisateur trouv√© (legacy): {user_data.get('nom')} {user_data.get('prenom')} (id: {user_data.get('id')})")
        
        current_hash = user_data.get("mot_de_passe_hash", "")
        hash_type = "bcrypt" if current_hash.startswith('$2') else "SHA256"
        logging.info(f"üîê Type de hash d√©tect√©: {hash_type}")
        
        if not verify_password(user_login.mot_de_passe, current_hash):
            logging.warning(f"‚ùå Mot de passe incorrect (legacy) pour {user_login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"‚úÖ Mot de passe v√©rifi√© avec succ√®s (legacy) pour {user_login.email}")
        
        user = User(**user_data)
        tenant_data = await db.tenants.find_one({"id": user.tenant_id})
        
        if not tenant_data:
            logging.error(f"‚ùå Tenant non trouv√© pour l'utilisateur {user_login.email}")
            raise HTTPException(status_code=404, detail="Caserne non trouv√©e")
        
        tenant = Tenant(**tenant_data)
        access_token = create_access_token(data={
            "sub": user.id,
            "tenant_id": tenant.id,
            "tenant_slug": tenant.slug
        })
        
        logging.info(f"‚úÖ Token JWT cr√©√© (legacy) pour {user_login.email}")
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "tenant": {
                "id": tenant.id,
                "slug": tenant.slug,
                "nom": tenant.nom,
                "parametres": tenant.parametres  # Inclure les param√®tres du tenant
            },
            "user": {
                "id": user.id,
                "nom": user.nom,
                "prenom": user.prenom,
                "email": user.email,
                "role": user.role,
                "grade": user.grade,
                "type_emploi": user.type_emploi,
                "photo_profil": user.photo_profil  # Ajouter la photo de profil
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur inattendue lors du login legacy pour {user_login.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

@api_router.get("/{tenant_slug}/auth/me")
async def get_current_user_info(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant (optionnel ici car d√©j√† valid√© dans le token)
    tenant = await get_tenant_from_slug(tenant_slug)
    
    return {
        "id": current_user.id,
        "tenant_id": current_user.tenant_id,
        "nom": current_user.nom,
        "prenom": current_user.prenom,
        "email": current_user.email,
        "role": current_user.role,
        "grade": current_user.grade,
        "type_emploi": current_user.type_emploi,
        "formations": current_user.formations,
        "photo_profil": current_user.photo_profil
    }


# ==================== SUPER ADMIN MANAGEMENT ROUTES ====================

@api_router.get("/admin/super-admins")
async def list_super_admins(admin: SuperAdmin = Depends(get_super_admin)):
    """Liste tous les super admins"""
    super_admins = await db.super_admins.find().to_list(1000)
    return [clean_mongo_doc(sa) for sa in super_admins]

@api_router.post("/admin/super-admins")
async def create_super_admin(
    super_admin_data: dict,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Cr√©er un nouveau super admin"""
    # Valider les donn√©es
    if not all(key in super_admin_data for key in ['email', 'prenom', 'nom', 'mot_de_passe']):
        raise HTTPException(status_code=400, detail="Tous les champs sont obligatoires")
    
    # V√©rifier si l'email existe d√©j√†
    existing = await db.super_admins.find_one({"email": super_admin_data['email']})
    if existing:
        raise HTTPException(status_code=400, detail="Cet email est d√©j√† utilis√©")
    
    # Valider la complexit√© du mot de passe
    if not validate_complex_password(super_admin_data['mot_de_passe']):
        raise HTTPException(
            status_code=400,
            detail="Le mot de passe doit contenir au moins 8 caract√®res, une majuscule, un chiffre et un caract√®re sp√©cial"
        )
    
    # Cr√©er le super admin
    temp_password = super_admin_data['mot_de_passe']  # Garder le mot de passe temporaire pour l'email
    full_name = f"{super_admin_data['prenom']} {super_admin_data['nom']}"
    new_super_admin = SuperAdmin(
        email=super_admin_data['email'],
        nom=full_name,
        mot_de_passe_hash=get_password_hash(temp_password)
    )
    
    await db.super_admins.insert_one(new_super_admin.dict())
    
    logging.info(f"‚úÖ Super admin cr√©√©: {new_super_admin.email}")
    
    # Envoyer l'email de bienvenue
    user_name = new_super_admin.nom
    email_sent = send_super_admin_welcome_email(
        new_super_admin.email,
        user_name,
        temp_password
    )
    
    if email_sent:
        logging.info(f"‚úÖ Email de bienvenue super admin envoy√© √† {new_super_admin.email}")
    else:
        logging.warning(f"‚ö†Ô∏è Email non envoy√© √† {new_super_admin.email} (Resend non configur√© ou erreur)")
    
    return {"message": "Super admin cr√©√© avec succ√®s", "id": new_super_admin.id, "email_sent": email_sent}

@api_router.delete("/admin/super-admins/{super_admin_id}")
async def delete_super_admin(
    super_admin_id: str,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Supprimer un super admin"""
    # Emp√™cher la suppression de soi-m√™me
    if super_admin_id == admin.id:
        raise HTTPException(status_code=400, detail="Vous ne pouvez pas supprimer votre propre compte")
    
    # V√©rifier qu'il reste au moins un autre super admin
    count = await db.super_admins.count_documents({})
    if count <= 1:
        raise HTTPException(status_code=400, detail="Impossible de supprimer le dernier super admin")
    
    # Supprimer
    result = await db.super_admins.delete_one({"id": super_admin_id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Super admin non trouv√©")
    
    logging.info(f"‚úÖ Super admin supprim√©: {super_admin_id}")
    
    return {"message": "Super admin supprim√© avec succ√®s"}

@api_router.put("/admin/super-admins/{super_admin_id}")
async def update_super_admin(
    super_admin_id: str,
    update_data: dict,
    admin: SuperAdmin = Depends(get_super_admin)
):
    """Modifier les informations d'un super admin"""
    # V√©rifier que le super admin existe
    existing = await db.super_admins.find_one({"id": super_admin_id})
    if not existing:
        raise HTTPException(status_code=404, detail="Super admin non trouv√©")
    
    # Pr√©parer les donn√©es √† mettre √† jour
    update_fields = {}
    if "prenom" in update_data and update_data["prenom"]:
        update_fields["prenom"] = update_data["prenom"]
    if "nom" in update_data and update_data["nom"]:
        update_fields["nom"] = update_data["nom"]
    
    if not update_fields:
        raise HTTPException(status_code=400, detail="Aucune donn√©e √† mettre √† jour")
    
    # Mettre √† jour
    await db.super_admins.update_one(
        {"id": super_admin_id},
        {"$set": update_fields}
    )
    
    logging.info(f"‚úÖ Super admin modifi√©: {super_admin_id}")
    
    return {"message": "Super admin modifi√© avec succ√®s"}

# User management routes
@api_router.post("/{tenant_slug}/users", response_model=User)
async def create_user(tenant_slug: str, user_create: UserCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√âRIFIER LA LIMITE DU PALIER
    current_count = await db.users.count_documents({"tenant_id": tenant.id})
    
    # D√©terminer le palier actuel
    if current_count < 30:
        palier = "Basic (1-30)"
        limite = 30
        prix = "12$"
    elif current_count < 50:
        palier = "Standard (31-50)"
        limite = 50
        prix = "20$"
    else:
        palier = "Premium (51+)"
        limite = None
        prix = "27$"
    
    # Bloquer si la limite du palier est atteinte
    if limite and current_count >= limite:
        # Envoyer email au super admin via Resend
        super_admin_email = "gussdub@icloud.com"
        try:
            resend_api_key = os.environ.get('RESEND_API_KEY')
            if resend_api_key:
                resend.api_key = resend_api_key
                
                params = {
                    "from": os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca'),
                    "to": [super_admin_email],
                    "subject": f'‚ö†Ô∏è Limite de palier atteinte - {tenant.nom}',
                    "html": f"""
                    <h2>Alerte - Limite de palier atteinte</h2>
                    <p><strong>Caserne:</strong> {tenant.nom} ({tenant_slug})</p>
                    <p><strong>Palier actuel:</strong> {palier}</p>
                    <p><strong>Personnel actuel:</strong> {current_count}/{limite}</p>
                    <p><strong>Prix actuel:</strong> {prix}/mois</p>
                    <p>L'administrateur a tent√© de cr√©er un {current_count + 1}e pompier mais la limite est atteinte.</p>
                    <p><strong>Action requise:</strong> Contacter le client pour upgrade vers palier sup√©rieur.</p>
                    """
                }
                resend.Emails.send(params)
        except Exception as e:
            print(f"Erreur envoi email super admin: {str(e)}")
        
        raise HTTPException(
            status_code=403, 
            detail=f"Limite du palier {palier} atteinte ({current_count}/{limite}). Contactez l'administrateur pour upgrader votre forfait."
        )
    
    # Validation du mot de passe complexe
    if not validate_complex_password(user_create.mot_de_passe):
        raise HTTPException(
            status_code=400, 
            detail="Le mot de passe doit contenir au moins 8 caract√®res, une majuscule, un chiffre et un caract√®re sp√©cial (!@#$%^&*+-?())"
        )
    
    # Check if user already exists DANS CE TENANT
    existing_user = await db.users.find_one({"email": user_create.email, "tenant_id": tenant.id})
    if existing_user:
        raise HTTPException(status_code=400, detail="Cet email est d√©j√† utilis√© dans cette caserne")
    
    user_dict = user_create.dict()
    temp_password = user_dict["mot_de_passe"]  # Sauvegarder pour l'email
    user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
    user_dict["tenant_id"] = tenant.id  # Assigner le tenant
    
    # CORRECTION CRITIQUE: Synchroniser formations vers competences
    # Le frontend utilise "formations" mais l'algorithme cherche dans "competences"
    if "formations" in user_dict:
        user_dict["competences"] = user_dict["formations"]
        logging.info(f"üîÑ [SYNC CREATE] Copie formations ‚Üí competences: {user_dict['formations']}")
    
    user_obj = User(**user_dict)
    
    await db.users.insert_one(user_obj.dict())
    
    # Cr√©er une activit√©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="personnel_creation",
        description=f"üë§ {current_user.prenom} {current_user.nom} a ajout√© {user_create.prenom} {user_create.nom} ({user_create.grade}) au personnel",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    # Envoyer l'email de bienvenue
    try:
        user_name = f"{user_create.prenom} {user_create.nom}"
        email_sent = send_welcome_email(user_create.email, user_name, user_create.role, temp_password, tenant_slug)
        
        if email_sent:
            print(f"Email de bienvenue envoy√© √† {user_create.email}")
        else:
            print(f"√âchec envoi email √† {user_create.email}")
            
    except Exception as e:
        print(f"Erreur lors de l'envoi de l'email: {str(e)}")
        # Ne pas √©chouer la cr√©ation du compte si l'email √©choue
    
    return user_obj

@api_router.post("/{tenant_slug}/users/import-csv")
async def import_users_csv(
    tenant_slug: str,
    users_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse d'utilisateurs/personnel depuis un CSV"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    users = users_data.get("users", [])
    if not users:
        raise HTTPException(status_code=400, detail="Aucun utilisateur √† importer")
    
    # V√©rifier la limite du palier
    current_count = await db.users.count_documents({"tenant_id": tenant.id})
    total_to_import = len(users)
    
    if current_count < 30:
        limite = 30
        palier = "Basic (1-30)"
    elif current_count < 50:
        limite = 50
        palier = "Standard (31-50)"
    else:
        limite = None
        palier = "Premium (51+)"
    
    if limite and (current_count + total_to_import) > limite:
        raise HTTPException(
            status_code=403,
            detail=f"Import refus√©: d√©passement du palier {palier}. Vous avez {current_count} utilisateurs, tentative d'import de {total_to_import}. Limite: {limite}."
        )
    
    results = {
        "total": total_to_import,
        "created": 0,
        "updated": 0,
        "errors": [],
        "duplicates": [],
        "password_reset_emails": []
    }
    
    # Pr√©charger tous les utilisateurs pour matching intelligent
    existing_users_list = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    users_by_email = {u.get("email", "").lower(): u for u in existing_users_list if u.get("email")}
    users_by_name = create_user_matching_index(existing_users_list)
    users_by_num = {u.get("numero_employe"): u for u in existing_users_list if u.get("numero_employe")}
    
    for index, user_data in enumerate(users):
        try:
            # Validation des champs obligatoires
            if not user_data.get("prenom") or not user_data.get("nom") or not user_data.get("email"):
                results["errors"].append({
                    "line": index + 1,
                    "error": "Pr√©nom, Nom et Email sont requis",
                    "data": user_data
                })
                continue
            
            # V√©rifier si l'utilisateur existe d√©j√† (strat√©gie multi-niveaux)
            existing_user = None
            
            # Niveau 1 : Par email (priorit√© haute - identifiant unique)
            if user_data.get("email"):
                email_normalized = user_data["email"].lower().strip()
                existing_user = users_by_email.get(email_normalized)
            
            # Niveau 2 : Par num√©ro d'employ√© (si email absent ou pas trouv√©)
            if not existing_user and user_data.get("numero_employe"):
                num_employe = user_data["numero_employe"].strip()
                existing_user = users_by_num.get(num_employe)
            
            # Niveau 3 : Par nom complet avec matching intelligent (fallback)
            if not existing_user and user_data.get("prenom") and user_data.get("nom"):
                # Construire la cha√Æne de recherche
                search_string = f"{user_data['prenom']} {user_data['nom']}"
                if user_data.get("numero_employe"):
                    search_string += f" ({user_data['numero_employe']})"
                
                existing_user = find_user_intelligent(
                    search_string=search_string,
                    users_by_name=users_by_name,
                    users_by_num=users_by_num,
                    numero_field="numero_employe"
                )
            
            if existing_user:
                results["duplicates"].append({
                    "line": index + 1,
                    "email": user_data["email"],
                    "action": user_data.get("action_doublon", "skip"),
                    "data": user_data
                })
                
                # Si action_doublon = update, mettre √† jour
                if user_data.get("action_doublon") == "update":
                    update_data = {
                        "prenom": user_data["prenom"],
                        "nom": user_data["nom"],
                        "numero_employe": user_data.get("numero_employe", ""),
                        "grade": user_data.get("grade", ""),
                        "type_emploi": user_data.get("type_emploi", "temps_plein"),
                        "telephone": user_data.get("telephone", ""),
                        "adresse": user_data.get("adresse", ""),
                        "role": user_data.get("role", "employe"),
                        "accepte_gardes_externes": user_data.get("accepte_gardes_externes", False)
                    }
                    
                    # Champs optionnels
                    if user_data.get("date_embauche"):
                        update_data["date_embauche"] = user_data["date_embauche"]
                    if user_data.get("taux_horaire"):
                        update_data["taux_horaire"] = float(user_data["taux_horaire"])
                    if user_data.get("competences"):
                        update_data["competences"] = user_data["competences"].split(",") if isinstance(user_data["competences"], str) else user_data["competences"]
                    
                    # Contact d'urgence
                    if user_data.get("contact_urgence_nom"):
                        update_data["contact_urgence"] = {
                            "nom": user_data.get("contact_urgence_nom", ""),
                            "telephone": user_data.get("contact_urgence_telephone", ""),
                            "relation": user_data.get("contact_urgence_relation", "")
                        }
                    
                    await db.users.update_one(
                        {"id": existing_user["id"], "tenant_id": tenant.id},
                        {"$set": update_data}
                    )
                    results["updated"] += 1
                else:
                    # skip par d√©faut
                    continue
            
            # Cr√©er l'utilisateur s'il n'existe pas
            if not existing_user:
                # G√©n√©rer un mot de passe temporaire
                temp_password = f"Temp{str(uuid.uuid4())[:8]}!"
                
                new_user = {
                    "id": str(uuid.uuid4()),
                    "tenant_id": tenant.id,
                    "email": user_data["email"],
                    "prenom": user_data["prenom"],
                    "nom": user_data["nom"],
                    "numero_employe": user_data.get("numero_employe", ""),
                    "grade": user_data.get("grade", ""),
                    "type_emploi": user_data.get("type_emploi", "temps_plein"),
                    "telephone": user_data.get("telephone", ""),
                    "adresse": user_data.get("adresse", ""),
                    "role": user_data.get("role", "employe"),
                    "accepte_gardes_externes": user_data.get("accepte_gardes_externes", False),
                    "mot_de_passe_hash": get_password_hash(temp_password),
                    "heures_internes": 0,
                    "heures_externes": 0,
                    "created_at": datetime.now(timezone.utc).isoformat()
                }
                
                # Champs optionnels
                if user_data.get("date_embauche"):
                    new_user["date_embauche"] = user_data["date_embauche"]
                if user_data.get("taux_horaire"):
                    new_user["taux_horaire"] = float(user_data["taux_horaire"])
                if user_data.get("competences"):
                    new_user["competences"] = user_data["competences"].split(",") if isinstance(user_data["competences"], str) else user_data["competences"]
                
                # Contact d'urgence
                if user_data.get("contact_urgence_nom"):
                    new_user["contact_urgence"] = {
                        "nom": user_data.get("contact_urgence_nom", ""),
                        "telephone": user_data.get("contact_urgence_telephone", ""),
                        "relation": user_data.get("contact_urgence_relation", "")
                    }
                
                await db.users.insert_one(new_user)
                results["created"] += 1
                
                # Envoyer email de r√©initialisation de mot de passe
                try:
                    # Cr√©er un token de r√©initialisation
                    reset_token = str(uuid.uuid4())
                    await db.password_resets.insert_one({
                        "email": user_data["email"],
                        "tenant_id": tenant.id,
                        "token": reset_token,
                        "created_at": datetime.now(timezone.utc),
                        "expires_at": datetime.now(timezone.utc) + timedelta(days=7)
                    })
                    
                    # Envoyer l'email (fonction √† impl√©menter selon votre syst√®me d'emails)
                    reset_url = f"{os.environ.get('FRONTEND_URL')}/reset-password?token={reset_token}"
                    # send_password_reset_email(user_data["email"], reset_url)
                    
                    results["password_reset_emails"].append({
                        "email": user_data["email"],
                        "reset_url": reset_url
                    })
                except Exception as e:
                    results["errors"].append({
                        "line": index + 1,
                        "error": f"Utilisateur cr√©√© mais email non envoy√©: {str(e)}",
                        "data": user_data
                    })
        
        except Exception as e:
            results["errors"].append({
                "line": index + 1,
                "error": str(e),
                "data": user_data
            })
    
    return results


# ============== ROUTES MIGR√âES VERS routes/personnel.py ==============
# Les routes suivantes sont maintenant g√©r√©es par le module routes/personnel.py
# GET  /{tenant_slug}/users - Liste utilisateurs
# GET  /{tenant_slug}/users/{user_id} - D√©tail utilisateur  
# POST /{tenant_slug}/users - Cr√©er utilisateur
# PUT  /{tenant_slug}/users/{user_id} - Modifier utilisateur
# DELETE /{tenant_slug}/users/{user_id} - Supprimer utilisateur
# =====================================================================

# Route legacy comment√©e - migr√©e vers routes/personnel.py
# @api_router.get("/{tenant_slug}/users", response_model=List[User])
# async def get_users(tenant_slug: str, current_user: User = Depends(get_current_user)):
#     tenant = await get_tenant_from_slug(tenant_slug)
#     users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
#     cleaned_users = [clean_mongo_doc(user) for user in users]
#     return [User(**user) for user in cleaned_users]

# Route legacy comment√©e - migr√©e vers routes/personnel.py
# @api_router.get("/{tenant_slug}/users/{user_id}", response_model=User)
# async def get_user(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
#     if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
#         raise HTTPException(status_code=403, detail="Acc√®s refus√©")
#     tenant = await get_tenant_from_slug(tenant_slug)
#     user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
#     if not user:
#         raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
#     user = clean_mongo_doc(user)
#     return User(**user)

class ProfileUpdate(BaseModel):
    prenom: str
    nom: str
    email: str
    telephone: str = ""
    adresse: str = ""
    contact_urgence: str = ""
    heures_max_semaine: int = 25
    tailles_epi: Optional[Dict[str, str]] = None  # Tailles EPI de l'employ√©

@api_router.put("/{tenant_slug}/users/mon-profil", response_model=User)
async def update_mon_profil(
    tenant_slug: str,
    profile_data: ProfileUpdate,
    current_user: User = Depends(get_current_user)
):
    """
    Permet √† un utilisateur de modifier son propre profil
    """
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # L'utilisateur peut modifier son propre profil
        # Utiliser exclude_unset=True pour ne mettre √† jour que les champs modifi√©s
        update_data = profile_data.dict(exclude_unset=True)
        
        if not update_data:
            # Aucune modification
            updated_user = await db.users.find_one({"id": current_user.id, "tenant_id": tenant.id})
            updated_user = clean_mongo_doc(updated_user)
            return User(**updated_user)
        
        result = await db.users.update_one(
            {"id": current_user.id, "tenant_id": tenant.id}, 
            {"$set": update_data}
        )
        
        if result.matched_count == 0:
            raise HTTPException(status_code=404, detail="Profil non trouv√©")
        
        # R√©cup√©rer le profil mis √† jour
        updated_user = await db.users.find_one({"id": current_user.id, "tenant_id": tenant.id})
        updated_user = clean_mongo_doc(updated_user)
        return User(**updated_user)
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise √† jour profil: {str(e)}")

# ==================== PHOTO DE PROFIL ====================

class PhotoProfilUpload(BaseModel):
    photo_base64: str  # Image en base64 (data:image/jpeg;base64,... ou juste le base64)

def resize_and_compress_image(base64_string: str, max_size: int = 200) -> str:
    """
    Redimensionne et compresse une image base64 √† max_size x max_size pixels
    Retourne une image JPEG en base64
    """
    try:
        # Nettoyer le pr√©fixe data:image si pr√©sent
        if ',' in base64_string:
            base64_string = base64_string.split(',')[1]
        
        # D√©coder le base64
        image_data = base64.b64decode(base64_string)
        
        # V√©rifier la taille (max 10MB - sera compress√©e)
        if len(image_data) > 10 * 1024 * 1024:
            raise ValueError("Image trop volumineuse (max 10MB)")
        
        # Ouvrir l'image avec PIL
        img = PILImage.open(BytesIO(image_data))
        
        # Convertir en RGB si n√©cessaire (pour les PNG avec transparence)
        if img.mode in ('RGBA', 'P'):
            img = img.convert('RGB')
        
        # Redimensionner en carr√© (crop au centre puis resize)
        width, height = img.size
        min_dim = min(width, height)
        
        # Crop au centre
        left = (width - min_dim) // 2
        top = (height - min_dim) // 2
        right = left + min_dim
        bottom = top + min_dim
        img = img.crop((left, top, right, bottom))
        
        # Redimensionner √† max_size x max_size
        img = img.resize((max_size, max_size), PILImage.Resampling.LANCZOS)
        
        # Sauvegarder en JPEG avec compression
        buffer = BytesIO()
        img.save(buffer, format='JPEG', quality=85, optimize=True)
        buffer.seek(0)
        
        # Encoder en base64
        result_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
        return f"data:image/jpeg;base64,{result_base64}"
        
    except Exception as e:
        raise ValueError(f"Erreur traitement image: {str(e)}")

@api_router.post("/{tenant_slug}/users/photo-profil")
async def upload_photo_profil(
    tenant_slug: str,
    photo_data: PhotoProfilUpload,
    current_user: User = Depends(get_current_user)
):
    """
    Upload une photo de profil pour l'utilisateur connect√©
    Redimensionne automatiquement √† 200x200 pixels
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Traiter et redimensionner l'image
        processed_photo = resize_and_compress_image(photo_data.photo_base64)
        
        # Mettre √† jour l'utilisateur
        result = await db.users.update_one(
            {"id": current_user.id, "tenant_id": tenant.id},
            {"$set": {"photo_profil": processed_photo}}
        )
        
        if result.matched_count == 0:
            raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
        
        return {"message": "Photo de profil mise √† jour", "photo_profil": processed_photo}
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur upload photo: {str(e)}")

@api_router.post("/{tenant_slug}/users/{user_id}/photo-profil")
async def upload_photo_profil_admin(
    tenant_slug: str,
    user_id: str,
    photo_data: PhotoProfilUpload,
    current_user: User = Depends(get_current_user)
):
    """
    Upload une photo de profil pour un utilisateur (Admin uniquement)
    """
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin requis")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # V√©rifier que l'utilisateur existe
        user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        if not user:
            raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
        
        # Traiter et redimensionner l'image
        processed_photo = resize_and_compress_image(photo_data.photo_base64)
        
        # Mettre √† jour l'utilisateur
        await db.users.update_one(
            {"id": user_id, "tenant_id": tenant.id},
            {"$set": {"photo_profil": processed_photo}}
        )
        
        return {"message": "Photo de profil mise √† jour", "photo_profil": processed_photo}
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur upload photo: {str(e)}")

@api_router.delete("/{tenant_slug}/users/photo-profil")
async def delete_photo_profil(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """
    Supprime la photo de profil de l'utilisateur connect√©
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.users.update_one(
        {"id": current_user.id, "tenant_id": tenant.id},
        {"$set": {"photo_profil": None}}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    return {"message": "Photo de profil supprim√©e"}

@api_router.delete("/{tenant_slug}/users/{user_id}/photo-profil")
async def delete_photo_profil_admin(
    tenant_slug: str,
    user_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Supprime la photo de profil d'un utilisateur (Admin uniquement)
    """
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin requis")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.users.update_one(
        {"id": user_id, "tenant_id": tenant.id},
        {"$set": {"photo_profil": None}}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    return {"message": "Photo de profil supprim√©e"}

# Route legacy comment√©e - migr√©e vers routes/personnel.py
# @api_router.put("/{tenant_slug}/users/{user_id}", response_model=User)
# async def update_user(tenant_slug: str, user_id: str, user_update: UserUpdate, current_user: User = Depends(get_current_user)):
#     ... (voir routes/personnel.py pour l'impl√©mentation compl√®te)

# Route legacy comment√©e - migr√©e vers routes/personnel.py
# @api_router.delete("/{tenant_slug}/users/{user_id}")
# async def delete_user(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
#     ... (voir routes/personnel.py pour l'impl√©mentation compl√®te)


@api_router.get("/{tenant_slug}/users/{user_id}/statistiques-interventions")
async def get_user_intervention_stats(
    tenant_slug: str,
    user_id: str,
    annee: int = None,
    current_user: User = Depends(get_current_user)
):
    """
    R√©cup√®re les statistiques d'interventions d'un employ√© :
    - Nombre total d'interventions
    - Taux de pr√©sence
    - Primes de repas
    - D√©tail par mois
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que l'utilisateur existe
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    # Ann√©e par d√©faut = ann√©e courante
    if not annee:
        annee = datetime.now().year
    
    # D√©finir la p√©riode
    date_debut = datetime(annee, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
    date_fin = datetime(annee, 12, 31, 23, 59, 59, tzinfo=timezone.utc)
    
    # R√©cup√©rer toutes les interventions de l'ann√©e
    interventions = await db.interventions.find({
        "tenant_id": tenant.id,
        "status": "signed",
        "xml_time_call_received": {"$gte": date_debut.isoformat(), "$lte": date_fin.isoformat()}
    }, {"_id": 0}).to_list(10000)
    
    # Statistiques
    total_interventions = 0
    total_present = 0
    total_absent = 0
    total_dejeuner = 0
    total_diner = 0
    total_souper = 0
    duree_totale_heures = 0
    
    # Par mois
    stats_par_mois = {i: {"interventions": 0, "present": 0, "absent": 0} for i in range(1, 13)}
    
    for intervention in interventions:
        personnel = intervention.get("personnel_present", [])
        
        # Chercher l'employ√© dans le personnel
        for p in personnel:
            p_id = p.get("id") or p.get("user_id")
            if p_id == user_id:
                total_interventions += 1
                
                # D√©terminer le mois
                date_str = intervention.get("xml_time_call_received")
                if date_str:
                    try:
                        dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                        mois = dt.month
                        stats_par_mois[mois]["interventions"] += 1
                    except:
                        mois = None
                
                # Statut de pr√©sence
                statut = p.get("statut_presence", "present")
                if statut in ["present", "rappele"]:
                    total_present += 1
                    if mois:
                        stats_par_mois[mois]["present"] += 1
                elif statut in ["absent", "absent_non_paye", "non_disponible"]:
                    total_absent += 1
                    if mois:
                        stats_par_mois[mois]["absent"] += 1
                else:
                    # remplace, absent_paye comptent comme pr√©sent pour le calcul
                    total_present += 1
                    if mois:
                        stats_par_mois[mois]["present"] += 1
                
                # Primes de repas
                if p.get("prime_dejeuner"):
                    total_dejeuner += 1
                if p.get("prime_diner"):
                    total_diner += 1
                if p.get("prime_souper"):
                    total_souper += 1
                
                # Dur√©e
                time_start = intervention.get("xml_time_call_received")
                time_end = intervention.get("xml_time_call_closed") or intervention.get("xml_time_terminated")
                if time_start and time_end:
                    try:
                        start_dt = datetime.fromisoformat(time_start.replace('Z', '+00:00'))
                        end_dt = datetime.fromisoformat(time_end.replace('Z', '+00:00'))
                        duree = (end_dt - start_dt).total_seconds() / 3600
                        duree_totale_heures += duree
                    except:
                        pass
                
                break  # Employ√© trouv√©, passer √† l'intervention suivante
    
    # Calculer le taux de pr√©sence
    taux_presence = 0
    if total_interventions > 0:
        taux_presence = round((total_present / total_interventions) * 100, 1)
    
    # Charger les tarifs pour calculer les montants
    settings = await db.intervention_settings.find_one({"tenant_id": tenant.id})
    montant_dejeuner = settings.get("repas_dejeuner", {}).get("montant", 15) if settings else 15
    montant_diner = settings.get("repas_diner", {}).get("montant", 18) if settings else 18
    montant_souper = settings.get("repas_souper", {}).get("montant", 20) if settings else 20
    
    total_primes = (total_dejeuner * montant_dejeuner) + (total_diner * montant_diner) + (total_souper * montant_souper)
    
    return {
        "user_id": user_id,
        "user_name": f"{user.get('prenom', '')} {user.get('nom', '')}",
        "annee": annee,
        "statistiques": {
            "total_interventions": total_interventions,
            "total_present": total_present,
            "total_absent": total_absent,
            "taux_presence": taux_presence,
            "duree_totale_heures": round(duree_totale_heures, 1),
            "primes_repas": {
                "dejeuner": {"count": total_dejeuner, "montant": total_dejeuner * montant_dejeuner},
                "diner": {"count": total_diner, "montant": total_diner * montant_diner},
                "souper": {"count": total_souper, "montant": total_souper * montant_souper},
                "total": total_primes
            }
        },
        "par_mois": stats_par_mois
    }


@api_router.put("/{tenant_slug}/users/{user_id}/password")
async def change_user_password(
    tenant_slug: str,
    user_id: str,
    password_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Changer le mot de passe d'un utilisateur (propre mot de passe ou admin reset)"""
    try:
        logging.info(f"üîë Demande de changement de mot de passe pour l'utilisateur {user_id}")
        
        # V√©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer l'utilisateur cible
        user_data = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        if not user_data:
            logging.warning(f"‚ùå Utilisateur non trouv√© pour changement de mot de passe: {user_id}")
            raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
        
        # Cas 1: Admin qui r√©initialise le mot de passe d'un autre utilisateur
        is_admin_reset = current_user.role == "admin" and current_user.id != user_id
        
        # Cas 2: Utilisateur qui change son propre mot de passe
        is_self_change = current_user.id == user_id
        
        if not is_admin_reset and not is_self_change:
            logging.warning(f"‚ùå Tentative de changement de mot de passe non autoris√©e par {current_user.id} pour {user_id}")
            raise HTTPException(status_code=403, detail="Vous ne pouvez changer que votre propre mot de passe")
        
        # Si c'est un changement personnel, v√©rifier l'ancien mot de passe
        if is_self_change and not is_admin_reset:
            if "current_password" not in password_data:
                raise HTTPException(status_code=400, detail="Le mot de passe actuel est requis")
            
            if not verify_password(password_data["current_password"], user_data["mot_de_passe_hash"]):
                logging.warning(f"‚ùå Ancien mot de passe incorrect pour {user_id}")
                raise HTTPException(status_code=401, detail="Mot de passe actuel incorrect")
            
            logging.info(f"‚úÖ Ancien mot de passe v√©rifi√© pour {user_id}")
            new_password = password_data["new_password"]
        else:
            # Admin reset - pas besoin de l'ancien mot de passe
            logging.info(f"üëë Reset administrateur du mot de passe pour {user_id} par {current_user.id}")
            new_password = password_data.get("mot_de_passe") or password_data.get("new_password")
            if not new_password:
                raise HTTPException(status_code=400, detail="Le nouveau mot de passe est requis")
        
        # Valider le nouveau mot de passe (8 caract√®res min, 1 majuscule, 1 chiffre, 1 sp√©cial)
        if len(new_password) < 8:
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins 8 caract√®res")
        if not any(c.isupper() for c in new_password):
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins une majuscule")
        if not any(c.isdigit() for c in new_password):
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins un chiffre")
        if not any(c in '!@#$%^&*+-?()' for c in new_password):
            raise HTTPException(status_code=400, detail="Le mot de passe doit contenir au moins un caract√®re sp√©cial (!@#$%^&*+-?())")
        
        # Hasher et mettre √† jour le mot de passe (utilise bcrypt maintenant)
        new_password_hash = get_password_hash(new_password)
        logging.info(f"üîê Nouveau mot de passe hash√© avec bcrypt pour {user_id}")
        
        result = await db.users.update_one(
            {"id": user_id, "tenant_id": tenant.id},
            {"$set": {"mot_de_passe_hash": new_password_hash}}
        )
        
        if result.modified_count == 0:
            logging.error(f"‚ùå Impossible de mettre √† jour le mot de passe pour {user_id}")
            raise HTTPException(status_code=400, detail="Impossible de mettre √† jour le mot de passe")
        
        logging.info(f"‚úÖ Mot de passe chang√© avec succ√®s pour {user_id}")
        
        # Si c'est un admin reset, envoyer un email au utilisateur
        email_sent = False
        if is_admin_reset:
            user_name = f"{user_data.get('prenom', '')} {user_data.get('nom', '')}".strip()
            user_email = user_data.get('email')
            
            if user_email:
                logging.info(f"üìß Envoi de l'email de r√©initialisation √† {user_email}")
                email_sent = send_temporary_password_email(
                    user_email=user_email,
                    user_name=user_name,
                    temp_password=new_password,
                    tenant_slug=tenant_slug
                )
                
                if email_sent:
                    logging.info(f"‚úÖ Email de r√©initialisation envoy√© avec succ√®s √† {user_email}")
                    return {
                        "message": "Mot de passe modifi√© avec succ√®s",
                        "email_sent": True,
                        "email_address": user_email
                    }
                else:
                    logging.warning(f"‚ö†Ô∏è √âchec de l'envoi de l'email √† {user_email}")
                    return {
                        "message": "Mot de passe modifi√© avec succ√®s, mais l'email n'a pas pu √™tre envoy√©",
                        "email_sent": False,
                        "error": "L'envoi de l'email a √©chou√©. Veuillez informer l'utilisateur manuellement."
                    }
            else:
                logging.warning(f"‚ö†Ô∏è Aucun email trouv√© pour l'utilisateur {user_id}")
                return {
                    "message": "Mot de passe modifi√© avec succ√®s, mais aucun email configur√© pour cet utilisateur",
                    "email_sent": False,
                    "error": "Aucune adresse email trouv√©e"
                }
        
        return {"message": "Mot de passe modifi√© avec succ√®s"}
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur inattendue lors du changement de mot de passe pour {user_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

# ==================== PERSONNALISATION ROUTES MIGR√âES VERS routes/personnalisation.py ====================
# Routes migr√©es:
# - GET  /{tenant_slug}/public/branding           - Branding public (sans auth)
# - GET  /{tenant_slug}/personnalisation          - Param√®tres de personnalisation
# - PUT  /{tenant_slug}/personnalisation          - Modifier la personnalisation
# - POST /{tenant_slug}/personnalisation/upload-logo - Uploader un logo (base64)
# ============================================================================

@api_router.put("/{tenant_slug}/users/{user_id}/access", response_model=User)
async def update_user_access(tenant_slug: str, user_id: str, role: str, statut: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Validation des valeurs
    valid_roles = ["admin", "superviseur", "employe"]
    valid_statuts = ["Actif", "Inactif"]
    
    if role not in valid_roles:
        raise HTTPException(status_code=400, detail="R√¥le invalide")
    if statut not in valid_statuts:
        raise HTTPException(status_code=400, detail="Statut invalide")
    
    # Check if user exists in this tenant
    existing_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not existing_user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    # Update user access
    result = await db.users.update_one(
        {"id": user_id, "tenant_id": tenant.id}, 
        {"$set": {"role": role, "statut": statut}}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de mettre √† jour l'acc√®s")
    
    updated_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    updated_user = clean_mongo_doc(updated_user)
    return User(**updated_user)

@api_router.delete("/{tenant_slug}/users/{user_id}/revoke")
async def revoke_user_completely(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Check if user exists IN THIS TENANT
    existing_user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not existing_user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    # Prevent admin from deleting themselves
    if user_id == current_user.id:
        raise HTTPException(status_code=400, detail="Impossible de supprimer votre propre compte")
    
    # Delete user and all related data (only for this tenant)
    await db.users.delete_one({"id": user_id, "tenant_id": tenant.id})
    await db.disponibilites.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    await db.assignations.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    await db.demandes_remplacement.delete_many({"demandeur_id": user_id, "tenant_id": tenant.id})
    await db.demandes_remplacement.delete_many({"remplacant_id": user_id, "tenant_id": tenant.id})
    
    return {"message": "Utilisateur et toutes ses donn√©es ont √©t√© supprim√©s d√©finitivement"}

# ==================== TYPES DE GARDE ROUTES MIGR√âES VERS routes/types_garde.py ====================
# Routes migr√©es:
# - POST   /{tenant_slug}/types-garde                  - Cr√©er un type de garde
# - GET    /{tenant_slug}/types-garde                  - Liste des types de garde
# - PUT    /{tenant_slug}/types-garde/{type_garde_id} - Modifier un type de garde
# - DELETE /{tenant_slug}/types-garde/{type_garde_id} - Supprimer un type de garde
# ============================================================================



# ===== FORMATAGE PLANNING (DEMO UNIQUEMENT) =====

@api_router.delete("/{tenant_slug}/planning/formater-mois")
async def formater_planning_mois(
    tenant_slug: str,
    mois: str,  # Format: YYYY-MM
    current_user: User = Depends(get_current_user)
):
    """
    Formate (vide) le planning d'un mois sp√©cifique
    UNIQUEMENT pour le tenant demo
    Supprime: assignations, demandes de remplacement
    """
    # 1. V√©rifier que c'est le tenant demo
    if tenant_slug != "demo":
        raise HTTPException(status_code=403, detail="Cette fonctionnalit√© est r√©serv√©e au tenant demo")
    
    # 2. V√©rifier que l'utilisateur est admin
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s r√©serv√© aux administrateurs")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # 3. Valider le format du mois
    try:
        year, month = map(int, mois.split('-'))
        if month < 1 or month > 12:
            raise ValueError()
    except:
        raise HTTPException(status_code=400, detail="Format de mois invalide. Utilisez YYYY-MM")
    
    # 4. Calculer les dates de d√©but et fin du mois
    date_debut = datetime(year, month, 1, tzinfo=timezone.utc)
    if month == 12:
        date_fin = datetime(year + 1, 1, 1, tzinfo=timezone.utc) - timedelta(seconds=1)
    else:
        date_fin = datetime(year, month + 1, 1, tzinfo=timezone.utc) - timedelta(seconds=1)
    
    # 5. Supprimer les assignations du mois
    result_assignations = await db.assignations.delete_many({
        "tenant_id": tenant.id,
        "date": {
            "$gte": date_debut.isoformat(),
            "$lte": date_fin.isoformat()
        }
    })
    
    # 6. Supprimer les demandes de remplacement du mois
    result_remplacements = await db.demandes_remplacement.delete_many({
        "tenant_id": tenant.id,
        "date_garde": {
            "$gte": date_debut.isoformat(),
            "$lte": date_fin.isoformat()
        }
    })
    
    return {
        "message": f"Planning format√© avec succ√®s pour {mois}",
        "mois": mois,
        "assignations_supprimees": result_assignations.deleted_count,
        "demandes_supprimees": result_remplacements.deleted_count
    }

# ===== EXPORTS PLANNING (doivent √™tre AVANT les routes avec param√®tres dynamiques) =====

@api_router.get("/{tenant_slug}/planning/export-pdf")
async def export_planning_pdf(
    tenant_slug: str, 
    periode: str,
    type: str,
    current_user: User = Depends(get_current_user)
):
    """Export du planning en PDF"""
    try:
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Calculer la p√©riode
        if type == 'semaine':
            date_debut = datetime.strptime(periode, '%Y-%m-%d')
            date_fin = date_debut + timedelta(days=6)
        else:  # mois
            year, month = map(int, periode.split('-'))
            date_debut = datetime(year, month, 1)
            if month == 12:
                date_fin = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                date_fin = datetime(year, month + 1, 1) - timedelta(days=1)
        
        # R√©cup√©rer les donn√©es
        assignations_list = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut.strftime('%Y-%m-%d'),
                "$lte": date_fin.strftime('%Y-%m-%d')
            }
        }).to_list(length=None)
        
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        types_map = {t['id']: t for t in types_garde_list}
        users_map = {u['id']: u for u in users_list}
        
        # Cr√©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(
            tenant,
            pagesize=landscape(letter),
            leftMargin=0.5*inch,
            rightMargin=0.5*inch,
            topMargin=0.75*inch,
            bottomMargin=0.75*inch
        )
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Titre principal
        titre = f"PLANNING DES GARDES - V4"
        elements.append(Paragraph(titre, modern_styles['title']))
        
        # Sous-titre avec p√©riode
        type_label = "Semaine" if type == "semaine" else "Mois"
        periode_str = f"{type_label} du {date_debut.strftime('%d/%m/%Y')} au {date_fin.strftime('%d/%m/%Y')}"
        elements.append(Paragraph(periode_str, modern_styles['subheading']))
        elements.append(Spacer(1, 0.1*inch))
        
        # Ligne de s√©paration
        from reportlab.platypus import HRFlowable
        elements.append(HRFlowable(width="100%", thickness=1, color=modern_styles['grid'], spaceAfter=0.3*inch))
        
        # Jours fran√ßais
        jours_fr = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim']
        
        # Couleurs pour la grille
        HEADER_BG = colors.HexColor('#1F2937')
        PRIMARY_RED = colors.HexColor('#DC2626')
        COMPLETE_GREEN = colors.HexColor('#D1FAE5')
        PARTIAL_YELLOW = colors.HexColor('#FEF3C7')
        VACANT_RED = colors.HexColor('#FEE2E2')
        LIGHT_GRAY = colors.HexColor('#F3F4F6')
        BORDER_COLOR = colors.HexColor('#E5E7EB')
        
        # Trier les types de garde par heure
        types_garde_sorted = sorted(types_garde_list, key=lambda x: x.get('heure_debut', '00:00'))
        
        if type == 'semaine':
            # ===== FORMAT GRILLE SEMAINE =====
            from reportlab.lib.enums import TA_LEFT
            
            # Styles pour les cellules - taille augment√©e et leading adapt√©
            header_style_white = ParagraphStyle('HeaderWhite', fontSize=9, alignment=TA_CENTER, textColor=colors.white, leading=12, wordWrap='CJK')
            garde_cell_style = ParagraphStyle('GardeCell', fontSize=8, alignment=TA_LEFT, textColor=colors.white, leading=11, wordWrap='CJK')
            day_cell_style = ParagraphStyle('DayCell', fontSize=8, alignment=TA_CENTER, leading=11, textColor=colors.HexColor('#1F2937'), wordWrap='CJK')
            
            # Debug: logger les assignations
            logging.warning(f"DEBUG PDF: {len(assignations_list)} assignations trouv√©es pour {date_debut.strftime('%Y-%m-%d')} √† {date_fin.strftime('%Y-%m-%d')}")
            logging.warning(f"DEBUG PDF: {len(types_garde_sorted)} types de garde")
            
            # En-t√™te : Type de garde + 7 jours
            header_row = [Paragraph("<b>Type de garde</b>", header_style_white)]
            for i in range(7):
                d = date_debut + timedelta(days=i)
                header_row.append(Paragraph(f"<b>{jours_fr[d.weekday()]}</b><br/>{d.strftime('%d/%m')}", header_style_white))
            
            table_data = [header_row]
            cell_colors = []
            
            # Une ligne par type de garde
            for type_garde in types_garde_sorted:
                garde_nom = type_garde.get('nom', 'N/A')
                heure_debut_garde = type_garde.get('heure_debut', '??:??')
                heure_fin_garde = type_garde.get('heure_fin', '??:??')
                personnel_requis = type_garde.get('personnel_requis', 1)
                jours_app = type_garde.get('jours_application', [])
                type_garde_id = type_garde.get('id')
                
                # Premi√®re colonne - nom complet sans troncature
                row = [Paragraph(f"<b>{garde_nom}</b><br/><font size='7'>{heure_debut_garde}-{heure_fin_garde}</font>", garde_cell_style)]
                row_colors = [PRIMARY_RED]
                
                for i in range(7):
                    d = date_debut + timedelta(days=i)
                    date_str = d.strftime('%Y-%m-%d')
                    day_name = d.strftime('%A').lower()
                    
                    # V√©rifier si applicable ce jour
                    if jours_app and day_name not in jours_app:
                        row.append(Paragraph("-", day_cell_style))
                        row_colors.append(LIGHT_GRAY)
                        continue
                    
                    # Trouver les assignations pour ce jour et ce type de garde
                    assignations_jour = [a for a in assignations_list 
                                        if a.get('date') == date_str and a.get('type_garde_id') == type_garde_id]
                    
                    # Construire les noms des pompiers
                    noms = []
                    for a in assignations_jour:
                        user_id = a.get('user_id')
                        if user_id and user_id in users_map:
                            u = users_map[user_id]
                            prenom = u.get('prenom', '')
                            nom = u.get('nom', '')
                            if prenom or nom:
                                noms.append(f"{prenom[:1]}. {nom}")
                    
                    if noms:
                        cell_text = "<br/>".join(noms[:4])
                        if len(noms) > 4:
                            cell_text += f"<br/><font size='6'>+{len(noms)-4}</font>"
                        row.append(Paragraph(cell_text, day_cell_style))
                        
                        if len(noms) >= personnel_requis:
                            row_colors.append(COMPLETE_GREEN)
                        else:
                            row_colors.append(PARTIAL_YELLOW)
                    else:
                        row.append(Paragraph("<font color='#B91C1C'>Vacant</font>", day_cell_style))
                        row_colors.append(VACANT_RED)
                
                table_data.append(row)
                cell_colors.append(row_colors)
            
            # Largeurs de colonnes - premi√®re colonne plus large pour les noms de garde
            page_width = landscape(letter)[0]
            available_width = page_width - 1*inch
            first_col = 1.8*inch
            day_col = (available_width - first_col) / 7
            col_widths = [first_col] + [day_col] * 7
            
            # Hauteur minimale des lignes pour permettre l'affichage des noms
            row_heights = [0.5*inch] + [0.7*inch] * (len(table_data) - 1)
            
            # Cr√©er la table avec hauteurs de lignes
            table = Table(table_data, colWidths=col_widths, rowHeights=row_heights)
            
            # Style de base - WORDWRAP activ√© pour permettre le retour √† la ligne
            style_commands = [
                ('BACKGROUND', (0, 0), (-1, 0), HEADER_BG),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 0.5, BORDER_COLOR),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('LEFTPADDING', (0, 0), (-1, -1), 4),
                ('RIGHTPADDING', (0, 0), (-1, -1), 4),
            ]
            
            # Appliquer les couleurs par cellule
            for row_idx, colors_row in enumerate(cell_colors, start=1):
                for col_idx, bg_color in enumerate(colors_row):
                    style_commands.append(('BACKGROUND', (col_idx, row_idx), (col_idx, row_idx), bg_color))
                    if col_idx == 0:
                        style_commands.append(('TEXTCOLOR', (col_idx, row_idx), (col_idx, row_idx), colors.white))
                        style_commands.append(('ALIGN', (col_idx, row_idx), (col_idx, row_idx), 'LEFT'))
                        style_commands.append(('LEFTPADDING', (col_idx, row_idx), (col_idx, row_idx), 8))
            
            table.setStyle(TableStyle(style_commands))
            elements.append(table)
            
            # L√©gende
            elements.append(Spacer(1, 0.3*inch))
            legend_style = ParagraphStyle('Legend', fontSize=9, alignment=TA_CENTER, textColor=colors.HexColor('#6B7280'))
            elements.append(Paragraph("Legende: Vert = Complet | Jaune = Partiel | Rouge = Vacant | Gris = Non applicable", legend_style))
            
        elif type == 'mois':
            # ===== FORMAT GRILLE MOIS - Une grille par semaine =====
            from reportlab.platypus import PageBreak
            
            current = date_debut
            semaine_num = 1
            page_width = landscape(letter)[0]
            
            # Style pour titre de semaine
            semaine_style = ParagraphStyle(
                'SemaineStyle',
                parent=styles['Heading2'],
                fontSize=12,
                textColor=PRIMARY_RED,
                spaceBefore=10,
                spaceAfter=10,
                fontName='Helvetica-Bold'
            )
            
            while current <= date_fin:
                fin_semaine = min(current + timedelta(days=6), date_fin)
                nb_jours = (fin_semaine - current).days + 1
                
                # Titre de la semaine
                elements.append(Paragraph(
                    f"Semaine {semaine_num} - Du {current.strftime('%d/%m')} au {fin_semaine.strftime('%d/%m/%Y')}",
                    semaine_style
                ))
                
                # Styles pour le format mois - avec retour √† la ligne
                from reportlab.lib.enums import TA_LEFT
                header_style_mois = ParagraphStyle('HeaderMois', fontSize=8, alignment=TA_CENTER, textColor=colors.white, leading=10, wordWrap='CJK')
                garde_cell_style_mois = ParagraphStyle('GardeCellMois', fontSize=7, alignment=TA_LEFT, textColor=colors.white, leading=9, wordWrap='CJK')
                day_cell_style_mois = ParagraphStyle('DayCellMois', fontSize=7, alignment=TA_CENTER, leading=9, textColor=colors.HexColor('#1F2937'), wordWrap='CJK')
                
                # En-t√™te avec des Paragraph pour le retour √† la ligne
                header_row = [Paragraph("<b>Type de garde</b>", header_style_mois)]
                for i in range(nb_jours):
                    d = current + timedelta(days=i)
                    header_row.append(Paragraph(f"<b>{jours_fr[d.weekday()]}</b><br/>{d.strftime('%d')}", header_style_mois))
                
                table_data = [header_row]
                cell_colors_mois = []
                
                for type_garde in types_garde_sorted:
                    garde_nom = type_garde.get('nom', 'N/A')  # NE PLUS TRONQUER
                    heure_debut_garde = type_garde.get('heure_debut', '')
                    heure_fin_garde = type_garde.get('heure_fin', '')
                    personnel_requis = type_garde.get('personnel_requis', 1)
                    jours_app = type_garde.get('jours_application', [])
                    type_garde_id = type_garde.get('id')
                    
                    # Premi√®re colonne avec nom complet et horaires
                    row = [Paragraph(f"<b>{garde_nom}</b><br/><font size='6'>{heure_debut_garde}-{heure_fin_garde}</font>", garde_cell_style_mois)]
                    row_colors = [PRIMARY_RED]
                    
                    for i in range(nb_jours):
                        d = current + timedelta(days=i)
                        date_str = d.strftime('%Y-%m-%d')
                        day_name = d.strftime('%A').lower()
                        
                        if jours_app and day_name not in jours_app:
                            row.append(Paragraph("-", day_cell_style_mois))
                            row_colors.append(LIGHT_GRAY)
                            continue
                        
                        assignations_jour = [a for a in assignations_list 
                                            if a['date'] == date_str and a['type_garde_id'] == type_garde_id]
                        
                        # Construire les noms des pompiers
                        noms = []
                        for a in assignations_jour:
                            user_id = a.get('user_id')
                            if user_id and user_id in users_map:
                                u = users_map[user_id]
                                prenom = u.get('prenom', '')
                                nom = u.get('nom', '')
                                if prenom or nom:
                                    noms.append(f"{prenom[:1]}. {nom}")
                        
                        if noms:
                            cell_text = "<br/>".join(noms[:3])  # Max 3 noms pour le mois
                            if len(noms) > 3:
                                cell_text += f"<br/><font size='5'>+{len(noms)-3}</font>"
                            row.append(Paragraph(cell_text, day_cell_style_mois))
                            
                            if len(noms) >= personnel_requis:
                                row_colors.append(COMPLETE_GREEN)
                            else:
                                row_colors.append(PARTIAL_YELLOW)
                        else:
                            row.append(Paragraph("<font color='#B91C1C'>Vacant</font>", day_cell_style_mois))
                            row_colors.append(VACANT_RED)
                    
                    table_data.append(row)
                    cell_colors_mois.append(row_colors)
                
                # Largeurs - premi√®re colonne plus large pour afficher le nom complet
                available_width = page_width - 1*inch
                first_col = 1.6*inch  # Augment√© pour les noms de garde complets
                day_col = (available_width - first_col) / nb_jours
                col_widths = [first_col] + [day_col] * nb_jours
                
                # Hauteurs de lignes - plus hautes pour afficher les noms des pompiers
                row_heights = [0.4*inch] + [0.6*inch] * (len(table_data) - 1)
                
                table = Table(table_data, colWidths=col_widths, rowHeights=row_heights)
                
                style_commands = [
                    ('BACKGROUND', (0, 0), (-1, 0), HEADER_BG),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 7),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('GRID', (0, 0), (-1, -1), 0.5, BORDER_COLOR),
                    ('TOPPADDING', (0, 0), (-1, -1), 4),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
                    ('LEFTPADDING', (0, 0), (-1, -1), 3),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ]
                
                for row_idx, colors_row in enumerate(cell_colors_mois, start=1):
                    for col_idx, bg_color in enumerate(colors_row):
                        style_commands.append(('BACKGROUND', (col_idx, row_idx), (col_idx, row_idx), bg_color))
                        if col_idx == 0:
                            style_commands.append(('TEXTCOLOR', (col_idx, row_idx), (col_idx, row_idx), colors.white))
                            style_commands.append(('ALIGN', (col_idx, row_idx), (col_idx, row_idx), 'LEFT'))
                            style_commands.append(('LEFTPADDING', (col_idx, row_idx), (col_idx, row_idx), 6))
                
                table.setStyle(TableStyle(style_commands))
                elements.append(table)
                elements.append(Spacer(1, 0.2*inch))
                
                current = fin_semaine + timedelta(days=1)
                semaine_num += 1
                
                if current <= date_fin:
                    elements.append(PageBreak())
        
        # Footer
        def add_footer(canvas, doc_obj):
            canvas.saveState()
            canvas.setStrokeColor(colors.HexColor('#e2e8f0'))
            canvas.setLineWidth(1)
            canvas.line(0.5*inch, 0.5*inch, landscape(letter)[0] - 0.5*inch, 0.5*inch)
            canvas.setFont('Helvetica', 9)
            canvas.setFillColor(colors.HexColor('#64748b'))
            footer_text = f"ProFireManager - {datetime.now().strftime('%d/%m/%Y %H:%M')}"
            canvas.drawCentredString(landscape(letter)[0] / 2, 0.35*inch, footer_text)
            canvas.setFont('Helvetica', 8)
            canvas.drawRightString(landscape(letter)[0] - 0.5*inch, 0.35*inch, f"Page {doc_obj.page}")
            canvas.restoreState()
        
        doc.build(elements, onFirstPage=add_footer, onLaterPages=add_footer)
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename=planning_{type}_{periode}.pdf"}
        )
        
    except Exception as e:
        import traceback
        logging.error(f"Erreur export PDF: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/planning/export-excel")
async def export_planning_excel(
    tenant_slug: str, 
    periode: str,
    type: str,
    current_user: User = Depends(get_current_user)
):
    """Export du planning en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Calculer la p√©riode
        if type == 'semaine':
            date_debut = datetime.strptime(periode, '%Y-%m-%d')
            date_fin = date_debut + timedelta(days=6)
        else:
            year, month = map(int, periode.split('-'))
            date_debut = datetime(year, month, 1)
            if month == 12:
                date_fin = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                date_fin = datetime(year, month + 1, 1) - timedelta(days=1)
        
        assignations_list = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut.strftime('%Y-%m-%d'),
                "$lte": date_fin.strftime('%Y-%m-%d')
            }
        }).to_list(length=None)
        
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        types_map = {t['id']: t for t in types_garde_list}
        users_map = {u['id']: u for u in users_list}
        
        wb = Workbook()
        ws = wb.active
        ws.title = f"Planning {type}"
        
        header_fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        center_alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        ws.merge_cells('A1:H1')
        ws['A1'] = f"Planning des Gardes - {type.capitalize()}"
        ws['A1'].font = Font(bold=True, size=16, color="EF4444")
        ws['A1'].alignment = center_alignment
        
        ws.merge_cells('A2:H2')
        ws['A2'] = f"Du {date_debut.strftime('%d/%m/%Y')} au {date_fin.strftime('%d/%m/%Y')}"
        ws['A2'].alignment = center_alignment
        
        row = 4
        if type == 'semaine':
            headers = ['Type de Garde', 'Horaires'] + [(date_debut + timedelta(days=i)).strftime('%a %d/%m') for i in range(7)]
        else:
            headers = ['Date', 'Jour', 'Type de Garde', 'Horaires', 'Personnel', 'Requis', 'Assign√©s', 'Statut']
        
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = center_alignment
            cell.border = border
        
        row += 1
        
        if type == 'semaine':
            for type_garde in sorted(types_garde_list, key=lambda x: x.get('heure_debut', '')):
                ws.cell(row=row, column=1, value=type_garde['nom'])
                ws.cell(row=row, column=2, value=f"{type_garde.get('heure_debut', '')} - {type_garde.get('heure_fin', '')}")
                
                for i in range(7):
                    current_date = (date_debut + timedelta(days=i)).strftime('%Y-%m-%d')
                    assignations_jour = [a for a in assignations_list if a['date'] == current_date and a['type_garde_id'] == type_garde['id']]
                    
                    noms = [f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}" 
                           for a in assignations_jour if a['user_id'] in users_map]
                    
                    cell_text = '\n'.join(noms) if noms else 'Vacant'
                    cell = ws.cell(row=row, column=3+i, value=cell_text)
                    cell.alignment = center_alignment
                    cell.border = border
                    
                    if len(noms) >= type_garde.get('personnel_requis', 1):
                        cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
                    elif noms:
                        cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
                    else:
                        cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
                
                row += 1
        else:
            current = date_debut
            while current <= date_fin:
                date_str = current.strftime('%Y-%m-%d')
                jour_fr = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'][current.weekday()]
                
                for type_garde in types_garde_list:
                    assignations_jour = [a for a in assignations_list if a['date'] == date_str and a['type_garde_id'] == type_garde['id']]
                    
                    noms = [f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}" 
                           for a in assignations_jour if a['user_id'] in users_map]
                    
                    personnel_str = ', '.join(noms) if noms else 'Aucun'
                    requis = type_garde.get('personnel_requis', 1)
                    assignes = len(noms)
                    statut = 'Complet' if assignes >= requis else 'Partiel' if noms else 'Vacant'
                    
                    ws.cell(row=row, column=1, value=current.strftime('%d/%m/%Y'))
                    ws.cell(row=row, column=2, value=jour_fr)
                    ws.cell(row=row, column=3, value=type_garde['nom'])
                    ws.cell(row=row, column=4, value=f"{type_garde.get('heure_debut', '')} - {type_garde.get('heure_fin', '')}")
                    ws.cell(row=row, column=5, value=personnel_str)
                    ws.cell(row=row, column=6, value=requis)
                    ws.cell(row=row, column=7, value=assignes)
                    status_cell = ws.cell(row=row, column=8, value=statut)
                    
                    if statut == 'Complet':
                        status_cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
                    elif statut == 'Partiel':
                        status_cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
                    else:
                        status_cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
                    
                    for col in range(1, 9):
                        ws.cell(row=row, column=col).border = border
                        ws.cell(row=row, column=col).alignment = center_alignment
                    
                    row += 1
                
                current += timedelta(days=1)
        
        # D√©finir les largeurs de colonnes fixes pour √©viter les erreurs avec MergedCell
        column_widths = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
        default_widths = [12, 12, 18, 15, 25, 10, 10, 12, 12]
        for i, col_letter in enumerate(column_widths):
            if i < len(default_widths):
                ws.column_dimensions[col_letter].width = default_widths[i]
        
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename=planning_{type}_{periode}.xlsx"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")

# ===== RAPPORT D'HEURES =====

@api_router.get("/{tenant_slug}/planning/mes-heures")
async def get_mes_heures(
    tenant_slug: str,
    date_debut: str,  # Format YYYY-MM-DD
    date_fin: str,    # Format YYYY-MM-DD
    current_user: User = Depends(get_current_user)
):
    """R√©cup√®re les heures travaill√©es de l'utilisateur connect√© sur une p√©riode"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les assignations de l'utilisateur pour la p√©riode
    assignations = await db.assignations.find({
        "tenant_id": tenant.id,
        "user_id": current_user.id,
        "date": {
            "$gte": date_debut,
            "$lte": date_fin
        }
    }).to_list(1000)
    
    # R√©cup√©rer les types de garde pour calculer les dur√©es
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(100)
    types_garde_map = {tg.get("id"): tg for tg in types_garde}
    
    # D√âDUPLICATION: Supprimer les doublons potentiels
    assignations_uniques = {}
    for assignation in assignations:
        key = f"{assignation.get('type_garde_id')}_{assignation.get('date')}"
        if key not in assignations_uniques:
            assignations_uniques[key] = assignation
    
    # Calculer les heures
    heures_internes = 0.0
    heures_externes = 0.0
    
    for assignation in assignations_uniques.values():
        type_garde_id = assignation.get("type_garde_id")
        type_garde = types_garde_map.get(type_garde_id, {})
        duree = type_garde.get("duree_heures", 8)
        type_assignation = type_garde.get("type", "interne")
        
        if type_assignation == "externe":
            heures_externes += duree
        else:
            heures_internes += duree
    
    return {
        "user_id": current_user.id,
        "heures_internes": heures_internes,
        "heures_externes": heures_externes,
        "total_heures": heures_internes + heures_externes,
        "nb_assignations": len(assignations_uniques),
        "periode": {
            "debut": date_debut,
            "fin": date_fin
        }
    }


@api_router.get("/{tenant_slug}/planning/rapport-heures")
async def get_rapport_heures(
    tenant_slug: str,
    date_debut: str,  # Format YYYY-MM-DD
    date_fin: str,    # Format YYYY-MM-DD
    current_user: User = Depends(get_current_user)
):
    """R√©cup√®re le rapport d'heures pour tous les employ√©s sur une p√©riode"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin/Superviseur uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer tous les utilisateurs actifs
    users = await db.users.find({
        "tenant_id": tenant.id,
        "statut": "Actif"
    }).to_list(1000)
    
    # R√©cup√©rer toutes les assignations de la p√©riode
    assignations = await db.assignations.find({
        "tenant_id": tenant.id,
        "date": {
            "$gte": date_debut,
            "$lte": date_fin
        }
    }).to_list(10000)
    
    # D√âDUPLICATION: Supprimer les doublons potentiels
    # Cl√© unique: user_id + type_garde_id + date
    assignations_uniques = {}
    for a in assignations:
        key = f"{a['user_id']}_{a['type_garde_id']}_{a['date']}"
        if key not in assignations_uniques:
            assignations_uniques[key] = a
    
    assignations = list(assignations_uniques.values())
    logging.info(f"üìä [RAPPORT] {len(assignations)} assignations uniques pour la p√©riode {date_debut} - {date_fin}")
    
    # R√©cup√©rer les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    # Calculer les heures pour chaque employ√©
    rapport_data = []
    total_heures_internes = 0
    total_heures_externes = 0
    
    for user in users:
        heures_internes = 0
        heures_externes = 0
        nb_assignations = 0
        
        # Compter les heures de cet utilisateur
        for assignation in assignations:
            if assignation["user_id"] == user["id"]:
                type_garde = types_garde_map.get(assignation["type_garde_id"])
                if type_garde:
                    duree = type_garde.get("duree_heures", 8)
                    nb_assignations += 1
                    if type_garde.get("est_garde_externe", False):
                        heures_externes += duree
                    else:
                        heures_internes += duree
        
        # Log pour utilisateurs avec beaucoup d'heures
        if heures_internes + heures_externes > 150:
            logging.warning(f"‚ö†Ô∏è [RAPPORT] {user.get('prenom')} {user.get('nom')}: {nb_assignations} assignations = {heures_internes}h int + {heures_externes}h ext = {heures_internes + heures_externes}h total")
        
        total_heures_internes += heures_internes
        total_heures_externes += heures_externes
        
        rapport_data.append({
            "user_id": user["id"],
            "nom": user.get("nom", ""),
            "prenom": user.get("prenom", ""),
            "nom_complet": f"{user.get('prenom', '')} {user.get('nom', '')}",
            "type_emploi": user.get("type_emploi", "temps_plein"),
            "grade": user.get("grade", ""),
            "heures_internes": heures_internes,
            "heures_externes": heures_externes,
            "total_heures": heures_internes + heures_externes,
            "heures_max_semaine": user.get("heures_max_semaine", 40)
        })
    
    # Trier par nom
    rapport_data.sort(key=lambda x: (x["nom"], x["prenom"]))
    
    # Calculer les statistiques
    nombre_employes = len(users)
    moyenne_heures_internes = total_heures_internes / nombre_employes if nombre_employes > 0 else 0
    moyenne_heures_externes = total_heures_externes / nombre_employes if nombre_employes > 0 else 0
    
    return {
        "periode": {
            "debut": date_debut,
            "fin": date_fin
        },
        "employes": rapport_data,
        "statistiques": {
            "nombre_employes": nombre_employes,
            "total_heures_internes": total_heures_internes,
            "total_heures_externes": total_heures_externes,
            "total_heures_planifiees": total_heures_internes + total_heures_externes,
            "moyenne_heures_internes": round(moyenne_heures_internes, 1),
            "moyenne_heures_externes": round(moyenne_heures_externes, 1)
        }
    }

@api_router.get("/{tenant_slug}/planning/rapport-heures/debug/{user_id}")
async def debug_rapport_heures_user(
    tenant_slug: str,
    user_id: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Endpoint de diagnostic pour comprendre le calcul des heures d'un utilisateur"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer l'utilisateur
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    # R√©cup√©rer TOUTES les assignations (avec doublons √©ventuels)
    assignations_brutes = await db.assignations.find({
        "user_id": user_id,
        "tenant_id": tenant.id,
        "date": {"$gte": date_debut, "$lte": date_fin}
    }, {"_id": 0}).to_list(10000)
    
    # D√©duplication
    assignations_uniques = {}
    doublons = []
    for a in assignations_brutes:
        key = f"{a['user_id']}_{a['type_garde_id']}_{a['date']}"
        if key not in assignations_uniques:
            assignations_uniques[key] = a
        else:
            doublons.append(a)
    
    assignations = list(assignations_uniques.values())
    
    # R√©cup√©rer les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    # Calculer les d√©tails
    details = []
    total_heures = 0
    total_heures_calculees = 0
    
    for a in assignations:
        type_garde = types_garde_map.get(a["type_garde_id"])
        if type_garde:
            duree_stored = type_garde.get("duree_heures", None)
            
            # Calculer la dur√©e r√©elle √† partir des horaires
            duree_calculee = None
            if type_garde.get("heure_debut") and type_garde.get("heure_fin"):
                try:
                    from datetime import datetime
                    debut = datetime.strptime(type_garde["heure_debut"], "%H:%M")
                    fin = datetime.strptime(type_garde["heure_fin"], "%H:%M")
                    if fin < debut:
                        fin = fin.replace(day=debut.day + 1)
                    delta = (fin - debut).total_seconds() / 3600
                    duree_calculee = round(delta, 2)
                except:
                    duree_calculee = None
            
            # Dur√©e utilis√©e par le code (celle dans le rapport)
            duree_utilisee = duree_stored if duree_stored is not None else 8
            
            total_heures += duree_utilisee
            if duree_calculee:
                total_heures_calculees += duree_calculee
            
            details.append({
                "date": a["date"],
                "type_garde_nom": type_garde.get("nom"),
                "type_garde_id": a["type_garde_id"],
                "heure_debut": type_garde.get("heure_debut"),
                "heure_fin": type_garde.get("heure_fin"),
                "duree_stored_bd": duree_stored,
                "duree_calculee_horaires": duree_calculee,
                "duree_utilisee_rapport": duree_utilisee,
                "est_garde_externe": type_garde.get("est_garde_externe", False)
            })
    
    return {
        "user": {
            "id": user["id"],
            "nom_complet": f"{user.get('prenom')} {user.get('nom')}",
            "email": user.get("email"),
            "heures_max_semaine": user.get("heures_max_semaine", 40)
        },
        "periode": f"{date_debut} au {date_fin}",
        "compteurs": {
            "assignations_brutes": len(assignations_brutes),
            "assignations_uniques": len(assignations),
            "doublons_detectes": len(doublons),
            "total_heures_rapport": total_heures,
            "total_heures_reelles_calculees": total_heures_calculees
        },
        "assignations_details": sorted(details, key=lambda x: x["date"]),
        "doublons": doublons[:10] if doublons else []
    }

@api_router.get("/{tenant_slug}/planning/rapport-assignations-invalides")
async def rapport_assignations_invalides(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Identifie toutes les assignations qui ne respectent pas les jours_application du type de garde"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer toutes les assignations
    assignations = await db.assignations.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(10000)
    
    # R√©cup√©rer tous les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    # R√©cup√©rer tous les users
    users = await db.users.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    users_map = {u["id"]: u for u in users}
    
    # Jours de la semaine
    jours_fr_to_en = {
        0: "monday",
        1: "tuesday", 
        2: "wednesday",
        3: "thursday",
        4: "friday",
        5: "saturday",
        6: "sunday"
    }
    
    assignations_invalides = []
    assignations_valides_count = 0
    
    for a in assignations:
        type_garde = types_garde_map.get(a["type_garde_id"])
        if not type_garde:
            continue
        
        jours_application = type_garde.get("jours_application", [])
        
        # Si pas de jours_application, consid√©r√© comme valide pour tous les jours
        if not jours_application or len(jours_application) == 0:
            assignations_valides_count += 1
            continue
        
        # V√©rifier le jour de la semaine de cette assignation
        try:
            from datetime import datetime
            date_obj = datetime.strptime(a["date"], "%Y-%m-%d")
            jour_semaine_index = date_obj.weekday()  # 0=lundi, 6=dimanche
            jour_semaine_en = jours_fr_to_en[jour_semaine_index]
            
            # V√©rifier si le jour est dans jours_application
            if jour_semaine_en not in jours_application:
                user = users_map.get(a["user_id"], {})
                assignations_invalides.append({
                    "assignation_id": a.get("id"),
                    "date": a["date"],
                    "jour_semaine": jour_semaine_en,
                    "user_nom_complet": f"{user.get('prenom', '')} {user.get('nom', '')}",
                    "user_id": a["user_id"],
                    "type_garde_nom": type_garde.get("nom"),
                    "type_garde_id": a["type_garde_id"],
                    "jours_application_garde": jours_application,
                    "raison": f"Assignation sur {jour_semaine_en} mais garde limit√©e √† {', '.join(jours_application)}"
                })
            else:
                assignations_valides_count += 1
        except Exception as e:
            logging.error(f"Erreur analyse assignation {a.get('id')}: {str(e)}")
    
    # Grouper par utilisateur
    by_user = {}
    for inv in assignations_invalides:
        user_id = inv["user_id"]
        if user_id not in by_user:
            by_user[user_id] = {
                "user_nom_complet": inv["user_nom_complet"],
                "count": 0,
                "assignations": []
            }
        by_user[user_id]["count"] += 1
        by_user[user_id]["assignations"].append(inv)
    
    return {
        "message": f"Trouv√© {len(assignations_invalides)} assignations invalides sur {len(assignations)} totales",
        "statistiques": {
            "total_assignations": len(assignations),
            "assignations_invalides": len(assignations_invalides),
            "assignations_valides": assignations_valides_count,
            "utilisateurs_affectes": len(by_user)
        },
        "par_utilisateur": by_user,
        "toutes_invalides": sorted(assignations_invalides, key=lambda x: (x["date"], x["user_nom_complet"]))
    }

@api_router.post("/{tenant_slug}/planning/supprimer-assignations-invalides")
async def supprimer_assignations_invalides(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Supprime toutes les assignations qui ne respectent pas les jours_application"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # D'abord, r√©cup√©rer le rapport des invalides
    assignations = await db.assignations.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(10000)
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    types_garde_map = {t["id"]: t for t in types_garde}
    
    jours_fr_to_en = {
        0: "monday", 1: "tuesday", 2: "wednesday", 3: "thursday",
        4: "friday", 5: "saturday", 6: "sunday"
    }
    
    ids_to_delete = []
    
    for a in assignations:
        type_garde = types_garde_map.get(a["type_garde_id"])
        if not type_garde:
            continue
        
        jours_application = type_garde.get("jours_application", [])
        if not jours_application:
            continue
        
        try:
            from datetime import datetime
            date_obj = datetime.strptime(a["date"], "%Y-%m-%d")
            jour_semaine_en = jours_fr_to_en[date_obj.weekday()]
            
            if jour_semaine_en not in jours_application:
                ids_to_delete.append(a["id"])
        except:
            pass
    
    # Supprimer
    if ids_to_delete:
        result = await db.assignations.delete_many({
            "id": {"$in": ids_to_delete},
            "tenant_id": tenant.id
        })
        deleted_count = result.deleted_count
    else:
        deleted_count = 0
    
    return {
        "message": f"Supprim√© {deleted_count} assignations invalides",
        "deleted_count": deleted_count,
        "ids_supprimes": ids_to_delete[:50]  # Max 50 pour la r√©ponse
    }

@api_router.post("/{tenant_slug}/planning/recalculer-durees-gardes")
async def recalculer_durees_gardes(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Recalcule le champ duree_heures pour tous les types de garde en utilisant heure_debut et heure_fin"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer tous les types de garde
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    
    corrections = []
    erreurs = []
    
    for tg in types_garde:
        type_id = tg["id"]
        nom = tg.get("nom", "Sans nom")
        heure_debut = tg.get("heure_debut")
        heure_fin = tg.get("heure_fin")
        duree_actuelle = tg.get("duree_heures")
        
        if heure_debut and heure_fin:
            try:
                from datetime import datetime
                debut = datetime.strptime(heure_debut, "%H:%M")
                fin = datetime.strptime(heure_fin, "%H:%M")
                
                # Gestion du cas o√π la garde traverse minuit
                if fin < debut:
                    fin = fin.replace(day=debut.day + 1)
                
                delta = (fin - debut).total_seconds() / 3600
                duree_calculee = round(delta, 2)
                
                # Mise √† jour seulement si diff√©rent ou absent
                if duree_actuelle is None or abs(duree_actuelle - duree_calculee) > 0.01:
                    await db.types_garde.update_one(
                        {"id": type_id, "tenant_id": tenant.id},
                        {"$set": {"duree_heures": duree_calculee}}
                    )
                    corrections.append({
                        "type_garde": nom,
                        "horaires": f"{heure_debut} - {heure_fin}",
                        "duree_avant": duree_actuelle,
                        "duree_apres": duree_calculee,
                        "statut": "corrig√©"
                    })
                else:
                    corrections.append({
                        "type_garde": nom,
                        "horaires": f"{heure_debut} - {heure_fin}",
                        "duree": duree_actuelle,
                        "statut": "d√©j√†_correct"
                    })
                    
            except Exception as e:
                erreurs.append({
                    "type_garde": nom,
                    "erreur": str(e),
                    "horaires": f"{heure_debut} - {heure_fin}"
                })
        else:
            erreurs.append({
                "type_garde": nom,
                "erreur": "horaires manquants",
                "heure_debut": heure_debut,
                "heure_fin": heure_fin
            })
    
    nb_corriges = len([c for c in corrections if c.get("statut") == "corrig√©"])
    nb_deja_ok = len([c for c in corrections if c.get("statut") == "d√©j√†_correct"])
    
    return {
        "message": f"Recalcul termin√©: {nb_corriges} corrig√©s, {nb_deja_ok} d√©j√† corrects, {len(erreurs)} erreurs",
        "corrections": corrections,
        "erreurs": erreurs,
        "statistiques": {
            "total_types_garde": len(types_garde),
            "corriges": nb_corriges,
            "deja_corrects": nb_deja_ok,
            "erreurs": len(erreurs)
        }
    }

@api_router.get("/{tenant_slug}/planning/rapport-heures/export-pdf")
async def export_rapport_heures_pdf(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """G√©n√®re le PDF du rapport d'heures pour impression"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es du rapport
    rapport_response = await get_rapport_heures(tenant_slug, date_debut, date_fin, current_user)
    
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.platypus import Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    
    # Utiliser la fonction helper pour cr√©er un PDF brand√©
    buffer, doc, elements = create_branded_pdf(tenant, pagesize=A4)
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Titre
    elements.append(Paragraph("Rapport d'Heures", modern_styles['title']))
    
    # P√©riode
    debut_dt = datetime.strptime(date_debut, "%Y-%m-%d")
    fin_dt = datetime.strptime(date_fin, "%Y-%m-%d")
    periode_text = f"P√©riode: {debut_dt.strftime('%d/%m/%Y')} - {fin_dt.strftime('%d/%m/%Y')}"
    elements.append(Paragraph(periode_text, modern_styles['subheading']))
    
    # Tableau des employ√©s
    table_data = [
        ['Employ√©', 'Type', 'Grade', 'H. Internes', 'H. Externes', 'Total']
    ]
    
    for emp in rapport_response["employes"]:
        type_emploi = emp.get("type_emploi", "temps_plein")
        if type_emploi == "temps_plein":
            type_emploi_abbr = "TP"
        elif type_emploi == "temporaire":
            type_emploi_abbr = "Tempo"
        else:
            type_emploi_abbr = "TPart"
        table_data.append([
            emp["nom_complet"],
            type_emploi_abbr,
            emp.get("grade", "N/A"),
            f"{emp['heures_internes']}h",
            f"{emp['heures_externes']}h",
            f"{emp['total_heures']}h"
        ])
    
    table = Table(table_data, colWidths=[2.5*inch, 0.6*inch, 1.2*inch, 1*inch, 1*inch, 0.8*inch])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('FONTSIZE', (0, 1), (-1, -1), 9),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    elements.append(table)
    elements.append(Spacer(1, 0.3*inch))
    
    # Statistiques
    stats = rapport_response["statistiques"]
    stats_text = f"""
    <b>Statistiques Globales</b><br/>
    Nombre d'employ√©s: {stats['nombre_employes']}<br/>
    Total heures planifi√©es: {stats['total_heures_planifiees']}h<br/>
    Moyenne heures internes: {stats['moyenne_heures_internes']}h<br/>
    Moyenne heures externes: {stats['moyenne_heures_externes']}h
    """
    elements.append(Paragraph(stats_text, styles['Normal']))
    
    # Ajouter footer ProFireManager
    elements.append(Spacer(1, 0.5*inch))
    footer_style = ParagraphStyle(
        'Footer',
        parent=styles['Normal'],
        fontSize=8,
        textColor=colors.grey,
        alignment=TA_CENTER
    )
    footer_text = create_pdf_footer_text(tenant)
    if footer_text:
        elements.append(Paragraph(footer_text, footer_style))
    
    doc.build(elements)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=rapport_heures_{date_debut}_{date_fin}.pdf"}
    )

@api_router.get("/{tenant_slug}/planning/rapport-heures/export-excel")
async def export_rapport_heures_excel(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """G√©n√®re l'Excel du rapport d'heures"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es du rapport
    rapport_response = await get_rapport_heures(tenant_slug, date_debut, date_fin, current_user)
    
    from openpyxl import Workbook
    from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
    from io import BytesIO
    
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport Heures"
    
    # Styles
    header_fill = PatternFill(start_color="DC2626", end_color="DC2626", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True, size=11)
    border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    center_alignment = Alignment(horizontal="center", vertical="center")
    
    # Titre
    ws.merge_cells('A1:F1')
    title_cell = ws['A1']
    title_cell.value = "Rapport d'Heures"
    title_cell.font = Font(size=16, bold=True, color="DC2626")
    title_cell.alignment = center_alignment
    
    # P√©riode
    ws.merge_cells('A2:F2')
    periode_cell = ws['A2']
    debut_dt = datetime.strptime(date_debut, "%Y-%m-%d")
    fin_dt = datetime.strptime(date_fin, "%Y-%m-%d")
    periode_cell.value = f"P√©riode: {debut_dt.strftime('%d/%m/%Y')} - {fin_dt.strftime('%d/%m/%Y')}"
    periode_cell.alignment = center_alignment
    
    # En-t√™tes du tableau
    headers = ['Employ√©', 'Type', 'Grade', 'H. Internes', 'H. Externes', 'Total']
    for col, header in enumerate(headers, start=1):
        cell = ws.cell(row=4, column=col)
        cell.value = header
        cell.fill = header_fill
        cell.font = header_font
        cell.border = border
        cell.alignment = center_alignment
    
    # Donn√©es
    row = 5
    for emp in rapport_response["employes"]:
        type_emploi = emp.get("type_emploi", "temps_plein")
        if type_emploi == "temps_plein":
            type_emploi_abbr = "TP"
        elif type_emploi == "temporaire":
            type_emploi_abbr = "Tempo"
        else:
            type_emploi_abbr = "TPart"
        ws.cell(row=row, column=1, value=emp["nom_complet"])
        ws.cell(row=row, column=2, value=type_emploi_abbr)
        ws.cell(row=row, column=3, value=emp.get("grade", "N/A"))
        ws.cell(row=row, column=4, value=emp["heures_internes"])
        ws.cell(row=row, column=5, value=emp["heures_externes"])
        ws.cell(row=row, column=6, value=emp["total_heures"])
        
        for col in range(1, 7):
            ws.cell(row=row, column=col).border = border
            ws.cell(row=row, column=col).alignment = center_alignment
        
        row += 1
    
    # Statistiques
    stats = rapport_response["statistiques"]
    row += 1
    ws.merge_cells(f'A{row}:F{row}')
    stats_cell = ws.cell(row=row, column=1)
    stats_cell.value = "Statistiques Globales"
    stats_cell.font = Font(bold=True, size=12)
    
    row += 1
    ws.cell(row=row, column=1, value="Nombre d'employ√©s:")
    ws.cell(row=row, column=2, value=stats['nombre_employes'])
    
    row += 1
    ws.cell(row=row, column=1, value="Total heures planifi√©es:")
    ws.cell(row=row, column=2, value=stats['total_heures_planifiees'])
    
    row += 1
    ws.cell(row=row, column=1, value="Moyenne heures internes:")
    ws.cell(row=row, column=2, value=stats['moyenne_heures_internes'])
    
    row += 1
    ws.cell(row=row, column=1, value="Moyenne heures externes:")
    ws.cell(row=row, column=2, value=stats['moyenne_heures_externes'])
    
    # Ajuster les largeurs
    ws.column_dimensions['A'].width = 25
    ws.column_dimensions['B'].width = 8
    ws.column_dimensions['C'].width = 15
    ws.column_dimensions['D'].width = 12
    ws.column_dimensions['E'].width = 12
    ws.column_dimensions['F'].width = 10
    
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename=rapport_heures_{date_debut}_{date_fin}.xlsx"}
    )

# ===== FIN EXPORTS PLANNING =====


@api_router.delete("/{tenant_slug}/planning/assignation/{assignation_id}")
async def retirer_assignation(tenant_slug: str, assignation_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Trouver l'assignation dans ce tenant
        assignation = await db.assignations.find_one({"id": assignation_id, "tenant_id": tenant.id})
        if not assignation:
            raise HTTPException(status_code=404, detail="Assignation non trouv√©e")
        
        # Supprimer l'assignation
        result = await db.assignations.delete_one({"id": assignation_id, "tenant_id": tenant.id})
        if result.deleted_count == 0:
            raise HTTPException(status_code=400, detail="Impossible de retirer l'assignation")
        
        # Cr√©er une activit√©
        user = await db.users.find_one({"id": assignation["user_id"], "tenant_id": tenant.id})
        type_garde = await db.types_garde.find_one({"id": assignation.get("type_garde_id"), "tenant_id": tenant.id})
        if user and type_garde:
            await creer_activite(
                tenant_id=tenant.id,
                type_activite="assignation_retrait",
                description=f"‚ùå {current_user.prenom} {current_user.nom} a retir√© {user['prenom']} {user['nom']} de la garde '{type_garde['nom']}' du {assignation['date']}",
                user_id=current_user.id,
                user_nom=f"{current_user.prenom} {current_user.nom}",
                data={"concerne_user_id": assignation["user_id"]}
            )
        
        return {
            "message": "Assignation retir√©e avec succ√®s",
            "assignation_supprimee": assignation_id,
            "date": assignation["date"],
            "user_id": assignation["user_id"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur suppression assignation: {str(e)}")

@api_router.post("/{tenant_slug}/planning/assignation")
async def create_assignation(tenant_slug: str, assignation: AssignationCreate, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer le type de garde pour validation
    type_garde = await db.types_garde.find_one({"id": assignation.type_garde_id, "tenant_id": tenant.id})
    if not type_garde:
        raise HTTPException(status_code=404, detail="Type de garde non trouv√©")
    
    # VALIDATION: V√©rifier que le jour de la date est autoris√© pour ce type de garde
    jours_application = type_garde.get("jours_application", [])
    if jours_application and len(jours_application) > 0:
        # Mapper les jours fran√ßais vers anglais pour la comparaison
        jours_fr_to_en = {
            0: "monday", 1: "tuesday", 2: "wednesday", 3: "thursday",
            4: "friday", 5: "saturday", 6: "sunday"
        }
        jours_en_to_fr = {
            "monday": "Lundi", "tuesday": "Mardi", "wednesday": "Mercredi",
            "thursday": "Jeudi", "friday": "Vendredi", "saturday": "Samedi", "sunday": "Dimanche"
        }
        
        date_obj = datetime.strptime(assignation.date, "%Y-%m-%d")
        jour_semaine_en = jours_fr_to_en[date_obj.weekday()]
        
        if jour_semaine_en not in jours_application:
            jours_autorises_fr = [jours_en_to_fr[j] for j in jours_application]
            raise HTTPException(
                status_code=400,
                detail=f"Impossible d'assigner la garde '{type_garde['nom']}' le {jours_en_to_fr[jour_semaine_en]}. "
                       f"Cette garde est uniquement applicable les: {', '.join(jours_autorises_fr)}"
            )
    
    # V√âRIFICATION CRITIQUE : Emp√™cher les doublons
    # V√©rifier si cet utilisateur est d√©j√† assign√© √† cette garde √† cette date
    existing_assignment = await db.assignations.find_one({
        "tenant_id": tenant.id,
        "user_id": assignation.user_id,
        "type_garde_id": assignation.type_garde_id,
        "date": assignation.date
    })
    
    if existing_assignment:
        raise HTTPException(
            status_code=400, 
            detail="Cet employ√© est d√©j√† assign√© √† cette garde pour cette date"
        )
    
    # Store assignation in database avec tenant_id
    assignation_dict = assignation.dict()
    assignation_dict["tenant_id"] = tenant.id
    assignation_obj = Assignation(**assignation_dict)
    await db.assignations.insert_one(assignation_obj.dict())
    
    # Cr√©er notification pour l'employ√© assign√© (filtr√© par tenant)
    user_assigne = await db.users.find_one({"id": assignation.user_id, "tenant_id": tenant.id})
    
    if user_assigne and type_garde:
        await creer_notification(
            tenant_id=tenant.id,
            destinataire_id=assignation.user_id,
            type="planning_assigne",
            titre="Nouveau quart assign√©",
            message=f"Vous avez √©t√© assign√©(e) au quart '{type_garde['nom']}' le {assignation.date}",
            lien="/planning",
            data={
                "assignation_id": assignation_obj.id,
                "date": assignation.date,
                "type_garde": type_garde["nom"]
            }
        )
        
        # Cr√©er une activit√©
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="assignation_manuelle",
            description=f"üìÖ {current_user.prenom} {current_user.nom} a assign√© {user_assigne['prenom']} {user_assigne['nom']} √† la garde '{type_garde['nom']}' le {assignation.date}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": assignation.user_id}  # Pour filtrage superviseur/employ√©
        )
    
    return {"message": "Assignation cr√©√©e avec succ√®s"}

@api_router.get("/{tenant_slug}/planning/assignations/{semaine_debut}")
async def get_assignations(tenant_slug: str, semaine_debut: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # D√©terminer la p√©riode en fonction du format de la date
    # Si c'est le 1er du mois (ex: 2024-10-01), r√©cup√©rer tout le mois
    # Sinon, r√©cup√©rer la semaine (7 jours)
    date_debut = datetime.strptime(semaine_debut, "%Y-%m-%d")
    
    if date_debut.day == 1:
        # Vue mensuelle : r√©cup√©rer tout le mois
        # Dernier jour du mois
        if date_debut.month == 12:
            date_fin = datetime(date_debut.year + 1, 1, 1) - timedelta(days=1)
        else:
            date_fin = datetime(date_debut.year, date_debut.month + 1, 1) - timedelta(days=1)
    else:
        # Vue hebdomadaire : r√©cup√©rer 7 jours
        date_fin = date_debut + timedelta(days=6)
    
    date_fin_str = date_fin.strftime("%Y-%m-%d")
    
    assignations = await db.assignations.find({
        "tenant_id": tenant.id,
        "date": {
            "$gte": semaine_debut,
            "$lte": date_fin_str
        }
    }).to_list(1000)
    
    # Clean MongoDB documents
    cleaned_assignations = [clean_mongo_doc(assignation) for assignation in assignations]
    return [Assignation(**assignation) for assignation in cleaned_assignations]

# ROUTE G√âN√âRIQUE - DOIT √äTRE APR√àS TOUTES LES ROUTES SP√âCIFIQUES
@api_router.get("/{tenant_slug}/planning/{semaine_debut}")
async def get_planning(tenant_slug: str, semaine_debut: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    planning = await db.planning.find_one({"semaine_debut": semaine_debut, "tenant_id": tenant.id})
    if not planning:
        # Create empty planning for the week
        semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        planning_obj = Planning(semaine_debut=semaine_debut, semaine_fin=semaine_fin)
        planning_dict = planning_obj.dict()
        planning_dict["tenant_id"] = tenant.id
        await db.planning.insert_one(planning_dict)
        planning = planning_dict
    else:
        planning = clean_mongo_doc(planning)
    
    return planning

# Remplacements routes

# ==================== SYST√àME AUTOMATIS√â DE REMPLACEMENT ====================

async def calculer_priorite_demande(date_garde: str) -> str:
    """
    Calcule la priorit√© d'une demande de remplacement
    - urgent: Si la garde est dans 24h ou moins
    - normal: Si la garde est dans plus de 24h
    """
    try:
        date_garde_obj = datetime.strptime(date_garde, "%Y-%m-%d").replace(tzinfo=timezone.utc)
        maintenant = datetime.now(timezone.utc)
        delta = date_garde_obj - maintenant
        
        if delta.total_seconds() <= 86400:  # 24 heures en secondes
            return "urgent"
        return "normal"
    except Exception as e:
        logging.error(f"Erreur calcul priorit√©: {e}")
        return "normal"

async def trouver_remplacants_potentiels(
    tenant_id: str,
    type_garde_id: str,
    date_garde: str,
    demandeur_id: str,
    exclus_ids: List[str] = []
) -> List[Dict[str, Any]]:
    """
    Trouve les rempla√ßants potentiels selon les crit√®res configur√©s dans Param√®tres > Remplacements:
    1. Comp√©tences requises pour le type de garde (si competences_egales activ√©)
    2. Grade √©quivalent ou sup√©rieur (si grade_egal activ√©)
    3. Pas d'indisponibilit√© pour cette date
    4. Disponibilit√© d√©clar√©e (filtr√© si privilegier_disponibles activ√©, sinon bonus de tri)
    5. Anciennet√© (date_embauche la plus ancienne)
    
    Retourne une liste tri√©e de rempla√ßants par ordre de priorit√©
    """
    try:
        # R√©cup√©rer les param√®tres de remplacements pour ce tenant
        parametres = await db.parametres_remplacements.find_one({"tenant_id": tenant_id})
        
        # Valeurs par d√©faut si pas de param√®tres
        privilegier_disponibles = parametres.get("privilegier_disponibles", False) if parametres else False
        grade_egal = parametres.get("grade_egal", False) if parametres else False
        competences_egales = parametres.get("competences_egales", False) if parametres else False
        
        logging.warning(f"‚öôÔ∏è Param√®tres remplacements - privilegier_disponibles: {privilegier_disponibles}, grade_egal: {grade_egal}, competences_egales: {competences_egales}")
        
        # R√©cup√©rer le type de garde pour conna√Ætre les comp√©tences requises
        type_garde_data = await db.types_garde.find_one({"id": type_garde_id, "tenant_id": tenant_id})
        if not type_garde_data:
            logging.error(f"Type de garde non trouv√©: {type_garde_id}")
            return []
        
        competences_requises = type_garde_data.get("competences_requises", [])
        officier_obligatoire = type_garde_data.get("officier_obligatoire", False)
        
        # R√©cup√©rer le demandeur pour comparer grade/comp√©tences
        demandeur = await db.users.find_one({"id": demandeur_id, "tenant_id": tenant_id})
        demandeur_grade = demandeur.get("grade", "pompier").lower() if demandeur else "pompier"
        demandeur_competences = set(demandeur.get("competences", [])) if demandeur else set()
        
        # R√©cup√©rer tous les utilisateurs du tenant (sauf demandeur et d√©j√† exclus)
        exclus_ids_set = set(exclus_ids + [demandeur_id])
        
        users_cursor = db.users.find({
            "tenant_id": tenant_id,
            "id": {"$nin": list(exclus_ids_set)},
            "type_emploi": "temps_partiel"  # Seulement temps partiel pour remplacements
        })
        users_list = await users_cursor.to_list(length=None)
        
        logging.warning(f"üîç Recherche rempla√ßants - Type garde: {type_garde_id}, Comp√©tences requises: {competences_requises}, Officier obligatoire: {officier_obligatoire}")
        logging.warning(f"üîç Trouv√© {len(users_list)} employ√©s temps partiel (excluant {len(exclus_ids_set)} IDs)")
        
        remplacants_potentiels = []
        
        # Hi√©rarchie des grades (du plus bas au plus haut)
        grades_hierarchie = {
            "pompier": 1,
            "lieutenant": 2,
            "capitaine": 3,
            "chef": 4,
            "eligible": 2,  # √âligible = √©quivalent lieutenant
            "√©ligible": 2
        }
        demandeur_grade_niveau = grades_hierarchie.get(demandeur_grade, 1)
        
        for user in users_list:
            user_name = f"{user.get('prenom', '')} {user.get('nom', '')}"
            user_grade = user.get("grade", "pompier")
            user_grade_lower = user_grade.lower() if user_grade else "pompier"
            user_grade_niveau = grades_hierarchie.get(user_grade_lower, 1)
            
            # 1. V√©rifier les comp√©tences (SI competences_egales est activ√©)
            if competences_egales:
                user_competences = set(user.get("competences", []))
                # V√©rifier que le rempla√ßant a les comp√©tences du demandeur
                if demandeur_competences and not demandeur_competences.issubset(user_competences):
                    logging.warning(f"‚ùå {user_name} - Comp√©tences insuffisantes: {user_competences} vs demandeur: {demandeur_competences}")
                    continue
                # Aussi v√©rifier les comp√©tences requises du type de garde
                if competences_requises and not set(competences_requises).issubset(user_competences):
                    logging.warning(f"‚ùå {user_name} - Comp√©tences type garde insuffisantes: {user_competences} vs requis: {competences_requises}")
                    continue
            
            # 2. V√©rifier le grade (SI grade_egal est activ√© OU si officier_obligatoire)
            if grade_egal:
                # Le rempla√ßant doit avoir un grade >= au demandeur
                if user_grade_niveau < demandeur_grade_niveau:
                    logging.warning(f"‚ùå {user_name} - Grade insuffisant: {user_grade} (niveau {user_grade_niveau}) vs demandeur niveau {demandeur_grade_niveau}")
                    continue
            
            if officier_obligatoire:
                # Pour officier obligatoire, il faut au moins lieutenant OU √™tre √©ligible
                grades_autorises = ["lieutenant", "capitaine", "chef", "eligible", "√©ligible"]
                if user_grade_lower not in grades_autorises:
                    logging.warning(f"‚ùå {user_name} - Grade insuffisant: {user_grade} (officier ou √©ligible requis)")
                    continue
            
            # 3. V√©rifier qu'il n'a PAS d'indisponibilit√© pour cette date
            indispo = await db.disponibilites.find_one({
                "user_id": user["id"],
                "tenant_id": tenant_id,
                "date": date_garde,
                "statut": "indisponible"
            })
            
            if indispo:
                logging.warning(f"‚ùå {user_name} - Indisponible pour cette date")
                continue  # A une indisponibilit√©, on passe
            
            # 4. V√©rifier s'il a une disponibilit√© d√©clar√©e
            dispo = await db.disponibilites.find_one({
                "user_id": user["id"],
                "tenant_id": tenant_id,
                "date": date_garde,
                "statut": "disponible"
            })
            
            has_disponibilite = dispo is not None
            
            # Si privilegier_disponibles est activ√©, FILTRER ceux qui n'ont pas de dispo
            if privilegier_disponibles and not has_disponibilite:
                logging.warning(f"‚ùå {user_name} - Pas de disponibilit√© d√©clar√©e (filtre privilegier_disponibles actif)")
                continue
            
            # 5. V√©rifier les limites d'heures (gestion heures suppl√©mentaires)
            if parametres and not parametres.get("activer_gestion_heures_sup", False):
                # Heures sup d√©sactiv√©es : v√©rifier la limite hebdo
                heures_max_user = user.get("heures_max_semaine", 40)
                
                # Calculer heures de la semaine pour cet utilisateur
                semaine_debut = datetime.strptime(date_garde, "%Y-%m-%d")
                while semaine_debut.weekday() != 0:  # Trouver le lundi
                    semaine_debut -= timedelta(days=1)
                semaine_fin = semaine_debut + timedelta(days=6)
                
                assignations_semaine = await db.assignations.find({
                    "user_id": user["id"],
                    "tenant_id": tenant_id,
                    "date": {
                        "$gte": semaine_debut.strftime("%Y-%m-%d"),
                        "$lte": semaine_fin.strftime("%Y-%m-%d")
                    }
                }).to_list(1000)
                
                heures_semaine = sum(8 for _ in assignations_semaine)  # Simplification: 8h par garde
                duree_garde = type_garde_data.get("duree_heures", 8)
                
                if heures_semaine + duree_garde > heures_max_user:
                    logging.warning(f"‚ùå {user_name} - D√©passe heures max hebdo ({heures_semaine + duree_garde} > {heures_max_user})")
                    continue
            
            # 6. Anciennet√© (date_embauche)
            date_embauche = user.get("date_embauche", "2999-12-31")  # Si pas de date, le plus r√©cent
            
            logging.warning(f"‚úÖ {user_name} - Ajout√© comme rempla√ßant potentiel (dispo d√©clar√©e: {has_disponibilite})")
            
            remplacants_potentiels.append({
                "user_id": user["id"],
                "nom_complet": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "email": user.get("email", ""),
                "grade": user_grade,
                "date_embauche": date_embauche,
                "has_disponibilite": has_disponibilite,
                "formations": list(set(user.get("competences", [])))
            })
        
        # Trier par: 1. Disponibilit√© d√©clar√©e (si pas de filtre), 2. Anciennet√© (date la plus ancienne)
        remplacants_potentiels.sort(
            key=lambda x: (
                not x["has_disponibilite"],  # False (a dispo) avant True (pas de dispo)
                x["date_embauche"]  # Date la plus ancienne en premier
            )
        )
        
        logging.info(f"‚úÖ Trouv√© {len(remplacants_potentiels)} rempla√ßants potentiels pour demande {type_garde_id}")
        return remplacants_potentiels
        
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de la recherche de rempla√ßants: {e}", exc_info=True)
        return []

async def generer_token_remplacement(demande_id: str, remplacant_id: str, tenant_id: str) -> str:
    """
    G√©n√®re un token unique et temporaire pour accepter/refuser un remplacement par email
    Le token est valide pendant 48 heures
    """
    token = str(uuid.uuid4())
    expiration = datetime.now(timezone.utc) + timedelta(hours=48)
    
    await db.tokens_remplacement.insert_one({
        "token": token,
        "demande_id": demande_id,
        "remplacant_id": remplacant_id,
        "tenant_id": tenant_id,
        "expiration": expiration.isoformat(),
        "utilise": False,
        "created_at": datetime.now(timezone.utc).isoformat()
    })
    
    return token

async def envoyer_email_remplacement(
    demande_data: dict,
    remplacant: dict,
    demandeur: dict,
    type_garde: dict,
    tenant_id: str,
    token: str
):
    """
    Envoie un email au rempla√ßant potentiel avec les boutons Accepter/Refuser
    """
    try:
        resend_api_key = os.environ.get('RESEND_API_KEY')
        if not resend_api_key:
            logging.warning(f"RESEND_API_KEY non configur√©e - Email non envoy√©")
            return False
        
        resend.api_key = resend_api_key
        
        # R√©cup√©rer l'email du rempla√ßant
        remplacant_user = await db.users.find_one({"id": remplacant["user_id"]})
        if not remplacant_user or not remplacant_user.get("email"):
            logging.warning(f"Email non trouv√© pour rempla√ßant {remplacant['user_id']}")
            return False
        
        remplacant_email = remplacant_user["email"]
        remplacant_prenom = remplacant_user.get("prenom", "")
        
        # URL de base pour les liens
        frontend_url = os.environ.get('FRONTEND_URL', 'https://profire-portal.preview.emergentagent.com')
        backend_url = os.environ.get('REACT_APP_BACKEND_URL', frontend_url)
        
        # Liens avec token - utilise l'API backend
        lien_accepter = f"{backend_url}/api/remplacement-action/{token}/accepter"
        lien_refuser = f"{backend_url}/api/remplacement-action/{token}/refuser"
        
        # Informations de la demande
        demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}"
        type_garde_nom = type_garde.get("nom", "Garde")
        date_garde = demande_data.get("date", "")
        heure_debut = type_garde.get("heure_debut", "")
        heure_fin = type_garde.get("heure_fin", "")
        raison = demande_data.get("raison", "")
        
        # HTML de l'email
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f5f5f5;">
            <div style="background-color: white; border-radius: 12px; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="color: #dc2626; margin: 0;">üö® Demande de Remplacement</h1>
                </div>
                
                <p style="font-size: 16px; color: #333;">Bonjour {remplacant_prenom},</p>
                
                <p style="font-size: 16px; color: #333;">
                    <strong>{demandeur_nom}</strong> recherche un rempla√ßant et vous avez √©t√© identifi√© comme disponible.
                </p>
                
                <div style="background-color: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h3 style="margin-top: 0; color: #1e3a5f;">üìã D√©tails de la garde</h3>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <td style="padding: 8px 0; color: #666; width: 40%;">Type de garde:</td>
                            <td style="padding: 8px 0; color: #333; font-weight: bold;">{type_garde_nom}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px 0; color: #666;">Date:</td>
                            <td style="padding: 8px 0; color: #333; font-weight: bold;">{date_garde}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px 0; color: #666;">Horaire:</td>
                            <td style="padding: 8px 0; color: #333; font-weight: bold;">{heure_debut} - {heure_fin}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px 0; color: #666;">Demandeur:</td>
                            <td style="padding: 8px 0; color: #333; font-weight: bold;">{demandeur_nom}</td>
                        </tr>
                        {f'<tr><td style="padding: 8px 0; color: #666;">Raison:</td><td style="padding: 8px 0; color: #333;">{raison}</td></tr>' if raison else ''}
                    </table>
                </div>
                
                <p style="font-size: 16px; color: #333; text-align: center; margin: 30px 0 20px;">
                    <strong>Pouvez-vous effectuer ce remplacement ?</strong>
                </p>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a href="{lien_accepter}" 
                       style="display: inline-block; background-color: #22c55e; color: white; padding: 15px 40px; 
                              text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 16px; 
                              margin: 0 10px; box-shadow: 0 2px 5px rgba(34,197,94,0.3);">
                        ‚úÖ J'accepte
                    </a>
                    <a href="{lien_refuser}" 
                       style="display: inline-block; background-color: #ef4444; color: white; padding: 15px 40px; 
                              text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 16px; 
                              margin: 0 10px; box-shadow: 0 2px 5px rgba(239,68,68,0.3);">
                        ‚ùå Je refuse
                    </a>
                </div>
                
                <p style="font-size: 14px; color: #666; text-align: center; margin-top: 30px;">
                    Vous pouvez √©galement r√©pondre directement dans l'application ProFireManager.
                </p>
                
                <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                
                <p style="font-size: 12px; color: #999; text-align: center;">
                    Ce lien est valide pendant 48 heures.<br>
                    Si vous n'√™tes pas concern√© par cette demande, veuillez ignorer cet email.
                </p>
            </div>
        </body>
        </html>
        """
        
        params = {
            "from": "ProFireManager <remplacement@profiremanager.ca>",
            "to": [remplacant_email],
            "subject": f"üö® Demande de remplacement - {type_garde_nom} le {date_garde}",
            "html": html_content
        }
        
        response = resend.Emails.send(params)
        logging.info(f"‚úÖ Email de remplacement envoy√© √† {remplacant_email} (ID: {response.get('id', 'N/A')})")
        return True
        
    except Exception as e:
        logging.error(f"‚ùå Erreur envoi email remplacement: {e}", exc_info=True)
        return False

async def lancer_recherche_remplacant(demande_id: str, tenant_id: str):
    """
    Lance la recherche de rempla√ßant pour une demande
    Contacte le(s) premier(s) rempla√ßant(s) selon le mode de notification
    """
    try:
        # R√©cup√©rer la demande
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            logging.error(f"Demande de remplacement non trouv√©e: {demande_id}")
            return
        
        # R√©cup√©rer les param√®tres de remplacement
        parametres_data = await db.parametres.find_one({"tenant_id": tenant_id})
        if not parametres_data:
            # Param√®tres par d√©faut
            mode_notification = "un_par_un"
            delai_attente_heures = 2
            nombre_simultane = 1
        else:
            mode_notification = parametres_data.get("mode_notification", "un_par_un")
            delai_attente_heures = parametres_data.get("delai_attente_heures", 2)
            nombre_simultane = parametres_data.get("nombre_simultane", 3)
        
        # Trouver les rempla√ßants potentiels (excluant ceux d√©j√† contact√©s)
        exclus_ids = [t.get("user_id") for t in demande_data.get("tentatives_historique", [])]
        
        remplacants = await trouver_remplacants_potentiels(
            tenant_id=tenant_id,
            type_garde_id=demande_data["type_garde_id"],
            date_garde=demande_data["date"],
            demandeur_id=demande_data["demandeur_id"],
            exclus_ids=exclus_ids
        )
        
        if not remplacants:
            # Aucun rempla√ßant trouv√©, marquer comme expiree et notifier superviseur
            logging.warning(f"‚ö†Ô∏è Aucun rempla√ßant trouv√© pour la demande {demande_id}")
            await db.demandes_remplacement.update_one(
                {"id": demande_id},
                {
                    "$set": {
                        "statut": "expiree",
                        "updated_at": datetime.now(timezone.utc)
                    }
                }
            )
            
            # Notifier superviseurs qu'aucun rempla√ßant n'a √©t√© trouv√©
            superviseurs = await db.users.find({
                "tenant_id": tenant_id,
                "role": {"$in": ["superviseur", "admin"]}
            }).to_list(100)
            
            superviseur_ids = [s["id"] for s in superviseurs]
            if superviseur_ids:
                demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
                await send_push_notification_to_users(
                    user_ids=superviseur_ids,
                    title="‚ùå Aucun rempla√ßant trouv√©",
                    body=f"Aucun rempla√ßant disponible pour {demandeur.get('prenom', '')} {demandeur.get('nom', '')} le {demande_data['date']}",
                    data={
                        "type": "remplacement_expiree",
                        "demande_id": demande_id
                    }
                )
            
            # Notifier le demandeur que sa demande a expir√©
            demandeur_id = demande_data.get("demandeur_id")
            if demandeur_id:
                await send_push_notification_to_users(
                    user_ids=[demandeur_id],
                    title="‚ùå Demande de remplacement expir√©e",
                    body=f"Aucun rempla√ßant n'a √©t√© trouv√© pour votre demande du {demande_data['date']}. Contactez votre superviseur.",
                    data={
                        "type": "remplacement_expiree",
                        "demande_id": demande_id
                    }
                )
                # Cr√©er une notification in-app
                await db.notifications.insert_one({
                    "id": str(uuid.uuid4()),
                    "tenant_id": tenant_id,
                    "user_id": demandeur_id,
                    "type": "remplacement_expiree",
                    "titre": "‚ùå Demande de remplacement expir√©e",
                    "message": f"Aucun rempla√ßant n'a √©t√© trouv√© pour votre demande du {demande_data['date']}.",
                    "lu": False,
                    "data": {"demande_id": demande_id},
                    "created_at": datetime.now(timezone.utc).isoformat()
                })
            return
        
        # D√©terminer combien de rempla√ßants contacter
        if mode_notification == "multiple":
            nombre_a_contacter = min(nombre_simultane, len(remplacants))
        else:  # un_par_un
            nombre_a_contacter = 1
        
        remplacants_a_contacter = remplacants[:nombre_a_contacter]
        
        # Contacter les rempla√ßants
        remplacant_ids = []
        maintenant = datetime.now(timezone.utc)
        
        for remplacant in remplacants_a_contacter:
            # Ajouter √† l'historique
            tentative = {
                "user_id": remplacant["user_id"],
                "nom_complet": remplacant["nom_complet"],
                "date_contact": maintenant.isoformat(),
                "statut": "contacted",
                "date_reponse": None
            }
            
            await db.demandes_remplacement.update_one(
                {"id": demande_id},
                {
                    "$push": {"tentatives_historique": tentative},
                    "$addToSet": {"remplacants_contactes_ids": remplacant["user_id"]}
                }
            )
            
            remplacant_ids.append(remplacant["user_id"])
            
            logging.info(f"üì§ Contact rempla√ßant {remplacant['nom_complet']} pour demande {demande_id}")
        
        # Calculer la date de prochaine tentative (si timeout sans r√©ponse)
        date_prochaine = maintenant + timedelta(hours=delai_attente_heures)
        
        # Mettre √† jour la demande
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "en_cours",
                    "date_prochaine_tentative": date_prochaine,
                    "updated_at": maintenant
                },
                "$inc": {"nombre_tentatives": 1}
            }
        )
        
        # Envoyer notifications push aux rempla√ßants
        demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
        type_garde = await db.types_garde.find_one({"id": demande_data["type_garde_id"]})
        
        await send_push_notification_to_users(
            user_ids=remplacant_ids,
            title="üö® Demande de remplacement",
            body=f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')} cherche un rempla√ßant pour {type_garde.get('nom', 'une garde')} le {demande_data['date']}",
            data={
                "type": "remplacement_proposition",
                "demande_id": demande_id,
                "lien": "/remplacements",
                "sound": "urgent"  # Son urgent pour les remplacements
            }
        )
        
        # Cr√©er des notifications in-app pour chaque rempla√ßant contact√©
        demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}"
        type_garde_nom = type_garde.get("nom", "une garde") if type_garde else "une garde"
        
        for remplacant_id in remplacant_ids:
            await db.notifications.insert_one({
                "id": str(uuid.uuid4()),
                "tenant_id": tenant_id,
                "user_id": remplacant_id,
                "type": "remplacement_proposition",
                "titre": "üö® Demande de remplacement urgente",
                "message": f"{demandeur_nom} cherche un rempla√ßant pour {type_garde_nom} le {demande_data['date']}. R√©pondez rapidement !",
                "lu": False,
                "urgent": True,  # Marqueur pour son urgent
                "data": {
                    "demande_id": demande_id,
                    "lien": "/remplacements"
                },
                "created_at": datetime.now(timezone.utc).isoformat()
            })
        
        # Envoyer emails aux rempla√ßants avec boutons Accepter/Refuser
        for remplacant in remplacants_a_contacter:
            try:
                # G√©n√©rer un token unique pour ce rempla√ßant
                token = await generer_token_remplacement(demande_id, remplacant["user_id"], tenant_id)
                
                # Envoyer l'email
                await envoyer_email_remplacement(
                    demande_data=demande_data,
                    remplacant=remplacant,
                    demandeur=demandeur,
                    type_garde=type_garde,
                    tenant_id=tenant_id,
                    token=token
                )
            except Exception as email_error:
                logging.error(f"Erreur envoi email √† {remplacant['nom_complet']}: {email_error}")
        
        logging.info(f"‚úÖ Recherche lanc√©e pour demande {demande_id}: {nombre_a_contacter} rempla√ßant(s) contact√©(s)")
        
    except Exception as e:
        logging.error(f"‚ùå Erreur lors du lancement de la recherche de rempla√ßant: {e}", exc_info=True)

async def accepter_remplacement(demande_id: str, remplacant_id: str, tenant_id: str):
    """
    Traite l'acceptation d'un remplacement par un rempla√ßant
    - V√©rifie que le rempla√ßant est le plus ancien si plusieurs acceptations simultan√©es
    - Met √† jour le planning (assignations)
    - Notifie le demandeur et les superviseurs
    """
    try:
        # R√©cup√©rer la demande
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            raise HTTPException(status_code=404, detail="Demande non trouv√©e")
        
        # V√©rifier que la demande est toujours en cours
        if demande_data["statut"] != "en_cours":
            raise HTTPException(status_code=400, detail="Cette demande n'est plus disponible")
        
        # V√©rifier que le rempla√ßant a bien √©t√© contact√©
        if remplacant_id not in demande_data.get("remplacants_contactes_ids", []):
            raise HTTPException(status_code=403, detail="Vous n'√™tes pas autoris√© √† accepter cette demande")
        
        # R√©cup√©rer le rempla√ßant
        remplacant = await db.users.find_one({"id": remplacant_id, "tenant_id": tenant_id})
        if not remplacant:
            raise HTTPException(status_code=404, detail="Rempla√ßant non trouv√©")
        
        # Mettre √† jour la demande
        maintenant = datetime.now(timezone.utc)
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "accepte",
                    "remplacant_id": remplacant_id,
                    "updated_at": maintenant
                }
            }
        )
        
        # Mettre √† jour l'historique des tentatives
        await db.demandes_remplacement.update_one(
            {
                "id": demande_id,
                "tentatives_historique.user_id": remplacant_id
            },
            {
                "$set": {
                    "tentatives_historique.$.statut": "accepted",
                    "tentatives_historique.$.date_reponse": maintenant.isoformat()
                }
            }
        )
        
        # Mettre √† jour le planning (assignations)
        # Trouver l'assignation du demandeur pour cette date et ce type de garde
        assignation = await db.assignations.find_one({
            "tenant_id": tenant_id,
            "user_id": demande_data["demandeur_id"],
            "date": demande_data["date"],
            "type_garde_id": demande_data["type_garde_id"]
        })
        
        if assignation:
            # Remplacer l'assignation par le rempla√ßant
            await db.assignations.update_one(
                {"id": assignation["id"]},
                {
                    "$set": {
                        "user_id": remplacant_id,
                        "est_remplacement": True,
                        "demandeur_original_id": demande_data["demandeur_id"],
                        "updated_at": maintenant
                    }
                }
            )
            logging.info(f"‚úÖ Planning mis √† jour: {remplacant['prenom']} {remplacant['nom']} remplace assignation {assignation['id']}")
        else:
            logging.warning(f"‚ö†Ô∏è Aucune assignation trouv√©e pour le demandeur {demande_data['demandeur_id']} le {demande_data['date']}")
        
        # Notifier le demandeur
        demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
        await send_push_notification_to_users(
            user_ids=[demande_data["demandeur_id"]],
            title="‚úÖ Remplacement trouv√©!",
            body=f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')} a accept√© de vous remplacer le {demande_data['date']}",
            data={
                "type": "remplacement_accepte",
                "demande_id": demande_id,
                "remplacant_id": remplacant_id
            }
        )
        
        # Cr√©er une notification in-app pour le demandeur
        await db.notifications.insert_one({
            "id": str(uuid.uuid4()),
            "tenant_id": tenant_id,
            "user_id": demande_data["demandeur_id"],
            "type": "remplacement_accepte",
            "titre": "‚úÖ Remplacement trouv√©!",
            "message": f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')} a accept√© de vous remplacer le {demande_data['date']}.",
            "lu": False,
            "data": {"demande_id": demande_id, "remplacant_id": remplacant_id},
            "created_at": datetime.now(timezone.utc).isoformat()
        })
        
        # Notifier les superviseurs
        superviseurs = await db.users.find({
            "tenant_id": tenant_id,
            "role": {"$in": ["superviseur", "admin"]}
        }).to_list(100)
        
        superviseur_ids = [s["id"] for s in superviseurs]
        if superviseur_ids:
            await send_push_notification_to_users(
                user_ids=superviseur_ids,
                title="‚úÖ Remplacement confirm√©",
                body=f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')} remplace {demandeur.get('prenom', '')} {demandeur.get('nom', '')} le {demande_data['date']}",
                data={
                    "type": "remplacement_accepte",
                    "demande_id": demande_id
                }
            )
        
        # Notifier les autres rempla√ßants contact√©s qu'ils ne sont plus n√©cessaires
        autres_remplacants_ids = [
            rid for rid in demande_data.get("remplacants_contactes_ids", [])
            if rid != remplacant_id
        ]
        
        if autres_remplacants_ids:
            await send_push_notification_to_users(
                user_ids=autres_remplacants_ids,
                title="Remplacement pourvu",
                body=f"Le remplacement du {demande_data['date']} a √©t√© pourvu par un autre pompier",
                data={
                    "type": "remplacement_pourvu",
                    "demande_id": demande_id
                }
            )
        
        # Cr√©er une activit√©
        type_garde = await db.types_garde.find_one({"id": demande_data["type_garde_id"], "tenant_id": tenant_id})
        garde_nom = type_garde['nom'] if type_garde else 'garde'
        await creer_activite(
            tenant_id=tenant_id,
            type_activite="remplacement_accepte",
            description=f"‚úÖ {remplacant.get('prenom', '')} {remplacant.get('nom', '')} a accept√© de remplacer {demandeur.get('prenom', '')} {demandeur.get('nom', '')} pour la {garde_nom} du {demande_data['date']}",
            user_id=remplacant_id,
            user_nom=f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')}",
            data={
                "concerne_user_id": demande_data["demandeur_id"],
                "demande_id": demande_id
            }
        )
        
        logging.info(f"‚úÖ Remplacement accept√©: demande {demande_id}, rempla√ßant {remplacant['nom_complet']}")
        return True
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de l'acceptation du remplacement: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur lors de l'acceptation du remplacement")

async def refuser_remplacement(demande_id: str, remplacant_id: str, tenant_id: str):
    """
    Traite le refus d'un remplacement par un rempla√ßant
    - Met √† jour l'historique
    - Si tous les rempla√ßants contact√©s ont refus√©, lance une nouvelle recherche
    """
    try:
        # R√©cup√©rer la demande
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            raise HTTPException(status_code=404, detail="Demande non trouv√©e")
        
        # V√©rifier que le rempla√ßant a bien √©t√© contact√©
        if remplacant_id not in demande_data.get("remplacants_contactes_ids", []):
            raise HTTPException(status_code=403, detail="Vous n'√™tes pas autoris√© √† refuser cette demande")
        
        # Mettre √† jour l'historique
        maintenant = datetime.now(timezone.utc)
        await db.demandes_remplacement.update_one(
            {
                "id": demande_id,
                "tentatives_historique.user_id": remplacant_id
            },
            {
                "$set": {
                    "tentatives_historique.$.statut": "refused",
                    "tentatives_historique.$.date_reponse": maintenant.isoformat()
                }
            }
        )
        
        # Retirer de la liste des rempla√ßants en attente
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$pull": {"remplacants_contactes_ids": remplacant_id},
                "$set": {"updated_at": maintenant}
            }
        )
        
        # V√©rifier s'il reste des rempla√ßants en attente
        demande_updated = await db.demandes_remplacement.find_one({"id": demande_id})
        if not demande_updated.get("remplacants_contactes_ids"):
            # Plus personne en attente, relancer la recherche imm√©diatement
            logging.info(f"üîÑ Tous les rempla√ßants ont refus√©, relance de la recherche pour demande {demande_id}")
            await lancer_recherche_remplacant(demande_id, tenant_id)
        
        logging.info(f"‚ùå Remplacement refus√© par rempla√ßant {remplacant_id} pour demande {demande_id}")
        return True
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur lors du refus du remplacement: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur lors du refus du remplacement")

async def verifier_et_traiter_timeouts():
    """
    Fonction appel√©e p√©riodiquement pour v√©rifier les demandes en timeout
    Relance la recherche si le d√©lai d'attente est d√©pass√©
    """
    try:
        maintenant = datetime.now(timezone.utc)
        
        # Trouver toutes les demandes en_cours dont la date_prochaine_tentative est d√©pass√©e
        demandes_cursor = db.demandes_remplacement.find({
            "statut": "en_cours",
            "date_prochaine_tentative": {"$lte": maintenant}
        })
        
        demandes_timeout = await demandes_cursor.to_list(length=None)
        
        for demande in demandes_timeout:
            logging.info(f"‚è±Ô∏è Timeout atteint pour demande {demande['id']}, relance de la recherche")
            
            # Marquer les rempla√ßants contact√©s comme expir√©s dans l'historique
            for remplacant_id in demande.get("remplacants_contactes_ids", []):
                await db.demandes_remplacement.update_one(
                    {
                        "id": demande["id"],
                        "tentatives_historique.user_id": remplacant_id,
                        "tentatives_historique.statut": "contacted"
                    },
                    {
                        "$set": {
                            "tentatives_historique.$.statut": "expired",
                            "tentatives_historique.$.date_reponse": maintenant.isoformat()
                        }
                    }
                )
            
            # Vider la liste des rempla√ßants en attente
            await db.demandes_remplacement.update_one(
                {"id": demande["id"]},
                {
                    "$set": {
                        "remplacants_contactes_ids": [],
                        "updated_at": maintenant
                    }
                }
            )
            
            # Relancer la recherche
            await lancer_recherche_remplacant(demande["id"], demande["tenant_id"])
        
        if demandes_timeout:
            logging.info(f"‚úÖ Trait√© {len(demandes_timeout)} demande(s) en timeout")
        
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de la v√©rification des timeouts: {e}", exc_info=True)


@api_router.post("/{tenant_slug}/remplacements", response_model=DemandeRemplacement)
async def create_demande_remplacement(tenant_slug: str, demande: DemandeRemplacementCreate, current_user: User = Depends(get_current_user)):
    """
    Cr√©er une demande de remplacement et lancer automatiquement la recherche de rempla√ßant
    """
    try:
        # V√©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Calculer la priorit√© automatiquement
        priorite = await calculer_priorite_demande(demande.date)
        
        demande_dict = demande.dict()
        demande_dict["tenant_id"] = tenant.id
        demande_dict["demandeur_id"] = current_user.id
        demande_dict["priorite"] = priorite
        demande_dict["statut"] = "en_attente"  # Commence en attente
        
        demande_obj = DemandeRemplacement(**demande_dict)
        await db.demandes_remplacement.insert_one(demande_obj.dict())
        
        logging.info(f"‚úÖ Demande de remplacement cr√©√©e: {demande_obj.id} (priorit√©: {priorite})")
        
        # Cr√©er notification pour les superviseurs/admins (info seulement, pas de gestion manuelle)
        superviseurs_admins = await db.users.find({
            "tenant_id": tenant.id,
            "role": {"$in": ["superviseur", "admin"]}
        }).to_list(100)
        
        superviseur_ids = []
        for user in superviseurs_admins:
            await creer_notification(
                tenant_id=tenant.id,
                destinataire_id=user["id"],
                type="remplacement_demande",
                titre=f"{'üö® ' if priorite == 'urgent' else ''}Recherche de remplacement en cours",
                message=f"{current_user.prenom} {current_user.nom} cherche un rempla√ßant pour le {demande.date}",
                lien="/remplacements",
                data={"demande_id": demande_obj.id}
            )
            superviseur_ids.append(user["id"])
        
        # Envoyer notifications push aux superviseurs (pour info)
        if superviseur_ids:
            await send_push_notification_to_users(
                user_ids=superviseur_ids,
                title=f"{'üö® ' if priorite == 'urgent' else ''}Recherche de remplacement",
                body=f"{current_user.prenom} {current_user.nom} cherche un rempla√ßant pour le {demande.date}",
                data={
                    "type": "remplacement_demande",
                    "demande_id": demande_obj.id,
                    "lien": "/remplacements"
                }
            )
        
        # üöÄ LANCER LA RECHERCHE AUTOMATIQUE DE REMPLA√áANT
        await lancer_recherche_remplacant(demande_obj.id, tenant.id)
        
        # Cr√©er une activit√©
        type_garde = await db.types_garde.find_one({"id": demande.type_garde_id, "tenant_id": tenant.id})
        garde_nom = type_garde['nom'] if type_garde else 'garde'
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="remplacement_demande",
            description=f"üîÑ {current_user.prenom} {current_user.nom} cherche un rempla√ßant pour la {garde_nom} du {demande.date}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": current_user.id, "demande_id": demande_obj.id}
        )
        
        # Clean the object before returning
        cleaned_demande = clean_mongo_doc(demande_obj.dict())
        return DemandeRemplacement(**cleaned_demande)
        
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de la cr√©ation de la demande de remplacement: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur lors de la cr√©ation de la demande")


# ===== EXPORTS REMPLACEMENTS (avant les routes dynamiques) =====

@api_router.get("/{tenant_slug}/remplacements/export-pdf")
async def export_remplacements_pdf(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des demandes de remplacement en PDF"""
    try:
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les demandes
        if user_id:
            demandes_list = await db.demandes_remplacement.find({
                "tenant_id": tenant.id,
                "demandeur_id": user_id
            }).to_list(length=None)
        else:
            if current_user.role == "employe":
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id,
                    "demandeur_id": current_user.id
                }).to_list(length=None)
            else:
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id
                }).to_list(length=None)
        
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        types_map = {t['id']: t for t in types_garde_list}
        
        # Cr√©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(tenant, pagesize=landscape(letter))
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Titre
        titre = "Demandes de Remplacement"
        if user_id and user_id in users_map:
            titre = f"Demandes de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        
        elements.append(Paragraph(titre, modern_styles['title']))
        elements.append(Spacer(1, 0.3*inch))
        
        # Construire le tableau
        table_data = [['Date', 'Type Garde', 'Demandeur', 'Statut', 'Priorit√©', 'Rempla√ßant', 'Notes']]
        
        for demande in sorted(demandes_list, key=lambda x: x.get('date', ''), reverse=True):
            demandeur = users_map.get(demande['demandeur_id'], {})
            demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}" if demandeur else "N/A"
            
            remplacant = users_map.get(demande.get('remplacant_id'), {})
            remplacant_nom = f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')}" if remplacant and demande.get('remplacant_id') else "Non trouv√©"
            
            type_garde = types_map.get(demande['type_garde_id'], {})
            type_nom = type_garde.get('nom', 'N/A') if type_garde else "N/A"
            
            statut_fr = {
                'en_cours': 'En cours',
                'approuve': 'Approuv√©',
                'refuse': 'Refus√©',
                'annule': 'Annul√©'
            }.get(demande.get('statut', ''), demande.get('statut', ''))
            
            priorite_fr = {
                'basse': 'Basse',
                'normale': 'Normale',
                'haute': 'Haute',
                'urgente': 'Urgente'
            }.get(demande.get('priorite', 'normale'), 'Normale')
            
            table_data.append([
                demande.get('date', 'N/A'),
                type_nom,
                demandeur_nom if not user_id else '',
                statut_fr,
                priorite_fr,
                remplacant_nom,
                demande.get('raison', '')[:30] if demande.get('raison') else ''
            ])
        
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('TOPPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        elements.append(table)
        doc.build(elements)
        buffer.seek(0)
        
        filename = f"remplacements_{user_id if user_id else 'tous'}.pdf"
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/remplacements/export-excel")
async def export_remplacements_excel(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des demandes de remplacement en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les demandes
        if user_id:
            demandes_list = await db.demandes_remplacement.find({
                "tenant_id": tenant.id,
                "demandeur_id": user_id
            }).to_list(length=None)
        else:
            if current_user.role == "employe":
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id,
                    "demandeur_id": current_user.id
                }).to_list(length=None)
            else:
                demandes_list = await db.demandes_remplacement.find({
                    "tenant_id": tenant.id
                }).to_list(length=None)
        
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        types_map = {t['id']: t for t in types_garde_list}
        
        # Cr√©er le workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Remplacements"
        
        # Styles
        header_fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        center_alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        # Titre
        ws.merge_cells('A1:H1')
        titre = "Demandes de Remplacement"
        if user_id and user_id in users_map:
            titre = f"Demandes de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        ws['A1'] = titre
        ws['A1'].font = Font(bold=True, size=16, color="EF4444")
        ws['A1'].alignment = center_alignment
        
        # En-t√™tes
        row = 3
        headers = ['Date', 'Type Garde', 'Demandeur', 'Statut', 'Priorit√©', 'Rempla√ßant', 'Notes', 'Cr√©√© le']
        
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = center_alignment
            cell.border = border
        
        # Donn√©es
        row += 1
        for demande in sorted(demandes_list, key=lambda x: x.get('date', ''), reverse=True):
            demandeur = users_map.get(demande['demandeur_id'], {})
            demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}" if demandeur else "N/A"
            
            remplacant = users_map.get(demande.get('remplacant_id'), {})
            remplacant_nom = f"{remplacant.get('prenom', '')} {remplacant.get('nom', '')}" if remplacant and demande.get('remplacant_id') else "Non trouv√©"
            
            type_garde = types_map.get(demande['type_garde_id'], {})
            type_nom = type_garde.get('nom', 'N/A') if type_garde else "N/A"
            
            statut_fr = {
                'en_cours': 'En cours',
                'approuve': 'Approuv√©',
                'refuse': 'Refus√©',
                'annule': 'Annul√©'
            }.get(demande.get('statut', ''), demande.get('statut', ''))
            
            priorite_fr = {
                'basse': 'Basse',
                'normale': 'Normale',
                'haute': 'Haute',
                'urgente': 'Urgente'
            }.get(demande.get('priorite', 'normale'), 'Normale')
            
            ws.cell(row=row, column=1, value=demande.get('date', 'N/A'))
            ws.cell(row=row, column=2, value=type_nom)
            ws.cell(row=row, column=3, value=demandeur_nom)
            status_cell = ws.cell(row=row, column=4, value=statut_fr)
            ws.cell(row=row, column=5, value=priorite_fr)
            ws.cell(row=row, column=6, value=remplacant_nom)
            ws.cell(row=row, column=7, value=demande.get('raison', ''))
            ws.cell(row=row, column=8, value=demande.get('created_at', 'N/A'))
            
            # Couleur statut
            if demande.get('statut') == 'approuve':
                status_cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
            elif demande.get('statut') == 'refuse':
                status_cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
            elif demande.get('statut') == 'en_cours':
                status_cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
            
            for col in range(1, 9):
                ws.cell(row=row, column=col).border = border
                ws.cell(row=row, column=col).alignment = center_alignment
            
            row += 1
        
        # Ajuster les largeurs de colonnes
        column_widths = {
            'A': 12,  # Date
            'B': 15,  # Type Garde
            'C': 20,  # Demandeur
            'D': 12,  # Statut
            'E': 10,  # Priorit√©
            'F': 20,  # Rempla√ßant
            'G': 30,  # Notes
            'H': 18,  # Cr√©√© le
        }
        for col_letter, width in column_widths.items():
            ws.column_dimensions[col_letter].width = width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        filename = f"remplacements_{user_id if user_id else 'tous'}.xlsx"
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")


@api_router.get("/{tenant_slug}/remplacements", response_model=List[DemandeRemplacement])
async def get_demandes_remplacement(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role == "employe":
        demandes = await db.demandes_remplacement.find({
            "tenant_id": tenant.id,
            "demandeur_id": current_user.id
        }).to_list(1000)
    else:
        demandes = await db.demandes_remplacement.find({"tenant_id": tenant.id}).to_list(1000)
    
    cleaned_demandes = [clean_mongo_doc(demande) for demande in demandes]
    return [DemandeRemplacement(**demande) for demande in cleaned_demandes]

@api_router.get("/{tenant_slug}/remplacements/propositions")
async def get_propositions_remplacement(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """
    R√©cup√®re les propositions de remplacement pour l'utilisateur connect√©
    (Les demandes o√π il a √©t√© contact√© et doit r√©pondre)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Trouver les demandes o√π l'utilisateur est dans remplacants_contactes_ids et statut = en_cours
    demandes = await db.demandes_remplacement.find({
        "tenant_id": tenant.id,
        "statut": "en_cours",
        "remplacants_contactes_ids": current_user.id
    }).to_list(1000)
    
    # Enrichir avec les d√©tails du demandeur et du type de garde
    propositions = []
    for demande in demandes:
        demandeur = await db.users.find_one({"id": demande["demandeur_id"]})
        type_garde = await db.types_garde.find_one({"id": demande["type_garde_id"]})
        
        demande["demandeur"] = {
            "nom": demandeur.get("nom", ""),
            "prenom": demandeur.get("prenom", ""),
            "email": demandeur.get("email", "")
        } if demandeur else None
        
        demande["type_garde"] = {
            "nom": type_garde.get("nom", ""),
            "heure_debut": type_garde.get("heure_debut", ""),
            "heure_fin": type_garde.get("heure_fin", "")
        } if type_garde else None
        
        propositions.append(clean_mongo_doc(demande))
    
    return propositions

@api_router.put("/{tenant_slug}/remplacements/{demande_id}/accepter")
async def accepter_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Accepter/Approuver manuellement une demande de remplacement
    - Si admin/superviseur: approbation manuelle (rempla√ßant trouv√© hors syst√®me)
    - Si rempla√ßant contact√©: acceptation de la proposition
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer la demande
    demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant.id})
    if not demande_data:
        raise HTTPException(status_code=404, detail="Demande non trouv√©e")
    
    # Si admin/superviseur, c'est une approbation manuelle
    if current_user.role in ["admin", "superviseur"]:
        maintenant = datetime.now(timezone.utc)
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "approuve_manuellement",
                    "approuve_par_id": current_user.id,
                    "date_approbation": maintenant.isoformat(),
                    "updated_at": maintenant
                }
            }
        )
        
        # Notifier le demandeur
        demandeur_id = demande_data.get("demandeur_id")
        if demandeur_id:
            await send_push_notification_to_users(
                user_ids=[demandeur_id],
                title="‚úÖ Demande approuv√©e",
                body=f"Votre demande de remplacement du {demande_data['date']} a √©t√© approuv√©e par un superviseur.",
                data={
                    "type": "remplacement_approuve",
                    "demande_id": demande_id
                }
            )
            # Notification in-app
            await db.notifications.insert_one({
                "id": str(uuid.uuid4()),
                "tenant_id": tenant.id,
                "user_id": demandeur_id,
                "type": "remplacement_approuve",
                "titre": "‚úÖ Demande approuv√©e",
                "message": f"Votre demande de remplacement du {demande_data['date']} a √©t√© approuv√©e.",
                "lu": False,
                "data": {"demande_id": demande_id},
                "created_at": maintenant.isoformat()
            })
        
        return {
            "message": "Demande approuv√©e avec succ√®s",
            "demande_id": demande_id
        }
    else:
        # C'est un rempla√ßant qui accepte
        await accepter_remplacement(demande_id, current_user.id, tenant.id)
        
        return {
            "message": "Remplacement accept√© avec succ√®s",
            "demande_id": demande_id
        }

@api_router.put("/{tenant_slug}/remplacements/{demande_id}/refuser")
async def refuser_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Refuser/Annuler une demande de remplacement
    - Si admin/superviseur: annulation manuelle de la demande
    - Si rempla√ßant contact√©: refus de la proposition
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer la demande
    demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant.id})
    if not demande_data:
        raise HTTPException(status_code=404, detail="Demande non trouv√©e")
    
    # Si admin/superviseur, c'est une annulation manuelle
    if current_user.role in ["admin", "superviseur"]:
        maintenant = datetime.now(timezone.utc)
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "annulee",
                    "annule_par_id": current_user.id,
                    "date_annulation": maintenant.isoformat(),
                    "updated_at": maintenant
                }
            }
        )
        
        # Notifier le demandeur
        demandeur_id = demande_data.get("demandeur_id")
        if demandeur_id:
            await send_push_notification_to_users(
                user_ids=[demandeur_id],
                title="‚ùå Demande annul√©e",
                body=f"Votre demande de remplacement du {demande_data['date']} a √©t√© annul√©e par un superviseur.",
                data={
                    "type": "remplacement_annulee",
                    "demande_id": demande_id
                }
            )
            # Notification in-app
            await db.notifications.insert_one({
                "id": str(uuid.uuid4()),
                "tenant_id": tenant.id,
                "user_id": demandeur_id,
                "type": "remplacement_annulee",
                "titre": "‚ùå Demande annul√©e",
                "message": f"Votre demande de remplacement du {demande_data['date']} a √©t√© annul√©e.",
                "lu": False,
                "data": {"demande_id": demande_id},
                "created_at": maintenant.isoformat()
            })
        
        return {
            "message": "Demande annul√©e avec succ√®s",
            "demande_id": demande_id
        }
    else:
        # C'est un rempla√ßant qui refuse
        await refuser_remplacement(demande_id, current_user.id, tenant.id)
        
        return {
            "message": "Remplacement refus√©",
            "demande_id": demande_id
        }

# Endpoints publics pour actions via email (sans authentification - utilise token)
@api_router.get("/remplacement-action/{token}/{action}")
async def action_remplacement_via_email(
    token: str,
    action: str
):
    """
    Traite une action de remplacement (accepter/refuser) via le lien email
    Redirige vers l'app avec le r√©sultat
    """
    frontend_url = os.environ.get('FRONTEND_URL', 'https://profire-portal.preview.emergentagent.com')
    
    try:
        # V√©rifier le token
        token_data = await db.tokens_remplacement.find_one({"token": token})
        
        if not token_data:
            # Token invalide - rediriger vers page d'erreur
            return RedirectResponse(
                url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Lien invalide ou expir√©",
                status_code=302
            )
        
        # V√©rifier si le token est expir√©
        expiration = datetime.fromisoformat(token_data["expiration"].replace('Z', '+00:00'))
        if datetime.now(timezone.utc) > expiration:
            return RedirectResponse(
                url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Ce lien a expir√©",
                status_code=302
            )
        
        # V√©rifier si le token a d√©j√† √©t√© utilis√©
        if token_data.get("utilise"):
            return RedirectResponse(
                url=f"{frontend_url}/remplacement-resultat?status=info&message=Cette action a d√©j√† √©t√© trait√©e",
                status_code=302
            )
        
        demande_id = token_data["demande_id"]
        remplacant_id = token_data["remplacant_id"]
        tenant_id = token_data["tenant_id"]
        
        # V√©rifier que la demande existe et est toujours en cours
        demande_data = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant_id})
        if not demande_data:
            return RedirectResponse(
                url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Demande non trouv√©e",
                status_code=302
            )
        
        if demande_data["statut"] not in ["en_cours", "en_attente"]:
            status_label = {
                "accepte": "d√©j√† accept√©e",
                "expiree": "expir√©e",
                "annulee": "annul√©e",
                "approuve_manuellement": "d√©j√† approuv√©e"
            }.get(demande_data["statut"], demande_data["statut"])
            return RedirectResponse(
                url=f"{frontend_url}/remplacement-resultat?status=info&message=Cette demande est {status_label}",
                status_code=302
            )
        
        # Marquer le token comme utilis√©
        await db.tokens_remplacement.update_one(
            {"token": token},
            {"$set": {"utilise": True, "action": action, "date_utilisation": datetime.now(timezone.utc).isoformat()}}
        )
        
        # Traiter l'action
        if action == "accepter":
            try:
                await accepter_remplacement(demande_id, remplacant_id, tenant_id)
                
                # R√©cup√©rer les infos pour le message
                demandeur = await db.users.find_one({"id": demande_data["demandeur_id"]})
                demandeur_nom = f"{demandeur.get('prenom', '')} {demandeur.get('nom', '')}" if demandeur else "le demandeur"
                
                return RedirectResponse(
                    url=f"{frontend_url}/remplacement-resultat?status=succes&message=Vous avez accept√© le remplacement de {demandeur_nom} le {demande_data['date']}",
                    status_code=302
                )
            except Exception as e:
                logging.error(f"Erreur acceptation via email: {e}")
                return RedirectResponse(
                    url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Erreur lors de l'acceptation",
                    status_code=302
                )
        
        elif action == "refuser":
            try:
                await refuser_remplacement(demande_id, remplacant_id, tenant_id)
                
                return RedirectResponse(
                    url=f"{frontend_url}/remplacement-resultat?status=info&message=Vous avez refus√© cette demande de remplacement",
                    status_code=302
                )
            except Exception as e:
                logging.error(f"Erreur refus via email: {e}")
                return RedirectResponse(
                    url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Erreur lors du refus",
                    status_code=302
                )
        
        else:
            return RedirectResponse(
                url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Action non reconnue",
                status_code=302
            )
            
    except Exception as e:
        logging.error(f"Erreur traitement action email: {e}", exc_info=True)
        return RedirectResponse(
            url=f"{frontend_url}/remplacement-resultat?status=erreur&message=Une erreur est survenue",
            status_code=302
        )

@api_router.delete("/{tenant_slug}/remplacements/{demande_id}")
async def annuler_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Annuler une demande de remplacement (seulement par le demandeur)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer la demande
    demande = await db.demandes_remplacement.find_one({"id": demande_id, "tenant_id": tenant.id})
    if not demande:
        raise HTTPException(status_code=404, detail="Demande non trouv√©e")
    
    # V√©rifier que c'est bien le demandeur
    if demande["demandeur_id"] != current_user.id:
        raise HTTPException(status_code=403, detail="Seul le demandeur peut annuler la demande")
    
    # V√©rifier que la demande n'est pas d√©j√† accept√©e
    if demande["statut"] == "accepte":
        raise HTTPException(status_code=400, detail="Impossible d'annuler une demande d√©j√† accept√©e")
    
    # Marquer comme annul√©e
    await db.demandes_remplacement.update_one(
        {"id": demande_id},
        {
            "$set": {
                "statut": "annulee",
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    # Notifier les rempla√ßants contact√©s que la demande est annul√©e
    if demande.get("remplacants_contactes_ids"):
        await send_push_notification_to_users(
            user_ids=demande["remplacants_contactes_ids"],
            title="Demande annul√©e",
            body=f"La demande de remplacement du {demande['date']} a √©t√© annul√©e",
            data={
                "type": "remplacement_annulee",
                "demande_id": demande_id
            }
        )
    
    logging.info(f"‚úÖ Demande de remplacement annul√©e: {demande_id}")
    
    return {
        "message": "Demande annul√©e avec succ√®s",
        "demande_id": demande_id
    }

# ==================== COMP√âTENCES ROUTES MIGR√âES VERS routes/competences_grades.py ====================
# Les routes comp√©tences et grades ont √©t√© extraites vers routes/competences_grades.py
# POST   /{tenant_slug}/competences
# GET    /{tenant_slug}/competences
# PUT    /{tenant_slug}/competences/{competence_id}
# DELETE /{tenant_slug}/competences/{competence_id}
# POST   /{tenant_slug}/competences/clean-invalid
# POST   /{tenant_slug}/grades
# GET    /{tenant_slug}/grades
# PUT    /{tenant_slug}/grades/{grade_id}
# DELETE /{tenant_slug}/grades/{grade_id}
# ============================================================================

# ==================== FORMATIONS ROUTES MIGR√âES VERS routes/formations.py ====================
# Routes migr√©es:
# - POST   /{tenant_slug}/formations                              - Cr√©er formation
# - GET    /{tenant_slug}/formations                              - Liste formations
# - PUT    /{tenant_slug}/formations/{formation_id}               - Modifier formation
# - DELETE /{tenant_slug}/formations/{formation_id}               - Supprimer formation
# - POST   /{tenant_slug}/formations/corriger-durees              - Corriger dur√©es
# - POST   /{tenant_slug}/formations/{formation_id}/inscription   - S'inscrire
# - DELETE /{tenant_slug}/formations/{formation_id}/inscription   - Se d√©sinscrire
# - GET    /{tenant_slug}/formations/{formation_id}/inscriptions  - Liste inscrits
# - PUT    /{tenant_slug}/formations/{formation_id}/presence/{user_id} - Valider pr√©sence
# - GET    /{tenant_slug}/formations/mon-taux-presence            - Taux pr√©sence

# Les rapports et exports restent ici car ils ont des d√©pendances complexes

@api_router.get("/{tenant_slug}/formations/rapports/debug/{user_id}")
async def debug_conformite_user(
    tenant_slug: str,
    user_id: str,
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """Debug : voir les donn√©es brutes d'un employ√©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer l'utilisateur
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    
    # R√©cup√©rer toutes ses inscriptions
    inscriptions = await db.inscriptions_formations.find({
        "user_id": user_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    
    # Pour chaque inscription, r√©cup√©rer la formation
    details = []
    for insc in inscriptions:
        formation = await db.formations.find_one({
            "id": insc["formation_id"],
            "tenant_id": tenant.id
        })
        if formation:
            details.append({
                "formation_nom": formation.get("nom"),
                "formation_date_fin": formation.get("date_fin"),
                "formation_annee_champ": formation.get("annee"),
                "inscription_statut": insc.get("statut"),
                "inscription_heures_creditees": insc.get("heures_creditees"),
                "heure_debut": formation.get("heure_debut"),
                "heure_fin": formation.get("heure_fin")
            })
    
    return {
        "user": user.get("prenom") + " " + user.get("nom"),
        "total_inscriptions": len(inscriptions),
        "details": details,
        "annee_recherchee": annee
    }

@api_router.get("/{tenant_slug}/formations/rapports/conformite")
async def rapport_conformite(tenant_slug: str, annee: int, current_user: User = Depends(get_current_user)):
    """Rapport conformit√© NFPA 1500 am√©lior√© avec formations obligatoires et validations manuelles"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    pompiers = await db.users.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    
    # Lire les param√®tres depuis tenant.parametres.formations (coh√©rent avec PUT /parametres/formations)
    params = tenant.parametres.get('formations', {}) if tenant.parametres else {}
    heures_min = params.get("heures_minimales_annuelles", 100)
    pourcentage_min = params.get("pourcentage_presence_minimum", 80)
    
    aujourd_hui = datetime.now(timezone.utc).date()
    
    # OPTIMISATION: Charger TOUTES les formations une seule fois (au lieu de 1 requ√™te par inscription)
    toutes_formations = await db.formations.find({
        "tenant_id": tenant.id
    }, {"_id": 0}).to_list(1000)
    formations_map = {f["id"]: f for f in toutes_formations if "id" in f}
    
    # R√©cup√©rer toutes les formations obligatoires de l'ann√©e
    formations_obligatoires = await db.formations.find({
        "tenant_id": tenant.id,
        "annee": annee,
        "obligatoire": True
    }, {"_id": 0}).to_list(1000)
    
    # OPTIMISATION: Charger toutes les inscriptions et validations en UNE FOIS
    toutes_inscriptions_db = await db.inscriptions_formations.find({
        "tenant_id": tenant.id
    }, {"_id": 0}).to_list(10000)
    
    toutes_validations_db = await db.validations_competences.find({
        "tenant_id": tenant.id
    }, {"_id": 0}).to_list(10000)
    
    # Grouper par user_id pour acc√®s rapide
    inscriptions_par_user = {}
    for insc in toutes_inscriptions_db:
        user_id = insc.get("user_id")
        if user_id not in inscriptions_par_user:
            inscriptions_par_user[user_id] = []
        inscriptions_par_user[user_id].append(insc)
    
    validations_par_user = {}
    for val in toutes_validations_db:
        user_id = val.get("user_id")
        if user_id not in validations_par_user:
            validations_par_user[user_id] = []
        validations_par_user[user_id].append(val)
    
    rapport = []
    for pompier in pompiers:
        # R√©cup√©rer les inscriptions et validations depuis les dictionnaires
        toutes_inscriptions = inscriptions_par_user.get(pompier["id"], [])
        validations = validations_par_user.get(pompier["id"], [])
        competences_validees = {v["competence_id"] for v in validations}
        
        total_heures = 0
        formations_passees = 0
        formations_futures = 0
        presences = 0
        formations_obligatoires_ratees = []
        
        for insc in toutes_inscriptions:
            # OPTIMISATION: Lookup dans le dictionnaire au lieu de requ√™te DB
            formation = formations_map.get(insc["formation_id"])
            
            if formation:
                try:
                    # Parser la date de fin avec gestion d'erreur
                    if "date_fin" in formation and formation["date_fin"]:
                        date_fin_str = formation["date_fin"]
                        date_fin = datetime.fromisoformat(date_fin_str.replace('Z', '+00:00')).date()
                    else:
                        continue
                    
                    # V√©rifier que la formation est de l'ann√©e demand√©e (depuis date_fin)
                    if date_fin.year != annee:
                        continue
                    
                    # Heures cr√©dit√©es
                    if insc.get("statut") == "present":
                        total_heures += insc.get("heures_creditees", 0)
                    
                    # Calcul taux de pr√©sence
                    if date_fin < aujourd_hui:
                        formations_passees += 1
                        if insc.get("statut") == "present":
                            presences += 1
                        # V√©rifier si formation obligatoire rat√©e
                        elif formation.get("obligatoire") and insc.get("statut") == "absent":
                            # V√©rifier si comp√©tence n'est pas valid√©e manuellement
                            if formation.get("competence_id") not in competences_validees:
                                formations_obligatoires_ratees.append(formation["nom"])
                    else:
                        formations_futures += 1
                except (ValueError, TypeError, AttributeError):
                    continue
        
        # Taux de pr√©sence = formations pr√©sentes / formations pass√©es (pas futures)
        taux_presence = round((presences / formations_passees * 100) if formations_passees > 0 else 100, 1)
        conforme_presence = taux_presence >= pourcentage_min
        conforme_heures = total_heures >= heures_min
        a_formation_obligatoire_ratee = len(formations_obligatoires_ratees) > 0
        
        # LOGIQUE SIMPLIFI√âE : 2 niveaux (Conforme / Non conforme)
        # CONFORME par d√©faut, sauf si :
        # 1. Formation obligatoire rat√©e (non r√©gularis√©e)
        # 2. Taux de pr√©sence < seuil (sur formations pass√©es)
        # Note: Les heures peuvent √™tre en cours d'accumulation, donc on ne p√©nalise pas
        
        if a_formation_obligatoire_ratee:
            # Formation obligatoire rat√©e ‚Üí Non conforme (r√©gularisable via Personnel)
            conforme = False
        elif not conforme_presence:
            # Taux de pr√©sence insuffisant sur formations pass√©es ‚Üí Non conforme
            conforme = False
        else:
            # Par d√©faut : Conforme (peut encore atteindre les heures requises)
            conforme = True
        
        pompier_data = clean_mongo_doc(pompier)
        pompier_data["total_heures"] = total_heures
        pompier_data["heures_requises"] = heures_min
        pompier_data["conforme"] = conforme
        pompier_data["pourcentage"] = round((total_heures / heures_min * 100) if heures_min > 0 else 0, 1)
        pompier_data["taux_presence"] = taux_presence
        pompier_data["formations_passees"] = formations_passees
        pompier_data["formations_futures"] = formations_futures
        pompier_data["presences"] = presences
        pompier_data["formations_obligatoires_ratees"] = formations_obligatoires_ratees
        pompier_data["validations_manuelles"] = len(validations)
        rapport.append(pompier_data)
    
    rapport.sort(key=lambda x: (
        0 if x["conforme"] else 1,  # Conformes en premier
        -x["total_heures"]  # Puis par heures d√©croissantes
    ))
    
    return {
        "annee": annee,
        "heures_minimales": heures_min,
        "pourcentage_presence_minimum": pourcentage_min,
        "total_pompiers": len(rapport),
        "conformes": len([p for p in rapport if p["conforme"]]),
        "non_conformes": len([p for p in rapport if not p["conforme"]]),
        "pourcentage_conformite": round(len([p for p in rapport if p["conforme"]]) / len(rapport) * 100, 1) if len(rapport) > 0 else 0,
        "pompiers": rapport
    }

@api_router.get("/{tenant_slug}/formations/rapports/dashboard")
async def dashboard_formations(tenant_slug: str, annee: int, current_user: User = Depends(get_current_user)):
    """Dashboard KPIs formations"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    formations = await db.formations.find({"tenant_id": tenant.id, "annee": annee}).to_list(1000)
    heures_planifiees = sum([f.get("duree_heures", 0) for f in formations])
    
    inscriptions = await db.inscriptions_formations.find({
        "tenant_id": tenant.id,
        "statut": "present"
    }).to_list(10000)
    
    heures_effectuees = sum([i.get("heures_creditees", 0) for i in inscriptions])
    
    total_pompiers = await db.users.count_documents({"tenant_id": tenant.id})
    users_formes = len(set([i["user_id"] for i in inscriptions]))
    
    return {
        "annee": annee,
        "heures_planifiees": heures_planifiees,
        "heures_effectuees": heures_effectuees,
        "pourcentage_realisation": round((heures_effectuees / heures_planifiees * 100) if heures_planifiees > 0 else 0, 1),
        "total_pompiers": total_pompiers,
        "pompiers_formes": users_formes,
        "pourcentage_pompiers": round((users_formes / total_pompiers * 100) if total_pompiers > 0 else 0, 1)
    }


# Route mon-taux-presence migr√©e vers routes/formations.py

# ====================================================================
# RAPPORTS AVANC√âS - EXPORTS PDF/EXCEL ET RAPPORTS PAR COMP√âTENCES
# ====================================================================

from reportlab.lib.pagesizes import letter, A4
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.chart import PieChart as ExcelPieChart, BarChart as ExcelBarChart, Reference
import io
from fastapi.responses import StreamingResponse
import matplotlib
matplotlib.use('Agg')  # Backend non-GUI
import matplotlib.pyplot as plt


@api_router.get("/{tenant_slug}/formations/rapports/export-presence")
async def export_rapport_presence(
    tenant_slug: str,
    format: str,
    type_formation: str,  # "obligatoires" ou "toutes"
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """
    Export des taux de pr√©sence en PDF ou Excel
    - format: "pdf" ou "excel"
    - type_formation: "obligatoires" ou "toutes"
    - annee: ann√©e concern√©e
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es
    pompiers = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    params = await db.parametres_formations.find_one({"tenant_id": tenant.id})
    pourcentage_min = params.get("pourcentage_presence_minimum", 80) if params else 80
    
    aujourd_hui = datetime.now(timezone.utc).date()
    
    rapport_data = []
    for pompier in pompiers:
        # Toutes les inscriptions
        mes_inscriptions = await db.inscriptions_formations.find({
            "user_id": pompier["id"],
            "tenant_id": tenant.id
        }).to_list(1000)
        
        formations_passees = 0
        presences = 0
        
        for insc in mes_inscriptions:
            formation = await db.formations.find_one({
                "id": insc["formation_id"],
                "annee": annee,
                "tenant_id": tenant.id
            })
            
            if formation:
                # Filtre selon type_formation
                if type_formation == "obligatoires" and not formation.get("obligatoire", False):
                    continue
                
                # V√©rifier que date_fin n'est pas vide
                date_fin_str = formation.get("date_fin", "")
                if not date_fin_str:
                    continue
                
                try:
                    date_fin = datetime.fromisoformat(date_fin_str).date()
                except ValueError:
                    # Ignorer les formations avec des dates invalides
                    continue
                
                if date_fin < aujourd_hui:
                    formations_passees += 1
                    if insc.get("statut") == "present":
                        presences += 1
        
        taux_presence = round((presences / formations_passees * 100) if formations_passees > 0 else 0, 1)
        conforme = taux_presence >= pourcentage_min
        
        rapport_data.append({
            "nom": f"{pompier.get('prenom', '')} {pompier.get('nom', '')}",
            "grade": pompier.get("grade", "N/A"),
            "formations_passees": formations_passees,
            "presences": presences,
            "absences": formations_passees - presences,
            "taux_presence": taux_presence,
            "conforme": conforme
        })
    
    # Tri par taux de pr√©sence d√©croissant
    rapport_data.sort(key=lambda x: -x["taux_presence"])
    
    # Statistiques globales
    total_pompiers = len(rapport_data)
    pompiers_conformes = len([p for p in rapport_data if p["conforme"]])
    taux_conformite = round((pompiers_conformes / total_pompiers * 100) if total_pompiers > 0 else 0, 1)
    
    # G√©n√©ration selon le format
    if format == "pdf":
        return await generer_pdf_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min, tenant)
    elif format == "excel":
        return await generer_excel_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min)
    else:
        raise HTTPException(status_code=400, detail="Format non support√©")


async def generer_pdf_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min, tenant):
    """G√©n√®re un PDF professionnel avec graphiques"""
    
    # Utiliser la fonction helper pour cr√©er un PDF brand√©
    buffer, doc, story = create_branded_pdf(tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Titre
    type_texte = "Formations Obligatoires" if type_formation == "obligatoires" else "Toutes les Formations"
    story.append(Paragraph(f"Rapport de Pr√©sence - {type_texte}", modern_styles['title']))
    story.append(Paragraph(f"ProFireManager - Ann√©e {annee}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # Statistiques globales
    stats_data = [
        ["Statistiques Globales", ""],
        ["Total pompiers", str(total_pompiers)],
        ["Pompiers conformes", f"{pompiers_conformes} ({taux_conformite}%)"],
        ["Taux minimum requis", f"{pourcentage_min}%"]
    ]
    
    stats_table = Table(stats_data, colWidths=[3*inch, 2*inch])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 0.4*inch))
    
    # Tableau des donn√©es
    story.append(Paragraph("D√©tail par Pompier", styles['Heading2']))
    story.append(Spacer(1, 0.2*inch))
    
    table_data = [["Nom", "Grade", "Formations", "Pr√©sences", "Absences", "Taux %", "Conforme"]]
    
    for p in rapport_data:
        table_data.append([
            p.get("nom", ""),
            p.get("grade", "N/A"),
            str(p.get("formations_passees", 0)),
            str(p.get("presences", 0)),
            str(p.get("absences", 0)),
            f"{p.get('taux_presence', 0)}%",
            "‚úì" if p.get("conforme", False) else "‚úó"
        ])
    
    detail_table = Table(table_data, colWidths=[1.5*inch, 1*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.7*inch, 0.7*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 9),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(detail_table)
    
    # Construction du PDF
    doc.build(story)
    buffer.seek(0)
    
    filename = f"rapport_presence_{type_formation}_{annee}.pdf"
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


async def generer_excel_presence(rapport_data, annee, type_formation, total_pompiers, pompiers_conformes, taux_conformite, pourcentage_min):
    """G√©n√®re un fichier Excel avec donn√©es et graphiques"""
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport Pr√©sence"
    
    # En-t√™te
    type_texte = "Formations Obligatoires" if type_formation == "obligatoires" else "Toutes les Formations"
    ws['A1'] = f"Rapport de Pr√©sence - {type_texte} - Ann√©e {annee}"
    ws['A1'].font = Font(size=16, bold=True, color="DC2626")
    ws.merge_cells('A1:G1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # Statistiques
    ws['A3'] = "Statistiques Globales"
    ws['A3'].font = Font(bold=True, size=12)
    ws['A4'] = "Total pompiers"
    ws['B4'] = total_pompiers
    ws['A5'] = "Pompiers conformes"
    ws['B5'] = f"{pompiers_conformes} ({taux_conformite}%)"
    ws['A6'] = "Taux minimum requis"
    ws['B6'] = f"{pourcentage_min}%"
    
    # Tableau des donn√©es
    headers = ["Nom", "Grade", "Formations", "Pr√©sences", "Absences", "Taux %", "Conforme"]
    row = 8
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=row, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    # Donn√©es
    for p in rapport_data:
        row += 1
        ws.cell(row=row, column=1, value=p.get("nom", ""))
        ws.cell(row=row, column=2, value=p.get("grade", "N/A"))
        ws.cell(row=row, column=3, value=p.get("formations_passees", 0))
        ws.cell(row=row, column=4, value=p.get("presences", 0))
        ws.cell(row=row, column=5, value=p.get("absences", 0))
        ws.cell(row=row, column=6, value=p.get("taux_presence", 0))
        ws.cell(row=row, column=7, value="Oui" if p.get("conforme", False) else "Non")
    
    # Ajuster les largeurs de colonnes
    for col in ['A', 'B', 'C', 'D', 'E', 'F', 'G']:
        ws.column_dimensions[col].width = 15
    
    # Sauvegarder dans un buffer
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    filename = f"rapport_presence_{type_formation}_{annee}.xlsx"
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


@api_router.get("/{tenant_slug}/formations/rapports/competences")
async def rapport_par_competences(
    tenant_slug: str,
    annee: int,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """
    Rapport par comp√©tences
    - Si user_id fourni: rapport pour cette personne uniquement
    - Sinon: rapport g√©n√©ral pour toute l'organisation
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer toutes les comp√©tences
    competences = await db.competences.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = []
    
    for comp in competences:
        # R√©cup√©rer toutes les formations pour cette comp√©tence
        formations = await db.formations.find({
            "tenant_id": tenant.id,
            "competence_id": comp["id"],
            "annee": annee
        }).to_list(1000)
        
        total_formations = len(formations)
        total_heures_planifiees = sum([f.get("duree_heures", 0) for f in formations])
        
        # R√©cup√©rer les inscriptions
        formation_ids = [f["id"] for f in formations]
        
        query_inscriptions = {
            "tenant_id": tenant.id,
            "formation_id": {"$in": formation_ids}
        }
        
        # Filtre par user si demand√©
        if user_id:
            query_inscriptions["user_id"] = user_id
        
        inscriptions = await db.inscriptions_formations.find(query_inscriptions).to_list(10000)
        
        total_inscrits = len(set([i["user_id"] for i in inscriptions]))
        presences = len([i for i in inscriptions if i.get("statut") == "present"])
        absences = len([i for i in inscriptions if i.get("statut") == "absent"])
        total_inscriptions = len(inscriptions)
        
        taux_presence = round((presences / total_inscriptions * 100) if total_inscriptions > 0 else 0, 1)
        
        heures_effectuees = sum([i.get("heures_creditees", 0) for i in inscriptions if i.get("statut") == "present"])
        
        rapport.append({
            "competence_id": comp["id"],
            "competence_nom": comp["nom"],
            "total_formations": total_formations,
            "total_heures_planifiees": total_heures_planifiees,
            "total_inscrits": total_inscrits,
            "total_inscriptions": total_inscriptions,
            "presences": presences,
            "absences": absences,
            "taux_presence": taux_presence,
            "heures_effectuees": heures_effectuees,
            "taux_realisation": round((heures_effectuees / total_heures_planifiees * 100) if total_heures_planifiees > 0 else 0, 1)
        })
    
    # Tri par nombre de formations d√©croissant
    rapport.sort(key=lambda x: -x["total_formations"])
    
    return {
        "annee": annee,
        "user_id": user_id,
        "competences": rapport
    }


@api_router.get("/{tenant_slug}/formations/rapports/export-competences")
async def export_rapport_competences(
    tenant_slug: str,
    format: str,
    annee: int,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """
    Export du rapport par comp√©tences en PDF ou Excel
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # R√©cup√©rer le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es
    rapport_response = await rapport_par_competences(tenant_slug, annee, user_id, current_user)
    rapport_data = rapport_response["competences"]
    
    # R√©cup√©rer le nom de l'utilisateur si filtr√©
    user_nom = None
    if user_id:
        user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        if user:
            user_nom = f"{user.get('prenom', '')} {user.get('nom', '')}"
    
    # G√©n√©ration selon le format
    if format == "pdf":
        return await generer_pdf_competences(rapport_data, annee, user_nom, tenant)
    elif format == "excel":
        return await generer_excel_competences(rapport_data, annee, user_nom)
    else:
        raise HTTPException(status_code=400, detail="Format non support√©")


async def generer_pdf_competences(rapport_data, annee, user_nom, tenant):
    """G√©n√®re un PDF pour le rapport par comp√©tences"""
    
    # Utiliser la fonction helper pour cr√©er un PDF brand√©
    buffer, doc, story = create_branded_pdf(tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Titre
    titre = f"Rapport par Comp√©tences - {user_nom}" if user_nom else "Rapport par Comp√©tences"
    story.append(Paragraph(titre, modern_styles['title']))
    story.append(Paragraph(f"ProFireManager - Ann√©e {annee}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # Statistiques globales
    total_formations = sum([c["total_formations"] for c in rapport_data])
    total_heures = sum([c["total_heures_planifiees"] for c in rapport_data])
    total_presences = sum([c["presences"] for c in rapport_data])
    total_inscriptions = sum([c["total_inscriptions"] for c in rapport_data])
    taux_presence_global = round((total_presences / total_inscriptions * 100) if total_inscriptions > 0 else 0, 1)
    
    stats_data = [
        ["Statistiques Globales", ""],
        ["Total comp√©tences", str(len(rapport_data))],
        ["Total formations", str(total_formations)],
        ["Total heures planifi√©es", f"{total_heures}h"],
        ["Taux de pr√©sence moyen", f"{taux_presence_global}%"]
    ]
    
    stats_table = Table(stats_data, colWidths=[3*inch, 2*inch])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 0.4*inch))
    
    # Tableau des comp√©tences
    story.append(Paragraph("D√©tail par Comp√©tence", styles['Heading2']))
    story.append(Spacer(1, 0.2*inch))
    
    table_data = [["Comp√©tence", "Formations", "Heures", "Inscrits", "Pr√©sences", "Taux %"]]
    
    for c in rapport_data:
        table_data.append([
            c["competence_nom"],
            str(c["total_formations"]),
            f"{c['total_heures_planifiees']}h",
            str(c["total_inscrits"]),
            f"{c['presences']}/{c['total_inscriptions']}",
            f"{c['taux_presence']}%"
        ])
    
    detail_table = Table(table_data, colWidths=[2*inch, 1*inch, 1*inch, 1*inch, 1.2*inch, 0.8*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#FCA5A5')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 9),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(detail_table)
    
    doc.build(story)
    buffer.seek(0)
    
    filename = f"rapport_competences_{annee}.pdf"
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


async def generer_excel_competences(rapport_data, annee, user_nom):
    """G√©n√®re un fichier Excel pour le rapport par comp√©tences"""
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport Comp√©tences"
    
    # En-t√™te
    titre = f"Rapport par Comp√©tences - {user_nom}" if user_nom else "Rapport par Comp√©tences"
    ws['A1'] = f"{titre} - Ann√©e {annee}"
    ws['A1'].font = Font(size=16, bold=True, color="DC2626")
    ws.merge_cells('A1:F1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # Statistiques globales
    total_formations = sum([c["total_formations"] for c in rapport_data])
    total_heures = sum([c["total_heures_planifiees"] for c in rapport_data])
    total_presences = sum([c["presences"] for c in rapport_data])
    total_inscriptions = sum([c["total_inscriptions"] for c in rapport_data])
    taux_presence_global = round((total_presences / total_inscriptions * 100) if total_inscriptions > 0 else 0, 1)
    
    ws['A3'] = "Statistiques Globales"
    ws['A3'].font = Font(bold=True, size=12)
    ws['A4'] = "Total comp√©tences"
    ws['B4'] = len(rapport_data)
    ws['A5'] = "Total formations"
    ws['B5'] = total_formations
    ws['A6'] = "Total heures planifi√©es"
    ws['B6'] = f"{total_heures}h"
    ws['A7'] = "Taux de pr√©sence moyen"
    ws['B7'] = f"{taux_presence_global}%"
    
    # Tableau des donn√©es
    headers = ["Comp√©tence", "Formations", "Heures", "Inscrits", "Pr√©sences", "Taux %"]
    row = 9
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=row, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    # Donn√©es
    for c in rapport_data:
        row += 1
        ws.cell(row=row, column=1, value=c["competence_nom"])
        ws.cell(row=row, column=2, value=c["total_formations"])
        ws.cell(row=row, column=3, value=f"{c['total_heures_planifiees']}h")
        ws.cell(row=row, column=4, value=c["total_inscrits"])
        ws.cell(row=row, column=5, value=f"{c['presences']}/{c['total_inscriptions']}")
        ws.cell(row=row, column=6, value=c["taux_presence"])
    
    # Ajuster les largeurs
    for col in ['A', 'B', 'C', 'D', 'E', 'F']:
        ws.column_dimensions[col].width = 18
    
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    filename = f"rapport_competences_{annee}.xlsx"
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

# ==================== VALIDATIONS MANUELLES COMPETENCES ====================

@api_router.post("/{tenant_slug}/validations-competences")
async def creer_validation_competence(
    tenant_slug: str,
    validation: ValidationCompetenceCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une validation manuelle de comp√©tence"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que la comp√©tence existe
    competence = await db.competences.find_one({
        "id": validation.competence_id,
        "tenant_id": tenant.id
    })
    if not competence:
        raise HTTPException(status_code=404, detail="Comp√©tence non trouv√©e")
    
    # Cr√©er la validation
    validation_obj = ValidationCompetence(
        **validation.dict(),
        tenant_id=tenant.id,
        validee_par=current_user.id
    )
    
    await db.validations_competences.insert_one(validation_obj.dict())
    
    # R√©cup√©rer l'employ√© concern√©
    user = await db.users.find_one({"id": validation.user_id, "tenant_id": tenant.id})
    
    # Cr√©er une activit√©
    if user:
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="validation_competence",
            description=f"‚úÖ {current_user.prenom} {current_user.nom} a valid√© la comp√©tence '{competence['nom']}' pour {user['prenom']} {user['nom']}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": validation.user_id}
        )
    
    return validation_obj

@api_router.get("/{tenant_slug}/validations-competences/{user_id}")
async def get_validations_competences(
    tenant_slug: str,
    user_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les validations manuelles d'un employ√©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    validations = await db.validations_competences.find({
        "user_id": user_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    
    return [clean_mongo_doc(v) for v in validations]

@api_router.delete("/{tenant_slug}/validations-competences/{validation_id}")
async def supprimer_validation_competence(
    tenant_slug: str,
    validation_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une validation manuelle"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.validations_competences.delete_one({
        "id": validation_id,
        "tenant_id": tenant.id
    })
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Validation non trouv√©e")
    
    return {"message": "Validation supprim√©e"}


class DemandeCong√©(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    demandeur_id: str
    type_conge: str  # maladie, vacances, parental, personnel
    date_debut: str  # YYYY-MM-DD
    date_fin: str  # YYYY-MM-DD
    nombre_jours: int
    raison: str
    documents: List[str] = []  # URLs des documents justificatifs
    priorite: str = "normale"  # urgente, haute, normale, faible
    statut: str = "en_attente"  # en_attente, approuve, refuse
    approuve_par: Optional[str] = None  # ID du superviseur/admin qui approuve
    date_approbation: Optional[str] = None
    commentaire_approbation: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class DemandeCongeCreate(BaseModel):
    tenant_id: Optional[str] = None  # Sera fourni automatiquement par l'endpoint
    type_conge: str
    date_debut: str
    date_fin: str
    raison: str = ""
    statut: str = "en_attente"

class Notification(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    destinataire_id: str
    type: str  # remplacement_disponible, conge_approuve, conge_refuse, conge_demande, planning_assigne
    titre: str
    message: str
    lien: Optional[str] = None  # Lien vers la page concern√©e
    statut: str = "non_lu"  # non_lu, lu
    data: Optional[Dict[str, Any]] = {}  # Donn√©es suppl√©mentaires (demande_id, etc.)
    date_creation: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    date_lecture: Optional[str] = None

class NotificationRemplacement(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    demande_remplacement_id: str
    destinataire_id: str
    message: str
    type_notification: str = "remplacement_disponible"  # remplacement_disponible, approbation_requise
    statut: str = "envoye"  # envoye, lu, accepte, refuse
    date_envoi: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    date_reponse: Optional[datetime] = None
    ordre_priorite: Optional[int] = None  # Pour le mode s√©quentiel

class ParametresRemplacements(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    mode_notification: str = "simultane"  # simultane, sequentiel, groupe_sequentiel
    taille_groupe: int = 3  # Pour mode groupe_sequentiel
    delai_attente_heures: int = 24  # D√©lai avant de passer au suivant
    max_contacts: int = 5
    priorite_grade: bool = True
    priorite_competences: bool = True
    # Gestion des heures suppl√©mentaires
    activer_gestion_heures_sup: bool = False
    seuil_max_heures: int = 40  # Nombre d'heures maximum
    periode_calcul_heures: str = "semaine"  # semaine, mois, personnalise
    jours_periode_personnalisee: int = 7  # Nombre de jours si p√©riode personnalis√©e
    # Regroupement des heures
    activer_regroupement_heures: bool = False
    duree_max_regroupement: int = 24  # Dur√©e maximale d'une garde regroup√©e en heures

class ParametresValidationPlanning(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    frequence: str = "mensuel"  # mensuel, hebdomadaire
    jour_envoi: int = 25  # Jour du mois (1-28)
    heure_envoi: str = "17:00"  # Heure d'envoi (HH:MM)
    periode_couverte: str = "mois_suivant"  # mois_suivant, mois_en_cours
    envoi_automatique: bool = True  # Activer/d√©sactiver l'envoi automatique
    derniere_notification: Optional[str] = None  # Derni√®re ex√©cution (ISO datetime)
    
    # Param√®tres d'√©quit√© des gardes
    periode_equite: str = "mensuel"  # hebdomadaire, bi-hebdomadaire, mensuel, personnalise
    periode_equite_jours: int = 30  # Nombre de jours pour p√©riode personnalis√©e
    
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

# ==================== PARAM√àTRES √âQUIPES DE GARDE ====================

class ConfigEquipePersonnalisee(BaseModel):
    """Configuration pour une √©quipe personnalis√©e"""
    numero: int  # 1, 2, 3, 4, 5
    nom: str = ""  # Nom personnalis√© (ex: "Alpha", "Bravo")
    couleur: str = "#3B82F6"  # Couleur hex pour l'affichage

class ConfigRotation(BaseModel):
    """Configuration de rotation pour temps plein ou temps partiel"""
    rotation_active: bool = False
    type_rotation: str = "aucun"  # "aucun", "montreal", "quebec", "longueuil", "personnalisee"
    date_reference: Optional[str] = None  # Date du jour 1 du cycle (YYYY-MM-DD)
    nombre_equipes: int = 4  # 2, 3, 4, 5 √©quipes
    duree_cycle: int = 28  # Dur√©e du cycle en jours
    pattern_mode: str = "hebdomadaire"  # "hebdomadaire", "quotidien", "deux_jours", "avance"
    pattern_personnalise: List[int] = []  # Pattern avanc√©: [1,1,1,1,1,1,1,2,2,2,2,2,2,2...]
    equipes_config: List[ConfigEquipePersonnalisee] = []  # Config des √©quipes personnalis√©es
    pre_remplissage_auto: bool = False  # Pr√©-remplir automatiquement le planning (temps plein)
    privilegier_equipe_garde: bool = True  # Privil√©gier l'√©quipe de garde (temps partiel)

class ParametresEquipesGarde(BaseModel):
    """Param√®tres du syst√®me d'√©quipes de garde pour un tenant"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    actif: bool = False  # Syst√®me activ√© ou non
    
    # Configuration pour les temps plein
    temps_plein: ConfigRotation = Field(default_factory=ConfigRotation)
    
    # Configuration pour les temps partiel
    temps_partiel: ConfigRotation = Field(default_factory=ConfigRotation)
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ParametresEquipesGardeUpdate(BaseModel):
    """Mise √† jour des param√®tres d'√©quipes de garde"""
    actif: Optional[bool] = None
    temps_plein: Optional[ConfigRotation] = None
    temps_partiel: Optional[ConfigRotation] = None

# ==================== CONFIGURATION IMPORTS CSV ====================

class ImportFieldConfig(BaseModel):
    """Configuration d'un champ pour l'import CSV"""
    key: str
    label: str
    required: bool = False

class ImportSettings(BaseModel):
    """Configuration des imports CSV pour un tenant"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_fields: List[ImportFieldConfig] = []
    personnel_fields: List[ImportFieldConfig] = []
    rapports_fields: List[ImportFieldConfig] = []
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ImportSettingsUpdate(BaseModel):
    """Mise √† jour des configurations d'import"""
    epi_fields: Optional[List[ImportFieldConfig]] = None
    personnel_fields: Optional[List[ImportFieldConfig]] = None
    rapports_fields: Optional[List[ImportFieldConfig]] = None

# EPI Models
# ==================== MOD√àLES EPI NFPA 1851 ====================

class EPI(BaseModel):
    """Mod√®le complet d'un √©quipement de protection individuelle selon NFPA 1851"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    numero_serie: str  # Num√©ro de s√©rie interne (format libre)
    type_epi: str  # ID du type d'EPI personnalis√©
    marque: str
    modele: str
    numero_serie_fabricant: str = ""
    date_fabrication: Optional[str] = None
    date_mise_en_service: str
    norme_certification: str = ""  # ex: NFPA 1971, √©dition 2018
    cout_achat: float = 0.0
    couleur: str = ""
    taille: str = ""
    user_id: Optional[str] = None  # Affect√© √† quel pompier
    statut: str = "En service"  # En service, En inspection, En r√©paration, Hors service, Retir√©
    notes: str = ""
    # Formulaires d'inspection assign√©s (3 types)
    formulaire_apres_usage_id: str = ""  # Formulaire pour inspection apr√®s utilisation
    formulaire_routine_id: str = ""  # Formulaire pour inspection routine mensuelle
    formulaire_avancee_id: str = ""  # Formulaire pour inspection avanc√©e annuelle
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

# ==================== TYPES D'EPI PERSONNALIS√âS ====================
class TypeEPI(BaseModel):
    """Type/Cat√©gorie d'EPI personnalisable"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Casque", "Harnais", "Bottes"
    icone: str = "üõ°Ô∏è"  # Emoji pour l'affichage
    description: str = ""
    ordre: int = 0  # Pour trier l'affichage
    est_defaut: bool = False  # Types par d√©faut non supprimables
    actif: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class TypeEPICreate(BaseModel):
    nom: str
    icone: str = "üõ°Ô∏è"
    description: str = ""
    ordre: int = 0

class TypeEPIUpdate(BaseModel):
    nom: Optional[str] = None
    icone: Optional[str] = None
    description: Optional[str] = None
    ordre: Optional[int] = None
    actif: Optional[bool] = None

class EPICreate(BaseModel):
    tenant_id: Optional[str] = None
    numero_serie: str = ""  # Auto-g√©n√©r√© si vide
    type_epi: str
    marque: str
    modele: str
    numero_serie_fabricant: str = ""
    date_fabrication: Optional[str] = None
    date_mise_en_service: str
    norme_certification: str = ""
    cout_achat: float = 0.0
    couleur: str = ""
    taille: str = ""
    user_id: Optional[str] = None
    statut: str = "En service"
    notes: str = ""
    # Formulaires d'inspection assign√©s (3 types)
    formulaire_apres_usage_id: str = ""
    formulaire_routine_id: str = ""
    formulaire_avancee_id: str = ""

class EPIUpdate(BaseModel):
    numero_serie: Optional[str] = None
    type_epi: Optional[str] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    numero_serie_fabricant: Optional[str] = None
    date_fabrication: Optional[str] = None
    date_mise_en_service: Optional[str] = None
    norme_certification: Optional[str] = None
    cout_achat: Optional[float] = None
    couleur: Optional[str] = None
    taille: Optional[str] = None
    user_id: Optional[str] = None
    statut: Optional[str] = None
    notes: Optional[str] = None
    # Formulaires d'inspection assign√©s (3 types)
    formulaire_apres_usage_id: Optional[str] = None
    formulaire_routine_id: Optional[str] = None
    formulaire_avancee_id: Optional[str] = None

class InspectionEPI(BaseModel):
    """Mod√®le pour les 3 types d'inspections NFPA 1851"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    type_inspection: str  # apres_utilisation, routine_mensuelle, avancee_annuelle
    date_inspection: str
    inspecteur_nom: str
    inspecteur_id: Optional[str] = None  # Si c'est un utilisateur du syst√®me
    isp_id: Optional[str] = None  # Si inspection par ISP
    isp_nom: str = ""
    isp_accreditations: str = ""
    statut_global: str  # conforme, non_conforme, necessite_reparation, hors_service
    checklist: Dict[str, Any] = {}  # JSON avec tous les points de v√©rification
    photos: List[str] = []
    commentaires: str = ""
    rapport_pdf_url: str = ""  # Pour inspection avanc√©e
    signature_numerique: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    type_inspection: str
    date_inspection: str
    inspecteur_nom: str
    inspecteur_id: Optional[str] = None
    isp_id: Optional[str] = None
    isp_nom: str = ""
    isp_accreditations: str = ""
    statut_global: str
    checklist: Dict[str, Any] = {}
    photos: List[str] = []
    commentaires: str = ""
    rapport_pdf_url: str = ""
    signature_numerique: str = ""

# Nouveaux mod√®les pour "Mes EPI"
class InspectionApresUsage(BaseModel):
    """Inspection simple apr√®s utilisation par l'employ√©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    user_id: str  # Employ√© qui fait l'inspection
    date_inspection: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    statut: str  # "ok" ou "defaut"
    defauts_constates: str = ""  # Description des d√©fauts si statut = "defaut"
    notes: str = ""
    photo_url: str = ""  # URL de la photo du d√©faut (optionnel)
    criteres_inspection: Optional[Dict[str, bool]] = {}  # Crit√®res coch√©s/d√©coch√©s

class InspectionApresUsageCreate(BaseModel):
    statut: str  # "ok" ou "defaut"
    defauts_constates: Optional[str] = ""
    notes: Optional[str] = ""
    photo_url: Optional[str] = ""
    criteres_inspection: Optional[Dict[str, bool]] = {}

class DemandeRemplacementEPI(BaseModel):
    """Demande de remplacement d'EPI par un employ√©"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    user_id: str  # Employ√© qui fait la demande
    raison: str  # "Us√©", "Perdu", "D√©fectueux", "Taille inadapt√©e"
    notes_employe: str = ""
    statut: str = "En attente"  # "En attente", "Approuv√©e", "Refus√©e"
    date_demande: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    date_traitement: Optional[datetime] = None
    traite_par: Optional[str] = None  # ID admin/superviseur qui traite
    notes_admin: str = ""  # Notes de l'admin lors du traitement

class DemandeRemplacementEPICreate(BaseModel):
    raison: str
    notes_employe: Optional[str] = ""

class ISP(BaseModel):
    """Fournisseur de Services Ind√©pendant"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    contact: str = ""
    telephone: str = ""
    email: str = ""
    accreditations: str = ""
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ISPCreate(BaseModel):
    tenant_id: Optional[str] = None
    nom: str
    contact: str = ""
    telephone: str = ""
    email: str = ""
    accreditations: str = ""
    notes: str = ""

class ISPUpdate(BaseModel):
    nom: Optional[str] = None
    contact: Optional[str] = None
    telephone: Optional[str] = None
    email: Optional[str] = None
    accreditations: Optional[str] = None
    notes: Optional[str] = None

# ==================== MOD√àLES PHASE 2 : NETTOYAGE, R√âPARATIONS, RETRAIT ====================

class NettoyageEPI(BaseModel):
    """Suivi des nettoyages EPI selon NFPA 1851"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    type_nettoyage: str  # routine, avance
    date_nettoyage: str
    methode: str  # laveuse_extractrice, manuel, externe
    effectue_par: str  # Nom de la personne ou organisation
    effectue_par_id: Optional[str] = None  # ID utilisateur si interne
    isp_id: Optional[str] = None  # Si nettoyage externe
    nombre_cycles: int = 1  # Pour suivi limite fabricant
    temperature: str = ""  # Ex: "Eau ti√®de max 40¬∞C"
    produits_utilises: str = ""
    cout_nettoyage: float = 0.0  # Co√ªt du nettoyage (pour les externes)
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class NettoyageEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    type_nettoyage: str
    date_nettoyage: str
    methode: str
    effectue_par: str
    effectue_par_id: Optional[str] = None
    isp_id: Optional[str] = None
    nombre_cycles: int = 1
    temperature: str = ""
    produits_utilises: str = ""
    cout_nettoyage: float = 0.0
    notes: str = ""

class ReparationEPI(BaseModel):
    """Gestion des r√©parations EPI"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    statut: str  # demandee, en_cours, terminee, impossible
    date_demande: str
    demandeur: str
    demandeur_id: Optional[str] = None
    date_envoi: Optional[str] = None
    date_reception: Optional[str] = None
    date_reparation: Optional[str] = None
    reparateur_type: str  # interne, externe
    reparateur_nom: str = ""
    isp_id: Optional[str] = None
    probleme_description: str
    pieces_remplacees: List[str] = []
    cout_reparation: float = 0.0
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ReparationEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    statut: str = "demandee"
    date_demande: str
    demandeur: str
    demandeur_id: Optional[str] = None
    reparateur_type: str
    reparateur_nom: str = ""
    isp_id: Optional[str] = None
    probleme_description: str
    notes: str = ""

class ReparationEPIUpdate(BaseModel):
    statut: Optional[str] = None
    date_envoi: Optional[str] = None
    date_reception: Optional[str] = None
    date_reparation: Optional[str] = None
    reparateur_nom: Optional[str] = None
    isp_id: Optional[str] = None
    pieces_remplacees: Optional[List[str]] = None
    cout_reparation: Optional[float] = None
    notes: Optional[str] = None

class RetraitEPI(BaseModel):
    """Enregistrement du retrait d√©finitif d'un EPI"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    epi_id: str
    date_retrait: str
    raison: str  # age_limite, dommage_irreparable, echec_inspection, autre
    description_raison: str
    methode_disposition: str  # coupe_detruit, recyclage, don, autre
    preuve_disposition: List[str] = []  # URLs photos
    certificat_disposition_url: str = ""
    cout_disposition: float = 0.0
    retire_par: str
    retire_par_id: Optional[str] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class RetraitEPICreate(BaseModel):
    tenant_id: Optional[str] = None
    epi_id: str
    date_retrait: str
    raison: str
    description_raison: str
    methode_disposition: str
    preuve_disposition: List[str] = []
    certificat_disposition_url: str = ""
    cout_disposition: float = 0.0
    retire_par: str
    retire_par_id: Optional[str] = None
    notes: str = ""



# ==================== MAT√âRIEL & √âQUIPEMENTS MODELS ====================

class CategorieMateriel(BaseModel):
    """Cat√©gorie de mat√©riel personnalisable"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    description: str = ""
    icone: str = "üì¶"  # Emoji pour l'affichage
    couleur: str = "#3b82f6"  # Couleur hex pour l'UI
    ordre: int = 0
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CategorieMaterielCreate(BaseModel):
    nom: str
    description: str = ""
    icone: str = "üì¶"
    couleur: str = "#3b82f6"
    ordre: int = 0

class CategorieMaterielUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    icone: Optional[str] = None
    couleur: Optional[str] = None
    ordre: Optional[int] = None

class Materiel(BaseModel):
    """Item de mat√©riel avec gestion compl√®te"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    
    # Identification
    numero_identification: str  # Code unique (ex: "COMP-001", "LANCE-042")
    nom: str  # Nom descriptif (ex: "Compresse st√©rile 10x10")
    categorie_id: str  # R√©f√©rence √† CategorieMateriel
    
    # Quantit√©s et stock
    quantite_stock: int = 0
    quantite_minimum: int = 0  # Seuil d'alerte
    unite_mesure: str = "unit√©"  # unit√©, paquet, bo√Æte, etc.
    
    # Dates
    date_acquisition: Optional[str] = None
    date_expiration: Optional[str] = None
    date_prochaine_maintenance: Optional[str] = None
    
    # √âtat et localisation
    etat: str = "bon"  # bon, a_reparer, hors_service, en_maintenance
    localisation_type: str = "stock"  # stock, vehicule, caserne, personne
    localisation_id: Optional[str] = None  # ID du v√©hicule, caserne, ou personne
    localisation_details: str = ""  # Description textuelle (ex: "Entrep√¥t A, √âtag√®re 3")
    
    # Fournisseur et co√ªts
    fournisseur: str = ""
    numero_modele: str = ""
    cout_unitaire: float = 0.0
    cout_total: float = 0.0  # quantite * cout_unitaire
    
    # Photos et documents
    photos: List[str] = []  # URLs des photos
    documents: List[str] = []  # URLs des documents (manuels, certificats, etc.)
    
    # Maintenance
    frequence_maintenance: Optional[str] = None  # mensuelle, trimestrielle, annuelle, personnalisee
    frequence_maintenance_jours: Optional[int] = None  # Pour fr√©quence personnalis√©e
    derniere_maintenance: Optional[str] = None
    
    # M√©tadonn√©es
    notes: str = ""
    code_barre: Optional[str] = None
    qr_code: Optional[str] = None
    created_by: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MaterielCreate(BaseModel):
    numero_identification: str
    nom: str
    categorie_id: str
    quantite_stock: int = 0
    quantite_minimum: int = 0
    unite_mesure: str = "unit√©"
    date_acquisition: Optional[str] = None
    date_expiration: Optional[str] = None
    etat: str = "bon"
    localisation_type: str = "stock"
    localisation_id: Optional[str] = None
    localisation_details: str = ""
    fournisseur: str = ""
    numero_modele: str = ""
    cout_unitaire: float = 0.0
    photos: List[str] = []
    documents: List[str] = []
    frequence_maintenance: Optional[str] = None
    frequence_maintenance_jours: Optional[int] = None
    notes: str = ""

class MaterielUpdate(BaseModel):
    numero_identification: Optional[str] = None
    nom: Optional[str] = None
    categorie_id: Optional[str] = None
    quantite_stock: Optional[int] = None
    quantite_minimum: Optional[int] = None
    unite_mesure: Optional[str] = None
    date_acquisition: Optional[str] = None
    date_expiration: Optional[str] = None
    date_prochaine_maintenance: Optional[str] = None
    etat: Optional[str] = None
    localisation_type: Optional[str] = None
    localisation_id: Optional[str] = None
    localisation_details: Optional[str] = None
    fournisseur: Optional[str] = None
    numero_modele: Optional[str] = None
    cout_unitaire: Optional[float] = None
    photos: Optional[List[str]] = None
    documents: Optional[List[str]] = None
    frequence_maintenance: Optional[str] = None
    frequence_maintenance_jours: Optional[int] = None
    derniere_maintenance: Optional[str] = None
    notes: Optional[str] = None

class MouvementStock(BaseModel):
    """Historique des mouvements de stock"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    materiel_id: str
    type_mouvement: str  # entree, sortie, ajustement, inventaire
    quantite: int  # Positif pour entr√©e, n√©gatif pour sortie
    quantite_avant: int
    quantite_apres: int
    raison: str  # reception_commande, utilisation, perte, casse, inventaire, correction, etc.
    reference: str = ""  # Num√©ro de commande, bon de sortie, etc.
    effectue_par: str
    effectue_par_id: Optional[str] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MouvementStockCreate(BaseModel):
    materiel_id: str
    type_mouvement: str
    quantite: int
    raison: str
    reference: str = ""
    notes: str = ""

class MaintenanceMateriel(BaseModel):
    """Maintenance pr√©ventive ou corrective"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    materiel_id: str
    type_maintenance: str  # preventive, corrective
    statut: str  # planifiee, en_cours, terminee, annulee
    
    # Dates
    date_prevue: str
    date_debut: Optional[str] = None
    date_fin: Optional[str] = None
    
    # Responsable
    responsable_type: str = "interne"  # interne, externe
    responsable_nom: str = ""
    responsable_id: Optional[str] = None  # Si interne
    fournisseur_externe: str = ""  # Si externe
    
    # D√©tails
    description_travaux: str = ""
    pieces_remplacees: List[str] = []
    cout: float = 0.0
    temps_hors_service_heures: float = 0.0
    
    # R√©sultat
    resultat: str = ""  # conforme, non_conforme, a_surveiller
    prochaine_maintenance: Optional[str] = None
    notes: str = ""
    
    # Photos et documents
    photos_avant: List[str] = []
    photos_apres: List[str] = []
    documents: List[str] = []  # Rapports, factures, etc.
    
    created_by: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MaintenanceMaterielCreate(BaseModel):
    materiel_id: str
    type_maintenance: str
    statut: str = "planifiee"
    date_prevue: str
    responsable_type: str = "interne"
    responsable_nom: str = ""
    responsable_id: Optional[str] = None
    fournisseur_externe: str = ""
    description_travaux: str = ""
    notes: str = ""

class MaintenanceMaterielUpdate(BaseModel):
    statut: Optional[str] = None
    date_debut: Optional[str] = None
    date_fin: Optional[str] = None
    responsable_type: Optional[str] = None
    responsable_nom: Optional[str] = None
    responsable_id: Optional[str] = None
    fournisseur_externe: Optional[str] = None
    description_travaux: Optional[str] = None
    pieces_remplacees: Optional[List[str]] = None
    cout: Optional[float] = None
    temps_hors_service_heures: Optional[float] = None
    resultat: Optional[str] = None
    prochaine_maintenance: Optional[str] = None
    notes: Optional[str] = None
    photos_avant: Optional[List[str]] = None
    photos_apres: Optional[List[str]] = None
    documents: Optional[List[str]] = None

class InspectionMateriel(BaseModel):
    """Inspection rapide de l'√©tat du mat√©riel"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    materiel_id: str
    date_inspection: str
    inspecteur: str
    inspecteur_id: Optional[str] = None
    etat_constate: str  # bon, endommage, defectueux, manquant
    fonctionnel: bool = True
    defauts: List[str] = []  # Liste des d√©fauts constat√©s
    action_requise: str = "aucune"  # aucune, nettoyage, reparation, remplacement
    notes: str = ""
    photos: List[str] = []
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionMaterielCreate(BaseModel):
    materiel_id: str
    date_inspection: str
    etat_constate: str
    fonctionnel: bool = True
    defauts: List[str] = []
    action_requise: str = "aucune"
    notes: str = ""
    photos: List[str] = []



# ==================== INVENTAIRES V√âHICULES MODELS ====================

class ItemInventaireVehicule(BaseModel):
    """Item individuel dans un mod√®le d'inventaire v√©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str
    photo_url: str = ""  # Photo de r√©f√©rence de l'item
    obligatoire: bool = False
    photo_requise: bool = False
    ordre: int = 0

# ==================== MOD√àLES INSPECTION BORNES S√àCHES PERSONNALISABLES ====================

class ItemInspectionBorneSeche(BaseModel):
    """Item individuel dans une section d'inspection de borne s√®che"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str
    description: str = ""
    photo_url: str = ""  # Photo de r√©f√©rence de l'item
    obligatoire: bool = False
    photo_requise: bool = False
    ordre: int = 0

class SectionInspectionBorneSeche(BaseModel):
    """Section dans un mod√®le d'inspection de borne s√®che"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    titre: str
    description: str = ""
    type_champ: str = "checkbox"  # Types: checkbox, radio, text, number, select, photo, timer, geolocation, signature, rating, toggle, date, multiselect, sketch
    options: List[dict] = []  # Options pour checkbox/radio/select: [{label, declencherAlerte, couleur}]
    photo_url: str = ""  # Photo de r√©f√©rence de la section
    items: List[ItemInspectionBorneSeche] = []
    ordre: int = 0
    # Param√®tres sp√©cifiques selon le type
    unite: str = ""  # Unit√© pour number (ex: "L/min", "PSI", "secondes")
    min_value: Optional[float] = None  # Valeur minimale pour number
    max_value: Optional[float] = None  # Valeur maximale pour number
    seuil_alerte: Optional[float] = None  # Seuil d√©clenchant une alerte pour number

class ModeleInspectionBorneSeche(BaseModel):
    """Mod√®le d'inspection personnalisable pour les bornes s√®ches"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Inspection standard", "Inspection compl√®te"
    description: str = ""
    est_actif: bool = True  # Si ce mod√®le est le mod√®le actif
    sections: List[SectionInspectionBorneSeche] = []
    created_by: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ModeleInspectionBorneSecheCreate(BaseModel):
    nom: str
    description: str = ""
    sections: List[dict] = []  # [{titre, type_champ, options, items}]

class ModeleInspectionBorneSecheUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    est_actif: Optional[bool] = None
    sections: Optional[List[dict]] = None

class InspectionBorneSecheRemplie(BaseModel):
    """Inspection effectu√©e sur une borne s√®che avec formulaire personnalisable"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    borne_seche_id: str
    borne_nom: str
    modele_id: str
    modele_nom: str
    inspecteur_id: str
    inspecteur_nom: str
    date_inspection: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    # R√©ponses aux sections du formulaire
    reponses: List[dict] = []  # [{section_id, section_titre, type_champ, valeur, notes, photos, alertes}]
    # G√©olocalisation
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    # Alertes g√©n√©r√©es
    alertes: List[dict] = []  # [{section_titre, item_nom, message, severite}]
    has_anomalie: bool = False  # Si une anomalie a √©t√© signal√©e
    commentaire_anomalie: str = ""
    photos_anomalie: List[str] = []
    # Signature
    signature_inspecteur: str = ""  # Base64 de la signature
    # Statut
    statut: str = "complete"  # complete, en_cours, anomalie
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

# ==================== FIN MOD√àLES INSPECTION BORNES S√àCHES ====================

class SectionInventaireVehicule(BaseModel):
    """Section dans un mod√®le d'inventaire v√©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    titre: str
    type_champ: str = "checkbox"  # Type de r√©ponse: checkbox, radio, text, number, select, photo
    options: List[dict] = []  # Options pour checkbox/radio/select: [{label, declencherAlerte}]
    photo_url: str = ""  # Photo de r√©f√©rence de la section
    items: List[ItemInventaireVehicule] = []
    ordre: int = 0

class ModeleInventaireVehicule(BaseModel):
    """Mod√®le d'inventaire pour un type de v√©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Inventaire Autopompe", "Inventaire √âchelle"
    type_vehicule: str  # autopompe, echelle_aerienne, camion_citerne, etc.
    description: str = ""
    sections: List[SectionInventaireVehicule] = []
    created_by: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ModeleInventaireVehiculeCreate(BaseModel):
    nom: str
    type_vehicule: str
    description: str = ""
    sections: List[dict] = []  # [{titre, items: [{nom, obligatoire, photo_requise}]}]

class ModeleInventaireVehiculeUpdate(BaseModel):
    nom: Optional[str] = None
    type_vehicule: Optional[str] = None
    description: Optional[str] = None
    sections: Optional[List[dict]] = None

class ItemInventaireVehiculeRempli(BaseModel):
    """Item rempli lors d'un inventaire"""
    item_id: str
    section: str
    nom: str
    type_champ: str  # checkbox, radio, text, number, select, photo
    valeur: Any  # Peut √™tre str, list, number selon type_champ
    notes: str = ""
    photo_prise: str = ""  # Photo prise pendant l'inventaire

class InventaireVehicule(BaseModel):
    """Inventaire hebdomadaire effectu√© sur un v√©hicule"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    vehicule_id: str
    vehicule_nom: str  # Pour affichage
    modele_id: str
    modele_nom: str
    date_inventaire: str
    effectue_par: str
    effectue_par_id: str
    items_coches: List[ItemInventaireVehiculeRempli] = []
    statut_global: str = "conforme"  # conforme, non_conforme
    items_manquants: int = 0
    items_defectueux: int = 0
    notes_generales: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InventaireVehiculeCreate(BaseModel):
    vehicule_id: str
    vehicule_nom: str = ""
    modele_id: str
    date_inventaire: str
    heure_debut: str = ""
    heure_fin: str = ""
    effectue_par: str = ""
    effectue_par_id: str = ""
    items_coches: List[dict]  # [{item_id, section, nom, type_champ, valeur, notes, photo_prise}]
    notes_generales: str = ""
    alertes: List[dict] = []  # [{section, item, valeur, notes, photo}]


# ==================== MAT√âRIEL & √âQUIPEMENTS ====================

class Fournisseur(BaseModel):
    """Fournisseur d'√©quipements"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    contact_nom: str = ""
    telephone: str = ""
    email: str = ""
    adresse: str = ""
    ville: str = ""
    province: str = ""
    code_postal: str = ""
    site_web: str = ""
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class FournisseurCreate(BaseModel):
    nom: str
    contact_nom: str = ""
    telephone: str = ""
    email: str = ""
    adresse: str = ""
    ville: str = ""
    province: str = ""
    code_postal: str = ""
    site_web: str = ""
    notes: str = ""

class FournisseurUpdate(BaseModel):
    nom: Optional[str] = None
    contact_nom: Optional[str] = None
    telephone: Optional[str] = None
    email: Optional[str] = None
    adresse: Optional[str] = None
    ville: Optional[str] = None
    province: Optional[str] = None
    code_postal: Optional[str] = None
    site_web: Optional[str] = None
    notes: Optional[str] = None

class CategorieEquipement(BaseModel):
    """Cat√©gorie d'√©quipement (pr√©d√©finie ou personnalis√©e)"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    description: str = ""
    norme_reference: str = ""  # NFPA 1962, NFPA 1852, etc.
    frequence_inspection: str = ""  # "1 an", "6 mois", etc.
    couleur: str = "#6366F1"  # Couleur pour l'interface
    icone: str = "üì¶"  # Emoji ou ic√¥ne
    est_predefinit: bool = False  # True pour cat√©gories syst√®me
    permet_assignation_employe: bool = False  # Si True, √©quipements peuvent √™tre assign√©s √† des employ√©s
    champs_supplementaires: List[dict] = []  # Champs sp√©cifiques √† la cat√©gorie [{nom, type, options, obligatoire}]
    # Support pour plusieurs personnes ressources
    personnes_ressources: List[dict] = []  # [{id: str, email: str}]
    # Anciens champs gard√©s pour compatibilit√©
    personne_ressource_id: str = ""  # ID de l'utilisateur responsable des inspections
    personne_ressource_email: str = ""  # Email pour notifications directes
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CategorieEquipementCreate(BaseModel):
    nom: str
    description: str = ""
    norme_reference: str = ""
    frequence_inspection: str = ""
    couleur: str = "#6366F1"
    icone: str = "üì¶"
    permet_assignation_employe: bool = False
    champs_supplementaires: List[dict] = []
    personnes_ressources: List[dict] = []
    personne_ressource_id: str = ""
    personne_ressource_email: str = ""

class CategorieEquipementUpdate(BaseModel):
    nom: Optional[str] = None
    description: Optional[str] = None
    norme_reference: Optional[str] = None
    frequence_inspection: Optional[str] = None
    couleur: Optional[str] = None
    icone: Optional[str] = None
    permet_assignation_employe: Optional[bool] = None
    champs_supplementaires: Optional[List[dict]] = None
    personnes_ressources: Optional[List[dict]] = None
    personne_ressource_id: Optional[str] = None
    personne_ressource_email: Optional[str] = None

class HistoriqueMaintenance(BaseModel):
    """Historique de maintenance/r√©paration d'un √©quipement"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    equipement_id: str
    type_intervention: str  # "maintenance", "reparation", "test", "inspection"
    date_intervention: str
    description: str
    cout: float = 0.0
    effectue_par: str = ""
    effectue_par_id: str = ""
    pieces_remplacees: List[str] = []
    resultats: str = ""  # R√©sultats de tests (ex: pression test√©e)
    prochaine_intervention: str = ""  # Date sugg√©r√©e
    documents: List[str] = []  # URLs de documents/photos
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class HistoriqueMaintenanceCreate(BaseModel):
    equipement_id: str = ""  # Optionnel car fourni via URL
    type_intervention: str
    date_intervention: str
    description: str
    cout: float = 0.0
    effectue_par: str = ""
    effectue_par_id: str = ""
    pieces_remplacees: List[str] = []
    resultats: str = ""
    prochaine_intervention: str = ""
    documents: List[str] = []
    notes: str = ""

class Equipement(BaseModel):
    """√âquipement de pompiers"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    
    # Informations de base
    nom: str
    code_unique: str  # Num√©ro de s√©rie, code interne
    categorie_id: str = ""  # R√©f√©rence √† CategorieEquipement
    categorie_nom: str = ""  # Pour affichage rapide
    description: str = ""
    
    # √âtat et quantit√©
    etat: str = "bon"  # neuf, bon, a_reparer, en_reparation, hors_service
    quantite: int = 1
    quantite_minimum: int = 1  # Seuil d'alerte stock bas
    gerer_quantite: bool = False  # Si True, d√©duire du stock lors des interventions (consommable)
    
    # Informations fournisseur
    fournisseur_id: str = ""
    fournisseur_nom: str = ""
    
    # Informations financi√®res
    date_achat: str = ""
    prix_achat: float = 0.0
    garantie_fin: str = ""
    
    # Emplacement - peut √™tre assign√© √† v√©hicule ET/OU emplacement ET/OU employ√©
    emplacement_type: str = ""  # "vehicule", "caserne", "entrepot", "stock", "autre"
    emplacement_id: str = ""  # ID du v√©hicule si applicable
    emplacement_nom: str = ""  # Nom lisible
    
    # Assignation √† un v√©hicule (optionnel)
    vehicule_id: str = ""
    vehicule_nom: str = ""
    
    # Assignation √† un employ√© (pour parties faciales, radios, etc.)
    employe_id: str = ""
    employe_nom: str = ""
    
    # Maintenance et conformit√©
    norme_reference: str = ""  # NFPA 1962, NFPA 1852, etc.
    frequence_maintenance: str = ""  # "1 an", "6 mois", etc.
    date_derniere_maintenance: str = ""
    date_prochaine_maintenance: str = ""
    date_fin_vie: str = ""  # Date de mise au rancart pr√©vue
    
    # Alertes actives
    alerte_maintenance: bool = False
    alerte_stock_bas: bool = False
    alerte_reparation: bool = False
    alerte_fin_vie: bool = False
    alerte_expiration: bool = False
    
    # Documents et photos
    photos: List[str] = []  # URLs
    documents: List[str] = []  # URLs
    
    # Champs personnalis√©s (flexibilit√© maximale)
    champs_personnalises: Dict[str, Any] = {}  # {nom_champ: valeur}
    
    # Formulaire d'inspection assign√© (optionnel)
    modele_inspection_id: str = ""  # ID du formulaire d'inspection assign√©
    
    # M√©tadonn√©es
    notes: str = ""
    tags: List[str] = []
    created_by: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class EquipementCreate(BaseModel):
    nom: str
    code_unique: str
    categorie_id: str = ""
    categorie_nom: str = ""
    description: str = ""
    etat: str = "bon"
    quantite: int = 1
    quantite_minimum: int = 1
    gerer_quantite: bool = False  # Si True, d√©duire du stock lors des interventions (consommable)
    fournisseur_id: str = ""
    fournisseur_nom: str = ""
    date_achat: str = ""
    prix_achat: float = 0.0
    garantie_fin: str = ""
    emplacement_type: str = ""
    emplacement_id: str = ""
    emplacement_nom: str = ""
    vehicule_id: str = ""
    vehicule_nom: str = ""
    employe_id: str = ""
    employe_nom: str = ""
    norme_reference: str = ""
    frequence_maintenance: str = ""
    date_derniere_maintenance: str = ""
    date_prochaine_maintenance: str = ""
    date_fin_vie: str = ""
    photos: List[str] = []
    documents: List[str] = []
    champs_personnalises: Dict[str, Any] = {}
    modele_inspection_id: str = ""  # ID du formulaire d'inspection assign√©
    notes: str = ""
    tags: List[str] = []

class EquipementUpdate(BaseModel):
    nom: Optional[str] = None
    code_unique: Optional[str] = None
    categorie_id: Optional[str] = None
    categorie_nom: Optional[str] = None
    description: Optional[str] = None
    etat: Optional[str] = None
    quantite: Optional[int] = None
    quantite_minimum: Optional[int] = None
    gerer_quantite: Optional[bool] = None  # Si True, d√©duire du stock lors des interventions (consommable)
    fournisseur_id: Optional[str] = None
    fournisseur_nom: Optional[str] = None
    date_achat: Optional[str] = None
    prix_achat: Optional[float] = None
    garantie_fin: Optional[str] = None
    emplacement_type: Optional[str] = None
    emplacement_id: Optional[str] = None
    emplacement_nom: Optional[str] = None
    vehicule_id: Optional[str] = None
    vehicule_nom: Optional[str] = None
    employe_id: Optional[str] = None
    employe_nom: Optional[str] = None
    norme_reference: Optional[str] = None
    frequence_maintenance: Optional[str] = None
    date_derniere_maintenance: Optional[str] = None
    date_prochaine_maintenance: Optional[str] = None
    date_fin_vie: Optional[str] = None
    photos: Optional[List[str]] = None
    documents: Optional[List[str]] = None
    champs_personnalises: Optional[Dict[str, Any]] = None
    notes: Optional[str] = None
    tags: Optional[List[str]] = None
    alerte_maintenance: Optional[bool] = None
    alerte_stock_bas: Optional[bool] = None
    alerte_reparation: Optional[bool] = None
    alerte_fin_vie: Optional[bool] = None
    alerte_expiration: Optional[bool] = None
    modele_inspection_id: Optional[str] = None  # ID du formulaire d'inspection assign√©


# ==================== MULTI-TENANT DEPENDENCIES ====================

# Cache simple pour les tenants (60 secondes)
_tenant_cache = {}
_tenant_cache_time = {}

async def get_tenant_from_slug(slug: str) -> Tenant:
    """R√©cup√®re le tenant depuis son slug avec cache"""
    # V√©rifier le cache (60 secondes)
    cache_key = f"tenant_{slug}"
    now = time.time()
    if cache_key in _tenant_cache and (now - _tenant_cache_time.get(cache_key, 0)) < 60:
        logging.warning(f"üóÑÔ∏è Cache hit pour tenant {slug}: {_tenant_cache[cache_key].id}")
        return _tenant_cache[cache_key]
    
    logging.warning(f"üîç Cache miss pour tenant {slug}, requ√™te DB...")
    
    # Requ√™te simplifi√©e avec index
    tenant_data = await db.tenants.find_one({"slug": slug}, {"_id": 0})
    logging.warning(f"üîç R√©sultat DB pour slug={slug}: id={tenant_data.get('id') if tenant_data else 'None'}, nom={tenant_data.get('nom') if tenant_data else 'None'}")
    
    # Fallback pour ancienne structure
    if not tenant_data:
        tenant_data = await db.tenants.find_one({"slug": slug, "actif": True}, {"_id": 0})
    
    if not tenant_data:
        tenant_data = await db.tenants.find_one({"slug": slug, "is_active": True}, {"_id": 0})
    
    # Si toujours pas trouv√©
    if not tenant_data:
        tenant_data = await db.tenants.find_one({"slug": slug}, {"_id": 0})
        if tenant_data:
            # V√©rifier manuellement le statut
            is_active = tenant_data.get('actif', tenant_data.get('is_active', True))
            if not is_active:
                raise HTTPException(status_code=403, detail=f"Caserne '{slug}' inactive")
    
    if not tenant_data:
        raise HTTPException(status_code=404, detail=f"Caserne '{slug}' non trouv√©e")
    
    logging.info(f"üîç Tenant data for {slug}: {tenant_data}")
    tenant = Tenant(**tenant_data)
    
    # Mettre en cache
    _tenant_cache[cache_key] = tenant
    _tenant_cache_time[cache_key] = now
    
    return tenant

async def get_current_tenant(tenant_slug: str) -> Tenant:
    """D√©pendance FastAPI pour obtenir le tenant actuel"""
    return await get_tenant_from_slug(tenant_slug)

# get_super_admin function moved to earlier in the file

# ==================== TENANT AUTH ROUTES ====================

@api_router.post("/{tenant_slug}/auth/login")
async def tenant_login(tenant_slug: str, user_login: UserLogin):
    """Login pour un tenant sp√©cifique avec migration automatique SHA256 -> bcrypt
    Les super-admins peuvent aussi se connecter sur n'importe quel tenant avec leurs identifiants"""
    try:
        logging.info(f"üîë Tentative de connexion pour {user_login.email} sur tenant {tenant_slug}")
        
        # V√©rifier que le tenant existe et est actif
        tenant = await get_tenant_from_slug(tenant_slug)
        logging.warning(f"‚úÖ Tenant trouv√©: {tenant.nom} (id: {tenant.id})")
        
        # D'abord, v√©rifier si c'est un super-admin qui essaie de se connecter
        super_admin_data = await db.super_admins.find_one({"email": user_login.email})
        if super_admin_data:
            logging.info(f"üîê Super-Admin d√©tect√©: {user_login.email}")
            
            # V√©rifier le mot de passe du super-admin
            current_hash = super_admin_data.get("mot_de_passe_hash", "")
            if verify_password(user_login.mot_de_passe, current_hash):
                logging.info(f"‚úÖ Super-Admin {user_login.email} authentifi√© sur tenant {tenant_slug}")
                
                # Cr√©er un token avec les droits admin sur ce tenant (expiration 2h pour super-admin)
                access_token = create_access_token(
                    data={
                        "sub": super_admin_data["id"],
                        "email": super_admin_data["email"],
                        "tenant_id": tenant.id,
                        "tenant_slug": tenant.slug,
                        "is_super_admin": True  # Flag pour identifier un super-admin
                    },
                    expires_delta=timedelta(minutes=SUPER_ADMIN_TOKEN_EXPIRE_MINUTES)
                )
                
                # Enregistrer l'action dans le journal d'audit
                await log_super_admin_action(
                    admin=SuperAdmin(**super_admin_data),
                    action="tenant_access",
                    details={"login_method": "password"},
                    tenant_id=tenant.id,
                    tenant_slug=tenant.slug,
                    tenant_nom=tenant.nom
                )
                
                return {
                    "access_token": access_token,
                    "token_type": "bearer",
                    "tenant": {
                        "id": tenant.id,
                        "slug": tenant.slug,
                        "nom": tenant.nom,
                        "parametres": tenant.parametres
                    },
                    "user": {
                        "id": super_admin_data["id"],
                        "nom": super_admin_data["nom"],
                        "prenom": "Super-Admin",
                        "email": super_admin_data["email"],
                        "role": "admin",  # Droits admin sur le tenant
                        "grade": "Super-Administrateur",
                        "type_emploi": "temps_plein",
                        "photo_profil": None,
                        "is_super_admin": True
                    }
                }
            else:
                logging.warning(f"‚ùå Mot de passe incorrect pour Super-Admin {user_login.email}")
                raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        # Sinon, chercher l'utilisateur dans ce tenant
        logging.warning(f"üîç Recherche utilisateur avec email={user_login.email} et tenant_id={tenant.id}")
        user_data = await db.users.find_one({
            "email": user_login.email,
            "tenant_id": tenant.id
        })
        
        # Debug: chercher sans tenant_id
        if not user_data:
            user_any = await db.users.find_one({"email": user_login.email})
            if user_any:
                logging.warning(f"üîç User existe mais avec tenant_id={user_any.get('tenant_id')} (attendu: {tenant.id})")
            logging.warning(f"‚ùå Utilisateur non trouv√©: {user_login.email} dans tenant {tenant_slug}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"‚úÖ Utilisateur trouv√©: {user_data.get('nom')} {user_data.get('prenom')} (id: {user_data.get('id')})")
        
        # V√©rifier que l'utilisateur est actif
        if user_data.get("statut") != "Actif":
            logging.warning(f"‚ùå Tentative de connexion d'un utilisateur inactif: {user_login.email}")
            raise HTTPException(
                status_code=403, 
                detail="Votre compte est d√©sactiv√©. Veuillez contacter votre administrateur."
            )
        
        logging.info(f"‚úÖ Statut de l'utilisateur v√©rifi√©: {user_data.get('statut')}")
        
        current_hash = user_data.get("mot_de_passe_hash", "")
        hash_type = "bcrypt" if current_hash.startswith('$2') else "SHA256"
        logging.info(f"üîê Type de hash d√©tect√©: {hash_type}")
        
        # V√©rifier le mot de passe
        if not verify_password(user_login.mot_de_passe, current_hash):
            logging.warning(f"‚ùå Mot de passe incorrect pour {user_login.email}")
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
        
        logging.info(f"‚úÖ Mot de passe v√©rifi√© avec succ√®s pour {user_login.email}")
        
        user = User(**user_data)
        
        # Inclure tenant_id dans le token
        access_token = create_access_token(data={
            "sub": user.id,
            "email": user.email,  # Ajout de l'email pour le fallback d'authentification
            "tenant_id": tenant.id,
            "tenant_slug": tenant.slug
        })
        
        logging.info(f"‚úÖ Token JWT cr√©√© pour {user_login.email}")
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "tenant": {
                "id": tenant.id,
                "slug": tenant.slug,
                "nom": tenant.nom,
                "parametres": tenant.parametres  # Inclure les param√®tres du tenant
            },
            "user": {
                "id": user.id,
                "nom": user.nom,
                "prenom": user.prenom,
                "email": user.email,
                "role": user.role,
                "grade": user.grade,
                "type_emploi": user.type_emploi,
                "photo_profil": user.photo_profil  # Ajouter la photo de profil
            }
        }
    except HTTPException:
        # Re-lever les HTTPExceptions sans les logger √† nouveau
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur inattendue lors du login pour {user_login.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

# ==================== PASSWORD RESET ROUTES ====================

@api_router.post("/{tenant_slug}/auth/forgot-password")
async def forgot_password(tenant_slug: str, request: ForgotPasswordRequest):
    """
    Endpoint pour demander une r√©initialisation de mot de passe.
    Envoie un email avec un lien contenant un token valide 1 heure.
    """
    try:
        logging.info(f"üîë Demande de r√©initialisation de mot de passe pour {request.email} sur tenant {tenant_slug}")
        
        # V√©rifier que le tenant existe
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Chercher l'utilisateur dans ce tenant
        user_data = await db.users.find_one({
            "email": request.email,
            "tenant_id": tenant.id
        })
        
        # M√™me si l'utilisateur n'existe pas, on retourne un message g√©n√©rique pour la s√©curit√©
        if not user_data:
            logging.warning(f"‚ö†Ô∏è Tentative de r√©initialisation pour email inexistant: {request.email} dans tenant {tenant_slug}")
            # Ne pas r√©v√©ler que l'email n'existe pas
            return {
                "message": "Si cet email existe dans notre syst√®me, vous recevrez un lien de r√©initialisation.",
                "email_sent": False
            }
        
        # G√©n√©rer un token unique
        reset_token = str(uuid.uuid4())
        
        # Calculer l'expiration (1 heure)
        expires_at = datetime.now(timezone.utc) + timedelta(hours=1)
        
        # Cr√©er l'objet token
        token_obj = PasswordResetToken(
            tenant_id=tenant.id,
            user_id=user_data["id"],
            email=request.email,
            token=reset_token,
            expires_at=expires_at
        )
        
        # Sauvegarder le token dans la base de donn√©es
        await db.password_reset_tokens.insert_one(token_obj.dict())
        
        logging.info(f"‚úÖ Token de r√©initialisation cr√©√© pour {request.email}, expire √† {expires_at}")
        
        # Envoyer l'email
        user_name = f"{user_data.get('prenom', '')} {user_data.get('nom', '')}".strip()
        email_sent = send_password_reset_email(
            user_email=request.email,
            user_name=user_name or request.email,
            reset_token=reset_token,
            tenant_slug=tenant_slug
        )
        
        if email_sent:
            logging.info(f"‚úÖ Email de r√©initialisation envoy√© avec succ√®s √† {request.email}")
        else:
            logging.warning(f"‚ö†Ô∏è L'email n'a pas pu √™tre envoy√© √† {request.email}")
        
        return {
            "message": "Si cet email existe dans notre syst√®me, vous recevrez un lien de r√©initialisation.",
            "email_sent": email_sent
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de la demande de r√©initialisation pour {request.email}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")


@api_router.get("/{tenant_slug}/auth/verify-reset-token/{token}")
async def verify_reset_token(tenant_slug: str, token: str):
    """
    V√©rifie si un token de r√©initialisation est valide et non expir√©
    """
    try:
        # V√©rifier que le tenant existe
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Chercher le token
        token_data = await db.password_reset_tokens.find_one({
            "token": token,
            "tenant_id": tenant.id,
            "used": False
        })
        
        if not token_data:
            raise HTTPException(status_code=404, detail="Token invalide ou d√©j√† utilis√©")
        
        # V√©rifier l'expiration
        expires_at = token_data["expires_at"]
        if isinstance(expires_at, str):
            expires_at = datetime.fromisoformat(expires_at.replace('Z', '+00:00'))
        elif expires_at.tzinfo is None:
            # Si c'est un datetime sans timezone, on assume UTC
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        
        if datetime.now(timezone.utc) > expires_at:
            raise HTTPException(status_code=400, detail="Ce lien a expir√©. Veuillez demander un nouveau lien de r√©initialisation.")
        
        return {
            "valid": True,
            "email": token_data["email"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de la v√©rification du token: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")


@api_router.post("/{tenant_slug}/auth/reset-password")
async def reset_password(tenant_slug: str, request: ResetPasswordRequest):
    """
    R√©initialise le mot de passe avec un token valide
    """
    try:
        logging.info(f"üîë Tentative de r√©initialisation de mot de passe avec token sur tenant {tenant_slug}")
        
        # V√©rifier que le tenant existe
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # Chercher le token
        token_data = await db.password_reset_tokens.find_one({
            "token": request.token,
            "tenant_id": tenant.id,
            "used": False
        })
        
        if not token_data:
            logging.warning(f"‚ö†Ô∏è Token invalide ou d√©j√† utilis√©: {request.token[:8]}...")
            raise HTTPException(status_code=404, detail="Token invalide ou d√©j√† utilis√©")
        
        # V√©rifier l'expiration
        expires_at = token_data["expires_at"]
        if isinstance(expires_at, str):
            expires_at = datetime.fromisoformat(expires_at.replace('Z', '+00:00'))
        elif expires_at.tzinfo is None:
            # Si c'est un datetime sans timezone, on assume UTC
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        
        if datetime.now(timezone.utc) > expires_at:
            logging.warning(f"‚ö†Ô∏è Token expir√© pour {token_data['email']}")
            raise HTTPException(status_code=400, detail="Ce lien a expir√©. Veuillez demander un nouveau lien de r√©initialisation.")
        
        # Valider le nouveau mot de passe
        if not validate_complex_password(request.nouveau_mot_de_passe):
            raise HTTPException(
                status_code=400,
                detail="Le mot de passe doit contenir au moins 8 caract√®res, une majuscule, un chiffre et un caract√®re sp√©cial"
            )
        
        # Hacher le nouveau mot de passe avec bcrypt
        nouveau_hash = get_password_hash(request.nouveau_mot_de_passe)
        logging.info(f"üîê Nouveau mot de passe hash√© avec bcrypt pour {token_data['email']}")
        
        # Mettre √† jour le mot de passe de l'utilisateur
        result = await db.users.update_one(
            {"id": token_data["user_id"], "tenant_id": tenant.id},
            {"$set": {"mot_de_passe_hash": nouveau_hash}}
        )
        
        if result.modified_count == 0:
            logging.error(f"‚ùå √âchec de la mise √† jour du mot de passe pour user_id: {token_data['user_id']}")
            raise HTTPException(status_code=500, detail="Erreur lors de la mise √† jour du mot de passe")
        
        # Marquer le token comme utilis√©
        await db.password_reset_tokens.update_one(
            {"token": request.token},
            {"$set": {"used": True}}
        )
        
        logging.info(f"‚úÖ Mot de passe r√©initialis√© avec succ√®s pour {token_data['email']}")
        
        return {
            "message": "Votre mot de passe a √©t√© r√©initialis√© avec succ√®s. Vous pouvez maintenant vous connecter.",
            "email": token_data["email"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"‚ùå Erreur lors de la r√©initialisation du mot de passe: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Erreur interne du serveur")

# ==================== DEMANDES DE CONG√â ROUTES MIGR√âES VERS routes/conges.py ====================
# Routes migr√©es:
# - POST /{tenant_slug}/demandes-conge                    - Cr√©er une demande de cong√©
# - GET  /{tenant_slug}/demandes-conge                    - Liste des demandes de cong√©
# - PUT  /{tenant_slug}/demandes-conge/{demande_id}/approuver - Approuver/Refuser une demande
# ============================================================================

# Algorithme intelligent de recherche de rempla√ßants
@api_router.post("/remplacements/{demande_id}/recherche-automatique")
async def recherche_remplacants_automatique(demande_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # R√©cup√©rer la demande de remplacement
        demande = await db.demandes_remplacement.find_one({"id": demande_id})
        if not demande:
            raise HTTPException(status_code=404, detail="Demande non trouv√©e")
        
        # R√©cup√©rer les param√®tres de remplacement
        # (selon les r√®gles d√©finies dans Param√®tres > Remplacements)
        
        # Trouver les rempla√ßants potentiels selon l'algorithme intelligent
        users = await db.users.find({"statut": "Actif"}).to_list(1000)
        type_garde = await db.types_garde.find_one({"id": demande["type_garde_id"]})
        
        remplacants_potentiels = []
        
        for user in users:
            if user["id"] == demande["demandeur_id"]:
                continue  # Skip demandeur
                
            # √âtape 1: V√©rifier disponibilit√©s (si temps partiel)
            if user.get("type_emploi", "temps_plein") == "temps_partiel":
                # Get user disponibilit√©s pour cette date exacte
                user_dispos = await db.disponibilites.find({
                    "user_id": user["id"],
                    "date": demande["date"],
                    "statut": "disponible"
                }).to_list(10)
                
                # V√©rifier si disponible pour ce type de garde sp√©cifiquement
                type_garde_compatible = any(
                    d.get("type_garde_id") == type_garde["id"] or d.get("type_garde_id") is None 
                    for d in user_dispos
                )
                
                if not type_garde_compatible:
                    continue  # Skip si pas disponible pour ce type de garde
            
            # √âtape 2: V√©rifier grade √©quivalent (si param√®tre activ√©)
            # √âtape 3: V√©rifier comp√©tences √©quivalentes (si param√®tre activ√©)
            
            remplacants_potentiels.append({
                "user_id": user["id"],
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "grade": user.get("grade", "N/A"),
                "score_compatibilite": 85  # Algorithme de scoring √† d√©velopper
            })
        
        # Trier par score de compatibilit√©
        remplacants_potentiels.sort(key=lambda x: x["score_compatibilite"], reverse=True)
        
        # Limiter selon max_personnes_contact des param√®tres
        max_contacts = 5  # √Ä r√©cup√©rer des param√®tres
        remplacants_finaux = remplacants_potentiels[:max_contacts]
        
        # Cr√©er les notifications pour les rempla√ßants potentiels
        for remplacant in remplacants_finaux:
            notification = Notification(
                tenant_id=tenant.id,
                destinataire_id=remplacant["user_id"],
                type="remplacement_disponible",
                titre="üîî Remplacement Disponible",
                message=f"Remplacement disponible le {demande['date']} - {type_garde['nom'] if type_garde else 'Garde'}",
                lien=f"/{tenant_slug}/remplacements",
                data={"demande_id": demande_id},
                statut="non_lu"
            )
            await db.notifications.insert_one(notification.dict())
        
        return {
            "message": "Recherche automatique effectu√©e",
            "remplacants_contactes": len(remplacants_finaux),
            "algorithme": "Disponibilit√©s ‚Üí Grade ‚Üí Comp√©tences ‚Üí Score compatibilit√©"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur recherche automatique: {str(e)}")

# Accepter une demande de remplacement
@api_router.post("/{tenant_slug}/remplacements/{demande_id}/accepter")
async def accepter_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    commentaire: str = Body(None, embed=True),
    current_user: User = Depends(get_current_user)
):
    """
    Un employ√© accepte une demande de remplacement
    """
    try:
        # V√©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer la demande
        demande = await db.demandes_remplacement.find_one({
            "id": demande_id,
            "tenant_id": tenant.id
        })
        
        if not demande:
            raise HTTPException(status_code=404, detail="Demande non trouv√©e")
        
        # V√©rifier que la demande est toujours en attente
        if demande["statut"] != "en_attente":
            raise HTTPException(
                status_code=400, 
                detail=f"Cette demande n'est plus disponible (statut: {demande['statut']})"
            )
        
        # V√©rifier que l'utilisateur a bien √©t√© contact√© pour cette demande
        remplacants_contactes = demande.get("remplacants_contactes", [])
        if current_user.id not in remplacants_contactes:
            raise HTTPException(
                status_code=403, 
                detail="Vous n'√™tes pas autoris√© √† accepter cette demande"
            )
        
        # Mettre √† jour le statut de la demande
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "statut": "accepte",
                    "remplacant_id": current_user.id,
                    "date_acceptation": datetime.now(timezone.utc).isoformat(),
                    "commentaire_remplacant": commentaire
                }
            }
        )
        
        # Cr√©er l'assignation dans le planning
        type_garde = await db.types_garde.find_one({"id": demande["type_garde_id"]})
        
        assignation = Assignation(
            user_id=current_user.id,
            type_garde_id=demande["type_garde_id"],
            date=demande["date"],
            statut="planifie",
            assignation_type="manuel",  # Remplacement accept√© = manuel
            tenant_id=tenant.id
        )
        
        await db.assignations.insert_one(assignation.dict())
        
        # Notifier le demandeur
        demandeur = await db.users.find_one({"id": demande["demandeur_id"]})
        notification_demandeur = Notification(
            user_id=demande["demandeur_id"],
            titre="‚úÖ Remplacement trouv√©",
            message=f"{current_user.prenom} {current_user.nom} a accept√© votre demande de remplacement pour le {demande['date']} - {type_garde['nom'] if type_garde else 'Garde'}",
            type="remplacement_accepte",
            lien=f"/{tenant_slug}/remplacements",
            tenant_id=tenant.id
        )
        await db.notifications.insert_one(notification_demandeur.dict())
        
        # Notifier les autres candidats que la demande est pourvue
        for remplacant_id in remplacants_contactes:
            if remplacant_id != current_user.id:
                notification_autres = Notification(
                    user_id=remplacant_id,
                    titre="‚ÑπÔ∏è Remplacement pourvu",
                    message=f"Le remplacement du {demande['date']} a √©t√© pourvu par un autre pompier",
                    type="remplacement_pourvu",
                    lien=f"/{tenant_slug}/remplacements",
                    tenant_id=tenant.id
                )
                await db.notifications.insert_one(notification_autres.dict())
        
        return {
            "message": "Demande accept√©e avec succ√®s",
            "demande_id": demande_id,
            "assignation_creee": True,
            "remplacant": f"{current_user.prenom} {current_user.nom}"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Erreur acceptation demande: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de l'acceptation: {str(e)}")

# Refuser une demande de remplacement
@api_router.post("/{tenant_slug}/remplacements/{demande_id}/refuser")
async def refuser_demande_remplacement(
    tenant_slug: str,
    demande_id: str,
    raison: str = Body(None, embed=True),
    current_user: User = Depends(get_current_user)
):
    """
    Un employ√© refuse une demande de remplacement
    """
    try:
        # V√©rifier le tenant
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer la demande
        demande = await db.demandes_remplacement.find_one({
            "id": demande_id,
            "tenant_id": tenant.id
        })
        
        if not demande:
            raise HTTPException(status_code=404, detail="Demande non trouv√©e")
        
        # V√©rifier que la demande est toujours en attente
        if demande["statut"] != "en_attente":
            raise HTTPException(
                status_code=400, 
                detail=f"Cette demande n'est plus disponible (statut: {demande['statut']})"
            )
        
        # V√©rifier que l'utilisateur a bien √©t√© contact√© pour cette demande
        remplacants_contactes = demande.get("remplacants_contactes", [])
        if current_user.id not in remplacants_contactes:
            raise HTTPException(
                status_code=403, 
                detail="Vous n'√™tes pas autoris√© √† refuser cette demande"
            )
        
        # Ajouter le refus √† l'historique
        historique = demande.get("historique_tentatives", [])
        historique.append({
            "user_id": current_user.id,
            "nom": f"{current_user.prenom} {current_user.nom}",
            "action": "refuse",
            "date": datetime.now(timezone.utc).isoformat(),
            "raison": raison
        })
        
        # Retirer cet utilisateur de la liste des contact√©s
        remplacants_restants = [r for r in remplacants_contactes if r != current_user.id]
        
        # Si plus personne de disponible, marquer comme expiree
        nouveau_statut = "expiree" if len(remplacants_restants) == 0 else "en_attente"
        
        await db.demandes_remplacement.update_one(
            {"id": demande_id},
            {
                "$set": {
                    "historique_tentatives": historique,
                    "remplacants_contactes": remplacants_restants,
                    "statut": nouveau_statut
                }
            }
        )
        
        # Notifier le demandeur si tous ont refus√©
        if nouveau_statut == "expiree":
            notification_demandeur = Notification(
                user_id=demande["demandeur_id"],
                titre="‚ùå Aucun rempla√ßant trouv√©",
                message=f"Malheureusement, aucun pompier n'est disponible pour votre remplacement du {demande['date']}",
                type="remplacement_expire",
                lien=f"/{tenant_slug}/remplacements",
                tenant_id=tenant.id
            )
            await db.notifications.insert_one(notification_demandeur.dict())
        
        return {
            "message": "Demande refus√©e",
            "demande_id": demande_id,
            "remplacants_restants": len(remplacants_restants),
            "statut": nouveau_statut
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Erreur refus demande: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors du refus: {str(e)}")

# Rapports et exports routes
@api_router.get("/rapports/export-pdf")
async def export_pdf_report(type_rapport: str = "general", user_id: str = None, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []
        
        # En-t√™te du rapport
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#dc2626')
        )
        
        story.append(Paragraph("ProFireManager v2.0 - Rapport d'Activit√©", title_style))
        story.append(Spacer(1, 12))
        
        if type_rapport == "general":
            # Rapport g√©n√©ral
            story.append(Paragraph("üìä Statistiques G√©n√©rales", styles['Heading2']))
            
            # R√©cup√©rer les donn√©es
            users = await db.users.find({"statut": "Actif"}).to_list(1000)
            assignations = await db.assignations.find().to_list(1000)
            formations = await db.formations.find().to_list(1000)
            
            data = [
                ['Indicateur', 'Valeur'],
                ['Personnel actif', str(len(users))],
                ['Assignations totales', str(len(assignations))],
                ['Formations disponibles', str(len(formations))],
                ['Employ√©s temps plein', str(len([u for u in users if u.get('type_emploi') == 'temps_plein']))],
                ['Employ√©s temps partiel', str(len([u for u in users if u.get('type_emploi') == 'temps_partiel']))],
            ]
            
            table = Table(data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 14),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            story.append(table)
            
        elif type_rapport == "employe" and user_id:
            # Rapport par employ√©
            user_data = await db.users.find_one({"id": user_id})
            if user_data:
                story.append(Paragraph(f"üë§ Rapport Personnel - {user_data['prenom']} {user_data['nom']}", styles['Heading2']))
                
                user_assignations = await db.assignations.find({"user_id": user_id}).to_list(1000)
                
                data = [
                    ['Information', 'D√©tail'],
                    ['Nom complet', f"{user_data.get('prenom', '')} {user_data.get('nom', '')}"],
                    ['Grade', user_data.get('grade', 'N/A')],
                    ['Type emploi', user_data.get('type_emploi', 'N/A')],
                    ['Gardes assign√©es', str(len(user_assignations))],
                    ['Statut', user_data.get('statut', 'N/A')]
                ]
                
                table = Table(data)
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#dc2626')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                
                story.append(table)
        
        doc.build(story)
        pdf_data = buffer.getvalue()
        buffer.close()
        
        # Retourner en base64 pour le frontend
        pdf_base64 = base64.b64encode(pdf_data).decode('utf-8')
        
        return {
            "message": "Rapport PDF g√©n√©r√© avec succ√®s",
            "filename": f"rapport_{type_rapport}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
            "data": pdf_base64
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur g√©n√©ration PDF: {str(e)}")

@api_router.get("/rapports/export-excel")
async def export_excel_report(type_rapport: str = "general", current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        wb = Workbook()
        ws = wb.active
        
        # Style de l'en-t√™te
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="DC2626", end_color="DC2626", fill_type="solid")
        
        if type_rapport == "general":
            ws.title = "Rapport G√©n√©ral"
            
            # En-t√™te
            headers = ["Indicateur", "Valeur", "D√©tails"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = Alignment(horizontal="center")
            
            # Donn√©es
            users = await db.users.find({"statut": "Actif"}).to_list(1000)
            assignations = await db.assignations.find().to_list(1000)
            
            data_rows = [
                ["Personnel Total", len(users), f"{len([u for u in users if u.get('type_emploi') == 'temps_plein'])} temps plein, {len([u for u in users if u.get('type_emploi') == 'temps_partiel'])} temps partiel"],
                ["Assignations", len(assignations), f"P√©riode: {datetime.now().strftime('%B %Y')}"],
                ["Taux Activit√©", "85%", "Personnel actif vs total"],
            ]
            
            for row, (indicateur, valeur, details) in enumerate(data_rows, 2):
                ws.cell(row=row, column=1, value=indicateur)
                ws.cell(row=row, column=2, value=valeur)
                ws.cell(row=row, column=3, value=details)
        
        # Sauvegarder en m√©moire
        buffer = BytesIO()
        wb.save(buffer)
        excel_data = buffer.getvalue()
        buffer.close()
        
        # Retourner en base64
        excel_base64 = base64.b64encode(excel_data).decode('utf-8')
        
        return {
            "message": "Rapport Excel g√©n√©r√© avec succ√®s",
            "filename": f"rapport_{type_rapport}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
            "data": excel_base64
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur g√©n√©ration Excel: {str(e)}")

@api_router.get("/{tenant_slug}/rapports/statistiques-avancees")
async def get_statistiques_avancees(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # R√©cup√©rer toutes les donn√©es n√©cessaires filtr√©es par tenant
        users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
        assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        formations = await db.formations.find({"tenant_id": tenant.id}).to_list(1000)
        demandes_remplacement = await db.demandes_remplacement.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Statistiques g√©n√©rales
        stats_generales = {
            "personnel_total": len(users),
            "personnel_actif": len([u for u in users if u.get("statut") == "Actif"]),
            "assignations_mois": len(assignations),
            "taux_couverture": 94.5,  # Calcul √† am√©liorer
            "formations_disponibles": len(formations),
            "remplacements_demandes": len(demandes_remplacement)
        }
        
        # Statistiques par r√¥le
        stats_par_role = {}
        for role in ["admin", "superviseur", "employe"]:
            users_role = [u for u in users if u.get("role") == role]
            assignations_role = [a for a in assignations if any(u["id"] == a["user_id"] and u.get("role") == role for u in users)]
            
            stats_par_role[role] = {
                "nombre_utilisateurs": len(users_role),
                "assignations_totales": len(assignations_role),
                "heures_moyennes": len(assignations_role) * 8,  # Estimation
                "formations_completees": sum(len(u.get("formations", [])) for u in users_role)
            }
        
        # Statistiques par employ√© (pour export individuel)
        stats_par_employe = []
        for user in users:
            user_assignations = [a for a in assignations if a["user_id"] == user["id"]]
            user_disponibilites = await db.disponibilites.find({"user_id": user["id"], "tenant_id": tenant.id}).to_list(100)
            
            stats_par_employe.append({
                "id": user["id"],
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "grade": user.get("grade", "N/A"),
                "role": user.get("role", "pompier"),
                "type_emploi": user.get("type_emploi", "temps_plein"),
                "assignations_count": len(user_assignations),
                "disponibilites_count": len(user_disponibilites),
                "formations_count": len(user.get("formations", [])),
                "heures_estimees": len(user_assignations) * 8
            })
        
        return {
            "statistiques_generales": stats_generales,
            "statistiques_par_role": stats_par_role,
            "statistiques_par_employe": stats_par_employe,
            "periode": datetime.now().strftime("%B %Y"),
            "date_generation": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur calcul statistiques: {str(e)}")


# ====================================================================
# MODULE RAPPORTS AVANC√âS - INTERNES ET EXTERNES
# ====================================================================

# Mod√®les pour les nouvelles donn√©es

class Budget(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    annee: int
    categorie: str  # salaires, formations, equipements, carburant, entretien, autres
    budget_alloue: float
    budget_consomme: float = 0.0
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BudgetCreate(BaseModel):
    annee: int
    categorie: str
    budget_alloue: float
    notes: str = ""

class Immobilisation(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    type_immobilisation: str  # vehicule, equipement_majeur
    nom: str
    date_acquisition: str  # YYYY-MM-DD
    cout_acquisition: float
    cout_entretien_annuel: float = 0.0
    etat: str = "bon"  # bon, moyen, mauvais
    date_remplacement_prevue: Optional[str] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ImmobilisationCreate(BaseModel):
    type_immobilisation: str
    nom: str
    date_acquisition: str
    cout_acquisition: float
    cout_entretien_annuel: float = 0.0
    etat: str = "bon"
    date_remplacement_prevue: Optional[str] = None
    notes: str = ""

class ProjetTriennal(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    description: str
    type_projet: str  # acquisition, renovation, recrutement
    annee_prevue: int
    cout_estime: float
    statut: str = "prevu"  # prevu, en_cours, termine, annule
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ProjetTriennalCreate(BaseModel):
    nom: str
    description: str
    type_projet: str
    annee_prevue: int
    cout_estime: float
    statut: str = "prevu"

class Intervention(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    date_intervention: str
    type_intervention: str  # incendie, medical, sauvetage, autre
    duree_minutes: int
    nombre_pompiers: int
    temps_reponse_minutes: Optional[int] = None
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InterventionCreate(BaseModel):
    date_intervention: str
    type_intervention: str
    duree_minutes: int
    nombre_pompiers: int
    temps_reponse_minutes: Optional[int] = None
    notes: str = ""


# ====== MOD√àLES POUR LE DASHBOARD ======

class MessageImportant(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    titre: str
    contenu: str
    priorite: str  # info, important, urgent
    date_expiration: Optional[str] = None
    auteur_id: str
    auteur_nom: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MessageImportantCreate(BaseModel):
    titre: str
    contenu: str
    priorite: str = "info"
    date_expiration: Optional[str] = None

class Activite(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    type_activite: str  # creation_personnel, assignation, formation, remplacement, etc.
    description: str
    user_id: Optional[str] = None
    user_nom: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


# ==================== PR√âVENTION MODELS ====================

class Batiment(BaseModel):
    """Fiche d'√©tablissement/b√¢timent pour les inspections de pr√©vention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    
    # Informations g√©n√©rales
    nom_etablissement: str = ""
    adresse_civique: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    cadastre_matricule: str = ""  # Renomm√© de numero_lot_cadastre
    valeur_fonciere: Optional[str] = ""  # String car peut √™tre vide
    
    # Informations sur le b√¢timent
    type_batiment: str = ""
    sous_type_batiment: str = ""
    annee_construction: str = ""
    nombre_etages: str = ""
    superficie_totale_m2: str = ""
    
    # Contacts - Propri√©taire
    proprietaire_nom: str = ""
    proprietaire_prenom: str = ""
    proprietaire_telephone: str = ""
    proprietaire_courriel: str = ""
    
    # Contacts - G√©rant/Gestionnaire
    gerant_nom: str = ""
    gerant_telephone: str = ""
    gerant_courriel: str = ""
    gestionnaire_nom: str = ""  # Alias pour compatibilit√© frontend
    gestionnaire_prenom: str = ""
    gestionnaire_telephone: str = ""
    gestionnaire_courriel: str = ""
    
    # Contacts - Locataire
    localaire_nom: str = ""  # Orthographe originale conserv√©e
    localaire_prenom: str = ""
    localaire_telephone: str = ""
    localaire_courriel: str = ""
    locataire_nom: str = ""  # Alias pour compatibilit√© frontend
    locataire_prenom: str = ""
    locataire_telephone: str = ""
    locataire_courriel: str = ""
    
    # Contacts - Responsable s√©curit√©
    responsable_securite_nom: str = ""
    responsable_securite_telephone: str = ""
    responsable_securite_courriel: str = ""
    
    # Classification selon Code national de pr√©vention des incendies - Canada 2020
    groupe_occupation: str = ""  # A, B, C, D, E, F, G, I
    sous_groupe: str = ""  # A-1, A-2, B-1, F-1, F-2, F-3, etc.
    description_activite: str = ""
    niveau_risque: str = ""  # Faible, Moyen, √âlev√©, Tr√®s √©lev√© (selon Tableau A1)
    
    # Risques
    risques: List[str] = []
    risques_identifes: List[str] = []  # Orthographe originale conserv√©e
    risques_identifies: List[str] = []  # Alias pour compatibilit√© frontend
    
    # G√©olocalisation
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    
    # Photo
    photo_url: Optional[str] = ""  # URL ou base64 de la photo du b√¢timent
    
    # M√©tadonn√©es
    statut: str = "actif"  # actif, inactif, demolition
    notes_generales: str = ""
    notes: str = ""  # Alias pour compatibilit√© frontend
    preventionniste_assigne_id: Optional[str] = None  # ID de l'employ√© pr√©ventionniste
    historique_assignations: List[Dict[str, Any]] = []  # Historique des changements de pr√©ventionniste
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BatimentCreate(BaseModel):
    nom_etablissement: str = ""
    adresse_civique: str = ""
    ville: str = ""
    province: str = "QC"
    code_postal: str = ""
    cadastre_matricule: str = ""
    valeur_fonciere: Optional[str] = ""  # String car peut √™tre vide
    
    # Informations sur le b√¢timent
    type_batiment: str = ""
    sous_type_batiment: str = ""
    annee_construction: str = ""
    nombre_etages: str = ""
    superficie_totale_m2: str = ""
    
    # Contacts - Propri√©taire
    proprietaire_nom: str = ""
    proprietaire_prenom: str = ""
    proprietaire_telephone: str = ""
    proprietaire_courriel: str = ""
    
    # Contacts - G√©rant/Gestionnaire
    gerant_nom: str = ""
    gerant_telephone: str = ""
    gerant_courriel: str = ""
    gestionnaire_nom: str = ""  # Alias pour compatibilit√© frontend
    gestionnaire_prenom: str = ""
    gestionnaire_telephone: str = ""
    gestionnaire_courriel: str = ""
    
    # Contacts - Locataire
    localaire_nom: str = ""  # Orthographe originale conserv√©e
    localaire_prenom: str = ""
    localaire_telephone: str = ""
    localaire_courriel: str = ""
    locataire_nom: str = ""  # Alias pour compatibilit√© frontend
    locataire_prenom: str = ""
    locataire_telephone: str = ""
    locataire_courriel: str = ""
    
    # Contacts - Responsable s√©curit√©
    responsable_securite_nom: str = ""
    responsable_securite_telephone: str = ""
    responsable_securite_courriel: str = ""
    
    # Classification
    groupe_occupation: str = ""
    sous_groupe: str = ""
    description_activite: str = ""
    niveau_risque: str = ""
    
    # Risques
    risques: List[str] = []
    risques_identifes: List[str] = []  # Orthographe originale conserv√©e
    risques_identifies: List[str] = []  # Alias pour compatibilit√© frontend
    
    # G√©olocalisation
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    
    # Photo
    photo_url: Optional[str] = ""
    
    # M√©tadonn√©es
    statut: str = "actif"
    notes_generales: str = ""
    notes: str = ""  # Alias pour compatibilit√© frontend
    preventionniste_assigne_id: Optional[str] = None
    
    class Config:
        extra = "ignore"  # Ignorer les champs suppl√©mentaires

class SecteurGeographique(BaseModel):
    """Secteur g√©ographique pour l'assignation des pr√©ventionnistes"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    
    # Informations du secteur
    nom: str  # Ex: "Secteur Nord", "Zone industrielle Est"
    description: str = ""
    couleur: str = "#3b82f6"  # Couleur d'affichage sur la carte (hex)
    
    # G√©om√©trie (polygone GeoJSON)
    geometry: Dict[str, Any]  # Format GeoJSON: {"type": "Polygon", "coordinates": [[[lng, lat], ...]]}
    
    # Assignation
    preventionniste_assigne_id: Optional[str] = None  # ID de l'employ√© pr√©ventionniste
    
    # M√©tadonn√©es
    actif: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SecteurGeographiqueCreate(BaseModel):
    """Mod√®le pour la cr√©ation d'un secteur g√©ographique"""
    nom: str
    description: str = ""
    couleur: str = "#3b82f6"
    geometry: Dict[str, Any]
    preventionniste_assigne_id: Optional[str] = None
    actif: bool = True
    
    class Config:
        extra = "ignore"

class SymbolePersonnalise(BaseModel):
    """Symbole personnalis√© pour les plans d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Borne-fontaine personnalis√©e"
    categorie: str = "Personnalis√©"  # Cat√©gorie du symbole
    image_base64: str  # Image en base64
    couleur: str = "#3b82f6"  # Couleur de bordure dans la palette
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    created_by: str  # ID de l'utilisateur qui a cr√©√©

class SymbolePersonnaliseCreate(BaseModel):
    """Mod√®le pour la cr√©ation d'un symbole personnalis√©"""
    nom: str
    categorie: str = "Personnalis√©"
    image_base64: str
    couleur: str = "#3b82f6"
    
    class Config:
        extra = "ignore"


class GrilleInspection(BaseModel):
    """Template de grille d'inspection selon le groupe d'occupation"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "Grille Groupe C - R√©sidentiel"
    groupe_occupation: str  # C, E, F, I, etc.
    sections: List[Dict[str, Any]] = []  # Structure JSON des sections et questions
    actif: bool = True
    version: str = "1.0"
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class GrilleInspectionCreate(BaseModel):
    nom: str
    groupe_occupation: str
    sections: List[Dict[str, Any]] = []
    actif: bool = True
    version: str = "1.0"

class Inspection(BaseModel):
    """Inspection r√©alis√©e sur un b√¢timent"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    batiment_id: str
    grille_inspection_id: str
    preventionniste_id: str  # ID de l'employ√© qui a fait l'inspection
    
    # M√©tadonn√©es inspection
    date_inspection: str = ""  # YYYY-MM-DD
    heure_debut: str = ""
    heure_fin: str = ""
    type_inspection: str = "reguliere"  # reguliere, suivi, urgence, plainte
    
    # R√©sultats
    resultats: Dict[str, Any] = {}  # R√©ponses JSON de la grille
    statut_global: str = "conforme"  # conforme, non_conforme, partiellement_conforme
    score_conformite: float = 100.0  # Pourcentage de conformit√©
    
    # Documentation
    photos: List[str] = []  # URLs des photos
    notes_inspection: str = ""
    recommandations: str = ""
    
    # Signature et validation
    signature_proprietaire: Optional[str] = None  # Signature num√©rique base64
    nom_representant: str = ""
    rapport_pdf_url: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionCreate(BaseModel):
    batiment_id: str
    grille_inspection_id: str
    preventionniste_id: str
    date_inspection: str
    heure_debut: str = ""
    heure_fin: str = ""
    type_inspection: str = "reguliere"
    resultats: Dict[str, Any] = {}
    statut_global: str = "conforme"
    score_conformite: float = 100.0
    photos: List[str] = []
    notes_inspection: str = ""
    recommandations: str = ""
    signature_proprietaire: Optional[str] = None
    nom_representant: str = ""

class NonConformite(BaseModel):
    """Non-conformit√© identifi√©e lors d'une inspection"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    inspection_id: str
    batiment_id: str
    
    # Description de la non-conformit√©
    titre: str = ""
    description: str = ""
    section_grille: str = ""  # Section de la grille o√π elle a √©t√© identifi√©e
    gravite: str = "moyen"  # faible, moyen, eleve, critique
    article_code: str = ""  # Article du code de s√©curit√©
    
    # Suivi
    statut: str = "ouverte"  # ouverte, en_cours, corrigee, fermee
    delai_correction: Optional[str] = None  # Date limite YYYY-MM-DD
    date_correction: Optional[str] = None
    notes_correction: str = ""
    
    # Documentation
    photos_avant: List[str] = []
    photos_apres: List[str] = []
    
    # Responsabilit√©
    responsable_correction: str = ""  # Propri√©taire/Gestionnaire
    preventionniste_suivi_id: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class NonConformiteCreate(BaseModel):
    inspection_id: str
    batiment_id: str
    titre: str
    description: str = ""
    section_grille: str = ""
    gravite: str = "moyen"
    article_code: str = ""
    delai_correction: Optional[str] = None
    photos_avant: List[str] = []
    responsable_correction: str = ""
    preventionniste_suivi_id: Optional[str] = None


# ==================== MOD√àLES √âTENDUS POUR INSPECTIONS VISUELLES ====================

class PhotoInspection(BaseModel):
    """Photo prise lors d'une inspection"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    url: str  # URL de stockage de la photo
    categorie: str = ""  # Ex: "Preuve accroche porte", "Adresse non visible", "Mati√®res dangereuses"
    secteur: Optional[str] = None  # Secteur 1, 2, 3, 4, 5 selon sch√©ma
    cadran: Optional[str] = None  # Cadran A, B, C, D (subdivision du Secteur 1)
    description: str = ""
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ParticipantInspection(BaseModel):
    """Participant √† une inspection (pompier ou pr√©ventionniste)"""
    user_id: str
    nom_complet: str
    role: str  # "pompier" ou "preventionniste"
    est_principal: bool = False  # Le pompier connect√© qui cr√©e l'inspection

class InspectionVisuelle(BaseModel):
    """Inspection visuelle compl√®te pour tablette/mobile"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    batiment_id: str
    
    # Participants
    participants: List[ParticipantInspection] = []
    
    # Timing
    date_inspection: str = ""  # YYYY-MM-DD
    heure_debut: Optional[str] = None
    heure_fin: Optional[str] = None
    duree_minutes: Optional[int] = None
    
    # G√©olocalisation (capture automatique)
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    
    # Photos cat√©goris√©es
    photos: List[PhotoInspection] = []
    
    # Non-conformit√©s d√©taill√©es
    non_conformites_ids: List[str] = []  # R√©f√©rences aux NonConformite
    
    # Checklist dynamique selon type de b√¢timent
    checklist_reponses: Dict[str, Any] = {}
    
    # Statuts
    statut: str = "en_cours"  # en_cours, validee, non_conforme, suivi_requis
    statut_conformite: str = "conforme"  # conforme, non_conforme, partiellement_conforme
    
    # Plan d'intervention
    plan_intervention_url: Optional[str] = None  # URL du PDF du plan
    
    # Notes
    notes_terrain: str = ""
    recommandations: str = ""
    
    # Validation (modifiable en tout temps)
    validee_par_id: Optional[str] = None
    date_validation: Optional[datetime] = None
    
    # Mode hors-ligne
    sync_status: str = "synced"  # synced, pending, offline
    
    # M√©tadonn√©es
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionVisuelleCreate(BaseModel):
    batiment_id: str
    participants: List[ParticipantInspection]
    date_inspection: str
    heure_debut: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    notes_terrain: str = ""

class InspectionVisuelleUpdate(BaseModel):
    participants: Optional[List[ParticipantInspection]] = None
    heure_fin: Optional[str] = None
    photos: Optional[List[PhotoInspection]] = None
    checklist_reponses: Optional[Dict[str, Any]] = None
    statut: Optional[str] = None
    statut_conformite: Optional[str] = None
    notes_terrain: Optional[str] = None
    recommandations: Optional[str] = None
    validee_par_id: Optional[str] = None

class NonConformiteVisuelle(BaseModel):
    """Non-conformit√© avec photos et gravit√© d√©taill√©e"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    inspection_id: str
    batiment_id: str
    
    # Description
    titre: str
    description: str = ""
    gravite: str = "mineur"  # mineur, majeur, critique
    
    # Articles et d√©lais
    article_municipal: str = ""  # Ex: "Article 45.2"
    delai_correction_jours: Optional[int] = None
    date_limite: Optional[str] = None  # YYYY-MM-DD
    
    # Photos
    photos_nc: List[PhotoInspection] = []  # Photos de la non-conformit√©
    photos_resolution: List[PhotoInspection] = []  # Photos apr√®s correction
    
    # Statut
    statut: str = "nouvelle"  # nouvelle, en_cours, resolue
    date_resolution: Optional[datetime] = None
    notes_resolution: str = ""
    
    # Suivi
    responsable_correction: str = ""  # Nom propri√©taire/gestionnaire
    preventionniste_suivi_id: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class NonConformiteVisuelleCreate(BaseModel):
    inspection_id: str
    batiment_id: str
    titre: str
    description: str = ""
    gravite: str = "mineur"
    article_municipal: str = ""
    delai_correction_jours: Optional[int] = None
    photos_nc: List[PhotoInspection] = []
    responsable_correction: str = ""

class BatimentMapView(BaseModel):
    """Vue simplifi√©e pour affichage sur carte"""
    id: str
    nom_etablissement: str
    adresse_civique: str
    ville: str
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    niveau_risque: str
    statut_inspection: str  # "fait_conforme", "a_faire", "non_conforme", "en_cours"
    derniere_inspection: Optional[str] = None  # Date ISO
    groupe_occupation: str
    sous_groupe: str

class GeocodeRequest(BaseModel):
    """Requ√™te de g√©ocodage d'adresse"""
    adresse_complete: str

class GeocodeResponse(BaseModel):
    """R√©ponse de g√©ocodage"""
    latitude: float
    longitude: float
    adresse_formatee: str
    precision: str  # "building", "street", "city"


# ==================== MOD√àLES PLANS D'INTERVENTION ====================

class ElementPlanBase(BaseModel):
    """Classe de base pour tous les √©l√©ments d'un plan d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type_element: str  # hydrant, sortie, matiere_dangereuse, generatrice, gaz_naturel, reservoir_propane, vehicule
    latitude: float
    longitude: float
    numero: Optional[str] = None  # Ex: H1, S1, MD1 (auto-g√©n√©r√©)
    notes: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class HydrantElement(ElementPlanBase):
    """Hydrant sur le plan"""
    type_element: str = "hydrant"
    type_hydrant: str  # borne_fontaine, borne_seche, aspiration
    debit: float  # D√©bit
    unite_debit: str = "gal/min"  # gal/min ou L/min
    couleur_indicateur: Optional[str] = None  # Rouge, jaune, vert selon d√©bit

class SortieElement(ElementPlanBase):
    """Sortie d'urgence sur le plan"""
    type_element: str = "sortie"
    type_sortie: str  # urgence, principale, secondaire
    largeur_m: Optional[float] = None
    acces_fauteuil: bool = False
    eclairage_secours: bool = False

class MatiereDangereuse(ElementPlanBase):
    """Mati√®re dangereuse pr√©sente"""
    type_element: str = "matiere_dangereuse"
    nom_produit: str
    pictogramme_simdut: str  # URL ou code du pictogramme
    quantite: Optional[float] = None
    unite_quantite: str = "L"  # L, kg, m¬≥
    classe_danger: str = ""  # Ex: "Inflammable", "Toxique", "Corrosif"

class GeneratriceElement(ElementPlanBase):
    """G√©n√©ratrice d'urgence"""
    type_element: str = "generatrice"
    puissance_kw: Optional[float] = None
    emplacement_commutateur: str = ""
    type_carburant: str = ""  # diesel, essence, gaz naturel

class GazNaturelElement(ElementPlanBase):
    """Entr√©e de gaz naturel"""
    type_element: str = "gaz_naturel"
    emplacement_vanne_coupure: str
    accessible_exterieur: bool = True

class ReservoirPropaneElement(ElementPlanBase):
    """R√©servoir de propane"""
    type_element: str = "reservoir_propane"
    capacite: float
    unite_capacite: str = "gallons"  # gallons ou litres
    emplacement_vanne: str
    type_reservoir: str = ""  # aerien, enterre

class VehiculeElement(ElementPlanBase):
    """Position recommand√©e pour v√©hicules d'intervention"""
    type_element: str = "vehicule"
    type_vehicule: str  # echelle, pompe, citerne
    position_recommandee: str  # Ex: "Face fa√ßade nord", "Cour arri√®re"
    notes_stationnement: str = ""

class RouteAcces(BaseModel):
    """Route d'acc√®s au b√¢timent"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str = "Route principale"
    chemin_polyline: List[Dict[str, float]] = []  # Liste de {lat, lng}
    largeur_m: Optional[float] = None
    pente: Optional[str] = None  # faible, moyenne, forte
    notes: str = ""
    est_principale: bool = True

class ZoneDanger(BaseModel):
    """Zone de danger ou p√©rim√®tre d'√©vacuation"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nom: str
    type_zone: str  # perimetre_evacuation, zone_chaude, zone_tiede, zone_froide
    polygone: List[Dict[str, float]] = []  # Liste de {lat, lng}
    couleur: str = "#ff0000"  # Hex color
    opacite: float = 0.3
    rayon_m: Optional[float] = None
    description: str = ""

class SecteurPlan(BaseModel):
    """Secteur du b√¢timent (m√™me syst√®me que photos inspection)"""
    numero: int  # 1, 2, 3, 4, 5
    cadran: Optional[str] = None  # A, B, C, D (subdivision secteur 1)
    description: str = ""
    elements_ids: List[str] = []  # IDs des √©l√©ments dans ce secteur

class PlanEtage(BaseModel):
    """Plan d'un √©tage int√©rieur"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    numero_etage: int  # -1 (sous-sol), 0 (RDC), 1, 2, 3...
    nom: str  # "Rez-de-chauss√©e", "1er √©tage", "Sous-sol"
    image_url: Optional[str] = None  # Image du plan d'√©tage
    annotations: List[Dict[str, Any]] = []  # Annotations sur le plan
    elements_interieurs: List[Dict[str, Any]] = []  # Escaliers, ascenseurs, etc.

class PhotoPlanIntervention(BaseModel):
    """Photo attach√©e au plan d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    url: str
    latitude: float = 0.0
    longitude: float = 0.0
    titre: str = ""
    description: str = ""
    localisation: str = ""  # Localisation textuelle dans le b√¢timent (ex: "Entr√©e principale", "2e √©tage - c√¥t√© est")
    categorie: str = ""  # facade, entree, systeme_alarme, points_eau, risques, autre
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class IconePersonnalisee(BaseModel):
    """Ic√¥ne personnalis√©e pour les plans d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str
    image_base64: str  # Image encod√©e en base64
    categorie: str  # hydrants, sorties, matieres_dangereuses, generateurs, gaz_naturel, propane, vehicules, autre
    created_by_id: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class IconePersonnaliseeCreate(BaseModel):
    """Cr√©ation d'une ic√¥ne personnalis√©e"""
    nom: str
    image_base64: str
    categorie: str

class PlanIntervention(BaseModel):
    """Plan d'intervention complet"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    batiment_id: str
    
    # Identification
    numero_plan: str  # Ex: "PI-2025-001"
    nom: str = ""
    
    # Versioning
    version: str = "1.0"
    version_precedente_id: Optional[str] = None
    
    # Statut et workflow
    statut: str = "brouillon"  # brouillon, en_attente_validation, valide, archive, rejete
    created_by_id: str  # ID du pr√©ventionniste cr√©ateur
    validated_by_id: Optional[str] = None  # ID admin/superviseur qui valide
    date_validation: Optional[datetime] = None
    commentaires_validation: str = ""
    commentaires_rejet: str = ""
    
    # √âl√©ments du plan
    hydrants: List[HydrantElement] = []
    sorties: List[SortieElement] = []
    matieres_dangereuses: List[MatiereDangereuse] = []
    generatrices: List[GeneratriceElement] = []
    gaz_naturel: List[GazNaturelElement] = []
    reservoirs_propane: List[ReservoirPropaneElement] = []
    vehicules: List[VehiculeElement] = []
    
    # Structure spatiale
    routes_acces: List[RouteAcces] = []
    zones_danger: List[ZoneDanger] = []
    secteurs: List[SecteurPlan] = []
    plans_etages: List[PlanEtage] = []
    photos: List[PhotoPlanIntervention] = []
    
    # Layers GeoJSON pour le plan interactif (depuis le builder)
    layers: List[Dict[str, Any]] = []
    
    # Vue a√©rienne
    centre_lat: float
    centre_lng: float
    zoom_level: int = 18
    vue_aerienne_url: Optional[str] = None  # Google Static Map URL
    carte_image: Optional[str] = None  # Capture d'√©cran de la carte en base64
    predefined_symbol_overrides: Dict[str, Any] = {}  # Modifications des ic√¥nes pr√©d√©finies
    
    # Calculs automatiques
    distance_caserne_km: Optional[float] = None
    distance_caserne_unite: str = "km"  # km ou m
    temps_acces_minutes: Optional[int] = None
    
    # Documentation
    notes_generales: str = ""
    instructions_particulieres: str = ""
    
    # Export
    pdf_url: Optional[str] = None
    date_derniere_maj: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    # M√©tadonn√©es
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class PlanInterventionCreate(BaseModel):
    batiment_id: str
    nom: str = ""
    centre_lat: float
    centre_lng: float
    notes_generales: str = ""
    
    # Champs optionnels pour permettre la sauvegarde depuis le builder
    layers: List[Dict[str, Any]] = Field(default_factory=list)
    hydrants: List[HydrantElement] = Field(default_factory=list)
    sorties: List[SortieElement] = Field(default_factory=list)
    matieres_dangereuses: List[MatiereDangereuse] = Field(default_factory=list)
    generatrices: List[GeneratriceElement] = Field(default_factory=list)
    gaz_naturel: List[GazNaturelElement] = Field(default_factory=list)
    reservoirs_propane: List[ReservoirPropaneElement] = Field(default_factory=list)
    vehicules: List[VehiculeElement] = Field(default_factory=list)
    routes_acces: List[RouteAcces] = Field(default_factory=list)
    zones_danger: List[ZoneDanger] = Field(default_factory=list)
    secteurs: List[SecteurPlan] = Field(default_factory=list)
    plans_etages: List[PlanEtage] = Field(default_factory=list)
    photos: List[PhotoPlanIntervention] = Field(default_factory=list)
    instructions_particulieres: str = ""
    carte_image: Optional[str] = None  # Capture d'√©cran de la carte en base64
    predefined_symbol_overrides: Dict[str, Any] = Field(default_factory=dict)  # Modifications des ic√¥nes pr√©d√©finies

class PlanInterventionUpdate(BaseModel):
    nom: Optional[str] = None
    statut: Optional[str] = None  # Permettre la mise √† jour du statut (pour repasser rejete -> brouillon)
    layers: Optional[List[Dict[str, Any]]] = None  # Layers GeoJSON du builder
    hydrants: Optional[List[HydrantElement]] = None
    sorties: Optional[List[SortieElement]] = None
    matieres_dangereuses: Optional[List[MatiereDangereuse]] = None
    generatrices: Optional[List[GeneratriceElement]] = None
    gaz_naturel: Optional[List[GazNaturelElement]] = None
    reservoirs_propane: Optional[List[ReservoirPropaneElement]] = None
    vehicules: Optional[List[VehiculeElement]] = None
    routes_acces: Optional[List[RouteAcces]] = None
    zones_danger: Optional[List[ZoneDanger]] = None
    secteurs: Optional[List[SecteurPlan]] = None
    plans_etages: Optional[List[PlanEtage]] = None
    photos: Optional[List[PhotoPlanIntervention]] = None
    notes_generales: Optional[str] = None
    instructions_particulieres: Optional[str] = None
    carte_image: Optional[str] = None  # Capture d'√©cran de la carte en base64
    predefined_symbol_overrides: Optional[Dict[str, Any]] = None  # Modifications des ic√¥nes pr√©d√©finies

class TemplatePlanIntervention(BaseModel):
    """Template pr√©-d√©fini de plan d'intervention"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    nom: str  # Ex: "R√©sidentiel unifamilial", "Commercial petit", "Industriel F-1"
    type_batiment: str  # residentiel, commercial, industriel
    groupe_occupation: str  # A, B, C, D, E, F, G, I
    sous_groupe: Optional[str] = None  # F-1, F-2, F-3, etc.
    
    # √âl√©ments pr√©-configur√©s (positions relatives)
    hydrants_defaut: List[Dict[str, Any]] = []
    sorties_defaut: List[Dict[str, Any]] = []
    vehicules_defaut: List[Dict[str, Any]] = []
    
    # Instructions
    instructions_utilisation: str = ""
    
    actif: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ValidationRequest(BaseModel):
    """Requ√™te de validation de plan"""
    commentaires: str = ""

class RejectionRequest(BaseModel):
    """Requ√™te de rejet de plan"""
    commentaires_rejet: str





# ====== ENDPOINTS CRUD POUR LES NOUVELLES DONN√âES ======

# BUDGETS
@api_router.post("/{tenant_slug}/rapports/budgets")
async def create_budget(tenant_slug: str, budget: BudgetCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    budget_dict = budget.dict()
    budget_dict["tenant_id"] = tenant.id
    budget_obj = Budget(**budget_dict)
    await db.budgets.insert_one(budget_obj.dict())
    return clean_mongo_doc(budget_obj.dict())

@api_router.post("/{tenant_slug}/rapports/import-csv")
async def import_rapports_csv(
    tenant_slug: str,
    rapports_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse de budgets et d√©penses depuis un CSV"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    items = rapports_data.get("items", [])
    if not items:
        raise HTTPException(status_code=400, detail="Aucun √©l√©ment √† importer")
    
    results = {
        "total": len(items),
        "created_budgets": 0,
        "created_depenses": 0,
        "updated": 0,
        "errors": [],
        "duplicates": []
    }
    
    for index, item_data in enumerate(items):
        try:
            # Validation des champs obligatoires
            if not item_data.get("date") or not item_data.get("description") or not item_data.get("montant"):
                results["errors"].append({
                    "line": index + 1,
                    "error": "Date, Description et Montant sont requis",
                    "data": item_data
                })
                continue
            
            # D√©terminer le type (budget ou d√©pense)
            item_type = item_data.get("type", "depense").lower()
            if item_type not in ["budget", "depense", "d√©pense"]:
                results["errors"].append({
                    "line": index + 1,
                    "error": f"Type invalide: {item_type}. Doit √™tre 'budget' ou 'depense'",
                    "data": item_data
                })
                continue
            
            # Normaliser le type
            if item_type in ["d√©pense", "depense"]:
                item_type = "depense"
            
            # V√©rifier si l'√©l√©ment existe d√©j√† (par date + description + montant)
            collection = db.budgets if item_type == "budget" else db.depenses
            
            # Cr√©er une date comparable
            date_str = item_data["date"]
            if isinstance(date_str, str):
                try:
                    # Essayer diff√©rents formats de date
                    from dateutil import parser
                    parsed_date = parser.parse(date_str)
                    date_comparable = parsed_date.strftime("%Y-%m-%d")
                except:
                    date_comparable = date_str
            else:
                date_comparable = date_str
            
            existing_item = await collection.find_one({
                "tenant_id": tenant.id,
                "date": date_comparable,
                "description": item_data["description"],
                "montant": float(item_data["montant"])
            })
            
            if existing_item:
                results["duplicates"].append({
                    "line": index + 1,
                    "type": item_type,
                    "date": date_comparable,
                    "description": item_data["description"],
                    "montant": item_data["montant"],
                    "action": item_data.get("action_doublon", "skip"),
                    "data": item_data
                })
                
                # Si action_doublon = update, mettre √† jour
                if item_data.get("action_doublon") == "update":
                    update_data = {
                        "description": item_data["description"],
                        "montant": float(item_data["montant"]),
                        "categorie": item_data.get("categorie", ""),
                        "numero_reference": item_data.get("numero_reference", ""),
                        "fournisseur": item_data.get("fournisseur", ""),
                        "compte_budgetaire": item_data.get("compte_budgetaire", ""),
                        "projet_service": item_data.get("projet_service", ""),
                        "notes": item_data.get("notes", ""),
                        "piece_jointe_url": item_data.get("piece_jointe_url", ""),
                        "updated_at": datetime.now(timezone.utc).isoformat()
                    }
                    
                    await collection.update_one(
                        {"id": existing_item["id"], "tenant_id": tenant.id},
                        {"$set": update_data}
                    )
                    results["updated"] += 1
                else:
                    # skip par d√©faut
                    continue
            
            # Cr√©er l'√©l√©ment s'il n'existe pas
            if not existing_item:
                new_item = {
                    "id": str(uuid.uuid4()),
                    "tenant_id": tenant.id,
                    "date": date_comparable,
                    "description": item_data["description"],
                    "montant": float(item_data["montant"]),
                    "categorie": item_data.get("categorie", ""),
                    "numero_reference": item_data.get("numero_reference", ""),
                    "fournisseur": item_data.get("fournisseur", ""),
                    "compte_budgetaire": item_data.get("compte_budgetaire", ""),
                    "projet_service": item_data.get("projet_service", ""),
                    "notes": item_data.get("notes", ""),
                    "piece_jointe_url": item_data.get("piece_jointe_url", ""),
                    "created_at": datetime.now(timezone.utc).isoformat()
                }
                
                # Champs sp√©cifiques selon le type
                if item_type == "budget":
                    new_item["annee"] = item_data.get("annee", datetime.now(timezone.utc).year)
                    await db.budgets.insert_one(new_item)
                    results["created_budgets"] += 1
                else:
                    new_item["statut"] = item_data.get("statut", "approuve")
                    await db.depenses.insert_one(new_item)
                    results["created_depenses"] += 1
        
        except Exception as e:
            results["errors"].append({
                "line": index + 1,
                "error": str(e),
                "data": item_data
            })
    
    return results



@api_router.get("/{tenant_slug}/rapports/budgets")
async def get_budgets(tenant_slug: str, annee: Optional[int] = None, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    query = {"tenant_id": tenant.id}
    if annee:
        query["annee"] = annee
    
    budgets = await db.budgets.find(query).to_list(1000)
    return [clean_mongo_doc(b) for b in budgets]

@api_router.put("/{tenant_slug}/rapports/budgets/{budget_id}")
async def update_budget(tenant_slug: str, budget_id: str, budget: BudgetCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    budget_dict = budget.dict()
    budget_dict["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.budgets.update_one(
        {"id": budget_id, "tenant_id": tenant.id},
        {"$set": budget_dict}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Budget non trouv√©")
    
    return {"message": "Budget mis √† jour"}

@api_router.delete("/{tenant_slug}/rapports/budgets/{budget_id}")
async def delete_budget(tenant_slug: str, budget_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.budgets.delete_one({"id": budget_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Budget non trouv√©")
    
    return {"message": "Budget supprim√©"}

# IMMOBILISATIONS
@api_router.post("/{tenant_slug}/rapports/immobilisations")
async def create_immobilisation(tenant_slug: str, immobilisation: ImmobilisationCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    immob_dict = immobilisation.dict()
    immob_dict["tenant_id"] = tenant.id
    immob_obj = Immobilisation(**immob_dict)
    await db.immobilisations.insert_one(immob_obj.dict())
    return clean_mongo_doc(immob_obj.dict())

@api_router.get("/{tenant_slug}/rapports/immobilisations")
async def get_immobilisations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    immobilisations = await db.immobilisations.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(i) for i in immobilisations]

@api_router.delete("/{tenant_slug}/rapports/immobilisations/{immob_id}")
async def delete_immobilisation(tenant_slug: str, immob_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.immobilisations.delete_one({"id": immob_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Immobilisation non trouv√©e")
    
    return {"message": "Immobilisation supprim√©e"}

# PROJETS TRIENNAUX
@api_router.post("/{tenant_slug}/rapports/projets-triennaux")
async def create_projet_triennal(tenant_slug: str, projet: ProjetTriennalCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    projet_dict = projet.dict()
    projet_dict["tenant_id"] = tenant.id
    projet_obj = ProjetTriennal(**projet_dict)
    await db.projets_triennaux.insert_one(projet_obj.dict())
    return clean_mongo_doc(projet_obj.dict())

@api_router.get("/{tenant_slug}/rapports/projets-triennaux")
async def get_projets_triennaux(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    projets = await db.projets_triennaux.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(p) for p in projets]

@api_router.delete("/{tenant_slug}/rapports/projets-triennaux/{projet_id}")
async def delete_projet_triennal(tenant_slug: str, projet_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    result = await db.projets_triennaux.delete_one({"id": projet_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Projet non trouv√©")
    
    return {"message": "Projet supprim√©"}

# INTERVENTIONS
@api_router.post("/{tenant_slug}/rapports/interventions")
async def create_intervention(tenant_slug: str, intervention: InterventionCreate, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    intervention_dict = intervention.dict()
    intervention_dict["tenant_id"] = tenant.id
    intervention_obj = Intervention(**intervention_dict)
    await db.interventions.insert_one(intervention_obj.dict())
    return clean_mongo_doc(intervention_obj.dict())

@api_router.get("/{tenant_slug}/rapports/interventions")
async def get_interventions(tenant_slug: str, current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    interventions = await db.interventions.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(i) for i in interventions]


# ====== RAPPORTS INTERNES ======

@api_router.get("/{tenant_slug}/rapports/dashboard-interne")
async def get_dashboard_interne(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Dashboard interne avec KPIs cl√©s"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Date du mois en cours
    today = datetime.now(timezone.utc)
    debut_mois = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    # R√©cup√©rer les donn√©es
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(1000)
    
    # Calculer heures travaill√©es ce mois
    heures_mois = 0
    for assignation in assignations:
        if "date" in assignation:
            try:
                date_assignation = datetime.fromisoformat(assignation["date"])
                if date_assignation >= debut_mois:
                    # Estimer 8h par assignation
                    heures_mois += 8
            except:
                pass
    
    # Calculer co√ªts salariaux du mois
    cout_salarial_mois = 0
    for user in users:
        taux_horaire = user.get("taux_horaire", 0)
        user_assignations = [a for a in assignations if a["user_id"] == user["id"]]
        user_heures = len(user_assignations) * 8
        cout_salarial_mois += user_heures * taux_horaire
    
    # Pompiers disponibles actuellement
    pompiers_disponibles = len([u for u in users if u.get("statut") == "Actif" and u.get("type_emploi") == "temps_plein"])
    
    return {
        "heures_travaillees_mois": heures_mois,
        "cout_salarial_mois": round(cout_salarial_mois, 2),
        "pompiers_disponibles": pompiers_disponibles,
        "total_pompiers": len(users),
        "periode": debut_mois.strftime("%B %Y")
    }


@api_router.get("/{tenant_slug}/rapports/couts-salariaux")
async def get_rapport_couts_salariaux(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    caserne: Optional[str] = None,
    type_personnel: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """Rapport d√©taill√© des co√ªts salariaux"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Convertir dates
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    # R√©cup√©rer les donn√©es
    query_users = {"tenant_id": tenant.id}
    if type_personnel:
        query_users["type_emploi"] = type_personnel
    
    users = await db.users.find(query_users).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    cout_total = 0
    
    for user in users:
        # Filtrer assignations par p√©riode
        user_assignations = []
        for assignation in assignations:
            if assignation["user_id"] == user["id"] and "date" in assignation:
                try:
                    date_assign = datetime.fromisoformat(assignation["date"])
                    if date_debut_dt <= date_assign <= date_fin_dt:
                        user_assignations.append(assignation)
                except:
                    pass
        
        if len(user_assignations) > 0:
            heures_travaillees = len(user_assignations) * 8  # Estimation
            taux_horaire = user.get("taux_horaire", 0)
            cout_individuel = heures_travaillees * taux_horaire
            cout_total += cout_individuel
            
            rapport.append({
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "matricule": user.get("numero_employe", "N/A"),
                "type_emploi": user.get("type_emploi", "N/A"),
                "heures_travaillees": heures_travaillees,
                "heures_supplementaires": 0,  # √Ä impl√©menter
                "taux_horaire": taux_horaire,
                "cout_total": round(cout_individuel, 2)
            })
    
    return {
        "periode": {"debut": date_debut, "fin": date_fin},
        "employes": rapport,
        "cout_total": round(cout_total, 2),
        "nombre_employes": len(rapport)
    }


@api_router.get("/{tenant_slug}/rapports/disponibilite")
async def get_rapport_disponibilite(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Rapport de disponibilit√©/indisponibilit√© des pompiers"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Convertir dates
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    # R√©cup√©rer les donn√©es
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    disponibilites = await db.disponibilites.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    total_jours_disponibles = 0
    total_jours_indisponibles = 0
    
    for user in users:
        # Filtrer disponibilit√©s par p√©riode
        user_disponibilites = []
        for dispo in disponibilites:
            if dispo["user_id"] == user["id"] and "date" in dispo:
                try:
                    date_dispo = datetime.fromisoformat(dispo["date"]).date()
                    if date_debut_dt.date() <= date_dispo <= date_fin_dt.date():
                        user_disponibilites.append(dispo)
                except:
                    pass
        
        jours_disponibles = len([d for d in user_disponibilites if d.get("disponible") == True])
        jours_indisponibles = len([d for d in user_disponibilites if d.get("disponible") == False])
        
        # Analyser motifs d'indisponibilit√©
        motifs = {}
        for dispo in user_disponibilites:
            if not dispo.get("disponible"):
                motif = dispo.get("motif", "non_specifie")
                motifs[motif] = motifs.get(motif, 0) + 1
        
        total_jours = jours_disponibles + jours_indisponibles
        taux_disponibilite = round((jours_disponibles / total_jours * 100) if total_jours > 0 else 0, 1)
        
        total_jours_disponibles += jours_disponibles
        total_jours_indisponibles += jours_indisponibles
        
        rapport.append({
            "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
            "grade": user.get("grade", "N/A"),
            "jours_disponibles": jours_disponibles,
            "jours_indisponibles": jours_indisponibles,
            "taux_disponibilite": taux_disponibilite,
            "motifs_indisponibilite": motifs
        })
    
    # Calculer statistiques globales
    total_jours = total_jours_disponibles + total_jours_indisponibles
    taux_global = round((total_jours_disponibles / total_jours * 100) if total_jours > 0 else 0, 1)
    
    return {
        "periode": {"debut": date_debut, "fin": date_fin},
        "employes": rapport,
        "total_jours_disponibles": total_jours_disponibles,
        "total_jours_indisponibles": total_jours_indisponibles,
        "taux_disponibilite_global": taux_global,
        "nombre_employes": len(rapport)
    }


@api_router.get("/{tenant_slug}/rapports/couts-formations")
async def get_rapport_couts_formations(
    tenant_slug: str,
    annee: int,
    current_user: User = Depends(get_current_user)
):
    """Rapport d√©taill√© des co√ªts de formation"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es
    formations = await db.formations.find({"tenant_id": tenant.id, "annee": annee}).to_list(1000)
    inscriptions = await db.inscriptions_formations.find({"tenant_id": tenant.id}).to_list(10000)
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = []
    cout_total = 0
    
    for formation in formations:
        # R√©cup√©rer inscriptions pour cette formation
        formation_inscriptions = [i for i in inscriptions if i["formation_id"] == formation["id"]]
        
        # Co√ªt de la formation (formateur, mat√©riel, etc.)
        cout_formation = formation.get("cout_formation", 0)
        
        # Co√ªt salarial des participants
        cout_salarial = 0
        for inscription in formation_inscriptions:
            user = next((u for u in users if u["id"] == inscription["user_id"]), None)
            if user:
                taux_horaire = user.get("taux_horaire", 0)
                heures_formation = formation.get("duree_heures", 0)
                cout_salarial += taux_horaire * heures_formation
        
        cout_total_formation = cout_formation + cout_salarial
        cout_total += cout_total_formation
        
        rapport.append({
            "nom_formation": formation.get("nom", "N/A"),
            "date": formation.get("date_debut", "N/A"),
            "duree_heures": formation.get("duree_heures", 0),
            "nombre_participants": len(formation_inscriptions),
            "cout_formation": cout_formation,
            "cout_salarial": round(cout_salarial, 2),
            "cout_total": round(cout_total_formation, 2)
        })
    
    return {
        "annee": annee,
        "formations": rapport,
        "cout_total": round(cout_total, 2),
        "nombre_formations": len(rapport),
        "nombre_total_participants": sum([f["nombre_participants"] for f in rapport]),
        "heures_totales": sum([f["duree_heures"] for f in rapport])
    }


# ====== RAPPORTS EXTERNES ======

@api_router.get("/{tenant_slug}/rapports/tableau-bord-budgetaire")
async def get_tableau_bord_budgetaire(tenant_slug: str, annee: int, current_user: User = Depends(get_current_user)):
    """Tableau de bord budg√©taire pour rapports externes"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les budgets de l'ann√©e
    budgets = await db.budgets.find({"tenant_id": tenant.id, "annee": annee}).to_list(1000)
    
    rapport_budgetaire = []
    total_alloue = 0
    total_consomme = 0
    
    for budget in budgets:
        alloue = budget.get("budget_alloue", 0)
        consomme = budget.get("budget_consomme", 0)
        total_alloue += alloue
        total_consomme += consomme
        
        rapport_budgetaire.append({
            "categorie": budget.get("categorie"),
            "budget_alloue": alloue,
            "budget_consomme": consomme,
            "pourcentage_utilise": round((consomme / alloue * 100) if alloue > 0 else 0, 1),
            "restant": alloue - consomme
        })
    
    return {
        "annee": annee,
        "budget_total_alloue": total_alloue,
        "budget_total_consomme": total_consomme,
        "pourcentage_global": round((total_consomme / total_alloue * 100) if total_alloue > 0 else 0, 1),
        "par_categorie": rapport_budgetaire
    }


@api_router.get("/{tenant_slug}/rapports/rapport-immobilisations")
async def get_rapport_immobilisations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Rapport d√©taill√© sur les immobilisations"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les immobilisations
    immobilisations = await db.immobilisations.find({"tenant_id": tenant.id}).to_list(1000)
    
    rapport = {
        "vehicules": [],
        "equipements": [],
        "statistiques": {
            "nombre_vehicules": 0,
            "nombre_equipements": 0,
            "cout_acquisition_total": 0,
            "cout_entretien_annuel_total": 0,
            "age_moyen_vehicules": 0,
            "age_moyen_equipements": 0
        }
    }
    
    today = datetime.now(timezone.utc).date()
    ages_vehicules = []
    ages_equipements = []
    
    for immob in immobilisations:
        # Calculer l'√¢ge
        try:
            date_acquisition = datetime.fromisoformat(immob["date_acquisition"]).date()
            age_annees = (today - date_acquisition).days / 365.25
        except:
            age_annees = 0
        
        item = {
            "id": immob["id"],
            "nom": immob["nom"],
            "date_acquisition": immob["date_acquisition"],
            "age_annees": round(age_annees, 1),
            "cout_acquisition": immob["cout_acquisition"],
            "cout_entretien_annuel": immob["cout_entretien_annuel"],
            "etat": immob["etat"],
            "date_remplacement_prevue": immob.get("date_remplacement_prevue"),
            "notes": immob.get("notes", "")
        }
        
        if immob["type_immobilisation"] == "vehicule":
            rapport["vehicules"].append(item)
            rapport["statistiques"]["nombre_vehicules"] += 1
            ages_vehicules.append(age_annees)
        else:
            rapport["equipements"].append(item)
            rapport["statistiques"]["nombre_equipements"] += 1
            ages_equipements.append(age_annees)
        
        rapport["statistiques"]["cout_acquisition_total"] += immob["cout_acquisition"]
        rapport["statistiques"]["cout_entretien_annuel_total"] += immob["cout_entretien_annuel"]
    
    # Calculer √¢ges moyens
    if ages_vehicules:
        rapport["statistiques"]["age_moyen_vehicules"] = round(sum(ages_vehicules) / len(ages_vehicules), 1)
    if ages_equipements:
        rapport["statistiques"]["age_moyen_equipements"] = round(sum(ages_equipements) / len(ages_equipements), 1)
    
    return rapport


# ====== EXPORTS PDF/EXCEL POUR LES RAPPORTS ======

@api_router.get("/{tenant_slug}/rapports/export-dashboard-pdf")
async def export_dashboard_pdf(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Export PDF du Dashboard interne"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es du dashboard
    today = datetime.now(timezone.utc)
    debut_mois = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(1000)
    
    heures_mois = 0
    for assignation in assignations:
        if "date" in assignation:
            try:
                date_assignation = datetime.fromisoformat(assignation["date"])
                if date_assignation >= debut_mois:
                    heures_mois += 8
            except:
                pass
    
    cout_salarial_mois = 0
    for user in users:
        taux_horaire = user.get("taux_horaire", 0)
        user_assignations = [a for a in assignations if a["user_id"] == user["id"]]
        user_heures = len(user_assignations) * 8
        cout_salarial_mois += user_heures * taux_horaire
    
    pompiers_disponibles = len([u for u in users if u.get("statut") == "Actif" and u.get("type_emploi") == "temps_plein"])
    
    # G√©n√©rer le PDF
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # D√©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Header personnalis√© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    story.append(Paragraph("Dashboard Interne ProFireManager", modern_styles['title']))
    story.append(Paragraph(f"P√©riode: {debut_mois.strftime('%B %Y')}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # KPIs
    kpi_data = [
        ["Indicateur", "Valeur"],
        ["Heures travaill√©es ce mois", f"{heures_mois}h"],
        ["Co√ªt salarial du mois", f"${cout_salarial_mois:,.2f}"],
        ["Pompiers disponibles", str(pompiers_disponibles)],
        ["Total pompiers", str(len(users))]
    ]
    
    kpi_table = Table(kpi_data, colWidths=[3*inch, 2*inch])
    kpi_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 11),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('TOPPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(kpi_table)
    doc.build(story)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=dashboard_interne_{debut_mois.strftime('%Y%m')}.pdf"}
    )


@api_router.get("/{tenant_slug}/rapports/export-salaires-pdf")
async def export_salaires_pdf(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Export PDF du rapport co√ªts salariaux"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    cout_total = 0
    
    for user in users:
        user_assignations = []
        for assignation in assignations:
            if assignation["user_id"] == user["id"] and "date" in assignation:
                try:
                    date_assign = datetime.fromisoformat(assignation["date"])
                    if date_debut_dt <= date_assign <= date_fin_dt:
                        user_assignations.append(assignation)
                except:
                    pass
        
        if len(user_assignations) > 0:
            heures_travaillees = len(user_assignations) * 8
            taux_horaire = user.get("taux_horaire", 0)
            cout_individuel = heures_travaillees * taux_horaire
            cout_total += cout_individuel
            
            rapport.append({
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "matricule": user.get("numero_employe", "N/A"),
                "type_emploi": user.get("type_emploi", "N/A"),
                "heures_travaillees": heures_travaillees,
                "taux_horaire": taux_horaire,
                "cout_total": cout_individuel
            })
    
    # G√©n√©rer PDF
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # D√©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Header personnalis√© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    story.append(Paragraph("Rapport de Co√ªts Salariaux D√©taill√©s", modern_styles['title']))
    story.append(Paragraph(f"P√©riode: {date_debut} au {date_fin}", modern_styles['subheading']))
    story.append(Spacer(1, 0.2*inch))
    
    # R√©sum√©
    summary_data = [
        ["R√©sum√©", ""],
        ["Co√ªt total", f"${cout_total:,.2f}"],
        ["Nombre d'employ√©s", str(len(rapport))],
        ["Total heures", f"{sum([r['heures_travaillees'] for r in rapport])}h"]
    ]
    
    summary_table = Table(summary_data, colWidths=[2.5*inch, 2*inch])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(summary_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Tableau d√©taill√©
    table_data = [["Nom", "Matricule", "Type", "Heures", "Taux/h", "Co√ªt"]]
    for emp in rapport:
        type_emploi = emp.get("type_emploi", "temps_plein")
        if type_emploi == "temps_plein":
            type_abbr = "TP"
        elif type_emploi == "temporaire":
            type_abbr = "Tempo"
        else:
            type_abbr = "TPart"
        table_data.append([
            emp.get("nom", ""),
            emp.get("matricule", ""),
            type_abbr,
            f"{emp.get('heures_travaillees', 0)}h",
            f"${emp.get('taux_horaire', 0)}",
            f"${emp.get('cout_total', 0):,.2f}"
        ])
    
    detail_table = Table(table_data, colWidths=[1.8*inch, 1*inch, 0.7*inch, 0.8*inch, 0.8*inch, 1.2*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(detail_table)
    doc.build(story)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=rapport_salaires_{date_debut}_{date_fin}.pdf"}
    )


@api_router.get("/{tenant_slug}/rapports/export-salaires-excel")
async def export_salaires_excel(
    tenant_slug: str,
    date_debut: str,
    date_fin: str,
    current_user: User = Depends(get_current_user)
):
    """Export Excel du rapport co√ªts salariaux"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les donn√©es (m√™me logique que PDF)
    date_debut_dt = datetime.fromisoformat(date_debut)
    date_fin_dt = datetime.fromisoformat(date_fin)
    
    users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    assignations = await db.assignations.find({"tenant_id": tenant.id}).to_list(10000)
    
    rapport = []
    cout_total = 0
    
    for user in users:
        user_assignations = []
        for assignation in assignations:
            if assignation["user_id"] == user["id"] and "date" in assignation:
                try:
                    date_assign = datetime.fromisoformat(assignation["date"])
                    if date_debut_dt <= date_assign <= date_fin_dt:
                        user_assignations.append(assignation)
                except:
                    pass
        
        if len(user_assignations) > 0:
            heures_travaillees = len(user_assignations) * 8
            taux_horaire = user.get("taux_horaire", 0)
            cout_individuel = heures_travaillees * taux_horaire
            cout_total += cout_individuel
            
            rapport.append({
                "nom": f"{user.get('prenom', '')} {user.get('nom', '')}",
                "matricule": user.get("numero_employe", "N/A"),
                "type_emploi": user.get("type_emploi", "N/A"),
                "heures_travaillees": heures_travaillees,
                "taux_horaire": taux_horaire,
                "cout_total": cout_individuel
            })
    
    # G√©n√©rer Excel
    wb = Workbook()
    ws = wb.active
    ws.title = "Co√ªts Salariaux"
    
    # En-t√™te
    ws['A1'] = f"Rapport de Co√ªts Salariaux - {date_debut} au {date_fin}"
    ws['A1'].font = Font(size=14, bold=True, color="DC2626")
    ws.merge_cells('A1:F1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # R√©sum√©
    ws['A3'] = "Co√ªt Total"
    ws['B3'] = f"${cout_total:,.2f}"
    ws['C3'] = "Employ√©s"
    ws['D3'] = len(rapport)
    ws['E3'] = "Total Heures"
    ws['F3'] = f"{sum([r['heures_travaillees'] for r in rapport])}h"
    
    # Tableau
    headers = ["Nom", "Matricule", "Type", "Heures", "Taux/h", "Co√ªt Total"]
    row = 5
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=row, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    for emp in rapport:
        row += 1
        ws.cell(row=row, column=1, value=emp.get("nom", ""))
        ws.cell(row=row, column=2, value=emp.get("matricule", ""))
        ws.cell(row=row, column=3, value=emp.get("type_emploi", "temps_plein"))
        ws.cell(row=row, column=4, value=emp.get("heures_travaillees", 0))
        ws.cell(row=row, column=5, value=emp.get("taux_horaire", 0))
        ws.cell(row=row, column=6, value=emp.get("cout_total", 0))
    
    # Ajuster largeurs
    for col in ['A', 'B', 'C', 'D', 'E', 'F']:
        ws.column_dimensions[col].width = 18
    
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename=rapport_salaires_{date_debut}_{date_fin}.xlsx"}
    )


# ==================== DASHBOARD MESSAGES ROUTES MIGR√âES VERS routes/dashboard_messages.py ====================
# Routes migr√©es:
# - POST   /{tenant_slug}/dashboard/messages              - Cr√©er un message important
# - GET    /{tenant_slug}/dashboard/messages              - Liste des messages importants
# - DELETE /{tenant_slug}/dashboard/messages/{message_id} - Supprimer un message
# ============================================================================


# DASHBOARD DONN√âES COMPL√àTES
@api_router.get("/{tenant_slug}/dashboard/donnees-completes")
async def get_dashboard_donnees_completes(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """Endpoint central pour toutes les donn√©es du dashboard"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Date du mois en cours
    today = datetime.now(timezone.utc)
    debut_mois = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    fin_mois = (debut_mois + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    debut_mois_prochain = fin_mois + timedelta(days=1)
    fin_mois_prochain = (debut_mois_prochain + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # R√©cup√©rer uniquement les donn√©es n√©cessaires avec filtres
    # Types de garde (petite collection, OK de tout charger)
    types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
    
    # Assignations du mois en cours UNIQUEMENT pour l'utilisateur
    mes_assignations_mois = await db.assignations.find({
        "tenant_id": tenant.id,
        "user_id": current_user.id,
        "date": {
            "$gte": debut_mois.isoformat(),
            "$lte": fin_mois.isoformat()
        }
    }).to_list(1000)
    
    # Inscriptions de l'utilisateur uniquement
    mes_inscriptions = await db.inscriptions_formations.find({
        "tenant_id": tenant.id,
        "user_id": current_user.id
    }).to_list(1000)
    
    # Formations pour les inscriptions + futures
    formation_ids = [i["formation_id"] for i in mes_inscriptions]
    formations = await db.formations.find({
        "tenant_id": tenant.id,
        "$or": [
            {"id": {"$in": formation_ids}},
            {"date_debut": {"$gte": today.isoformat()}}
        ]
    }).to_list(1000)
    
    # Pour section admin : charger donn√©es agr√©g√©es uniquement si n√©cessaire
    if current_user.role in ["admin", "superviseur"]:
        users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
        assignations = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": debut_mois.isoformat(),
                "$lte": fin_mois.isoformat()
            }
        }).to_list(5000)
        demandes_remplacement = await db.demandes_remplacement.find({"tenant_id": tenant.id}).to_list(1000)
    else:
        users = []
        assignations = mes_assignations_mois
        demandes_remplacement = []
    
    # Cr√©er un mapping des types de garde pour acc√®s rapide
    type_garde_map = {t["id"]: t for t in types_garde}
    
    # V√©rifier si le tenant a au moins une garde externe
    has_garde_externe = any(t.get("est_garde_externe", False) for t in types_garde)
    
    # ===== SECTION PERSONNELLE =====
    # Heures travaill√©es ce mois (s√©par√© interne/externe)
    logger.info(f"üìä Dashboard - User {current_user.email}: {len(mes_assignations_mois)} assignations trouv√©es")
    heures_mois_internes = 0
    heures_mois_externes = 0
    heures_mois_total = 0
    nombre_gardes_mois = 0
    for assignation in mes_assignations_mois:
        try:
            date_str = assignation["date"]
            logger.info(f"üìä Traitement assignation - date: {date_str}, type: {type(date_str)}")
            
            # G√©rer les diff√©rents formats de date
            if isinstance(date_str, str):
                # Retirer le 'Z' et g√©rer le timezone
                date_str = date_str.replace('Z', '+00:00')
                if 'T' in date_str:
                    date_assign = datetime.fromisoformat(date_str)
                else:
                    # Format date simple YYYY-MM-DD
                    date_assign = datetime.fromisoformat(date_str + "T00:00:00").replace(tzinfo=timezone.utc)
            else:
                # Si c'est d√©j√† un datetime
                date_assign = date_str
            
            logger.info(f"üìä Date pars√©e: {date_assign}, debut_mois: {debut_mois}, fin_mois: {fin_mois}")
            
            if debut_mois <= date_assign <= fin_mois:
                # R√©cup√©rer le type de garde pour calculer la dur√©e exacte
                type_garde = type_garde_map.get(assignation.get("type_garde_id"))
                logger.info(f"üìä Type garde trouv√©: {type_garde.get('nom') if type_garde else 'None'}")
                if type_garde:
                    duree = type_garde.get("duree_heures", 8)
                    if type_garde.get("est_garde_externe", False):
                        heures_mois_externes += duree
                    else:
                        heures_mois_internes += duree
                    heures_mois_total += duree
                    logger.info(f"üìä Heures ajout√©es: {duree}h (total: {heures_mois_total}h)")
                else:
                    # Fallback si type garde non trouv√©
                    heures_mois_internes += 8
                    heures_mois_total += 8
                    logger.info(f"üìä Heures ajout√©es (fallback): 8h (total: {heures_mois_total}h)")
                nombre_gardes_mois += 1
            else:
                logger.info(f"üìä Date hors du mois en cours, ignor√©e")
        except Exception as e:
            logger.error(f"üìä Erreur traitement assignation: {e}, assignation: {assignation}")
            pass
    
    # Pr√©sence aux formations
    formations_passees = 0
    presences = 0
    for insc in mes_inscriptions:
        formation = next((f for f in formations if f["id"] == insc["formation_id"]), None)
        if formation:
            try:
                date_fin_formation = datetime.fromisoformat(formation["date_fin"]).date()
                if date_fin_formation < today.date():
                    formations_passees += 1
                    if insc.get("statut") == "present":
                        presences += 1
            except:
                pass
    
    pourcentage_presence_formations = round((presences / formations_passees * 100) if formations_passees > 0 else 0, 1)
    
    # Formations √† venir (toutes les formations futures √† partir d'aujourd'hui)
    formations_a_venir = []
    for formation in formations:
        try:
            if "date_debut" in formation and formation["date_debut"]:
                date_debut_formation = datetime.fromisoformat(formation["date_debut"].replace('Z', '+00:00'))
                # Inclure toutes les formations qui commencent aujourd'hui ou dans le futur
                if date_debut_formation.date() >= today.date():
                    # V√©rifier si inscrit
                    est_inscrit = any(i for i in mes_inscriptions if i["formation_id"] == formation["id"])
                    formations_a_venir.append({
                        "id": formation["id"],
                        "nom": formation["nom"],
                        "date_debut": formation["date_debut"],
                        "date_fin": formation["date_fin"],
                        "est_inscrit": est_inscrit
                    })
        except (ValueError, TypeError, AttributeError):
            # Ignorer les formations avec des dates invalides
            pass
    
    formations_a_venir.sort(key=lambda x: x["date_debut"])
    
    section_personnelle = {
        "heures_travaillees_mois": heures_mois_total,  # Total pour compatibilit√©
        "heures_internes_mois": heures_mois_internes,
        "heures_externes_mois": heures_mois_externes,
        "has_garde_externe": has_garde_externe,  # Indicateur si garde externe existe
        "nombre_gardes_mois": nombre_gardes_mois,
        "pourcentage_presence_formations": pourcentage_presence_formations,
        "formations_a_venir": formations_a_venir
    }
    
    # ===== SECTION G√âN√âRALE (Admin/Superviseur uniquement) =====
    section_generale = None
    if current_user.role in ["admin", "superviseur"]:
        # OPTIMISATION : Calculs simplifi√©s pour dashboard rapide
        # Compter assignations et statistiques avec agr√©gation MongoDB
        
        # Nombre total d'assignations du mois
        nb_assignations_mois = len(assignations)
        
        # Estimation rapide de couverture (√©viter boucles co√ªteuses)
        # Personnel requis estim√© : types_garde √ó jours_mois √ó personnel moyen
        jours_mois = (fin_mois - debut_mois).days + 1
        personnel_moyen_par_garde = sum(t.get("personnel_requis", 1) for t in types_garde) / len(types_garde) if types_garde else 1
        total_personnel_requis_estime = len(types_garde) * jours_mois * personnel_moyen_par_garde * 0.7  # 70% des jours (moyenne)
        
        couverture_planning = round((nb_assignations_mois / total_personnel_requis_estime * 100), 1) if total_personnel_requis_estime > 0 else 0
        couverture_planning = min(couverture_planning, 100.0)  # Cap √† 100%
        
        # Postes √† pourvoir estim√©s
        postes_a_pourvoir = max(0, int(total_personnel_requis_estime - nb_assignations_mois))
        
        # Demandes de cong√© √† approuver (d√©j√† filtr√©es)
        demandes_en_attente = len([d for d in demandes_remplacement if d.get("statut") == "en_attente"])
        
        # Stats du mois - Utiliser les donn√©es d√©j√† charg√©es
        nb_formations_mois = await db.formations.count_documents({
            "tenant_id": tenant.id,
            "date_debut": {
                "$gte": debut_mois.isoformat(),
                "$lte": fin_mois.isoformat()
            }
        })
        
        nb_personnel_actif = await db.users.count_documents({
            "tenant_id": tenant.id,
            "statut": "Actif"
        })
        
        stats_mois = {
            "total_assignations": nb_assignations_mois,
            "total_personnel_actif": nb_personnel_actif,
            "formations_ce_mois": nb_formations_mois
        }
        
        section_generale = {
            "couverture_planning": couverture_planning,
            "postes_a_pourvoir": postes_a_pourvoir,  # Renomm√© pour clart√©
            "demandes_conges_en_attente": demandes_en_attente,
            "statistiques_mois": stats_mois
        }
    
    # ===== ACTIVIT√âS R√âCENTES (Filtrage selon le r√¥le) =====
    activites_recentes = []
    
    # Filtrer selon le r√¥le
    if current_user.role == "admin":
        # Admins voient tout (sauf param√®tres)
        activites = await db.activites.find({
            "tenant_id": tenant.id,
            "type_activite": {"$nin": ["parametres"]}  # Exclure les param√®tres
        }).sort("created_at", -1).limit(50).to_list(50)
        activites_recentes = [clean_mongo_doc(a) for a in activites]
    
    elif current_user.role in ["superviseur", "employe"]:
        # Superviseurs et employ√©s voient :
        # - Formations cr√©√©es
        # - Planning valid√©/publi√©
        # - Activit√©s les concernant directement
        # - Messages importants
        activites = await db.activites.find({
            "tenant_id": tenant.id,
            "$or": [
                {"type_activite": {"$in": ["formation_creation", "planning_publication", "message_important"]}},
                {"user_id": current_user.id},  # Leurs propres activit√©s
                {"data.concerne_user_id": current_user.id}  # Activit√©s qui les concernent
            ]
        }).sort("created_at", -1).limit(30).to_list(30)
        activites_recentes = [clean_mongo_doc(a) for a in activites]
    
    return {
        "section_personnelle": section_personnelle,
        "section_generale": section_generale,
        "activites_recentes": activites_recentes
    }


# Fonction helper pour cr√©er des activit√©s
async def creer_activite(
    tenant_id: str, 
    type_activite: str, 
    description: str, 
    user_id: Optional[str] = None, 
    user_nom: Optional[str] = None,
    data: Optional[dict] = None  # Donn√©es suppl√©mentaires pour filtrage
):
    """Helper pour cr√©er une activit√© dans le syst√®me avec auto-nettoyage apr√®s 30 jours"""
    activite = Activite(
        tenant_id=tenant_id,
        type_activite=type_activite,
        description=description,
        user_id=user_id,
        user_nom=user_nom
    )
    
    activite_dict = activite.dict()
    if data:
        activite_dict["data"] = data  # Ajouter les donn√©es suppl√©mentaires
    
    await db.activites.insert_one(activite_dict)
    
    # Nettoyage automatique des activit√©s > 30 jours
    date_limite = datetime.now(timezone.utc) - timedelta(days=30)
    await db.activites.delete_many({
        "tenant_id": tenant_id,
        "created_at": {"$lt": date_limite}
    })


# ====================================================================
# MODULE PERSONNEL - EXPORTS PDF/EXCEL
# ====================================================================

@api_router.get("/{tenant_slug}/personnel/export-pdf")
async def export_personnel_pdf(
    tenant_slug: str,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """Export PDF de la liste personnel ou d'un utilisateur individuel"""
    if current_user.role == "employe":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les utilisateurs
    if user_id:
        users_data = await db.users.find({"id": user_id, "tenant_id": tenant.id}).to_list(1)
    else:
        users_data = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    
    # G√©n√©rer PDF
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # D√©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Header personnalis√© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    titre = "Fiche Employ√©" if user_id else "Liste du Personnel"
    story.append(Paragraph(titre, modern_styles['title']))
    story.append(Spacer(1, 0.2*inch))
    
    if not user_id:
        # Statistiques globales
        total = len(users_data)
        actifs = len([u for u in users_data if u.get("statut") == "Actif"])
        temps_plein = len([u for u in users_data if u.get("type_emploi") == "temps_plein"])
        temps_partiel = len([u for u in users_data if u.get("type_emploi") == "temps_partiel"])
        
        stats_data = [
            ["Statistiques", ""],
            ["Total personnel", str(total)],
            ["Actifs", str(actifs)],
            ["Temps plein", str(temps_plein)],
            ["Temps partiel", str(temps_partiel)]
        ]
        
        stats_table = Table(stats_data, colWidths=[2.5*inch, 2*inch])
        stats_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('TOPPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        story.append(stats_table)
        story.append(Spacer(1, 0.3*inch))
    
    # Tableau ou fiche individuelle
    if user_id and users_data:
        # Fiche individuelle d√©taill√©e
        user = users_data[0]
        fiche_data = [
            ["Nom complet", f"{user.get('prenom', '')} {user.get('nom', '')}"],
            ["Email", user.get("email", "N/A")],
            ["T√©l√©phone", user.get("telephone", "N/A")],
            ["Grade", user.get("grade", "N/A")],
            ["R√¥le", user.get("role", "N/A")],
            ["Type emploi", user.get("type_emploi", "N/A")],
            ["Statut", user.get("statut", "N/A")],
            ["Taux horaire", f"${user.get('taux_horaire', 0)}/h"],
            ["Adresse", user.get("adresse", "N/A")]
        ]
        
        fiche_table = Table(fiche_data, colWidths=[2*inch, 4*inch])
        fiche_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), modern_styles['bg_light']),
            ('TEXTCOLOR', (0, 0), (0, -1), modern_styles['primary_color']),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('PADDING', (0, 0), (-1, -1), 8),
            ('BACKGROUND', (1, 0), (1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid'])
        ]))
        
        story.append(fiche_table)
    else:
        # Liste compl√®te
        table_data = [["Nom", "Email", "Grade", "R√¥le", "Type", "Statut"]]
        
        for user in users_data:
            type_emploi = user.get("type_emploi", "temps_plein")
            if type_emploi == "temps_plein":
                type_abbr = "TP"
            elif type_emploi == "temporaire":
                type_abbr = "Tempo"
            else:
                type_abbr = "TPart"
            table_data.append([
                f"{user.get('prenom', '')} {user.get('nom', '')}",
                user.get("email", "N/A"),
                user.get("grade", "N/A"),
                user.get("role", "N/A"),
                type_abbr,
                user.get("statut", "N/A")
            ])
        
        detail_table = Table(table_data, colWidths=[1.5*inch, 1.5*inch, 1.2*inch, 1*inch, 0.6*inch, 0.8*inch])
        detail_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('TOPPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        story.append(detail_table)
    
    doc.build(story)
    buffer.seek(0)
    
    filename = f"fiche_employe_{user_id}.pdf" if user_id else "liste_personnel.pdf"
    return StreamingResponse(
        buffer,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


@api_router.get("/{tenant_slug}/personnel/export-excel")
async def export_personnel_excel(
    tenant_slug: str,
    user_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """Export Excel de la liste personnel ou d'un utilisateur individuel"""
    if current_user.role == "employe":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les utilisateurs
    if user_id:
        users_data = await db.users.find({"id": user_id, "tenant_id": tenant.id}).to_list(1)
    else:
        users_data = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    
    # G√©n√©rer Excel
    wb = Workbook()
    ws = wb.active
    ws.title = "Personnel"
    
    # En-t√™te
    titre = "Fiche Employ√©" if user_id else "Liste du Personnel"
    ws['A1'] = titre
    ws['A1'].font = Font(size=14, bold=True, color="DC2626")
    ws.merge_cells('A1:F1')
    ws['A1'].alignment = Alignment(horizontal='center')
    
    if not user_id:
        # Stats
        total = len(users_data)
        actifs = len([u for u in users_data if u.get("statut") == "Actif"])
        
        ws['A3'] = "Total personnel"
        ws['B3'] = total
        ws['A4'] = "Personnel actif"
        ws['B4'] = actifs
        
        # Tableau
        headers = ["Nom", "Pr√©nom", "Email", "Grade", "R√¥le", "Type", "Statut", "T√©l√©phone"]
        row = 6
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
            cell.alignment = Alignment(horizontal='center')
        
        for user in users_data:
            row += 1
            ws.cell(row=row, column=1, value=user.get("nom", ""))
            ws.cell(row=row, column=2, value=user.get("prenom", ""))
            ws.cell(row=row, column=3, value=user.get("email", ""))
            ws.cell(row=row, column=4, value=user.get("grade", ""))
            ws.cell(row=row, column=5, value=user.get("role", ""))
            ws.cell(row=row, column=6, value=user.get("type_emploi", ""))
            ws.cell(row=row, column=7, value=user.get("statut", ""))
            ws.cell(row=row, column=8, value=user.get("telephone", ""))
    else:
        # Fiche individuelle
        if users_data:
            user = users_data[0]
            row = 3
            fields = [
                ("Nom", user.get("nom", "")),
                ("Pr√©nom", user.get("prenom", "")),
                ("Email", user.get("email", "")),
                ("T√©l√©phone", user.get("telephone", "")),
                ("Grade", user.get("grade", "")),
                ("R√¥le", user.get("role", "")),
                ("Type emploi", user.get("type_emploi", "")),
                ("Statut", user.get("statut", "")),
                ("Adresse", user.get("adresse", ""))
            ]
            
            for field, value in fields:
                ws.cell(row=row, column=1, value=field).font = Font(bold=True)
                ws.cell(row=row, column=2, value=value)
                row += 1
    
    # Ajuster largeurs
    for col in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']:
        ws.column_dimensions[col].width = 18
    
    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    filename = f"fiche_employe_{user_id}.xlsx" if user_id else "liste_personnel.xlsx"
    return StreamingResponse(
        buffer,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


# Sessions de formation routes
@api_router.post("/{tenant_slug}/sessions-formation", response_model=SessionFormation)
async def create_session_formation(tenant_slug: str, session: SessionFormationCreate, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    session_dict = session.dict()
    session_dict["tenant_id"] = tenant.id
    session_obj = SessionFormation(**session_dict)
    await db.sessions_formation.insert_one(session_obj.dict())
    return session_obj

@api_router.get("/{tenant_slug}/sessions-formation", response_model=List[SessionFormation])
async def get_sessions_formation(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    sessions = await db.sessions_formation.find({"tenant_id": tenant.id}).to_list(1000)
    cleaned_sessions = [clean_mongo_doc(session) for session in sessions]
    return [SessionFormation(**session) for session in cleaned_sessions]

@api_router.post("/{tenant_slug}/sessions-formation/{session_id}/inscription")
async def inscrire_formation(tenant_slug: str, session_id: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que la session existe dans ce tenant
    session = await db.sessions_formation.find_one({"id": session_id, "tenant_id": tenant.id})
    if not session:
        raise HTTPException(status_code=404, detail="Session de formation non trouv√©e")
    
    # V√©rifier si d√©j√† inscrit
    if current_user.id in session.get("participants", []):
        raise HTTPException(status_code=400, detail="Vous √™tes d√©j√† inscrit √† cette formation")
    
    # V√©rifier les places disponibles
    if len(session.get("participants", [])) >= session.get("places_max", 20):
        raise HTTPException(status_code=400, detail="Formation compl√®te - Plus de places disponibles")
    
    # Ajouter l'utilisateur aux participants
    await db.sessions_formation.update_one(
        {"id": session_id, "tenant_id": tenant.id},
        {"$push": {"participants": current_user.id}}
    )
    
    # Cr√©er l'inscription
    inscription_dict = {
        "tenant_id": tenant.id,
        "session_id": session_id,
        "user_id": current_user.id
    }
    inscription_obj = InscriptionFormation(**inscription_dict)
    await db.inscriptions_formation.insert_one(inscription_obj.dict())
    
    return {"message": "Inscription r√©ussie", "session_id": session_id}

@api_router.delete("/{tenant_slug}/sessions-formation/{session_id}/desinscription")
async def desinscrire_formation(tenant_slug: str, session_id: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que la session existe dans ce tenant
    session = await db.sessions_formation.find_one({"id": session_id, "tenant_id": tenant.id})
    if not session:
        raise HTTPException(status_code=404, detail="Session de formation non trouv√©e")
    
    # V√©rifier si inscrit
    if current_user.id not in session.get("participants", []):
        raise HTTPException(status_code=400, detail="Vous n'√™tes pas inscrit √† cette formation")
    
    # Retirer l'utilisateur des participants
    await db.sessions_formation.update_one(
        {"id": session_id, "tenant_id": tenant.id},
        {"$pull": {"participants": current_user.id}}
    )
    
    # Supprimer l'inscription
    await db.inscriptions_formation.delete_one({
        "session_id": session_id,
        "user_id": current_user.id,
        "tenant_id": tenant.id
    })
    
    return {"message": "D√©sinscription r√©ussie", "session_id": session_id}

# ==================== GESTION DES CONFLITS DISPONIBILIT√âS/INDISPONIBILIT√âS ====================

async def detect_conflicts(tenant_id: str, user_id: str, date: str, heure_debut: str, 
                          heure_fin: str, type_garde_id: Optional[str], 
                          element_type: str) -> List[Dict[str, Any]]:
    """
    D√©tecte les conflits entre disponibilit√©s/indisponibilit√©s
    
    D√©tecte 3 types de conflits:
    1. Disponibilit√© ‚Üî Indisponibilit√© (incompatible)
    2. Disponibilit√© ‚Üî Disponibilit√© avec horaires diff√©rents (peut fusionner)
    3. Indisponibilit√© ‚Üî Indisponibilit√© (peut fusionner)
    
    Args:
        tenant_id: ID du tenant
        user_id: ID de l'utilisateur
        date: Date au format YYYY-MM-DD
        heure_debut: Heure de d√©but (HH:MM)
        heure_fin: Heure de fin (HH:MM)
        type_garde_id: ID du type de garde (optionnel)
        element_type: "disponibilite" ou "indisponibilite"
        
    Returns:
        Liste des conflits avec d√©tails et type (incompatible/mergeable)
    """
    from datetime import datetime
    
    conflicts = []
    
    # NOUVELLE LOGIQUE: Chercher TOUS les √©l√©ments du m√™me jour (pas seulement l'oppos√©)
    # On filtrera apr√®s pour d√©terminer si c'est incompatible ou fusionnable
    existing_entries = await db.disponibilites.find({
        "tenant_id": tenant_id,
        "user_id": user_id,
        "date": date
    }).to_list(length=None)
    
    # Convertir les heures en minutes pour comparaison
    def time_to_minutes(time_str):
        h, m = map(int, time_str.split(':'))
        return h * 60 + m
    
    new_start = time_to_minutes(heure_debut)
    new_end = time_to_minutes(heure_fin)
    
    # R√©cup√©rer les types de garde pour affichage
    types_garde_map = {}
    types_garde_list = await db.types_garde.find({"tenant_id": tenant_id}).to_list(length=None)
    for tg in types_garde_list:
        types_garde_map[tg["id"]] = tg.get("nom", "N/A")
    
    for entry in existing_entries:
        existing_start = time_to_minutes(entry["heure_debut"])
        existing_end = time_to_minutes(entry["heure_fin"])
        
        # V√©rifier le chevauchement
        if not (new_end <= existing_start or new_start >= existing_end):
            # Il y a chevauchement
            overlap_start = max(new_start, existing_start)
            overlap_end = min(new_end, existing_end)
            
            # Convertir retour en HH:MM
            def minutes_to_time(minutes):
                h = minutes // 60
                m = minutes % 60
                return f"{h:02d}:{m:02d}"
            
            # D√©terminer le type de conflit
            is_same_type = entry["statut"] == element_type
            
            # V√©rifier si c'est une couverture compl√®te (fusionnable)
            is_covered = (existing_start <= new_start and existing_end >= new_end)
            
            conflict_detail = {
                "conflict_id": entry["id"],
                "conflict_type": entry["statut"],
                "date": entry["date"],
                "heure_debut": entry["heure_debut"],
                "heure_fin": entry["heure_fin"],
                "type_garde_id": entry.get("type_garde_id"),
                "type_garde_nom": types_garde_map.get(entry.get("type_garde_id"), "Tous types"),
                "statut": entry["statut"],
                "overlap_start": minutes_to_time(overlap_start),
                "overlap_end": minutes_to_time(overlap_end),
                "origine": entry.get("origine", "manuelle"),
                "conflict_severity": "compatible_covered" if (is_same_type and is_covered) else ("compatible_overlap" if is_same_type else "incompatible")
            }
            
            # Ajouter un message descriptif
            if is_same_type and is_covered:
                conflict_detail["message"] = "Cette plage horaire est d√©j√† couverte par une entr√©e existante."
            elif is_same_type:
                conflict_detail["message"] = f"Chevauchement avec une autre {element_type}. Fusion automatique possible."
            else:
                action = "disponibilit√©" if element_type == "disponibilite" else "indisponibilit√©"
                conflict = "indisponibilit√©" if entry["statut"] == "indisponible" else "disponibilit√©"
                conflict_detail["message"] = f"Incompatible: Vous essayez d'ajouter une {action} alors qu'une {conflict} existe d√©j√†."
            
            conflicts.append(conflict_detail)
    
    return conflicts

# Disponibilit√©s routes
@api_router.post("/{tenant_slug}/disponibilites", response_model=Disponibilite)
async def create_disponibilite(
    tenant_slug: str, 
    disponibilite: DisponibiliteCreate, 
    force: bool = False,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une disponibilit√© avec d√©tection de conflits
    
    R√àGLE: Premier arriv√©, premier servi
    - Si une indisponibilit√© existe ‚Üí impossible d'ajouter une disponibilit√© sur la m√™me p√©riode
    - Si une disponibilit√© existe ‚Üí impossible d'ajouter une indisponibilit√© sur la m√™me p√©riode
    """
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # TOUJOURS d√©tecter les conflits incompatibles (dispo vs indispo)
    conflicts = await detect_conflicts(
        tenant_id=tenant.id,
        user_id=disponibilite.user_id,
        date=disponibilite.date,
        heure_debut=disponibilite.heure_debut,
        heure_fin=disponibilite.heure_fin,
        type_garde_id=disponibilite.type_garde_id,
        element_type="disponibilite"
    )
    
    if conflicts:
        # S√©parer les conflits incompatibles des compatibles
        incompatible_conflicts = [c for c in conflicts if c.get("conflict_severity") == "incompatible"]
        compatible_conflicts = [c for c in conflicts if c.get("conflict_severity") in ["compatible_overlap", "compatible_covered"]]
        
        # R√àGLE STRICTE: Les conflits incompatibles (dispo vs indispo) sont TOUJOURS refus√©s
        # Pas de possibilit√© de forcer - premier arriv√©, premier servi
        if incompatible_conflicts:
            conflit = incompatible_conflicts[0]
            statut_existant = "indisponibilit√©" if conflit.get("statut") == "indisponible" else "disponibilit√©"
            statut_nouveau = "disponibilit√©" if disponibilite.statut == "disponible" else "indisponibilit√©"
            raise HTTPException(
                status_code=409,
                detail=f"Conflit d√©tect√© : Une {statut_existant} existe d√©j√† pour cette p√©riode ({conflit.get('heure_debut', '?')} - {conflit.get('heure_fin', '?')}). "
                       f"Impossible d'ajouter une {statut_nouveau} en conflit. Supprimez d'abord l'entr√©e existante si vous souhaitez la modifier."
            )
        
        # Si conflit couvert compl√®tement, ne rien cr√©er (d√©j√† existe)
        if any(c.get("conflict_severity") == "compatible_covered" for c in conflicts):
            raise HTTPException(
                status_code=409,
                detail="Cette disponibilit√© est d√©j√† couverte par une entr√©e existante"
            )
        
        # Si seulement des conflits compatibles (chevauchement dispo-dispo) et pas de force
        if compatible_conflicts and not force:
            raise HTTPException(
                status_code=409,
                detail={
                    "message": "Chevauchement d√©tect√© avec une disponibilit√© existante - Fusion possible",
                    "conflicts": compatible_conflicts,
                    "new_item": disponibilite.dict(),
                    "action_required": "merge"  # Proposer la fusion automatique
                }
            )
    
    # Cr√©er la disponibilit√©
    dispo_dict = disponibilite.dict()
    dispo_dict["tenant_id"] = tenant.id
    disponibilite_obj = Disponibilite(**dispo_dict)
    await db.disponibilites.insert_one(disponibilite_obj.dict())
    
    # Cr√©er une activit√© (seulement si l'utilisateur modifie ses propres disponibilit√©s)
    if disponibilite.user_id == current_user.id:
        statut_text = "disponible" if disponibilite.statut == "disponible" else "indisponible"
        type_garde = await db.types_garde.find_one({"id": disponibilite.type_garde_id, "tenant_id": tenant.id})
        garde_text = f" pour la garde '{type_garde['nom']}'" if type_garde else ""
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="disponibilite_ajout",
            description=f"üìÖ {current_user.prenom} {current_user.nom} s'est d√©clar√©(e) {statut_text}{garde_text} le {disponibilite.date}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": current_user.id}
        )
    
    return disponibilite_obj

# ===== EXPORTS DISPONIBILITES =====

@api_router.get("/{tenant_slug}/disponibilites/export-pdf")
async def export_disponibilites_pdf(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des disponibilit√©s en PDF"""
    try:
        from reportlab.lib.pagesizes import letter
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les disponibilit√©s
        if user_id:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id,
                "user_id": user_id
            }).to_list(length=None)
            users_list = [await db.users.find_one({"id": user_id, "tenant_id": tenant.id})]
        else:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id
            }).to_list(length=None)
            users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        
        # Cr√©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(tenant, pagesize=letter)
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Titre
        titre = "Disponibilit√©s du Personnel Temps Partiel"
        if user_id and user_id in users_map:
            titre = f"Disponibilit√©s de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        
        elements.append(Paragraph(titre, modern_styles['title']))
        elements.append(Spacer(1, 0.3*inch))
        
        # Construire le tableau
        table_data = [['Date', 'Heure D√©but', 'Heure Fin', 'Statut', 'Type Garde', 'Pompier']]
        
        for dispo in sorted(disponibilites_list, key=lambda x: x.get('date', '')):
            user = users_map.get(dispo['user_id'], {})
            pompier_nom = f"{user.get('prenom', '')} {user.get('nom', '')}" if user else "N/A"
            
            statut_fr = {
                'disponible': 'Disponible',
                'indisponible': 'Indisponible',
                'conge': 'Cong√©'
            }.get(dispo.get('statut', ''), dispo.get('statut', ''))
            
            table_data.append([
                dispo.get('date', 'N/A'),
                dispo.get('heure_debut', 'N/A'),
                dispo.get('heure_fin', 'N/A'),
                statut_fr,
                dispo.get('type_garde_id', 'Tous') if dispo.get('type_garde_id') else 'Tous',
                pompier_nom if not user_id else ''
            ])
        
        # Si pas de user_id, afficher la colonne pompier, sinon la cacher
        if user_id:
            table_data = [[row[i] for i in range(5)] for row in table_data]
        
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('TOPPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        elements.append(table)
        doc.build(elements)
        buffer.seek(0)
        
        filename = f"disponibilites_{user_id if user_id else 'tous'}.pdf"
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/disponibilites/export-excel")
async def export_disponibilites_excel(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des disponibilit√©s en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les disponibilit√©s
        if user_id:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id,
                "user_id": user_id
            }).to_list(length=None)
            users_list = [await db.users.find_one({"id": user_id, "tenant_id": tenant.id})]
        else:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id
            }).to_list(length=None)
            users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        
        # Cr√©er le workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Disponibilit√©s"
        
        # Styles
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        # En-t√™tes
        headers = ['Date', 'Heure D√©but', 'Heure Fin', 'Statut', 'Type Garde']
        if not user_id:
            headers.append('Pompier')
        
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = Alignment(horizontal='center')
            cell.border = border
        
        # Donn√©es
        row = 2
        for dispo in sorted(disponibilites_list, key=lambda x: x.get('date', '')):
            user = users_map.get(dispo['user_id'], {})
            pompier_nom = f"{user.get('prenom', '')} {user.get('nom', '')}" if user else "N/A"
            
            statut_fr = {
                'disponible': 'Disponible',
                'indisponible': 'Indisponible',
                'conge': 'Cong√©'
            }.get(dispo.get('statut', ''), dispo.get('statut', ''))
            
            data_row = [
                dispo.get('date', 'N/A'),
                dispo.get('heure_debut', 'N/A'),
                dispo.get('heure_fin', 'N/A'),
                statut_fr,
                dispo.get('type_garde_id', 'Tous') if dispo.get('type_garde_id') else 'Tous'
            ]
            
            if not user_id:
                data_row.append(pompier_nom)
            
            for col, value in enumerate(data_row, 1):
                cell = ws.cell(row=row, column=col, value=value)
                cell.border = border
                cell.alignment = Alignment(horizontal='center')
            
            row += 1
        
        # Ajuster la largeur des colonnes
        for column in ws.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column_letter].width = adjusted_width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        filename = f"disponibilites_{user_id if user_id else 'tous'}.xlsx"
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")

@api_router.get("/{tenant_slug}/disponibilites/statut-blocage")
async def get_statut_blocage_disponibilites(
    tenant_slug: str,
    mois: Optional[str] = None,  # Format YYYY-MM
    current_user: User = Depends(get_current_user)
):
    """
    V√©rifie si la saisie des disponibilit√©s est bloqu√©e pour un mois donn√©.
    Retourne l'√©tat du blocage et les informations associ√©es.
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les param√®tres
    params = await db.parametres_disponibilites.find_one({"tenant_id": tenant.id})
    
    if not params:
        return {
            "bloque": False,
            "raison": "Param√®tres non configur√©s",
            "blocage_actif": False
        }
    
    blocage_actif = params.get("blocage_dispos_active", False)
    
    if not blocage_actif:
        return {
            "bloque": False,
            "raison": "Syst√®me de blocage d√©sactiv√©",
            "blocage_actif": False
        }
    
    # D√©terminer le mois cible
    today = datetime.now(timezone.utc).date()
    
    if mois:
        try:
            mois_parts = mois.split("-")
            mois_annee = int(mois_parts[0])
            mois_mois = int(mois_parts[1])
        except:
            raise HTTPException(status_code=400, detail="Format de mois invalide. Utilisez YYYY-MM")
    else:
        # Par d√©faut, v√©rifier pour le mois suivant
        if today.month == 12:
            mois_mois = 1
            mois_annee = today.year + 1
        else:
            mois_mois = today.month + 1
            mois_annee = today.year
    
    jour_blocage = params.get("jour_blocage_dispos", 15)
    exceptions_admin = params.get("exceptions_admin_superviseur", True)
    
    # Logique de blocage:
    # La date de blocage (ex: 15 janvier) concerne les disponibilit√©s du mois SUIVANT (f√©vrier)
    # Apr√®s le 15 janvier: 
    #   - F√©vrier est BLOQU√â
    #   - Mars et au-del√† restent LIBRES
    
    # Date de blocage = jour X du mois courant
    try:
        date_blocage = date(today.year, today.month, jour_blocage)
    except ValueError:
        # Si le jour n'existe pas dans ce mois (ex: 31 f√©vrier), prendre le dernier jour
        import calendar
        dernier_jour = calendar.monthrange(today.year, today.month)[1]
        date_blocage = date(today.year, today.month, min(jour_blocage, dernier_jour))
    
    # Quel mois est concern√© par ce blocage ? Le mois SUIVANT le mois courant
    if today.month == 12:
        mois_bloque = 1
        annee_mois_bloque = today.year + 1
    else:
        mois_bloque = today.month + 1
        annee_mois_bloque = today.year
    
    # V√©rifier si le mois demand√© (mois_cible) est concern√© par le blocage
    # Le blocage s'applique SI:
    # 1. On est APR√àS la date de blocage (ex: apr√®s le 15 janvier)
    # 2. ET le mois demand√© est le mois suivant (f√©vrier) OU un mois pass√©
    
    est_apres_date_limite = today > date_blocage
    mois_cible_est_passe = (mois_annee < today.year) or (mois_annee == today.year and mois_mois <= today.month)
    mois_cible_est_le_mois_bloque = (mois_annee == annee_mois_bloque and mois_mois == mois_bloque)
    
    # Le mois est bloqu√© si:
    # - C'est un mois pass√© ou le mois courant (on ne peut pas modifier le pass√©)
    # - OU c'est le mois suivant ET on est apr√®s la date limite
    est_bloque = mois_cible_est_passe or (est_apres_date_limite and mois_cible_est_le_mois_bloque)
    
    # V√©rifier les exceptions pour admin/superviseur
    if est_bloque and exceptions_admin and current_user.role in ["admin", "superviseur"]:
        return {
            "bloque": False,
            "raison": "Exception admin/superviseur active",
            "blocage_actif": True,
            "date_blocage": date_blocage.isoformat(),
            "exception_appliquee": True,
            "mois_cible": f"{mois_annee}-{str(mois_mois).zfill(2)}"
        }
    
    mois_noms = ["janvier", "f√©vrier", "mars", "avril", "mai", "juin", 
                 "juillet", "ao√ªt", "septembre", "octobre", "novembre", "d√©cembre"]
    
    if est_bloque:
        if mois_cible_est_passe:
            raison = f"Ce mois est pass√© ou en cours, modification impossible"
        else:
            raison = f"La date limite ({jour_blocage} {mois_noms[today.month - 1]}) pour {mois_noms[mois_mois - 1]} est d√©pass√©e"
        
        return {
            "bloque": True,
            "raison": raison,
            "blocage_actif": True,
            "date_blocage": date_blocage.isoformat(),
            "mois_cible": f"{mois_annee}-{str(mois_mois).zfill(2)}"
        }
    else:
        jours_restants = (date_blocage - today).days
        if jours_restants < 0:
            # On est apr√®s la date limite mais le mois demand√© n'est pas bloqu√© (mois futur)
            return {
                "bloque": False,
                "raison": f"Mois futur - saisie libre",
                "blocage_actif": True,
                "date_blocage": date_blocage.isoformat(),
                "mois_cible": f"{mois_annee}-{str(mois_mois).zfill(2)}"
            }
        else:
            return {
                "bloque": False,
                "raison": f"Saisie autoris√©e jusqu'au {jour_blocage} {mois_noms[today.month - 1]}",
                "blocage_actif": True,
                "date_blocage": date_blocage.isoformat(),
                "jours_restants": jours_restants,
                "mois_cible": f"{mois_annee}-{str(mois_mois).zfill(2)}"
            }


@api_router.get("/{tenant_slug}/disponibilites/{user_id}", response_model=List[Disponibilite])
async def get_user_disponibilites(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    disponibilites = await db.disponibilites.find({
        "user_id": user_id,
        "tenant_id": tenant.id
    }).to_list(1000)
    cleaned_disponibilites = [clean_mongo_doc(dispo) for dispo in disponibilites]
    return [Disponibilite(**dispo) for dispo in cleaned_disponibilites]

@api_router.post("/{tenant_slug}/disponibilites/resolve-conflict")
async def resolve_disponibilite_conflict(
    tenant_slug: str,
    data: Dict[str, Any] = Body(...),
    current_user: User = Depends(get_current_user)
):
    """
    R√©sout un conflit lors de la cr√©ation d'une disponibilit√©
    
    Actions possibles:
    - supprimer_conflits: Supprime les indisponibilit√©s en conflit et cr√©e la disponibilit√©
    - creer_quand_meme: Cr√©e la disponibilit√© sans supprimer les conflits
    - annuler: Ne fait rien
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    action = data.get("action")  # "supprimer_conflits", "creer_quand_meme", "annuler"
    new_item_data = data.get("new_item")
    conflict_ids = data.get("conflict_ids", [])
    
    if action == "annuler":
        return {"message": "Op√©ration annul√©e", "action": "annuler"}
    
    # R√©cup√©rer les d√©tails des conflits avant suppression pour l'historique
    conflicts_to_delete = []
    if action == "supprimer_conflits" and conflict_ids:
        for conflict_id in conflict_ids:
            conflict_doc = await db.disponibilites.find_one({"id": conflict_id, "tenant_id": tenant.id})
            if conflict_doc:
                conflicts_to_delete.append(conflict_doc)
        
        # Supprimer les conflits
        await db.disponibilites.delete_many({
            "id": {"$in": conflict_ids},
            "tenant_id": tenant.id
        })
        
        # Notifier l'utilisateur affect√© si diff√©rent de l'utilisateur courant
        affected_user_id = new_item_data.get("user_id")
        if affected_user_id != current_user.id:
            notification = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant.id,
                "user_id": affected_user_id,
                "titre": "Indisponibilit√©s modifi√©es",
                "message": f"{len(conflict_ids)} indisponibilit√©(s) supprim√©e(s) en raison d'un conflit avec une nouvelle disponibilit√©",
                "type": "disponibilite",
                "lue": False,
                "created_at": datetime.now(timezone.utc).isoformat()
            }
            await db.notifications.insert_one(notification)
    
    # Cr√©er la disponibilit√©
    dispo_dict = new_item_data.copy()
    dispo_dict["tenant_id"] = tenant.id
    dispo_dict["id"] = str(uuid.uuid4())
    dispo_dict["created_at"] = datetime.now(timezone.utc).isoformat()
    
    await db.disponibilites.insert_one(dispo_dict)
    
    # Enregistrer dans l'historique
    resolution = ConflictResolution(
        tenant_id=tenant.id,
        user_id=current_user.id,
        affected_user_id=new_item_data.get("user_id"),
        action=action,
        type_created="disponibilite",
        conflicts_deleted=conflicts_to_delete,
        created_item=dispo_dict
    )
    await db.conflict_resolutions.insert_one(resolution.dict())
    
    return {
        "message": f"Disponibilit√© cr√©√©e avec succ√®s. Action: {action}",
        "action": action,
        "conflicts_deleted": len(conflicts_to_delete),
        "created_item": dispo_dict
    }

@api_router.put("/{tenant_slug}/disponibilites/{user_id}")
@api_router.put("/{tenant_slug}/disponibilites/{user_id}")
async def update_user_disponibilites(tenant_slug: str, user_id: str, disponibilites: List[DisponibiliteCreate], current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # S√âCURIT√â: V√©rifier le blocage des disponibilit√©s pour chaque mois concern√©
    if disponibilites:
        mois_concernes = set()
        for dispo in disponibilites:
            # Extraire le mois de la date de d√©but
            date_debut = dispo.date_debut
            if isinstance(date_debut, str):
                try:
                    date_debut = datetime.fromisoformat(date_debut.replace('Z', '+00:00'))
                except:
                    continue
            if hasattr(date_debut, 'year') and hasattr(date_debut, 'month'):
                mois_concernes.add(f"{date_debut.year}-{str(date_debut.month).zfill(2)}")
        
        # V√©rifier le blocage pour chaque mois
        for mois in mois_concernes:
            # R√©cup√©rer les param√®tres de blocage
            params = await db.parametres_disponibilites.find_one({"tenant_id": tenant.id})
            if params and params.get("blocage_dispos_active", False):
                from datetime import date as date_type
                today = datetime.now(timezone.utc).date()
                jour_blocage = params.get("jour_blocage_dispos", 15)
                exceptions_admin = params.get("exceptions_admin_superviseur", True)
                
                # Parser le mois
                mois_parts = mois.split("-")
                mois_annee = int(mois_parts[0])
                mois_mois = int(mois_parts[1])
                
                # Calculer si le mois est bloqu√©
                try:
                    date_blocage = date_type(today.year, today.month, jour_blocage)
                except ValueError:
                    import calendar
                    dernier_jour = calendar.monthrange(today.year, today.month)[1]
                    date_blocage = date_type(today.year, today.month, min(jour_blocage, dernier_jour))
                
                # Mois suivant = mois bloqu√© apr√®s la date limite
                if today.month == 12:
                    mois_bloque = 1
                    annee_mois_bloque = today.year + 1
                else:
                    mois_bloque = today.month + 1
                    annee_mois_bloque = today.year
                
                est_apres_date_limite = today > date_blocage
                mois_cible_est_passe = (mois_annee < today.year) or (mois_annee == today.year and mois_mois <= today.month)
                mois_cible_est_le_mois_bloque = (mois_annee == annee_mois_bloque and mois_mois == mois_bloque)
                
                est_bloque = mois_cible_est_passe or (est_apres_date_limite and mois_cible_est_le_mois_bloque)
                
                # Exception pour admin/superviseur
                if est_bloque and exceptions_admin and current_user.role in ["admin", "superviseur"]:
                    est_bloque = False
                
                if est_bloque:
                    raise HTTPException(
                        status_code=403, 
                        detail=f"La saisie des disponibilit√©s pour {mois} est bloqu√©e. Date limite d√©pass√©e."
                    )
    
    # Delete existing disponibilit√©s for this user dans ce tenant
    await db.disponibilites.delete_many({"user_id": user_id, "tenant_id": tenant.id})
    
    # Insert new disponibilit√©s
    if disponibilites:
        dispo_docs = []
        for dispo in disponibilites:
            dispo_dict = dispo.dict()
            dispo_dict["tenant_id"] = tenant.id
            dispo_obj = Disponibilite(**dispo_dict)
            dispo_docs.append(dispo_obj.dict())
        
        await db.disponibilites.insert_many(dispo_docs)
    
    return {"message": f"Disponibilit√©s mises √† jour avec succ√®s ({len(disponibilites)} entr√©es)"}


@api_router.post("/{tenant_slug}/disponibilites/import-csv")
async def import_disponibilites_csv(
    tenant_slug: str,
    disponibilites_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Import en masse de disponibilit√©s depuis un CSV/XLS"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    disponibilites = disponibilites_data.get("disponibilites", [])
    if not disponibilites:
        raise HTTPException(status_code=400, detail="Aucune disponibilit√© √† importer")
    
    # S√âCURIT√â: V√©rifier le blocage des disponibilit√©s
    params = await db.parametres_disponibilites.find_one({"tenant_id": tenant.id})
    blocage_actif = params and params.get("blocage_dispos_active", False)
    exceptions_admin = params.get("exceptions_admin_superviseur", True) if params else True
    
    # Fonction locale pour v√©rifier si un mois est bloqu√©
    def is_month_blocked(mois_str):
        if not blocage_actif:
            return False
        
        from datetime import date as date_type
        today = datetime.now(timezone.utc).date()
        jour_blocage = params.get("jour_blocage_dispos", 15)
        
        mois_parts = mois_str.split("-")
        mois_annee = int(mois_parts[0])
        mois_mois = int(mois_parts[1])
        
        try:
            date_blocage = date_type(today.year, today.month, jour_blocage)
        except ValueError:
            import calendar
            dernier_jour = calendar.monthrange(today.year, today.month)[1]
            date_blocage = date_type(today.year, today.month, min(jour_blocage, dernier_jour))
        
        if today.month == 12:
            mois_bloque_num = 1
            annee_mois_bloque = today.year + 1
        else:
            mois_bloque_num = today.month + 1
            annee_mois_bloque = today.year
        
        est_apres_date_limite = today > date_blocage
        mois_cible_est_passe = (mois_annee < today.year) or (mois_annee == today.year and mois_mois <= today.month)
        mois_cible_est_le_mois_bloque = (mois_annee == annee_mois_bloque and mois_mois == mois_bloque_num)
        
        est_bloque = mois_cible_est_passe or (est_apres_date_limite and mois_cible_est_le_mois_bloque)
        
        # Exception pour admin/superviseur
        if est_bloque and exceptions_admin and current_user.role in ["admin", "superviseur"]:
            return False
        
        return est_bloque
    
    results = {
        "total": len(disponibilites),
        "created": 0,
        "updated": 0,
        "errors": [],
        "skipped": 0,
        "blocked": 0
    }
    
    # Pr√©charger les utilisateurs et types de garde pour optimisation
    users_list = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
    users_by_num = {u.get("numero_employe"): u for u in users_list if u.get("numero_employe")}
    users_by_name = create_user_matching_index(users_list)
    
    types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(100)
    types_garde_by_name = {tg.get("nom", "").strip().lower(): tg for tg in types_garde_list}
    
    for index, dispo_data in enumerate(disponibilites):
        try:
            # 1. Trouver l'utilisateur avec matching intelligent (fuzzy)
            # Supporter les anciennes cl√©s (Employ√©) et nouvelles cl√©s (employe) pour compatibilit√©
            employe_str = dispo_data.get("employe", dispo_data.get("Employ√©", "")).strip()
            if not employe_str:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": "Employ√© manquant"
                })
                continue
            
            # Utiliser la fonction de matching intelligent (recherche fuzzy)
            # G√®re les espaces doubles, accents, ordre des noms, etc.
            user_obj = find_user_intelligent(
                search_string=employe_str,
                users_by_name=users_by_name,
                users_by_num=users_by_num,
                numero_field="numero_employe"
            )
            
            if not user_obj:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"Employ√© non trouv√© avec recherche fuzzy: {employe_str}"
                })
                continue
            
            # 2. Parser les dates/heures
            debut_str = str(dispo_data.get("debut", dispo_data.get("D√©but", ""))).strip()
            fin_str = str(dispo_data.get("fin", dispo_data.get("Fin", ""))).strip()
            
            if not debut_str or not fin_str:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": "Date/heure de d√©but ou fin manquante"
                })
                continue
            
            try:
                # Parser les dates/heures - supporter plusieurs formats
                from datetime import datetime as dt
                
                # Essayer format standard: "2025-12-01 06:00"
                try:
                    debut_dt = dt.strptime(debut_str, "%Y-%m-%d %H:%M")
                    fin_dt = dt.strptime(fin_str, "%Y-%m-%d %H:%M")
                except ValueError:
                    # Essayer format avec secondes: "2025-12-01 06:00:00"
                    debut_dt = dt.strptime(debut_str, "%Y-%m-%d %H:%M:%S")
                    fin_dt = dt.strptime(fin_str, "%Y-%m-%d %H:%M:%S")
                
                date_str = debut_dt.strftime("%Y-%m-%d")
                heure_debut = debut_dt.strftime("%H:%M")
                heure_fin = fin_dt.strftime("%H:%M")
                
            except ValueError as e:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"Format de date/heure invalide: {e}"
                })
                continue
            
            # S√âCURIT√â: V√©rifier le blocage pour ce mois
            mois_str = debut_dt.strftime("%Y-%m")
            if is_month_blocked(mois_str):
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"Mois {mois_str} bloqu√© - date limite d√©pass√©e"
                })
                results["blocked"] += 1
                continue
            
            # 3. Mapper la s√©lection au statut (avec valeur par d√©faut "Disponible")
            selection = dispo_data.get("selection", dispo_data.get("S√©lection", "Disponible")).strip().lower()
            
            # Si "Aucune", ignorer cette ligne (ne pas cr√©er de disponibilit√©)
            if selection == "aucune":
                results["skipped"] += 1
                continue
            
            # Mapper les valeurs √† "disponible"
            if selection in ["disponible", "disponibilit√©", ""]:
                statut = "disponible"
            else:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"S√©lection invalide: '{selection}'. Attendu: 'Disponible' ou 'Aucune'"
                })
                continue
            
            # 4. Trouver le type de garde (optionnel)
            type_garde_id = None
            quart_str = dispo_data.get("quart", dispo_data.get("Quart", "")).strip().lower()
            if quart_str:
                type_garde_obj = types_garde_by_name.get(quart_str)
                if type_garde_obj:
                    type_garde_id = type_garde_obj.get("id")
            
            # 5. V√©rifier si une disponibilit√© existe d√©j√†
            existing = await db.disponibilites.find_one({
                "tenant_id": tenant.id,
                "user_id": user_obj["id"],
                "date": date_str,
                "heure_debut": heure_debut,
                "heure_fin": heure_fin
            })
            
            dispo_obj = Disponibilite(
                tenant_id=tenant.id,
                user_id=user_obj["id"],
                date=date_str,
                heure_debut=heure_debut,
                heure_fin=heure_fin,
                statut=statut,
                type_garde_id=type_garde_id,
                origine="import_csv"
            )
            
            if existing:
                # Mettre √† jour
                await db.disponibilites.update_one(
                    {"id": existing["id"]},
                    {"$set": dispo_obj.dict()}
                )
                results["updated"] += 1
            else:
                # Cr√©er nouveau
                await db.disponibilites.insert_one(dispo_obj.dict())
                results["created"] += 1
                
        except Exception as e:
            results["errors"].append({
                "ligne": index + 2,
                "erreur": str(e)
            })
    
    # Cr√©er une activit√©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="import_disponibilites",
        description=f"üìä {current_user.prenom} {current_user.nom} a import√© {results['created'] + results['updated']} disponibilit√©s ({results['created']} cr√©√©es, {results['updated']} mises √† jour, {results['skipped']} ignor√©es)",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return results


# ===== EXPORTS DISPONIBILITES =====

@api_router.get("/{tenant_slug}/disponibilites/export-pdf")
async def export_disponibilites_pdf(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des disponibilit√©s en PDF"""
    try:
        from reportlab.lib.pagesizes import letter
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.enums import TA_CENTER
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les disponibilit√©s
        if user_id:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id,
                "user_id": user_id
            }).to_list(length=None)
            users_list = [await db.users.find_one({"id": user_id, "tenant_id": tenant.id})]
        else:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id
            }).to_list(length=None)
            users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        
        # Cr√©er le PDF avec branding
        buffer, doc, elements = create_branded_pdf(tenant, pagesize=letter)
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Titre
        titre = "Disponibilit√©s du Personnel Temps Partiel"
        if user_id and user_id in users_map:
            titre = f"Disponibilit√©s de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        
        elements.append(Paragraph(titre, modern_styles['title']))
        elements.append(Spacer(1, 0.3*inch))
        
        # Construire le tableau
        table_data = [['Date', 'Heure D√©but', 'Heure Fin', 'Statut', 'Type Garde', 'Pompier']]
        
        for dispo in sorted(disponibilites_list, key=lambda x: x.get('date', '')):
            user = users_map.get(dispo['user_id'], {})
            pompier_nom = f"{user.get('prenom', '')} {user.get('nom', '')}" if user else "N/A"
            
            statut_fr = {
                'disponible': 'Disponible',
                'indisponible': 'Indisponible',
                'conge': 'Cong√©'
            }.get(dispo.get('statut', ''), dispo.get('statut', ''))
            
            table_data.append([
                dispo.get('date', 'N/A'),
                dispo.get('heure_debut', 'N/A'),
                dispo.get('heure_fin', 'N/A'),
                statut_fr,
                dispo.get('type_garde_id', 'Tous') if dispo.get('type_garde_id') else 'Tous',
                pompier_nom if not user_id else ''
            ])
        
        # Si pas de user_id, afficher la colonne pompier, sinon la cacher
        if user_id:
            table_data = [[row[i] for i in range(5)] for row in table_data]
        
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('TOPPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
        ]))
        
        elements.append(table)
        doc.build(elements)
        buffer.seek(0)
        
        filename = f"disponibilites_{user_id if user_id else 'tous'}.pdf"
        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export PDF: {str(e)}")


@api_router.get("/{tenant_slug}/disponibilites/export-excel")
async def export_disponibilites_excel(
    tenant_slug: str,
    user_id: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export des disponibilit√©s en Excel"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO
        
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les disponibilit√©s
        if user_id:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id,
                "user_id": user_id
            }).to_list(length=None)
            users_list = [await db.users.find_one({"id": user_id, "tenant_id": tenant.id})]
        else:
            disponibilites_list = await db.disponibilites.find({
                "tenant_id": tenant.id
            }).to_list(length=None)
            users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        
        users_map = {u['id']: u for u in users_list}
        
        # Cr√©er le workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Disponibilit√©s"
        
        # Styles
        header_fill = PatternFill(start_color="FCA5A5", end_color="FCA5A5", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        center_alignment = Alignment(horizontal="center", vertical="center")
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        # Titre
        ws.merge_cells('A1:F1')
        titre = "Disponibilit√©s du Personnel Temps Partiel"
        if user_id and user_id in users_map:
            titre = f"Disponibilit√©s de {users_map[user_id]['prenom']} {users_map[user_id]['nom']}"
        ws['A1'] = titre
        ws['A1'].font = Font(bold=True, size=16, color="EF4444")
        ws['A1'].alignment = center_alignment
        
        # En-t√™tes
        row = 3
        if user_id:
            headers = ['Date', 'Heure D√©but', 'Heure Fin', 'Statut', 'Type Garde']
        else:
            headers = ['Date', 'Heure D√©but', 'Heure Fin', 'Statut', 'Type Garde', 'Pompier']
        
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=row, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = center_alignment
            cell.border = border
        
        # Donn√©es
        row += 1
        for dispo in sorted(disponibilites_list, key=lambda x: x.get('date', '')):
            user = users_map.get(dispo['user_id'], {})
            pompier_nom = f"{user.get('prenom', '')} {user.get('nom', '')}" if user else "N/A"
            
            statut_fr = {
                'disponible': 'Disponible',
                'indisponible': 'Indisponible',
                'conge': 'Cong√©'
            }.get(dispo.get('statut', ''), dispo.get('statut', ''))
            
            ws.cell(row=row, column=1, value=dispo.get('date', 'N/A'))
            ws.cell(row=row, column=2, value=dispo.get('heure_debut', 'N/A'))
            ws.cell(row=row, column=3, value=dispo.get('heure_fin', 'N/A'))
            status_cell = ws.cell(row=row, column=4, value=statut_fr)
            ws.cell(row=row, column=5, value=dispo.get('type_garde_id', 'Tous') if dispo.get('type_garde_id') else 'Tous')
            
            if not user_id:
                ws.cell(row=row, column=6, value=pompier_nom)
            
            # Couleur statut
            if dispo.get('statut') == 'disponible':
                status_cell.fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
            elif dispo.get('statut') == 'indisponible':
                status_cell.fill = PatternFill(start_color="FEE2E2", end_color="FEE2E2", fill_type="solid")
            else:
                status_cell.fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
            
            for col in range(1, len(headers) + 1):
                ws.cell(row=row, column=col).border = border
                ws.cell(row=row, column=col).alignment = center_alignment
            
            row += 1
        
        # Ajuster les largeurs de colonnes
        column_widths = {
            'A': 12,  # Date
            'B': 15,  # Type Garde
            'C': 20,  # Demandeur
            'D': 12,  # Statut
            'E': 10,  # Priorit√©
            'F': 20,  # Rempla√ßant
            'G': 30,  # Notes
            'H': 18,  # Cr√©√© le
        }
        for col_letter, width in column_widths.items():
            ws.column_dimensions[col_letter].width = width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        filename = f"disponibilites_{user_id if user_id else 'tous'}.xlsx"
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export Excel: {str(e)}")


@api_router.delete("/{tenant_slug}/disponibilites/reinitialiser")
async def reinitialiser_disponibilites(
    tenant_slug: str,
    reinit_data: DisponibiliteReinitialiser,
    current_user: User = Depends(get_current_user)
):
    """
    R√©initialise les disponibilit√©s/indisponibilit√©s pour une p√©riode donn√©e
    """
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier les permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.id != reinit_data.user_id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Calculer les dates de d√©but et fin selon la p√©riode
        today = datetime.now(timezone.utc).date()
        
        if reinit_data.periode == "semaine":
            # Semaine courante : lundi √† dimanche
            days_since_monday = today.weekday()  # 0 = lundi, 6 = dimanche
            date_debut = today - timedelta(days=days_since_monday)
            date_fin = date_debut + timedelta(days=6)
        elif reinit_data.periode == "mois":
            # Mois courant : 1er du mois √† dernier jour
            date_debut = today.replace(day=1)
            # Dernier jour du mois
            if today.month == 12:
                date_fin = today.replace(day=31)
            else:
                next_month = today.replace(month=today.month + 1, day=1)
                date_fin = next_month - timedelta(days=1)
        elif reinit_data.periode == "mois_prochain":
            # Mois prochain : 1er du mois prochain √† dernier jour du mois prochain
            if today.month == 12:
                # Si on est en d√©cembre, mois prochain = janvier de l'ann√©e suivante
                date_debut = today.replace(year=today.year + 1, month=1, day=1)
                next_next_month = date_debut.replace(month=2, day=1)
                date_fin = next_next_month - timedelta(days=1)
            else:
                # Mois prochain
                date_debut = today.replace(month=today.month + 1, day=1)
                # Dernier jour du mois prochain
                if today.month == 11:
                    # Si on est en novembre, mois prochain = d√©cembre
                    date_fin = date_debut.replace(day=31)
                else:
                    next_next_month = today.replace(month=today.month + 2, day=1)
                    date_fin = next_next_month - timedelta(days=1)
        elif reinit_data.periode == "annee":
            # Ann√©e courante : 1er janvier √† 31 d√©cembre
            date_debut = today.replace(month=1, day=1)
            date_fin = today.replace(month=12, day=31)
        elif reinit_data.periode == "personnalisee":
            # P√©riode personnalis√©e : dates fournies
            if not reinit_data.date_debut or not reinit_data.date_fin:
                raise HTTPException(
                    status_code=400,
                    detail="date_debut et date_fin sont requis pour une p√©riode personnalis√©e"
                )
            try:
                date_debut = datetime.fromisoformat(reinit_data.date_debut).date()
                date_fin = datetime.fromisoformat(reinit_data.date_fin).date()
                
                # Validation : date_debut <= date_fin
                if date_debut > date_fin:
                    raise HTTPException(
                        status_code=400,
                        detail="date_debut doit √™tre avant ou √©gale √† date_fin"
                    )
                
                # Validation : plage maximale de 1 an
                if (date_fin - date_debut).days > 365:
                    raise HTTPException(
                        status_code=400,
                        detail="La plage de dates ne peut pas d√©passer 1 an"
                    )
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail="Format de date invalide. Utilisez YYYY-MM-DD"
                )
        else:
            raise HTTPException(
                status_code=400,
                detail="periode doit √™tre 'semaine', 'mois', 'mois_prochain', 'annee' ou 'personnalisee'"
            )
        
        # Construire la requ√™te de suppression
        delete_query = {
            "user_id": reinit_data.user_id,
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut.isoformat(),
                "$lte": date_fin.isoformat()
            }
        }
        
        # Filtre par type d'entr√©e (disponibilit√©s/indisponibilit√©s)
        if reinit_data.type_entree == "disponibilites":
            delete_query["statut"] = "disponible"
        elif reinit_data.type_entree == "indisponibilites":
            delete_query["statut"] = "indisponible"
        elif reinit_data.type_entree != "les_deux":
            raise HTTPException(
                status_code=400,
                detail="type_entree doit √™tre 'disponibilites', 'indisponibilites' ou 'les_deux'"
            )
        
        # Si mode "generees_seulement", ne supprimer que les entr√©es g√©n√©r√©es automatiquement
        if reinit_data.mode == "generees_seulement":
            # Supprimer uniquement celles avec origine diff√©rente de "manuelle"
            # ET qui ont un champ origine (pour g√©rer les anciennes entr√©es)
            delete_query["$or"] = [
                {"origine": {"$exists": True, "$ne": "manuelle"}},
                {"origine": {"$exists": False}}  # Anciennes entr√©es sans champ origine
            ]
        elif reinit_data.mode != "tout":
            raise HTTPException(
                status_code=400,
                detail="mode doit √™tre 'tout' ou 'generees_seulement'"
            )
        
        # Supprimer les disponibilit√©s
        result = await db.disponibilites.delete_many(delete_query)
        
        return {
            "message": "R√©initialisation effectu√©e avec succ√®s",
            "periode": reinit_data.periode,
            "mode": reinit_data.mode,
            "date_debut": date_debut.isoformat(),
            "date_fin": date_fin.isoformat(),
            "nombre_supprimees": result.deleted_count
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur lors de la r√©initialisation: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la r√©initialisation: {str(e)}")

@api_router.delete("/{tenant_slug}/disponibilites/{disponibilite_id}")
async def delete_disponibilite(tenant_slug: str, disponibilite_id: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Find the disponibilit√© to check ownership dans ce tenant
    disponibilite = await db.disponibilites.find_one({
        "id": disponibilite_id,
        "tenant_id": tenant.id
    })
    if not disponibilite:
        raise HTTPException(status_code=404, detail="Disponibilit√© non trouv√©e")
    
    if current_user.role not in ["admin", "superviseur"] and current_user.id != disponibilite["user_id"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    result = await db.disponibilites.delete_one({
        "id": disponibilite_id,
        "tenant_id": tenant.id
    })
    if result.deleted_count == 0:
        raise HTTPException(status_code=400, detail="Impossible de supprimer la disponibilit√©")
    
    # Cr√©er une activit√© (seulement si l'utilisateur supprime ses propres disponibilit√©s)
    if disponibilite["user_id"] == current_user.id:
        statut_text = "disponibilit√©" if disponibilite["statut"] == "disponible" else "indisponibilit√©"
        await creer_activite(
            tenant_id=tenant.id,
            type_activite="disponibilite_suppression",
            description=f"üóëÔ∏è {current_user.prenom} {current_user.nom} a supprim√© une {statut_text} du {disponibilite['date']}",
            user_id=current_user.id,
            user_nom=f"{current_user.prenom} {current_user.nom}",
            data={"concerne_user_id": current_user.id}
        )
    
    return {"message": "Disponibilit√© supprim√©e avec succ√®s"}

# ==================== PUSH NOTIFICATIONS ROUTES ====================

@api_router.post("/{tenant_slug}/notifications/register-device")
async def register_device_token(
    tenant_slug: str,
    device_data: DeviceTokenRegister,
    current_user: User = Depends(get_current_user)
):
    """
    Enregistre un device token pour les notifications push
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que l'utilisateur enregistre son propre device
    if current_user.id != device_data.user_id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # V√©rifier si un token existe d√©j√† pour cet utilisateur et cette plateforme
        existing = await db.device_tokens.find_one({
            "user_id": device_data.user_id,
            "platform": device_data.platform
        })
        
        if existing:
            # Mettre √† jour le token existant
            await db.device_tokens.update_one(
                {"_id": existing["_id"]},
                {"$set": {
                    "device_token": device_data.device_token,
                    "updated_at": datetime.now(timezone.utc)
                }}
            )
            message = "Device token mis √† jour"
        else:
            # Cr√©er un nouveau token
            new_token = DeviceToken(
                user_id=device_data.user_id,
                device_token=device_data.device_token,
                platform=device_data.platform
            )
            await db.device_tokens.insert_one(new_token.dict())
            message = "Device token enregistr√©"
        
        return {"message": message, "platform": device_data.platform}
    
    except Exception as e:
        print(f"Erreur lors de l'enregistrement du device token: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

async def send_push_notification_to_users(user_ids: List[str], title: str, body: str, data: Optional[dict] = None, tenant_slug: str = None):
    """
    Helper function pour envoyer des notifications push √† plusieurs utilisateurs
    """
    if not firebase_admin._apps:
        print("‚ö†Ô∏è Firebase not initialized, skipping push notification")
        return
    
    try:
        # R√©cup√©rer tous les device tokens pour ces utilisateurs
        tokens_cursor = db.device_tokens.find({"user_id": {"$in": user_ids}})
        tokens_list = await tokens_cursor.to_list(length=None)
        
        if not tokens_list:
            print(f"No device tokens found for users: {user_ids}")
            return
        
        device_tokens = [token["device_token"] for token in tokens_list]
        
        # Ajouter le tenant aux donn√©es si fourni
        notification_data = data or {}
        if tenant_slug and "tenant" not in notification_data:
            notification_data["tenant"] = tenant_slug
        
        # V√©rifier si c'est une notification urgente (remplacement)
        is_urgent = notification_data.get("sound") == "urgent" or notification_data.get("type") == "remplacement_proposition"
        
        # S'assurer que toutes les valeurs sont des strings (requis par FCM)
        string_data = {k: str(v) if v is not None else "" for k, v in notification_data.items()}
        
        # Configuration Android
        android_config = messaging.AndroidConfig(
            priority="high" if is_urgent else "normal",
            notification=messaging.AndroidNotification(
                sound="default",
                priority="max" if is_urgent else "default",
                channel_id="urgent_channel" if is_urgent else "default_channel"
            )
        )
        
        # Configuration iOS/APNs
        apns_config = messaging.APNSConfig(
            payload=messaging.APNSPayload(
                aps=messaging.Aps(
                    sound=messaging.CriticalSound(name="default", critical=is_urgent, volume=1.0) if is_urgent else "default",
                    badge=1
                )
            )
        )
        
        # Cr√©er le message
        message = messaging.MulticastMessage(
            notification=messaging.Notification(
                title=title,
                body=body
            ),
            data=string_data,
            tokens=device_tokens,
            android=android_config,
            apns=apns_config
        )
        
        # Envoyer
        response = messaging.send_multicast(message)
        print(f"‚úÖ Push notification sent: {response.success_count} success, {response.failure_count} failures")
        
        # Supprimer les tokens invalides
        if response.failure_count > 0:
            failed_tokens = [device_tokens[idx] for idx, resp in enumerate(response.responses) if not resp.success]
            await db.device_tokens.delete_many({"device_token": {"$in": failed_tokens}})
            print(f"Removed {len(failed_tokens)} invalid tokens")
        
        return response
    
    except Exception as e:
        print(f"Error sending push notification: {str(e)}")
        return None

@api_router.post("/{tenant_slug}/notifications/send")
async def send_push_notification(
    tenant_slug: str,
    notification_data: PushNotificationSend,
    current_user: User = Depends(get_current_user)
):
    """
    Envoie une notification push √† des utilisateurs sp√©cifiques (Admin/Superviseur uniquement)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Seuls les admins et superviseurs peuvent envoyer des notifications
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        response = await send_push_notification_to_users(
            user_ids=notification_data.user_ids,
            title=notification_data.title,
            body=notification_data.body,
            data=notification_data.data
        )
        
        return {
            "message": "Notification envoy√©e",
            "success_count": response.success_count if response else 0,
            "failure_count": response.failure_count if response else 0
        }
    
    except Exception as e:
        print(f"Erreur lors de l'envoi de la notification: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")


# ==================== WEB PUSH NOTIFICATIONS (VAPID) ====================
# Ces endpoints permettent les notifications push sur les PWA (iOS 16.4+ et tous navigateurs)

from pywebpush import webpush, WebPushException

# Cl√©s VAPID pr√©-g√©n√©r√©es (√† configurer dans .env pour la production)
# Ces cl√©s sont utilis√©es pour authentifier le serveur aupr√®s des services push
VAPID_PRIVATE_KEY = os.environ.get('VAPID_PRIVATE_KEY', 
    'MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgDXr3Kq0TKQrEV3Rk_FBiYGrPnvKQT3qrF_H3h0sK_0mhRANCAAT5YRwxiCKfb-5mvbU4bN5cVrC9YZh5TvBKQz4TnrpNYqv0s5L0vVsJXZvVQqS_x3N3rVpSqmkDnmr7R_JQKQQE')
VAPID_PUBLIC_KEY = os.environ.get('VAPID_PUBLIC_KEY',
    'BPlhHDGIIp9v7ma9tThs3lxWsL1hmHlO8EpDPhOeuk1iq_SzkvS9WwldmVWpL_Hc3etWlKqaQOeavtH8lApBBAQ')
VAPID_CLAIMS_EMAIL = os.environ.get('VAPID_EMAIL', 'admin@profiremanager.ca')

if VAPID_PUBLIC_KEY:
    logging.info(f"‚úÖ Web Push configur√© avec cl√© VAPID: {VAPID_PUBLIC_KEY[:20]}...")
else:
    logging.warning("‚ö†Ô∏è Web Push d√©sactiv√©: cl√©s VAPID non configur√©es")


class WebPushSubscription(BaseModel):
    user_id: str
    subscription: dict  # {endpoint, keys: {p256dh, auth}}
    platform: str = "web"
    user_agent: Optional[str] = None


@api_router.get("/{tenant_slug}/notifications/vapid-key")
async def get_vapid_public_key(tenant_slug: str):
    """
    Retourne la cl√© publique VAPID pour l'inscription aux notifications push Web
    """
    return {"publicKey": VAPID_PUBLIC_KEY}


@api_router.post("/{tenant_slug}/notifications/subscribe")
async def subscribe_web_push(
    tenant_slug: str,
    subscription_data: WebPushSubscription,
    current_user: User = Depends(get_current_user)
):
    """
    Enregistre un abonnement Web Push pour un utilisateur
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # V√©rifier si un abonnement existe d√©j√† pour cet endpoint
        existing = await db.web_push_subscriptions.find_one({
            "subscription.endpoint": subscription_data.subscription.get("endpoint")
        })
        
        if existing:
            # Mettre √† jour l'abonnement existant
            await db.web_push_subscriptions.update_one(
                {"_id": existing["_id"]},
                {"$set": {
                    "user_id": subscription_data.user_id,
                    "subscription": subscription_data.subscription,
                    "user_agent": subscription_data.user_agent,
                    "updated_at": datetime.now(timezone.utc).isoformat()
                }}
            )
            return {"message": "Abonnement mis √† jour", "status": "updated"}
        else:
            # Cr√©er un nouvel abonnement
            new_sub = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant.id,
                "user_id": subscription_data.user_id,
                "subscription": subscription_data.subscription,
                "platform": subscription_data.platform,
                "user_agent": subscription_data.user_agent,
                "created_at": datetime.now(timezone.utc).isoformat(),
                "updated_at": datetime.now(timezone.utc).isoformat()
            }
            await db.web_push_subscriptions.insert_one(new_sub)
            return {"message": "Abonnement cr√©√©", "status": "created"}
    
    except Exception as e:
        logging.error(f"Erreur inscription Web Push: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/{tenant_slug}/notifications/unsubscribe")
async def unsubscribe_web_push(
    tenant_slug: str,
    data: dict,
    current_user: User = Depends(get_current_user)
):
    """
    Supprime un abonnement Web Push
    """
    user_id = data.get("user_id")
    if not user_id:
        raise HTTPException(status_code=400, detail="user_id requis")
    
    result = await db.web_push_subscriptions.delete_many({"user_id": user_id})
    return {"message": f"{result.deleted_count} abonnement(s) supprim√©(s)"}


async def send_web_push_to_users(tenant_id: str, user_ids: List[str], title: str, body: str, data: Optional[dict] = None):
    """
    Envoie une notification Web Push √† plusieurs utilisateurs
    Retourne le nombre de succ√®s et d'√©checs
    """
    if not VAPID_PRIVATE_KEY:
        logging.warning("Web Push: Cl√©s VAPID non configur√©es")
        return {"success": 0, "failed": 0}
    
    # R√©cup√©rer les abonnements pour ces utilisateurs
    subscriptions = await db.web_push_subscriptions.find({
        "tenant_id": tenant_id,
        "user_id": {"$in": user_ids}
    }).to_list(length=None)
    
    if not subscriptions:
        logging.info(f"Web Push: Aucun abonnement trouv√© pour {len(user_ids)} utilisateurs")
        return {"success": 0, "failed": 0}
    
    success_count = 0
    failed_count = 0
    
    # Payload de la notification
    payload = json.dumps({
        "title": title,
        "body": body,
        "icon": "/logo192.png",
        "badge": "/logo192.png",
        "tag": f"profiremanager-{int(time.time())}",
        "data": data or {}
    })
    
    # Envoyer √† chaque abonnement
    for sub in subscriptions:
        try:
            webpush(
                subscription_info=sub["subscription"],
                data=payload,
                vapid_private_key=VAPID_PRIVATE_KEY,
                vapid_claims={"sub": f"mailto:{VAPID_CLAIMS_EMAIL}"}
            )
            success_count += 1
        except WebPushException as e:
            logging.error(f"Web Push √©chec: {e}")
            # Si l'abonnement est expir√©/invalide, le supprimer
            if e.response and e.response.status_code in [404, 410]:
                await db.web_push_subscriptions.delete_one({"_id": sub["_id"]})
            failed_count += 1
        except Exception as e:
            logging.error(f"Web Push erreur: {e}")
            failed_count += 1
    
    logging.info(f"Web Push: {success_count} succ√®s, {failed_count} √©checs")
    return {"success": success_count, "failed": failed_count}


@api_router.post("/{tenant_slug}/notifications/send-web-push")
async def send_web_push_notification(
    tenant_slug: str,
    notification_data: PushNotificationSend,
    current_user: User = Depends(get_current_user)
):
    """
    Envoie une notification Web Push √† des utilisateurs sp√©cifiques (Admin/Superviseur)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    result = await send_web_push_to_users(
        tenant_id=tenant.id,
        user_ids=notification_data.user_ids,
        title=notification_data.title,
        body=notification_data.body,
        data=notification_data.data
    )
    
    return {
        "message": "Notifications envoy√©es",
        "success_count": result["success"],
        "failure_count": result["failed"]
    }


# ==================== FONCTIONS HELPER POUR G√âN√âRATION D'INDISPONIBILIT√âS ====================

def generer_indisponibilites_montreal(user_id: str, tenant_id: str, equipe: str, date_debut: str, date_fin: str) -> List[Dict]:
    """
    G√©n√®re les indisponibilit√©s pour l'horaire Montreal 7/24
    Cycle de 28 jours commen√ßant le 27 janvier 2025 (premier lundi rouge = jour 1)
    
    Pattern R√âEL Montreal 7/24 (v√©rifi√© avec calendrier 2025):
    Chaque √©quipe travaille exactement 7 jours sp√©cifiques sur le cycle de 28 jours
    
    √âquipes avec num√©ros et patterns:
    - Vert (√âquipe #1) : jours 2, 8, 11, 19, 21, 24, 27 du cycle
    - Bleu (√âquipe #2) : jours 3, 6, 9, 15, 18, 26, 28 du cycle
    - Jaune (√âquipe #3) : jours 5, 7, 10, 13, 16, 22, 25 du cycle
    - Rouge (√âquipe #4) : jours 1, 4, 12, 14, 17, 20, 23 du cycle
    
    Le jour 1 du cycle = 27 janvier 2025 (premier lundi rouge)
    
    On g√©n√®re les INDISPONIBILIT√âS pour les jours o√π l'√©quipe TRAVAILLE √† son emploi principal
    """
    
    # Mapping √©quipe -> num√©ro -> jours de travail dans le cycle de 28 jours
    equipes_config = {
        "Vert": {
            "numero": 1,
            "jours_cycle": [2, 8, 11, 19, 21, 24, 27]
        },
        "Bleu": {
            "numero": 2,
            "jours_cycle": [3, 6, 9, 15, 18, 26, 28]
        },
        "Jaune": {
            "numero": 3,
            "jours_cycle": [5, 7, 10, 13, 16, 22, 25]
        },
        "Rouge": {
            "numero": 4,
            "jours_cycle": [1, 4, 12, 14, 17, 20, 23]
        }
    }
    
    if equipe not in equipes_config:
        raise ValueError(f"√âquipe invalide: {equipe}. Doit √™tre Vert, Bleu, Jaune ou Rouge")
    
    config = equipes_config[equipe]
    jours_travail_cycle = config["jours_cycle"]
    
    logging.info(f"Montreal 7/24 - {equipe} (#{config['numero']}): jours de travail dans cycle = {jours_travail_cycle}")
    
    # Le jour 1 du cycle = 27 janvier 2025
    jour_1_cycle = datetime(2025, 1, 27).date()
    
    # Parser les dates de d√©but et fin
    date_debut_obj = datetime.strptime(date_debut, "%Y-%m-%d").date()
    date_fin_obj = datetime.strptime(date_fin, "%Y-%m-%d").date()
    
    indisponibilites = []
    current_date = date_debut_obj
    
    while current_date <= date_fin_obj:
        # Calculer le jour dans le cycle (1-28)
        jours_depuis_jour1 = (current_date - jour_1_cycle).days
        jour_cycle = (jours_depuis_jour1 % 28) + 1
        
        # Si n√©gatif (avant le 27 janvier 2025), calculer en arri√®re
        if jours_depuis_jour1 < 0:
            jour_cycle = 28 - ((-jours_depuis_jour1 - 1) % 28)
        
        # Si le jour EST dans les jours de travail de l'√©quipe, c'est une INDISPONIBILIT√â
        if jour_cycle in jours_travail_cycle:
            indispo = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant_id,
                "user_id": user_id,
                "date": current_date.isoformat(),
                "type_garde_id": None,
                "heure_debut": "00:00",
                "heure_fin": "23:59",
                "statut": "indisponible",
                "origine": "montreal_7_24",
                "created_at": datetime.now(timezone.utc)
            }
            indisponibilites.append(indispo)
        
        current_date += timedelta(days=1)
    
    logging.info(f"‚úÖ Montreal 7/24 - {equipe} (#{config['numero']}): {len(indisponibilites)} indisponibilit√©s g√©n√©r√©es de {date_debut} √† {date_fin}")
    return indisponibilites

def generer_indisponibilites_quebec(user_id: str, tenant_id: str, equipe: str, date_debut: str, date_fin: str) -> List[Dict]:
    """
    G√©n√®re les indisponibilit√©s pour l'horaire Quebec 10/14
    Cycle de 28 jours commen√ßant le 1er f√©vrier 2026 (jour 1 du cycle)
    
    Pattern R√âEL Quebec 10/14 (bas√© sur f√©vrier 2026):
    Chaque √©quipe travaille selon un pattern sp√©cifique sur 28 jours
    
    √âquipes avec num√©ros et jours de travail:
    - Vert (√âquipe #1) : jours 2,3,4,5, 12,13,14, 20,21, 22, 23,24,25
    - Bleu (√âquipe #2) : jours 6,7, 8, 9,10,11, 16,17,18,19, 26,27,28
    - Jaune (√âquipe #3) : jours 1, 2,3,4, 9,10,11,12, 19,20,21, 27,28
    - Rouge (√âquipe #4) : jours 5,6,7, 13,14, 15, 16,17,18, 23,24,25,26
    
    Le jour 1 du cycle = 1er f√©vrier 2026 (DATE FIXE COD√âE EN DUR)
    Le cycle recommence tous les 28 jours (1er mars, 29 mars, 26 avril, etc.)
    
    On g√©n√®re les INDISPONIBILIT√âS pour les jours o√π l'√©quipe TRAVAILLE √† son emploi principal
    (car ils ne sont pas disponibles pour les gardes de pompiers ces jours-l√†)
    
    Note: Pour les gardes de nuit (17h-7h), on marque seulement le jour de d√©but comme indisponible
    """
    
    # Mapping √©quipe -> num√©ro -> jours de travail dans le cycle de 28 jours
    equipes_config = {
        "Vert": {
            "numero": 1,
            "jours_cycle": [2, 3, 4, 5, 12, 13, 14, 20, 21, 22, 23, 24, 25]
        },
        "Bleu": {
            "numero": 2,
            "jours_cycle": [6, 7, 8, 9, 10, 11, 16, 17, 18, 19, 26, 27, 28]
        },
        "Jaune": {
            "numero": 3,
            "jours_cycle": [1, 2, 3, 4, 9, 10, 11, 12, 19, 20, 21, 27, 28]
        },
        "Rouge": {
            "numero": 4,
            "jours_cycle": [5, 6, 7, 13, 14, 15, 16, 17, 18, 23, 24, 25, 26]
        }
    }
    
    if equipe not in equipes_config:
        raise ValueError(f"√âquipe invalide: {equipe}. Doit √™tre Vert, Bleu, Jaune ou Rouge")
    
    config = equipes_config[equipe]
    jours_travail_cycle = config["jours_cycle"]
    
    logging.info(f"Quebec 10/14 - {equipe} (#{config['numero']}): jours de travail dans cycle = {jours_travail_cycle}")
    
    # Le jour 1 du cycle = 1er f√©vrier 2026 (DATE FIXE)
    jour_1_cycle = datetime(2026, 2, 1).date()
    
    # Parser les dates de d√©but et fin
    date_debut_obj = datetime.strptime(date_debut, "%Y-%m-%d").date()
    date_fin_obj = datetime.strptime(date_fin, "%Y-%m-%d").date()
    
    indisponibilites = []
    current_date = date_debut_obj
    
    while current_date <= date_fin_obj:
        # Calculer le jour dans le cycle (1-28)
        jours_depuis_jour1 = (current_date - jour_1_cycle).days
        jour_cycle = (jours_depuis_jour1 % 28) + 1
        
        # Si n√©gatif (avant le jour 1), calculer en arri√®re
        if jours_depuis_jour1 < 0:
            jour_cycle = 28 - ((-jours_depuis_jour1 - 1) % 28)
        
        # Si le jour EST dans les jours de travail de l'√©quipe, c'est une INDISPONIBILIT√â
        if jour_cycle in jours_travail_cycle:
            indispo = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant_id,
                "user_id": user_id,
                "date": current_date.isoformat(),
                "type_garde_id": None,
                "heure_debut": "00:00",
                "heure_fin": "23:59",
                "statut": "indisponible",
                "origine": "quebec_10_14",
                "created_at": datetime.now(timezone.utc)
            }
            indisponibilites.append(indispo)
        
        current_date += timedelta(days=1)
    
    logging.info(f"‚úÖ Quebec 10/14 - {equipe} (#{config['numero']}): {len(indisponibilites)} indisponibilit√©s g√©n√©r√©es de {date_debut} √† {date_fin}")
    return indisponibilites

def generer_indisponibilites_longueuil(user_id: str, tenant_id: str, equipe: str, date_debut: str, date_fin: str) -> List[Dict]:
    """
    G√©n√®re les indisponibilit√©s pour l'horaire Longueuil 7/24
    Cycle de 28 jours commen√ßant le 1er dimanche rouge du calendrier
    
    Pattern Longueuil 7/24:
    Chaque √©quipe travaille exactement 7 jours de 24h sur le cycle de 28 jours
    
    √âquipes avec num√©ros et patterns:
    - Vert (√âquipe #1) : jours 2, 6, 8, 12, 18, 21, 24 du cycle
    - Bleu (√âquipe #2) : jours 3, 9, 13, 15, 19, 25, 28 du cycle
    - Jaune (√âquipe #3) : jours 4, 7, 10, 16, 20, 22, 26 du cycle
    - Rouge (√âquipe #4) : jours 1, 5, 11, 14, 17, 23, 27 du cycle
    
    Le jour 1 du cycle = 4 janvier 2026 (premier dimanche rouge)
    
    On g√©n√®re les INDISPONIBILIT√âS pour les jours o√π l'√©quipe TRAVAILLE √† son emploi principal
    """
    
    # Mapping √©quipe -> num√©ro -> jours de travail dans le cycle de 28 jours
    equipes_config = {
        "Vert": {
            "numero": 1,
            "jours_cycle": [2, 6, 8, 12, 18, 21, 24]
        },
        "Bleu": {
            "numero": 2,
            "jours_cycle": [3, 9, 13, 15, 19, 25, 28]
        },
        "Jaune": {
            "numero": 3,
            "jours_cycle": [4, 7, 10, 16, 20, 22, 26]
        },
        "Rouge": {
            "numero": 4,
            "jours_cycle": [1, 5, 11, 14, 17, 23, 27]
        }
    }
    
    if equipe not in equipes_config:
        raise ValueError(f"√âquipe invalide: {equipe}. Doit √™tre Vert, Bleu, Jaune ou Rouge")
    
    config = equipes_config[equipe]
    jours_travail_cycle = config["jours_cycle"]
    
    logging.info(f"Longueuil 7/24 - {equipe} (#{config['numero']}): jours de travail dans cycle = {jours_travail_cycle}")
    
    # Le jour 1 du cycle = 25 janvier 2026 (premier dimanche rouge)
    jour_1_cycle = datetime(2026, 1, 25).date()
    
    # Parser les dates de d√©but et fin
    date_debut_obj = datetime.strptime(date_debut, "%Y-%m-%d").date()
    date_fin_obj = datetime.strptime(date_fin, "%Y-%m-%d").date()
    
    indisponibilites = []
    current_date = date_debut_obj
    
    while current_date <= date_fin_obj:
        # Calculer le jour dans le cycle (1-28)
        jours_depuis_jour1 = (current_date - jour_1_cycle).days
        jour_cycle = (jours_depuis_jour1 % 28) + 1
        
        # Si n√©gatif (avant le jour 1), calculer en arri√®re
        if jours_depuis_jour1 < 0:
            jour_cycle = 28 - ((-jours_depuis_jour1 - 1) % 28)
        
        # Si le jour EST dans les jours de travail de l'√©quipe, c'est une INDISPONIBILIT√â
        if jour_cycle in jours_travail_cycle:
            indispo = {
                "id": str(uuid.uuid4()),
                "tenant_id": tenant_id,
                "user_id": user_id,
                "date": current_date.isoformat(),
                "type_garde_id": None,
                "heure_debut": "00:00",
                "heure_fin": "23:59",
                "statut": "indisponible",
                "origine": "longueuil_7_24",
                "created_at": datetime.now(timezone.utc)
            }
            indisponibilites.append(indispo)
        
        current_date += timedelta(days=1)
    
    logging.info(f"‚úÖ Longueuil 7/24 - {equipe} (#{config['numero']}): {len(indisponibilites)} indisponibilit√©s g√©n√©r√©es de {date_debut} √† {date_fin}")
    return indisponibilites

# ==================== ROUTE DE G√âN√âRATION D'INDISPONIBILIT√âS ====================

@api_router.post("/{tenant_slug}/disponibilites/generer")
async def generer_indisponibilites(
    tenant_slug: str,
    generation_data: IndisponibiliteGenerate,
    current_user: User = Depends(get_current_user)
):
    """
    G√©n√®re automatiquement les indisponibilit√©s selon l'horaire s√©lectionn√©
    """
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier les permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.id != generation_data.user_id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Supprimer les anciennes disponibilit√©s g√©n√©r√©es automatiquement si demand√©
        if not generation_data.conserver_manuelles:
            # Supprimer toutes les disponibilit√©s de cet utilisateur pour la p√©riode
            await db.disponibilites.delete_many({
                "user_id": generation_data.user_id,
                "tenant_id": tenant.id,
                "date": {
                    "$gte": generation_data.date_debut,
                    "$lte": generation_data.date_fin
                }
            })
        else:
            # Supprimer uniquement les disponibilit√©s g√©n√©r√©es automatiquement (pr√©server manuelles)
            origine_map = {
                "montreal": "montreal_7_24",
                "quebec": "quebec_10_14",
                "longueuil": "longueuil_7_24"
            }
            origine_type = origine_map.get(generation_data.horaire_type, "montreal_7_24")
            await db.disponibilites.delete_many({
                "user_id": generation_data.user_id,
                "tenant_id": tenant.id,
                "origine": origine_type,
                "date": {
                    "$gte": generation_data.date_debut,
                    "$lte": generation_data.date_fin
                }
            })
        
        # G√©n√©rer les nouvelles indisponibilit√©s
        if generation_data.horaire_type == "montreal":
            indispos = generer_indisponibilites_montreal(
                user_id=generation_data.user_id,
                tenant_id=tenant.id,
                equipe=generation_data.equipe,
                date_debut=generation_data.date_debut,
                date_fin=generation_data.date_fin
            )
        elif generation_data.horaire_type == "quebec":
            indispos = generer_indisponibilites_quebec(
                user_id=generation_data.user_id,
                tenant_id=tenant.id,
                equipe=generation_data.equipe,
                date_debut=generation_data.date_debut,
                date_fin=generation_data.date_fin
            )
        elif generation_data.horaire_type == "longueuil":
            indispos = generer_indisponibilites_longueuil(
                user_id=generation_data.user_id,
                tenant_id=tenant.id,
                equipe=generation_data.equipe,
                date_debut=generation_data.date_debut,
                date_fin=generation_data.date_fin
            )
        else:
            raise HTTPException(
                status_code=400,
                detail="horaire_type doit √™tre 'montreal', 'quebec' ou 'longueuil'"
            )
        
        # Ins√©rer les indisponibilit√©s dans la base de donn√©es
        if indispos:
            await db.disponibilites.insert_many(indispos)
        
        # Cr√©er une activit√©
        horaire_texts = {
            "montreal": "Montr√©al 7/24",
            "quebec": "Qu√©bec 10/14",
            "longueuil": "Longueuil 7/24"
        }
        horaire_text = horaire_texts.get(generation_data.horaire_type, generation_data.horaire_type)
        user = await db.users.find_one({"id": generation_data.user_id, "tenant_id": tenant.id})
        if user:
            await creer_activite(
                tenant_id=tenant.id,
                type_activite="disponibilite_generation_auto",
                description=f"üîÑ {current_user.prenom} {current_user.nom} a g√©n√©r√© {len(indispos)} indisponibilit√©s automatiques ({horaire_text} - {generation_data.equipe}) pour {user['prenom']} {user['nom']}",
                user_id=current_user.id,
                user_nom=f"{current_user.prenom} {current_user.nom}",
                data={"concerne_user_id": generation_data.user_id}
            )
        
        return {
            "message": "Indisponibilit√©s g√©n√©r√©es avec succ√®s",
            "horaire_type": generation_data.horaire_type,
            "equipe": generation_data.equipe,
            "date_debut": generation_data.date_debut,
            "date_fin": generation_data.date_fin,
            "nombre_indisponibilites": len(indispos),
            "conserver_manuelles": generation_data.conserver_manuelles
        }
        
    except HTTPException:
        # Re-raise HTTPExceptions as-is (don't convert to 500)
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        print(f"Erreur lors de la g√©n√©ration des indisponibilit√©s: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la g√©n√©ration: {str(e)}")

# Assignation manuelle avanc√©e avec r√©currence
@api_router.post("/{tenant_slug}/planning/assignation-avancee")
async def assignation_manuelle_avancee(
    tenant_slug: str,
    assignation_data: dict,
    current_user: User = Depends(get_current_user)
):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        user_id = assignation_data.get("user_id")
        type_garde_id = assignation_data.get("type_garde_id")
        recurrence_type = assignation_data.get("recurrence_type", "unique")
        date_debut = datetime.strptime(assignation_data.get("date_debut"), "%Y-%m-%d").date()
        date_fin = datetime.strptime(assignation_data.get("date_fin", assignation_data.get("date_debut")), "%Y-%m-%d").date()
        jours_semaine = assignation_data.get("jours_semaine", [])
        bi_hebdomadaire = assignation_data.get("bi_hebdomadaire", False)
        recurrence_intervalle = assignation_data.get("recurrence_intervalle", 1)
        recurrence_frequence = assignation_data.get("recurrence_frequence", "jours")
        
        assignations_creees = []
        
        if recurrence_type == "unique":
            # Assignation unique
            assignation_obj = Assignation(
                user_id=user_id,
                type_garde_id=type_garde_id,
                date=date_debut.strftime("%Y-%m-%d"),
                assignation_type="manuel_avance",
                tenant_id=tenant.id
            )
            await db.assignations.insert_one(assignation_obj.dict())
            assignations_creees.append(assignation_obj.dict())
            
        elif recurrence_type == "hebdomadaire":
            # R√©currence hebdomadaire (avec option bi-hebdomadaire)
            current_date = date_debut
            jours_semaine_index = {
                'monday': 0, 'tuesday': 1, 'wednesday': 2, 'thursday': 3,
                'friday': 4, 'saturday': 5, 'sunday': 6
            }
            
            # Pour bi-hebdomadaire : calculer le num√©ro de semaine ISO de la date de d√©but
            def get_iso_week_number(date):
                # Python's isocalendar() retourne (ann√©e, semaine, jour_semaine)
                return date.isocalendar()[1]
            
            reference_week = get_iso_week_number(date_debut)
            
            while current_date <= date_fin:
                day_name = current_date.strftime("%A").lower()
                
                # V√©rifier si c'est un jour s√©lectionn√©
                if day_name in jours_semaine:
                    # Si bi-hebdomadaire, v√©rifier la diff√©rence de semaines
                    current_week = get_iso_week_number(current_date)
                    weeks_difference = current_week - reference_week
                    
                    if not bi_hebdomadaire or weeks_difference % 2 == 0:
                        # V√©rifier qu'il n'y a pas d√©j√† une assignation
                        existing = await db.assignations.find_one({
                            "user_id": user_id,
                            "type_garde_id": type_garde_id,
                            "date": current_date.strftime("%Y-%m-%d"),
                            "tenant_id": tenant.id
                        })
                        
                        if not existing:
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_garde_id,
                                date=current_date.strftime("%Y-%m-%d"),
                                assignation_type="manuel_avance",
                                tenant_id=tenant.id
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_creees.append(assignation_obj.dict())
                
                current_date += timedelta(days=1)
        
        elif recurrence_type == "bihebdomadaire":
            # R√©currence bi-hebdomadaire (toutes les 2 semaines)
            current_date = date_debut
            
            # Calculer le num√©ro de semaine ISO de r√©f√©rence
            def get_iso_week_number(date):
                return date.isocalendar()[1]
            
            reference_week = get_iso_week_number(date_debut)
            
            while current_date <= date_fin:
                day_name = current_date.strftime("%A").lower()
                
                # Calculer la diff√©rence de semaines
                current_week = get_iso_week_number(current_date)
                weeks_difference = current_week - reference_week
                
                # V√©rifier si c'est un jour s√©lectionn√© et une semaine paire
                if day_name in jours_semaine and weeks_difference % 2 == 0:
                    existing = await db.assignations.find_one({
                        "user_id": user_id,
                        "type_garde_id": type_garde_id,
                        "date": current_date.strftime("%Y-%m-%d"),
                        "tenant_id": tenant.id
                    })
                    
                    if not existing:
                        assignation_obj = Assignation(
                            user_id=user_id,
                            type_garde_id=type_garde_id,
                            date=current_date.strftime("%Y-%m-%d"),
                            assignation_type="manuel_avance",
                            tenant_id=tenant.id
                        )
                        await db.assignations.insert_one(assignation_obj.dict())
                        assignations_creees.append(assignation_obj.dict())
                
                current_date += timedelta(days=1)
                
        elif recurrence_type == "mensuel" or recurrence_type == "mensuelle":
            # R√©currence mensuelle (m√™me jour du mois)
            jour_mois = date_debut.day
            current_month = date_debut.replace(day=1)
            
            while current_month <= date_fin:
                try:
                    # Essayer de cr√©er la date pour ce mois
                    target_date = current_month.replace(day=jour_mois)
                    
                    if date_debut <= target_date <= date_fin:
                        existing = await db.assignations.find_one({
                            "user_id": user_id,
                            "type_garde_id": type_garde_id,
                            "date": target_date.strftime("%Y-%m-%d"),
                            "tenant_id": tenant.id
                        })
                        
                        if not existing:
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_garde_id,
                                date=target_date.strftime("%Y-%m-%d"),
                                assignation_type="manuel_avance",
                                tenant_id=tenant.id
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_creees.append(assignation_obj.dict())
                            
                except ValueError:
                    # Jour n'existe pas dans ce mois (ex: 31 f√©vrier)
                    pass
                
                # Passer au mois suivant
                if current_month.month == 12:
                    current_month = current_month.replace(year=current_month.year + 1, month=1)
                else:
                    current_month = current_month.replace(month=current_month.month + 1)
        
        elif recurrence_type == "annuelle":
            # R√©currence annuelle (m√™me jour et mois chaque ann√©e)
            jour_mois = date_debut.day
            mois = date_debut.month
            current_year = date_debut.year
            
            while True:
                try:
                    target_date = date(current_year, mois, jour_mois)
                    
                    if target_date > date_fin:
                        break
                    
                    if target_date >= date_debut:
                        existing = await db.assignations.find_one({
                            "user_id": user_id,
                            "type_garde_id": type_garde_id,
                            "date": target_date.strftime("%Y-%m-%d"),
                            "tenant_id": tenant.id
                        })
                        
                        if not existing:
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_garde_id,
                                date=target_date.strftime("%Y-%m-%d"),
                                assignation_type="manuel_avance",
                                tenant_id=tenant.id
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_creees.append(assignation_obj.dict())
                    
                    current_year += 1
                except ValueError:
                    # Jour n'existe pas (ex: 29 f√©vrier dans une ann√©e non bissextile)
                    current_year += 1
        
        elif recurrence_type == "personnalisee":
            # R√©currence personnalis√©e
            current_date = date_debut
            
            if recurrence_frequence == "jours":
                delta = timedelta(days=recurrence_intervalle)
            elif recurrence_frequence == "semaines":
                delta = timedelta(weeks=recurrence_intervalle)
            else:
                # Pour mois et ans, on g√©rera diff√©remment
                delta = None
            
            if delta:
                while current_date <= date_fin:
                    existing = await db.assignations.find_one({
                        "user_id": user_id,
                        "type_garde_id": type_garde_id,
                        "date": current_date.strftime("%Y-%m-%d"),
                        "tenant_id": tenant.id
                    })
                    
                    if not existing:
                        assignation_obj = Assignation(
                            user_id=user_id,
                            type_garde_id=type_garde_id,
                            date=current_date.strftime("%Y-%m-%d"),
                            assignation_type="manuel_avance",
                            tenant_id=tenant.id
                        )
                        await db.assignations.insert_one(assignation_obj.dict())
                        assignations_creees.append(assignation_obj.dict())
                    
                    current_date += delta
            else:
                # Pour mois et ans
                current_date = date_debut
                while current_date <= date_fin:
                    existing = await db.assignations.find_one({
                        "user_id": user_id,
                        "type_garde_id": type_garde_id,
                        "date": current_date.strftime("%Y-%m-%d"),
                        "tenant_id": tenant.id
                    })
                    
                    if not existing:
                        assignation_obj = Assignation(
                            user_id=user_id,
                            type_garde_id=type_garde_id,
                            date=current_date.strftime("%Y-%m-%d"),
                            assignation_type="manuel_avance",
                            tenant_id=tenant.id
                        )
                        await db.assignations.insert_one(assignation_obj.dict())
                        assignations_creees.append(assignation_obj.dict())
                    
                    if recurrence_frequence == "mois":
                        # Ajouter X mois
                        month = current_date.month + recurrence_intervalle
                        year = current_date.year
                        while month > 12:
                            month -= 12
                            year += 1
                        try:
                            current_date = current_date.replace(year=year, month=month)
                        except ValueError:
                            # Jour invalide pour ce mois
                            break
                    elif recurrence_frequence == "ans":
                        # Ajouter X ans
                        try:
                            current_date = current_date.replace(year=current_date.year + recurrence_intervalle)
                        except ValueError:
                            # Jour invalide (29 f√©vrier)
                            break
        
        return {
            "message": "Assignation avanc√©e cr√©√©e avec succ√®s",
            "assignations_creees": len(assignations_creees),
            "recurrence": recurrence_type,
            "periode": f"{date_debut.strftime('%Y-%m-%d')} √† {date_fin.strftime('%Y-%m-%d')}"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur assignation avanc√©e: {str(e)}")

# Mode d√©mo sp√©cial - Attribution automatique agressive pour impression client
@api_router.post("/{tenant_slug}/planning/attribution-auto-demo")
async def attribution_automatique_demo(tenant_slug: str, semaine_debut: str, current_user: User = Depends(get_current_user)):
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Get all available users and types de garde pour ce tenant
        users = await db.users.find({"statut": "Actif", "tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Get existing assignations for the week
        semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        existing_assignations = await db.assignations.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "tenant_id": tenant.id
        }).to_list(1000)
        
        nouvelles_assignations = []
        
        # MODE D√âMO AGRESSIF - REMPLIR AU MAXIMUM
        for type_garde in types_garde:
            for day_offset in range(7):
                current_date = datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=day_offset)
                date_str = current_date.strftime("%Y-%m-%d")
                day_name = current_date.strftime("%A").lower()
                
                # CORRECTION CRITIQUE: Skip if type garde doesn't apply to this day
                jours_app = type_garde.get("jours_application", [])
                if jours_app and len(jours_app) > 0 and day_name not in jours_app:
                    logging.debug(f"‚è≠Ô∏è [SKIP DAY DEMO] {type_garde['nom']} - {date_str} ({day_name}): Jour non applicable (limit√© √† {jours_app})")
                    continue
                
                # Compter combien de personnel d√©j√† assign√© pour cette garde
                existing_for_garde = [a for a in existing_assignations 
                                    if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                
                personnel_deja_assigne = len(existing_for_garde)
                personnel_requis = type_garde.get("personnel_requis", 1)
                
                # Assigner jusqu'au maximum requis
                for i in range(personnel_requis - personnel_deja_assigne):
                    # Trouver utilisateurs disponibles
                    available_users = []
                    
                    for user in users:
                        # Skip si d√©j√† assign√© cette garde ce jour
                        if any(a["user_id"] == user["id"] and a["date"] == date_str and a["type_garde_id"] == type_garde["id"] 
                               for a in existing_assignations):
                            continue
                        
                        # Skip si d√©j√† assign√© autre garde ce jour (√©viter conflits)
                        if any(a["user_id"] == user["id"] and a["date"] == date_str 
                               for a in existing_assignations):
                            continue
                        
                        # V√©rifier disponibilit√©s
                        user_dispos = await db.disponibilites.find({
                            "user_id": user["id"],
                            "date": date_str,
                            "type_garde_id": type_garde["id"],
                            "statut": "disponible"
                        }).to_list(10)
                        
                        if user_dispos:
                            available_users.append(user)
                    
                    if not available_users:
                        break  # Pas d'utilisateurs disponibles pour ce poste
                    
                    # MODE D√âMO : ASSOUPLIR CONTRAINTE OFFICIER
                    if type_garde.get("officier_obligatoire", False):
                        # Chercher officiers d'abord
                        officers = [u for u in available_users if u.get("grade", "") in ["Capitaine", "Lieutenant", "Directeur"]]
                        # Sinon pompiers avec fonction sup√©rieur
                        if not officers:
                            officers = [u for u in available_users if u.get("fonction_superieur", False)]
                        # En dernier recours : tous pompiers (MODE D√âMO)
                        if not officers:
                            officers = available_users
                        
                        if officers:
                            selected_user = officers[0]
                        else:
                            continue
                    else:
                        selected_user = available_users[0]
                    
                    # Cr√©er assignation
                    assignation_obj = Assignation(
                        user_id=selected_user["id"],
                        type_garde_id=type_garde["id"],
                        date=date_str,
                        assignation_type="auto_demo",
                        tenant_id=tenant.id
                    )
                    
                    await db.assignations.insert_one(assignation_obj.dict())
                    nouvelles_assignations.append(assignation_obj.dict())
                    existing_assignations.append(assignation_obj.dict())
        
        return {
            "message": "Attribution D√âMO agressive effectu√©e avec succ√®s",
            "assignations_creees": len(nouvelles_assignations),
            "algorithme": "Mode d√©mo : Contraintes assouplies pour impression maximum",
            "semaine": f"{semaine_debut} - {semaine_fin}"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur attribution d√©mo: {str(e)}")

# V√©rification des assignations existantes pour une p√©riode
@api_router.get("/{tenant_slug}/planning/assignations/check-periode")
async def check_assignations_periode(
    tenant_slug: str, 
    debut: str, 
    fin: str, 
    current_user: User = Depends(get_current_user)
):
    """V√©rifie s'il existe des assignations pour la p√©riode donn√©e"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        existing_count = await db.assignations.count_documents({
            "date": {
                "$gte": debut,
                "$lte": fin
            },
            "tenant_id": tenant.id
        })
        
        return {
            "existing_count": existing_count,
            "periode": f"{debut} au {fin}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur v√©rification p√©riode: {str(e)}")

# ==================== SSE ENDPOINT POUR PROGRESSION ====================
@api_router.get("/{tenant_slug}/planning/attribution-auto/progress/{task_id}")
async def attribution_progress_stream(
    tenant_slug: str,
    task_id: str
):
    """Stream SSE pour suivre la progression de l'attribution automatique
    
    Note: Pas d'authentification JWT car EventSource ne peut pas envoyer de headers.
    La s√©curit√© est assur√©e par le task_id unique et √©ph√©m√®re.
    """
    # V√©rifier que le task_id existe (s√©curit√© basique)
    if task_id not in attribution_progress_store and task_id != "test":
        # Attendre un peu que la t√¢che soit cr√©√©e
        await asyncio.sleep(1)
        if task_id not in attribution_progress_store:
            raise HTTPException(status_code=404, detail="Task ID non trouv√©")
    
    return StreamingResponse(
        progress_event_generator(task_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"  # Nginx buffering disabled
        }
    )

# Attribution automatique intelligente avec rotation √©quitable et anciennet√©
@api_router.post("/{tenant_slug}/planning/attribution-auto")
async def attribution_automatique(
    tenant_slug: str, 
    semaine_debut: str, 
    semaine_fin: str = None,
    reset: bool = False,  # Nouveau param√®tre pour r√©initialiser
    current_user: User = Depends(get_current_user)
):
    """Attribution automatique pour une ou plusieurs semaines avec progression temps r√©el
    
    Args:
        reset: Si True, supprime d'abord toutes les assignations AUTO de la p√©riode
        
    Returns:
        task_id: Identifiant pour suivre la progression via SSE
    """
    logging.info(f"üî• [ENDPOINT] Attribution auto appel√© par {current_user.email}")
    logging.info(f"üî• [ENDPOINT] Param√®tres re√ßus: tenant={tenant_slug}, debut={semaine_debut}, fin={semaine_fin}, reset={reset}")
    
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # G√©n√©rer un task_id unique
    task_id = str(uuid.uuid4())
    
    # Lancer la t√¢che en arri√®re-plan
    asyncio.create_task(
        process_attribution_auto_async(
            task_id, tenant, semaine_debut, semaine_fin, reset
        )
    )
    
    # Retourner imm√©diatement le task_id
    return {
        "task_id": task_id,
        "message": "Attribution automatique lanc√©e en arri√®re-plan",
        "stream_url": f"/api/{tenant_slug}/planning/attribution-auto/progress/{task_id}"
    }

async def process_attribution_auto_async(
    task_id: str,
    tenant,
    semaine_debut: str,
    semaine_fin: str = None,
    reset: bool = False
):
    """Traite l'attribution automatique de mani√®re asynchrone avec suivi de progression"""
    progress = AttributionProgress(task_id)
    
    try:
        start_time = time.time()
        logging.info(f"‚è±Ô∏è [PERF] Attribution auto d√©marr√©e - Task ID: {task_id}")
        logging.info(f"üîç [DEBUG] reset={reset}, type={type(reset)}, tenant_id={tenant.id}")
        logging.info(f"üîç [DEBUG] P√©riode: {semaine_debut} ‚Üí {semaine_fin}")
        
        # Si pas de semaine_fin fournie, calculer pour une seule semaine
        if not semaine_fin:
            semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        
        progress.update("Initialisation...", 5)
        
        # Si reset=True, supprimer d'abord toutes les assignations AUTO de la p√©riode
        assignations_supprimees = 0
        if reset:
            logging.info(f"üîç [DEBUG] RESET MODE ACTIV√â - Tentative de suppression...")
            
            # V√©rifier combien d'assignations existent
            count_before = await db.assignations.count_documents({
                "tenant_id": tenant.id,
                "date": {"$gte": semaine_debut, "$lte": semaine_fin}
            })
            logging.info(f"üîç [DEBUG] Assignations totales dans p√©riode: {count_before}")
            
            # V√©rifier les types d'assignation existants
            distinct_types = await db.assignations.distinct("assignation_type", {
                "tenant_id": tenant.id,
                "date": {"$gte": semaine_debut, "$lte": semaine_fin}
            })
            logging.info(f"üîç [DEBUG] Types d'assignation existants: {distinct_types}")
            
            progress.update("Suppression des assignations existantes...", 10)
            # CORRECTION: Supprimer TOUTES les assignations AUTO + celles sans type (anciennes)
            result = await db.assignations.delete_many({
                "tenant_id": tenant.id,
                "date": {
                    "$gte": semaine_debut,
                    "$lte": semaine_fin
                },
                "$or": [
                    {"assignation_type": {"$in": ["auto", "automatique"]}},
                    {"assignation_type": {"$exists": False}},  # Assignations sans type (anciennes)
                    {"assignation_type": None}  # Assignations avec type null
                ]
            })
            assignations_supprimees = result.deleted_count
            logging.info(f"‚è±Ô∏è [PERF] ‚úÖ {assignations_supprimees} assignations supprim√©es (incluant anciennes sans type)")
        else:
            logging.info(f"üîç [DEBUG] RESET MODE D√âSACTIV√â - Pas de suppression")
        
        # Pour une p√©riode compl√®te (mois), traiter semaine par semaine
        start_date = datetime.strptime(semaine_debut, "%Y-%m-%d")
        end_date = datetime.strptime(semaine_fin, "%Y-%m-%d")
        
        # Calculer le nombre total de semaines
        total_weeks = ((end_date - start_date).days // 7) + 1
        progress.total_gardes = total_weeks
        
        total_assignations_creees = 0
        current_week_start = start_date
        week_number = 0
        
        # It√©rer sur toutes les semaines de la p√©riode
        while current_week_start <= end_date:
            week_number += 1
            current_week_end = current_week_start + timedelta(days=6)
            if current_week_end > end_date:
                current_week_end = end_date
            
            week_start_str = current_week_start.strftime("%Y-%m-%d")
            week_end_str = current_week_end.strftime("%Y-%m-%d")
            
            # Mise √† jour progression
            progress_percent = 15 + int((week_number / total_weeks) * 80)
            progress.update(
                f"Traitement semaine {week_number}/{total_weeks} ({week_start_str})",
                progress_percent,
                gardes_traitees=week_number
            )
            
            week_start_time = time.time()
            
            # Traiter cette semaine
            assignations_cette_semaine = await traiter_semaine_attribution_auto(
                tenant, 
                week_start_str, 
                week_end_str,
                progress=progress  # Passer l'objet progress pour mises √† jour granulaires
            )
            
            week_elapsed = time.time() - week_start_time
            logging.info(f"‚è±Ô∏è [PERF] Semaine {week_number} trait√©e en {week_elapsed:.2f}s - {assignations_cette_semaine} assignations")
            
            total_assignations_creees += assignations_cette_semaine
            progress.assignations_creees = total_assignations_creees
            
            # Passer √† la semaine suivante
            current_week_start += timedelta(days=7)
        
        # Terminer
        total_elapsed = time.time() - start_time
        logging.info(f"‚è±Ô∏è [PERF] Attribution auto termin√©e en {total_elapsed:.2f}s - Total: {total_assignations_creees} assignations")
        
        progress.complete(total_assignations_creees)
        
    except Exception as e:
        logging.error(f"‚ùå [ERROR] Attribution auto √©chou√©e: {str(e)}", exc_info=True)
        progress.error(str(e))

async def generer_justification_attribution(
    selected_user: Dict,
    all_candidates: List[Dict],
    type_garde: Dict,
    date_str: str,
    user_monthly_hours_internes: Dict,
    user_monthly_hours_externes: Dict,
    activer_heures_sup: bool,
    existing_assignations: List[Dict],
    disponibilites_evaluees: List[Dict] = None,
    dispos_lookup: Dict = None  # NOUVEAU: pour v√©rifier les disponibilit√©s
) -> Dict[str, Any]:
    """
    G√©n√®re une justification d√©taill√©e pour une attribution automatique
    """
    # Utiliser le compteur appropri√© selon le type de garde
    user_monthly_hours = user_monthly_hours_externes if type_garde.get("est_garde_externe", False) else user_monthly_hours_internes
    
    # Calculer les scores pour l'utilisateur s√©lectionn√©
    heures_selectionnee = user_monthly_hours.get(selected_user["id"], 0)
    moyenne_equipe = sum(user_monthly_hours.values()) / len(user_monthly_hours) if user_monthly_hours else 0
    
    # Score d'√©quit√© (0-100) - Plus les heures sont basses, meilleur le score
    if moyenne_equipe > 0:
        ecart_ratio = (moyenne_equipe - heures_selectionnee) / moyenne_equipe
        score_equite = min(100, max(0, 50 + (ecart_ratio * 50)))
    else:
        score_equite = 50
    
    # Score d'anciennet√© (0-100)
    try:
        date_embauche = selected_user.get("date_embauche", "1900-01-01")
        try:
            embauche_dt = datetime.strptime(date_embauche, "%Y-%m-%d")
        except:
            embauche_dt = datetime.strptime(date_embauche, "%d/%m/%Y")
        
        annees_service = (datetime.now() - embauche_dt).days / 365.25
        score_anciennete = min(100, annees_service * 5)  # 5 points par an, max 100
    except:
        annees_service = 0
        score_anciennete = 0
    
    # Score de disponibilit√© (0-100)
    if selected_user.get("type_emploi") in ("temps_partiel", "temporaire"):
        score_disponibilite = 100 if disponibilites_evaluees else 50
    else:
        score_disponibilite = 75  # Temps plein toujours disponible
    
    # Score de comp√©tences (0-100) - bas√© sur le grade
    grade_scores = {
        "Directeur": 100,
        "Capitaine": 85,
        "Lieutenant": 70,
        "Pompier": 50
    }
    score_competences = grade_scores.get(selected_user.get("grade", "Pompier"), 50)
    
    # Score total
    score_total = score_equite + score_anciennete + score_disponibilite + score_competences
    
    # D√©tails de l'utilisateur s√©lectionn√©
    assigned_user_info = {
        "user_id": selected_user["id"],
        "nom_complet": f"{selected_user['prenom']} {selected_user['nom']}",
        "grade": selected_user.get("grade", "N/A"),
        "type_emploi": selected_user.get("type_emploi", "N/A"),
        "scores": {
            "equite": round(score_equite, 1),
            "anciennete": round(score_anciennete, 1),
            "disponibilite": round(score_disponibilite, 1),
            "competences": round(score_competences, 1),
            "total": round(score_total, 1)
        },
        "details": {
            "heures_ce_mois": heures_selectionnee,
            "moyenne_equipe": round(moyenne_equipe, 1),
            "annees_service": round(annees_service, 1),
            "disponibilite_declaree": selected_user.get("type_emploi") in ("temps_partiel", "temporaire") and bool(disponibilites_evaluees),
            "heures_max_autorisees": selected_user.get("heures_max_semaine", 40) if not activer_heures_sup else None
        }
    }
    
    # √âvaluer les autres candidats
    other_candidates = []
    for candidate in all_candidates:
        if candidate["id"] == selected_user["id"]:
            continue  # Skip l'utilisateur s√©lectionn√©
        
        # D√©terminer la raison d'exclusion
        raison_exclusion = None
        candidate_scores = None
        
        # V√©rifier heures suppl√©mentaires (seulement si d√©sactiv√©es)
        if not activer_heures_sup:
            # Calculer heures de la semaine pour ce candidat
            heures_semaine_candidate = 0
            for assignation in existing_assignations:
                if assignation["user_id"] == candidate["id"]:
                    heures_semaine_candidate += 8  # Simplification
            
            heures_max_user = candidate.get("heures_max_semaine", 40)
            
            if heures_semaine_candidate + type_garde.get("duree_heures", 8) > heures_max_user:
                raison_exclusion = f"Heures max atteintes ({heures_semaine_candidate}h/{heures_max_user}h)"
        
        # V√©rifier disponibilit√© (temps partiel)
        if not raison_exclusion and candidate.get("type_emploi") in ("temps_partiel", "temporaire"):
            # V√©rifier s'il a d√©clar√© une disponibilit√© (m√™me logique que l'attribution)
            has_dispo = False
            if dispos_lookup and candidate["id"] in dispos_lookup and date_str in dispos_lookup[candidate["id"]]:
                # Disponibilit√© sp√©cifique pour ce type de garde
                if type_garde["id"] in dispos_lookup[candidate["id"]][date_str]:
                    has_dispo = True
                # OU disponibilit√© g√©n√©rale (type_garde_id = None)
                elif None in dispos_lookup[candidate["id"]][date_str]:
                    has_dispo = True
            
            if not has_dispo:
                raison_exclusion = "Disponibilit√© non d√©clar√©e"
        
        # V√©rifier s'il est d√©j√† assign√©
        if not raison_exclusion:
            deja_assigne = any(
                a["user_id"] == candidate["id"] and 
                a["date"] == date_str and 
                a["type_garde_id"] == type_garde["id"]
                for a in existing_assignations
            )
            if deja_assigne:
                raison_exclusion = "D√©j√† assign√© √† cette garde"
        
        # Si pas exclu, calculer les scores
        if not raison_exclusion:
            heures_candidate = user_monthly_hours.get(candidate["id"], 0)
            
            # Scores similaires √† l'utilisateur s√©lectionn√©
            if moyenne_equipe > 0:
                ecart_ratio = (moyenne_equipe - heures_candidate) / moyenne_equipe
                cand_score_equite = min(100, max(0, 50 + (ecart_ratio * 50)))
            else:
                cand_score_equite = 50
            
            try:
                date_emb = candidate.get("date_embauche", "1900-01-01")
                try:
                    emb_dt = datetime.strptime(date_emb, "%Y-%m-%d")
                except:
                    emb_dt = datetime.strptime(date_emb, "%d/%m/%Y")
                cand_annees = (datetime.now() - emb_dt).days / 365.25
                cand_score_anc = min(100, cand_annees * 5)
            except:
                cand_score_anc = 0
            
            cand_score_dispo = 100 if candidate.get("type_emploi") in ("temps_partiel", "temporaire") else 75
            cand_score_comp = grade_scores.get(candidate.get("grade", "Pompier"), 50)
            cand_total = cand_score_equite + cand_score_anc + cand_score_dispo + cand_score_comp
            
            candidate_scores = {
                "equite": round(cand_score_equite, 1),
                "anciennete": round(cand_score_anc, 1),
                "disponibilite": round(cand_score_dispo, 1),
                "competences": round(cand_score_comp, 1),
                "total": round(cand_total, 1)
            }
            
            raison_exclusion = f"Score inf√©rieur (total: {round(cand_total, 1)} vs {round(score_total, 1)})"
        
        other_candidates.append({
            "user_id": candidate["id"],
            "nom_complet": f"{candidate['prenom']} {candidate['nom']}",
            "grade": candidate.get("grade", "N/A"),
            "excluded_reason": raison_exclusion,
            "scores": candidate_scores,
            "heures_ce_mois": user_monthly_hours.get(candidate["id"], 0)
        })
    
    # Trier les autres candidats par score d√©croissant (si scores disponibles)
    other_candidates.sort(key=lambda x: x["scores"]["total"] if x["scores"] else 0, reverse=True)
    
    return {
        "assigned_user": assigned_user_info,
        "other_candidates": other_candidates[:10],  # Limiter √† 10 pour ne pas surcharger
        "total_candidates_evaluated": len(all_candidates),
        "date_attribution": datetime.now(timezone.utc).isoformat(),
        "type_garde_info": {
            "nom": type_garde.get("nom", "N/A"),
            "duree_heures": type_garde.get("duree_heures", 8),
            "personnel_requis": type_garde.get("personnel_requis", 1)
        }
    }


async def traiter_semaine_attribution_auto(tenant, semaine_debut: str, semaine_fin: str, progress: AttributionProgress = None):
    """Traite l'attribution automatique pour une seule semaine avec suivi de performance"""
    perf_start = time.time()
    
    try:
        # Get all available users and types de garde pour ce tenant
        users = await db.users.find({"statut": "Actif", "tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        
        # R√©cup√©rer les param√®tres de remplacements (incluant gestion heures sup)
        parametres = await db.parametres_remplacements.find_one({"tenant_id": tenant.id})
        if not parametres:
            # Cr√©er des param√®tres par d√©faut
            default_params = ParametresRemplacements(tenant_id=tenant.id)
            await db.parametres_remplacements.insert_one(default_params.dict())
            parametres = default_params.dict()
        
        activer_heures_sup = parametres.get("activer_gestion_heures_sup", False)
        
        # R√©cup√©rer les param√®tres des √©quipes de garde
        params_equipes_garde = await db.parametres_equipes_garde.find_one({"tenant_id": tenant.id})
        equipes_garde_actif = params_equipes_garde.get("actif", False) if params_equipes_garde else False
        privilegier_equipe_garde_tp = False
        if equipes_garde_actif and params_equipes_garde:
            privilegier_equipe_garde_tp = params_equipes_garde.get("temps_partiel", {}).get("privilegier_equipe_garde", False)
        
        # CORRECTION CRITIQUE: Charger les param√®tres des niveaux d'attribution
        niveaux_actifs = {
            "niveau_2": tenant.parametres.get("niveau_2_actif", True),
            "niveau_3": tenant.parametres.get("niveau_3_actif", True),
            "niveau_4": tenant.parametres.get("niveau_4_actif", True),
            "niveau_5": tenant.parametres.get("niveau_5_actif", True)
        }
        logging.info(f"üìä [NIVEAUX] Niveaux d'attribution actifs: {niveaux_actifs}")
        
        # R√©cup√©rer les grades pour v√©rifier les officiers
        grades = await db.grades.find({"tenant_id": tenant.id}).to_list(1000)
        grades_map = {g["nom"]: g for g in grades}
        
        # R√©cup√©rer les comp√©tences pour la priorisation des gardes
        competences = await db.competences.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Get existing assignations for the week
        # NOTE: Ne PAS √©craser semaine_fin car il est pass√© correctement depuis la boucle appelante
        # (Bug pr√©c√©dent: la ligne suivante √©crasait semaine_fin et limitait √† 7 jours)
        if not semaine_fin:
            semaine_fin = (datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
        existing_assignations = await db.assignations.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "tenant_id": tenant.id
        }).to_list(1000)
        
        # Get monthly statistics for rotation √©quitable (current month)
        current_month_start = datetime.strptime(semaine_debut, "%Y-%m-%d").replace(day=1).strftime("%Y-%m-%d")
        current_month_end = (datetime.strptime(current_month_start, "%Y-%m-%d") + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        current_month_end = current_month_end.strftime("%Y-%m-%d")
        
        monthly_assignations = await db.assignations.find({
            "date": {
                "$gte": current_month_start,
                "$lte": current_month_end
            },
            "tenant_id": tenant.id
        }).to_list(1000)
        
        # ‚ö° OPTIMIZATION: Pr√©charger TOUTES les disponibilit√©s de la semaine en UNE SEULE requ√™te
        # Cela √©vite le probl√®me N+1 (une requ√™te par user/garde)
        all_disponibilites = await db.disponibilites.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "statut": "disponible",
            "tenant_id": tenant.id
        }).to_list(10000)
        
        # Cr√©er un index/dictionnaire pour lookup rapide
        # Structure: {user_id: {date: {type_garde_id: [list of dispos with horaires]}}}
        dispos_lookup = {}
        for dispo in all_disponibilites:
            user_id = dispo.get("user_id")
            date = dispo.get("date")
            type_garde_id = dispo.get("type_garde_id")
            
            if user_id not in dispos_lookup:
                dispos_lookup[user_id] = {}
            if date not in dispos_lookup[user_id]:
                dispos_lookup[user_id][date] = {}
            if type_garde_id not in dispos_lookup[user_id][date]:
                dispos_lookup[user_id][date][type_garde_id] = []
            
            # Stocker la dispo compl√®te avec ses horaires
            dispos_lookup[user_id][date][type_garde_id].append({
                "heure_debut": dispo.get("heure_debut"),
                "heure_fin": dispo.get("heure_fin")
            })
        
        # ‚ö° OPTIMIZATION: Pr√©charger TOUTES les indisponibilit√©s de la semaine
        all_indisponibilites = await db.disponibilites.find({
            "date": {
                "$gte": semaine_debut,
                "$lte": semaine_fin
            },
            "statut": "indisponible",
            "tenant_id": tenant.id
        }).to_list(10000)
        
        # Cr√©er un index pour les indisponibilit√©s
        # Structure: {user_id: {date: True}}
        # PRIORIT√â: Les disponibilit√©s manuelles ont priorit√© sur les indisponibilit√©s auto-g√©n√©r√©es
        indispos_lookup = {}
        for indispo in all_indisponibilites:
            user_id = indispo.get("user_id")
            date = indispo.get("date")
            source = indispo.get("source", "manuel")  # Par d√©faut: manuel
            
            # V√©rifier s'il existe une disponibilit√© manuelle pour ce user/date
            has_manual_dispo = any(
                d.get("user_id") == user_id and 
                d.get("date") == date and 
                d.get("source", "manuel") == "manuel"
                for d in all_disponibilites
            )
            
            # N'ajouter l'indisponibilit√© que si:
            # - C'est une indispo manuelle OU
            # - Il n'y a pas de dispo manuelle qui la contredit
            if source == "manuel" or not has_manual_dispo:
                if user_id not in indispos_lookup:
                    indispos_lookup[user_id] = {}
                indispos_lookup[user_id][date] = True
            else:
                logging.info(f"‚úÖ [CONFLIT R√âSOLU] Indispo auto-g√©n√©r√©e ignor√©e pour {user_id} le {date} (dispo manuelle trouv√©e)")
        
        # R√©cup√©rer les param√®tres d'√©quit√©
        params_planning = await db.parametres_validation_planning.find_one({"tenant_id": tenant.id})
        periode_equite = params_planning.get("periode_equite", "mensuel") if params_planning else "mensuel"
        periode_equite_jours = params_planning.get("periode_equite_jours", 30) if params_planning else 30
        
        # Calculer la date de d√©but de la p√©riode d'√©quit√©
        start_date = datetime.strptime(semaine_debut, "%Y-%m-%d")
        end_date = datetime.strptime(semaine_fin, "%Y-%m-%d")
        date_debut_periode = start_date
        if periode_equite == "hebdomadaire":
            # D√©but de la semaine (lundi)
            jours_depuis_lundi = date_debut_periode.weekday()
            date_debut_periode = date_debut_periode - timedelta(days=jours_depuis_lundi)
        elif periode_equite == "bi-hebdomadaire":
            # D√©but de la bi-semaine (14 jours glissants)
            date_debut_periode = start_date - timedelta(days=14)
        elif periode_equite == "mensuel":
            # D√©but du mois
            date_debut_periode = date_debut_periode.replace(day=1)
        elif periode_equite == "personnalise":
            # P√©riode personnalis√©e en jours
            date_debut_periode = start_date - timedelta(days=periode_equite_jours)
        
        logging.info(f"üìä [√âQUIT√â] P√©riode: {periode_equite}, D√©but: {date_debut_periode}, Jours: {periode_equite_jours if periode_equite == 'personnalise' else 'N/A'}")
        
        # R√©cup√©rer les assignations de la p√©riode d'√©quit√©
        assignations_periode = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut_periode.strftime("%Y-%m-%d"),
                "$lt": end_date.strftime("%Y-%m-%d")
            }
        }).to_list(length=None)
        
        logging.info(f"üìä [√âQUIT√â] {len(assignations_periode)} assignations trouv√©es pour la p√©riode d'√©quit√©")
        
        # Calculate hours for each user based on equity period (s√©par√© interne/externe)
        user_monthly_hours_internes = {}
        user_monthly_hours_externes = {}
        for user in users:
            user_hours_internes = 0
            user_hours_externes = 0
            for assignation in assignations_periode:
                if assignation["user_id"] == user["id"]:
                    # Find type garde to get duration
                    type_garde = next((t for t in types_garde if t["id"] == assignation["type_garde_id"]), None)
                    if type_garde:
                        duree = type_garde.get("duree_heures", 8)
                        # S√©parer les heures selon le type de garde
                        if type_garde.get("est_garde_externe", False):
                            user_hours_externes += duree
                        else:
                            user_hours_internes += duree
            user_monthly_hours_internes[user["id"]] = user_hours_internes
            user_monthly_hours_externes[user["id"]] = user_hours_externes
        
        logging.info(f"üìä [√âQUIT√â] Heures calcul√©es pour {len(users)} utilisateurs sur la p√©riode")
        
        # Initialiser la liste des nouvelles assignations
        nouvelles_assignations = []
        
        # REGROUPEMENT DES HEURES - TEMPORAIREMENT D√âSACTIV√â (cause des doublons)
        # TODO: R√©impl√©menter avec v√©rifications correctes de personnel_requis
        regroupements_traites = []
        if False:  # D√©sactiv√© car cause des assignations multiples incorrectes
            # Code de regroupement comment√© pour investigation future
            pass
        
        # Attribution automatique logic (5 niveaux de priorit√©)
        # nouvelles_assignations d√©j√† d√©clar√© plus haut
        
        # ==================== FONCTION HELPER: V√âRIFICATION COUVERTURE HORAIRE ====================
        def dispo_couvre_garde(dispos_list, heure_debut_garde, heure_fin_garde):
            """
            V√©rifie si au moins UNE des disponibilit√©s couvre COMPL√àTEMENT l'horaire de la garde.
            G√®re les gardes qui traversent minuit (ex: 18:00-06:00).
            """
            if not dispos_list or not heure_debut_garde or not heure_fin_garde:
                return False
            
            def time_to_minutes(time_str):
                if not time_str:
                    return None
                h, m = map(int, time_str.split(':'))
                return h * 60 + m
            
            debut_garde_min = time_to_minutes(heure_debut_garde)
            fin_garde_min = time_to_minutes(heure_fin_garde)
            
            if debut_garde_min is None or fin_garde_min is None:
                return False
            
            garde_traverse_minuit = fin_garde_min < debut_garde_min
            
            for dispo in dispos_list:
                debut_dispo_min = time_to_minutes(dispo.get("heure_debut"))
                fin_dispo_min = time_to_minutes(dispo.get("heure_fin"))
                
                if debut_dispo_min is None or fin_dispo_min is None:
                    continue
                
                dispo_traverse_minuit = fin_dispo_min < debut_dispo_min
                
                # Logique de couverture compl√®te
                if garde_traverse_minuit and dispo_traverse_minuit:
                    # Les deux traversent minuit - v√©rifier si dispo couvre garde
                    if debut_dispo_min <= debut_garde_min and fin_dispo_min >= fin_garde_min:
                        return True
                elif garde_traverse_minuit:
                    # Garde traverse minuit, pas la dispo - impossible de couvrir compl√®tement
                    continue
                elif dispo_traverse_minuit:
                    # Dispo traverse minuit, pas la garde - impossible de couvrir une garde qui ne traverse pas minuit
                    continue
                else:
                    # Aucune ne traverse minuit - v√©rification standard
                    if debut_dispo_min <= debut_garde_min and fin_dispo_min >= fin_garde_min:
                        return True
            
            return False
        
        # ==================== PRIORISATION DES GARDES PAR COMP√âTENCES ====================
        # Trier les types de garde par criticit√© des comp√©tences requises
        # Les gardes avec comp√©tences rares/uniques sont trait√©es EN PREMIER
        
        def calculate_garde_priority(type_garde):
            """Calcule un score de priorit√© pour trier les gardes
            Score plus √âLEV√â = Plus prioritaire (trait√© en premier)
            """
            score = 0
            
            # CRIT√àRE 1: Comp√©tences requises (score √©lev√© si comp√©tences rares)
            competences_requises = type_garde.get("competences_requises", [])
            if competences_requises:
                # Pour chaque comp√©tence requise, compter combien d'users l'ont
                for comp_id in competences_requises:
                    users_with_comp = sum(1 for u in users if comp_id in u.get("competences", []))
                    if users_with_comp == 0:
                        score += 10000  # Comp√©tence impossible (personne ne l'a) - priorit√© maximale
                    elif users_with_comp == 1:
                        score += 1000   # Comp√©tence unique (1 seul user) - tr√®s haute priorit√©
                    elif users_with_comp <= 3:
                        score += 500    # Comp√©tence rare (2-3 users) - haute priorit√©
                    elif users_with_comp <= 5:
                        score += 100    # Comp√©tence peu commune (4-5 users) - priorit√© moyenne
                    else:
                        score += 10     # Comp√©tence commune (6+ users) - faible priorit√©
            
            # CRIT√àRE 2: Officier obligatoire (aussi une contrainte rare)
            if type_garde.get("officier_obligatoire", False):
                officiers_count = sum(1 for u in users 
                                    if grades_map.get(u.get("grade", ""), {}).get("est_officier", False))
                if officiers_count <= 2:
                    score += 300  # Peu d'officiers disponibles
                else:
                    score += 50   # Plusieurs officiers disponibles
            
            # CRIT√àRE 3: Personnel requis √©lev√© (plus difficile √† remplir)
            personnel_requis = type_garde.get("personnel_requis", 1)
            if personnel_requis >= 3:
                score += 50
            
            return score
        
        # Trier les types de garde par priorit√© d√©croissante (score √©lev√© en premier)
        types_garde_sorted = sorted(types_garde, key=calculate_garde_priority, reverse=True)
        
        logging.info(f"üìä [ATTRIBUTION] Ordre de traitement des gardes (par priorit√© de comp√©tences):")
        for tg in types_garde_sorted[:5]:  # Logger les 5 premi√®res
            priority = calculate_garde_priority(tg)
            comp_names = [c for c in competences if c["id"] in tg.get("competences_requises", [])]
            logging.info(f"  - {tg['nom']}: priorit√©={priority}, comp√©tences={[c['nom'] for c in comp_names]}")
        
        # ==================== FIN PRIORISATION ====================
        
        # ==================== PR√â-REMPLISSAGE AUTOMATIQUE TEMPS PLEIN ====================
        # Si activ√©, assigner automatiquement les temps plein de l'√©quipe de garde du jour
        # AVANT l'attribution automatique standard (niveau prioritaire 0)
        
        pre_remplissage_actif_tp = False
        if equipes_garde_actif and params_equipes_garde:
            tpl_config = params_equipes_garde.get("temps_plein", {})
            pre_remplissage_actif_tp = tpl_config.get("rotation_active", False) and tpl_config.get("pre_remplissage_auto", False)
        
        if pre_remplissage_actif_tp:
            logging.info(f"üî• [PR√â-REMPLISSAGE T.PLEIN] Activation du pr√©-remplissage automatique pour temps plein")
            tpl_config = params_equipes_garde.get("temps_plein", {})
            type_rotation_tpl = tpl_config.get("type_rotation", "personnalisee")
            date_reference_tpl = tpl_config.get("date_reference", "")
            nombre_equipes_tpl = tpl_config.get("nombre_equipes", 4)
            pattern_mode_tpl = tpl_config.get("pattern_mode", "hebdomadaire")
            pattern_personnalise_tpl = tpl_config.get("pattern_personnalise", [])
            duree_cycle_tpl = tpl_config.get("duree_cycle", 28)
            
            # R√©cup√©rer la liste des temps plein actifs
            temps_plein_users = [u for u in users if u.get("type_emploi", "temps_plein") == "temps_plein" and u.get("statut") == "Actif"]
            logging.info(f"üî• [PR√â-REMPLISSAGE] {len(temps_plein_users)} temps plein actifs trouv√©s")
            
            # Calculer le nombre de jours √† traiter (de semaine_debut √† semaine_fin)
            start_date_pre = datetime.strptime(semaine_debut, "%Y-%m-%d")
            end_date_pre = datetime.strptime(semaine_fin, "%Y-%m-%d")
            nb_jours_pre = (end_date_pre - start_date_pre).days + 1
            
            # Pour chaque jour de la p√©riode
            for day_offset_pre in range(nb_jours_pre):
                current_date_pre = start_date_pre + timedelta(days=day_offset_pre)
                date_str_pre = current_date_pre.strftime("%Y-%m-%d")
                day_name_en_pre = current_date_pre.strftime("%A").lower()
                
                # Calculer l'√©quipe de garde du jour pour les temps plein
                equipe_garde_jour_tpl = None
                if type_rotation_tpl in ["montreal", "quebec", "longueuil"]:
                    equipe_garde_jour_tpl = get_equipe_garde_rotation_standard(type_rotation_tpl, "", date_str_pre)
                elif type_rotation_tpl == "personnalisee" and date_reference_tpl:
                    equipe_garde_jour_tpl = get_equipe_garde_du_jour_sync(
                        type_rotation=type_rotation_tpl,
                        date_reference=date_reference_tpl,
                        date_cible=date_str_pre,
                        nombre_equipes=nombre_equipes_tpl,
                        pattern_mode=pattern_mode_tpl,
                        pattern_personnalise=pattern_personnalise_tpl,
                        duree_cycle=duree_cycle_tpl
                    )
                
                if equipe_garde_jour_tpl is None:
                    continue
                
                logging.info(f"üî• [PR√â-REMPLISSAGE] {date_str_pre}: √âquipe de garde temps plein = {equipe_garde_jour_tpl}")
                
                # Identifier les temps plein de cette √©quipe
                temps_plein_equipe = [u for u in temps_plein_users if u.get("equipe_garde") == equipe_garde_jour_tpl]
                if not temps_plein_equipe:
                    logging.info(f"‚ö†Ô∏è [PR√â-REMPLISSAGE] {date_str_pre}: Aucun temps plein assign√© √† l'√©quipe {equipe_garde_jour_tpl}")
                    continue
                
                logging.info(f"üî• [PR√â-REMPLISSAGE] {date_str_pre}: {len(temps_plein_equipe)} temps plein dans l'√©quipe {equipe_garde_jour_tpl}")
                
                # Mapping jours anglais/fran√ßais pour les jours d'application
                day_name_mapping_pre = {
                    'monday': 'lundi', 'tuesday': 'mardi', 'wednesday': 'mercredi',
                    'thursday': 'jeudi', 'friday': 'vendredi', 'saturday': 'samedi', 'sunday': 'dimanche'
                }
                day_name_fr_pre = day_name_mapping_pre.get(day_name_en_pre, day_name_en_pre)
                
                # Pour chaque type de garde applicable ce jour-l√† (gardes internes uniquement)
                for type_garde_pre in types_garde:
                    # Skip les gardes externes (ne pas pr√©-remplir)
                    if type_garde_pre.get("est_garde_externe", False):
                        continue
                    
                    # V√©rifier si cette garde s'applique ce jour-l√†
                    jours_app_pre = type_garde_pre.get("jours_application", [])
                    if jours_app_pre and len(jours_app_pre) > 0:
                        jour_applicable_pre = day_name_en_pre in jours_app_pre or day_name_fr_pre in jours_app_pre
                        if not jour_applicable_pre:
                            continue
                    
                    # V√©rifier combien de places sont d√©j√† prises
                    existing_for_garde_pre = [a for a in existing_assignations 
                                              if a["date"] == date_str_pre and a["type_garde_id"] == type_garde_pre["id"]]
                    personnel_requis_pre = type_garde_pre.get("personnel_requis", 1)
                    personnel_assigne_pre = len(existing_for_garde_pre)
                    
                    if personnel_assigne_pre >= personnel_requis_pre:
                        continue  # Garde d√©j√† compl√®te
                    
                    places_restantes_pre = personnel_requis_pre - personnel_assigne_pre
                    
                    # Assigner les temps plein de l'√©quipe (dans la limite des places)
                    assignes_pre = 0
                    for user_tpl in temps_plein_equipe:
                        if assignes_pre >= places_restantes_pre:
                            break
                        
                        # V√©rifier si d√©j√† assign√© √† cette garde
                        deja_assigne_pre = any(
                            a["user_id"] == user_tpl["id"] and 
                            a["date"] == date_str_pre and 
                            a["type_garde_id"] == type_garde_pre["id"]
                            for a in existing_assignations + nouvelles_assignations
                        )
                        if deja_assigne_pre:
                            continue
                        
                        # V√©rifier conflits d'horaires avec autres gardes du m√™me jour
                        has_conflit_pre = False
                        heure_debut_pre = type_garde_pre.get("heure_debut", "")
                        heure_fin_pre = type_garde_pre.get("heure_fin", "")
                        
                        toutes_assign_pre = existing_assignations + nouvelles_assignations
                        for assignation_check in toutes_assign_pre:
                            if assignation_check["user_id"] == user_tpl["id"] and assignation_check["date"] == date_str_pre:
                                garde_existante_pre = next((g for g in types_garde if g["id"] == assignation_check["type_garde_id"]), None)
                                if garde_existante_pre and heure_debut_pre and heure_fin_pre:
                                    heure_debut_ex = garde_existante_pre.get("heure_debut", "")
                                    heure_fin_ex = garde_existante_pre.get("heure_fin", "")
                                    if heure_debut_ex and heure_fin_ex:
                                        # V√©rification simple de chevauchement
                                        if not (heure_fin_pre <= heure_debut_ex or heure_fin_ex <= heure_debut_pre):
                                            has_conflit_pre = True
                                            break
                        
                        if has_conflit_pre:
                            logging.info(f"‚è≠Ô∏è [PR√â-REMPLISSAGE] {user_tpl['prenom']} {user_tpl['nom']} a un conflit horaire pour {type_garde_pre['nom']} le {date_str_pre}")
                            continue
                        
                        # V√©rifier les comp√©tences requises
                        competences_requises_pre = type_garde_pre.get("competences_requises", [])
                        if competences_requises_pre:
                            user_competences_pre = user_tpl.get("competences", [])
                            has_all_comp = all(comp_id in user_competences_pre for comp_id in competences_requises_pre)
                            if not has_all_comp:
                                logging.info(f"‚è≠Ô∏è [PR√â-REMPLISSAGE] {user_tpl['prenom']} {user_tpl['nom']} n'a pas les comp√©tences pour {type_garde_pre['nom']}")
                                continue
                        
                        # V√©rifier contrainte officier obligatoire
                        if type_garde_pre.get("officier_obligatoire", False) and assignes_pre == 0:
                            # Le premier poste doit √™tre un officier
                            grade_obj_pre = grades_map.get(user_tpl.get("grade"))
                            is_officier_pre = (grade_obj_pre and grade_obj_pre.get("est_officier", False)) or user_tpl.get("fonction_superieur", False)
                            if not is_officier_pre:
                                # Chercher un officier dans l'√©quipe
                                officier_dans_equipe = None
                                for u_off in temps_plein_equipe:
                                    grade_obj_off = grades_map.get(u_off.get("grade"))
                                    if (grade_obj_off and grade_obj_off.get("est_officier", False)) or u_off.get("fonction_superieur", False):
                                        # V√©rifier qu'il n'est pas d√©j√† assign√©
                                        deja_assigne_off = any(
                                            a["user_id"] == u_off["id"] and 
                                            a["date"] == date_str_pre and 
                                            a["type_garde_id"] == type_garde_pre["id"]
                                            for a in existing_assignations + nouvelles_assignations
                                        )
                                        if not deja_assigne_off:
                                            officier_dans_equipe = u_off
                                            break
                                
                                if officier_dans_equipe:
                                    # Assigner d'abord l'officier
                                    user_tpl = officier_dans_equipe
                                else:
                                    # Pas d'officier disponible, laisser la place vacante
                                    logging.warning(f"‚ö†Ô∏è [PR√â-REMPLISSAGE] Pas d'officier disponible pour {type_garde_pre['nom']} le {date_str_pre}")
                                    break
                        
                        # Cr√©er l'assignation
                        justification_pre = {
                            "raison_principale": f"Pr√©-remplissage automatique - √âquipe de garde {equipe_garde_jour_tpl}",
                            "type_attribution": "pre_remplissage_temps_plein",
                            "equipe_garde": equipe_garde_jour_tpl,
                            "date_attribution": datetime.now(timezone.utc).isoformat(),
                            "criteres": {
                                "membre_equipe_garde": True,
                                "type_emploi": "temps_plein"
                            }
                        }
                        
                        assignation_obj_pre = Assignation(
                            user_id=user_tpl["id"],
                            type_garde_id=type_garde_pre["id"],
                            date=date_str_pre,
                            assignation_type="auto_pre_remplissage",
                            tenant_id=tenant.id,
                            justification=justification_pre,
                            notes_admin=None,
                            justification_historique=[]
                        )
                        
                        await db.assignations.insert_one(assignation_obj_pre.dict())
                        nouvelles_assignations.append(assignation_obj_pre.dict())
                        existing_assignations.append(assignation_obj_pre.dict())
                        assignes_pre += 1
                        
                        logging.info(f"‚úÖ [PR√â-REMPLISSAGE] {user_tpl['prenom']} {user_tpl['nom']} assign√© √† {type_garde_pre['nom']} le {date_str_pre} (√©quipe {equipe_garde_jour_tpl})")
                    
                    if assignes_pre > 0:
                        logging.info(f"üî• [PR√â-REMPLISSAGE] {type_garde_pre['nom']} - {date_str_pre}: {assignes_pre} temps plein pr√©-assign√©(s)")
            
            # Compter les assignations de pr√©-remplissage
            nb_pre_remplissage = len([a for a in nouvelles_assignations if a.get("assignation_type") == "auto_pre_remplissage"])
            logging.info(f"üî• [PR√â-REMPLISSAGE TERMIN√â] {nb_pre_remplissage} assignation(s) cr√©√©e(s) par pr√©-remplissage temps plein")
        
        # ==================== FIN PR√â-REMPLISSAGE TEMPS PLEIN ====================
        
        for type_garde in types_garde_sorted:  # Utiliser la liste tri√©e au lieu de types_garde
            # Check each day for this type de garde
            for day_offset in range(7):
                current_date = datetime.strptime(semaine_debut, "%Y-%m-%d") + timedelta(days=day_offset)
                date_str = current_date.strftime("%Y-%m-%d")
                day_name_en = current_date.strftime("%A").lower()  # english: monday, tuesday...
                
                # LOG DEBUG: Afficher CHAQUE jour it√©r√© pour cette garde
                logging.info(f"üìÖ [ITERATION] {type_garde['nom']} - Jour {day_offset}: {date_str} ({day_name_en})")
                
                # Mapping anglais ‚Üí fran√ßais pour compatibilit√© avec les deux formats
                day_name_mapping = {
                    'monday': 'lundi', 'tuesday': 'mardi', 'wednesday': 'mercredi',
                    'thursday': 'jeudi', 'friday': 'vendredi', 'saturday': 'samedi', 'sunday': 'dimanche'
                }
                day_name_fr = day_name_mapping.get(day_name_en, day_name_en)
                
                # CORRECTION CRITIQUE: Skip if type garde doesn't apply to this day
                # Supporte les deux formats: anglais (monday) et fran√ßais (lundi)
                jours_app = type_garde.get("jours_application", [])
                if jours_app and len(jours_app) > 0:
                    # V√©rifier si le jour est dans la liste (anglais OU fran√ßais)
                    jour_applicable = day_name_en in jours_app or day_name_fr in jours_app
                    if not jour_applicable:
                        logging.info(f"‚è≠Ô∏è [SKIP DAY] {type_garde['nom']} - {date_str} ({day_name_en}/{day_name_fr}): Jour non applicable (limit√© √† {jours_app})")
                        continue
                
                # √âTAPE 1: V√©rifier si la garde est d√©j√† compl√®te
                existing_for_garde = [a for a in existing_assignations 
                                     if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                
                personnel_requis = type_garde.get("personnel_requis", 1)
                personnel_assigne = len(existing_for_garde)
                
                # üîç LOG pour debug sur-assignation
                logging.info(f"üîç [ASSIGNATION] {type_garde['nom']} - {date_str}: {personnel_assigne}/{personnel_requis} assign√©s")
                
                # Si d√©j√† complet ou plus, passer √† la garde suivante
                if personnel_assigne >= personnel_requis:
                    logging.info(f"‚úÖ [SKIP] {type_garde['nom']} - {date_str}: Garde d√©j√† compl√®te ({personnel_assigne}/{personnel_requis})")
                    continue  # Garde d√©j√† compl√®te, ne rien ajouter
                
                # Calculer combien de pompiers il faut encore assigner
                places_restantes = personnel_requis - personnel_assigne
                logging.info(f"üìù [DEBUG-PLACES] {type_garde['nom']} - {date_str}: {places_restantes} places restantes, {len(users)} users √† analyser")
                
                # Find available users for this slot
                available_users = []
                logging.info(f"üîÑ [DEBUT-USERS] {type_garde['nom']} - {date_str}: D√©but analyse des {len(users)} utilisateurs")
                user_count = 0
                for user in users:
                    user_count += 1
                    # LOG SP√âCIAL pour Jean-Fran√ßois Tardif (AVANT toute v√©rification)
                    is_jf_tardif = "jean" in user.get("prenom", "").lower() and "tardif" in user.get("nom", "").lower()
                    if is_jf_tardif:
                        logging.info(f"üîç [JF TARDIF] ===== Analyse pour {type_garde['nom']} - {date_str} =====")
                        logging.info(f"    prenom: {user.get('prenom')}")
                        logging.info(f"    nom: {user.get('nom')}")
                        logging.info(f"    statut: {user.get('statut')}")
                        logging.info(f"    type_emploi: {user.get('type_emploi')}")
                        logging.info(f"    fonction_superieur: {user.get('fonction_superieur')}")
                        logging.info(f"    grade: {user.get('grade')}")
                        logging.info(f"    competences: {user.get('competences', [])}")
                    
                    # V√âRIFICATION STATUT ACTIF (doit √™tre en premier)
                    if user.get("statut") != "Actif":
                        if is_jf_tardif:
                            logging.info(f"    ‚ùå [JF TARDIF] EXCLU: Statut non actif ({user.get('statut')})")
                        continue
                    
                    # V√âRIFICATION CRITIQUE: √âviter les conflits d'horaires
                    # Un utilisateur ne peut pas √™tre sur 2 gardes qui se chevauchent
                    user_a_conflit_horaire = False
                    
                    # R√©cup√©rer les horaires de la garde actuelle
                    heure_debut_actuelle = type_garde.get("heure_debut", "")
                    heure_fin_actuelle = type_garde.get("heure_fin", "")
                    
                    for assignation in existing_assignations:
                        if assignation["user_id"] == user["id"] and assignation["date"] == date_str:
                            # L'utilisateur est d√©j√† assign√© √† une garde ce jour
                            garde_existante = next((g for g in types_garde if g["id"] == assignation["type_garde_id"]), None)
                            if garde_existante:
                                # V√©rifier si les horaires se chevauchent R√âELLEMENT
                                heure_debut_existante = garde_existante.get("heure_debut", "")
                                heure_fin_existante = garde_existante.get("heure_fin", "")
                                
                                # V√©rification intelligente de chevauchement avec support des gardes traversant minuit
                                if heure_debut_actuelle and heure_fin_actuelle and heure_debut_existante and heure_fin_existante:
                                    # Convertir les heures en minutes depuis minuit pour comparaison correcte
                                    def time_to_minutes(time_str):
                                        h, m = map(int, time_str.split(':'))
                                        return h * 60 + m
                                    
                                    debut_actuelle_min = time_to_minutes(heure_debut_actuelle)
                                    fin_actuelle_min = time_to_minutes(heure_fin_actuelle)
                                    debut_existante_min = time_to_minutes(heure_debut_existante)
                                    fin_existante_min = time_to_minutes(heure_fin_existante)
                                    
                                    # D√©tecter si les gardes traversent minuit
                                    actuelle_traverse_minuit = fin_actuelle_min < debut_actuelle_min
                                    existante_traverse_minuit = fin_existante_min < debut_existante_min
                                    
                                    # Logique de chevauchement selon les cas
                                    if actuelle_traverse_minuit and existante_traverse_minuit:
                                        # Les deux traversent minuit - elles se chevauchent forc√©ment
                                        chevauchement = True
                                    elif actuelle_traverse_minuit:
                                        # Actuelle traverse minuit (ex: 18:00-06:00)
                                        # Chevauche si existante commence avant fin_actuelle OU termine apr√®s debut_actuelle
                                        chevauchement = (debut_existante_min < fin_actuelle_min) or (fin_existante_min > debut_actuelle_min)
                                    elif existante_traverse_minuit:
                                        # Existante traverse minuit
                                        chevauchement = (debut_actuelle_min < fin_existante_min) or (fin_actuelle_min > debut_existante_min)
                                    else:
                                        # Aucune ne traverse minuit - logique standard
                                        chevauchement = (debut_actuelle_min < fin_existante_min) and (debut_existante_min < fin_actuelle_min)
                                    
                                    if chevauchement:
                                        user_a_conflit_horaire = True
                                        logging.info(f"‚ùå [CONFLIT HORAIRE] {user['prenom']} {user['nom']} d√©j√† sur {garde_existante['nom']} ({heure_debut_existante}-{heure_fin_existante}) chevauche {type_garde['nom']} ({heure_debut_actuelle}-{heure_fin_actuelle})")
                                        logging.info(f"   [DEBUG CONFLIT] Garde existante externe: {garde_existante.get('est_garde_externe', False)}, Garde actuelle externe: {type_garde.get('est_garde_externe', False)}")
                                        break
                                else:
                                    # Si pas d'horaires d√©finis, on consid√®re conflit par s√©curit√©
                                    user_a_conflit_horaire = True
                                    logging.info(f"‚ö†Ô∏è [CONFLIT] {user['prenom']} {user['nom']} d√©j√† assign√© √† {garde_existante['nom']} le {date_str} (horaires non d√©finis)")
                                    break
                    
                    if user_a_conflit_horaire:
                        if is_jf_tardif:
                            logging.info(f"    ‚ùå [JF TARDIF] EXCLU: Conflit d'horaires")
                        continue  # Skip cet utilisateur pour √©viter le conflit
                    
                    # V√âRIFICATION GLOBALE: Gestion de la limite heures_max_semaine
                    # R√àGLE IMPORTANTE: Les gardes EXTERNES n'ont AUCUNE limite d'heures
                    # M√™me si un employ√© a d√©pass√© ses heures max en INTERNE, il peut toujours avoir des gardes EXTERNES
                    if type_garde.get("est_garde_externe", False):
                        # Garde EXTERNE: Pas de v√©rification d'heures max
                        logging.info(f"‚úÖ [GARDE_EXTERNE] {user['prenom']} {user['nom']}: Pas de limite d'heures pour garde externe {type_garde['nom']}")
                    else:
                        # Garde INTERNE: V√©rifier heures_max_semaine POUR LA SEMAINE CALENDAIRE de cette garde
                        heures_max_user = user.get("heures_max_semaine", 40)
                        
                        # Calculer la semaine calendaire de cette garde (lundi = d√©but de semaine)
                        garde_date = datetime.strptime(date_str, "%Y-%m-%d")
                        # Trouver le lundi de cette semaine
                        days_since_monday = garde_date.weekday()  # 0 = lundi, 6 = dimanche
                        semaine_start = garde_date - timedelta(days=days_since_monday)
                        semaine_end = semaine_start + timedelta(days=6)
                        semaine_start_str = semaine_start.strftime("%Y-%m-%d")
                        semaine_end_str = semaine_end.strftime("%Y-%m-%d")
                        
                        if activer_heures_sup:
                            # Heures sup activ√©es : peut d√©passer heures_max_user mais respecter limite syst√®me si elle existe
                            # Pour l'instant, on ne limite pas (les heures sup sont autoris√©es)
                            pass  # Pas de skip, autoriser l'attribution
                        else:
                            # Heures sup D√âSACTIV√âES : appliquer limite intelligente
                            # Si employ√© a mis > 42h, on limite √† 42h (overtime standard = au-del√† de 42h)
                            # Si employ√© a mis < 42h (ex: 25h, 30h), on respecte sa limite
                            heures_max_user = min(heures_max_user, 42)
                            logging.info(f"üîí [LIMITE] {user['prenom']} {user['nom']}: heures_max_semaine limit√©e √† {heures_max_user}h (heures sup d√©sactiv√©es)")
                            # Heures sup D√âSACTIV√âES : v√©rifier strictement heures_max_semaine
                            # CORRECTION CRITIQUE: Calculer les heures pour LA SEMAINE CALENDAIRE de cette garde
                            # (lundi √† dimanche), pas pour toute la p√©riode d'attribution
                            heures_semaine_actuelle = 0
                            
                            # Compter les assignations EXISTANTES + NOUVELLES (avec d√©duplication par ID)
                            assignations_vues = set()  # Pour √©viter de compter 2 fois la m√™me assignation
                            toutes_assignations_semaine = existing_assignations + nouvelles_assignations
                            
                            for assignation in toutes_assignations_semaine:
                                # D√©duplication: ne compter chaque assignation qu'une seule fois
                                assignation_key = f"{assignation['user_id']}_{assignation['type_garde_id']}_{assignation['date']}"
                                if assignation_key in assignations_vues:
                                    continue
                                assignations_vues.add(assignation_key)
                                
                                if assignation["user_id"] == user["id"]:
                                    # CORRECTION CRITIQUE: V√©rifier que l'assignation est dans LA SEMAINE CALENDAIRE de cette garde
                                    # (pas dans toute la p√©riode d'attribution)
                                    if semaine_start_str <= assignation["date"] <= semaine_end_str:
                                        type_g = next((t for t in types_garde if t["id"] == assignation["type_garde_id"]), None)
                                        if type_g:
                                            # Ne compter QUE les gardes internes (gardes externes ne sont pas des heures travaill√©es)
                                            if not type_g.get("est_garde_externe", False):
                                                heures_semaine_actuelle += type_g.get("duree_heures", 8)
                            
                            # Log sp√©cifique pour S√©bastien Charest
                            if user.get("email") == "sebas.charest18@hotmail.com":
                                logging.info(f"üîç [HEURES] S√©bastien Charest - V√©rification heures:")
                                logging.info(f"    heures_max_semaine: {heures_max_user}")
                                logging.info(f"    heures_semaine_actuelle (INTERNES uniquement): {heures_semaine_actuelle}")
                                logging.info(f"    duree_garde: {type_garde.get('duree_heures', 8)}")
                                logging.info(f"    est_garde_externe: {type_garde.get('est_garde_externe', False)}")
                                logging.info(f"    total_si_assign√©: {heures_semaine_actuelle + type_garde.get('duree_heures', 8)}")
                                logging.info(f"    d√©passe_limite: {heures_semaine_actuelle + type_garde.get('duree_heures', 8) > heures_max_user}")
                            
                            # Pour les gardes INTERNES uniquement : v√©rifier heures_max_semaine
                            # Pour les gardes EXTERNES : pas de v√©rification heures (ce ne sont pas des heures travaill√©es)
                            if not type_garde.get("est_garde_externe", False):
                                # Ne PAS attribuer si d√©passe heures_max_semaine
                                if heures_semaine_actuelle + type_garde.get("duree_heures", 8) > heures_max_user:
                                    if user.get("email") == "sebas.charest18@hotmail.com":
                                        logging.info(f"‚ùå [HEURES] S√©bastien Charest EXCLU pour d√©passement limite heures!")
                                    if is_jf_tardif:
                                        logging.info(f"    ‚ùå [JF TARDIF] EXCLU: D√©passement heures max ({heures_semaine_actuelle + type_garde.get('duree_heures', 8)} > {heures_max_user})")
                                    continue  # Skip si d√©passe la limite hebdo
                    
                    # √âTAPE 2: Check if user has availability 
                    # Temps partiel : DOIVENT d√©clarer disponibilit√© (obligatoire) ET accepter les gardes externes
                    # Temps plein : √âligibles comme backup si pas assez de temps partiel disponibles ET acceptent les gardes externes
                    
                    # NOUVELLE V√âRIFICATION: Gardes externes - v√©rifier accepte_gardes_externes
                    if type_garde.get("est_garde_externe", False):
                        if not user.get("accepte_gardes_externes", True):  # Default True pour compatibilit√©
                            # Log sp√©cifique pour debug
                            if user.get("email") == "sebas.charest18@hotmail.com":
                                logging.info(f"‚ùå [GARDE_EXTERNE] S√©bastien Charest EXCLU: accepte_gardes_externes=False")
                            if is_jf_tardif:
                                logging.info(f"    ‚ùå [JF TARDIF] EXCLU: N'accepte pas les gardes externes")
                            continue  # Skip si n'accepte pas les gardes externes
                    
                    if user.get("type_emploi", "temps_plein") in ("temps_partiel", "temporaire"):
                        # V√©rifier si a d√©clar√© une INDISPONIBILIT√â (exclusion totale)
                        has_indispo = (
                            user.get("id") in indispos_lookup and
                            date_str in indispos_lookup[user.get("id")]
                        )
                        
                        if has_indispo:
                            if is_jf_tardif:
                                logging.info(f"    ‚ùå [JF TARDIF] EXCLU: A d√©clar√© une indisponibilit√©")
                            continue  # Skip temps partiel si INDISPONIBLE
                        
                        # Note: Les temps partiel sans dispo (stand-by) sont maintenant inclus
                        # Ils seront tri√©s en priorit√© 2 dans l'√©tape 4
                    
                    # Temps plein : √©ligibles automatiquement pour gardes vacantes (backup)
                    # Note: Les temps plein sont trait√©s apr√®s les temps partiel pour priorit√©
                    # V√©rification heures/comp√©tences d√©j√† faite avant
                    
                    # V√âRIFICATION : Check if user already assigned to THIS TYPE DE GARDE on this date
                    # Important : On permet plusieurs gardes diff√©rentes le m√™me jour (ex: matin + apr√®s-midi)
                    # CORRECTION CRITIQUE: V√©rifier dans existing_assignations ET nouvelles_assignations
                    toutes_assignations_check = existing_assignations + nouvelles_assignations
                    already_assigned = next((a for a in toutes_assignations_check 
                                           if a["date"] == date_str 
                                           and a["user_id"] == user["id"]
                                           and a["type_garde_id"] == type_garde["id"]), None)
                    if already_assigned:
                        continue
                    
                    # V√âRIFICATION DES COMP√âTENCES REQUISES
                    competences_requises = type_garde.get("competences_requises", [])
                    if competences_requises:
                        # V√©rifier si l'utilisateur poss√®de toutes les comp√©tences requises
                        user_competences = user.get("competences", [])
                        has_all_competences = all(comp_id in user_competences for comp_id in competences_requises)
                        
                        # LOG D√âTAILL√â pour TOUTES les gardes (pas seulement Pr√©ventionniste)
                        logging.info(f"üîç [COMPETENCE CHECK] Garde: {type_garde['nom']}")
                        logging.info(f"   User: {user['prenom']} {user['nom']} (Grade: {user.get('grade', 'N/A')})")
                        logging.info(f"   Comp√©tences requises: {competences_requises}")
                        logging.info(f"   Comp√©tences user: {user_competences}")
                        logging.info(f"   A toutes les comp√©tences: {has_all_competences}")
                        
                        if not has_all_competences:
                            # CORRECTION: V√©rification stricte des comp√©tences - AUCUNE exception
                            # Un Premier R√©pondant ne peut PAS faire une garde de Pompier
                            # Un Pompier Auxiliaire ne peut PAS faire une garde n√©cessitant Pompier 1
                            logging.info(f"‚ùå [COMPETENCE] {user['prenom']} {user['nom']} (Grade: {user.get('grade')}) EXCLU - comp√©tences manquantes")
                            if is_jf_tardif:
                                logging.info(f"    ‚ùå [JF TARDIF] EXCLU: Comp√©tences manquantes pour cette garde")
                            continue  # Skip si comp√©tences manquantes - AUCUNE EXCEPTION
                        else:
                            logging.info(f"‚úÖ [COMPETENCE] {user['prenom']} {user['nom']} ELIGIBLE - a toutes les comp√©tences")
                    
                    # D√âDUPLICATION CRITIQUE : Comparer par ID car dict comparison ne fonctionne pas
                    if user["id"] not in [u["id"] for u in available_users]:
                        available_users.append(user)
                        if is_jf_tardif:
                            logging.info(f"    ‚úÖ [JF TARDIF] AJOUT√â √† available_users!")
                
                logging.info(f"üìù [DEBUG-AVAILABLE] {type_garde['nom']} - {date_str}: {len(available_users)} utilisateurs disponibles")
                
                if not available_users:
                    continue
                
                # SAUVEGARDE: Conserver TOUS les candidats AVANT le filtrage officier
                # Cette liste sera utilis√©e pour les postes suivants apr√®s qu'un officier soit assign√©
                tous_candidats_avant_filtrage = available_users.copy()
                
                # √âTAPE 3: V√©rifier si un officier est d√©j√† assign√© (pour info seulement)
                # La logique de s√©lection d'officier sera appliqu√©e APR√àS le filtrage N2-N5
                officier_deja_assigne = False
                besoin_officier = type_garde.get("officier_obligatoire", False)
                
                if besoin_officier:
                    toutes_assignations_pour_officier = existing_assignations + nouvelles_assignations
                    toutes_assignations_garde = [a for a in toutes_assignations_pour_officier 
                                                  if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                    for assignation in toutes_assignations_garde:
                        assigned_user = next((u for u in users if u["id"] == assignation["user_id"]), None)
                        if assigned_user:
                            grade_obj = grades_map.get(assigned_user.get("grade"))
                            if (grade_obj and grade_obj.get("est_officier", False)) or assigned_user.get("fonction_superieur", False):
                                officier_deja_assigne = True
                                logging.info(f"‚úÖ [OFFICIER TROUV√â] {assigned_user.get('prenom')} {assigned_user.get('nom')} ({assigned_user.get('grade')}) d√©j√† assign√© - contrainte satisfaite")
                                break
                    
                    if not officier_deja_assigne:
                        logging.info(f"üéñÔ∏è [OFFICIER] {type_garde['nom']} - {date_str}: Aucun officier assign√©, recherche apr√®s filtrage N2-N5")
                
                # √âTAPE 4: TRI PAR NIVEAUX DE PRIORIT√â (N2, N3, N4, N5)
                # IMPORTANT: Ce tri doit se faire ICI, apr√®s l'√©tape officier
                # Pour garantir que les niveaux sont appliqu√©s sur la liste finale de candidats
                
                # Cat√©gorie 1: Temps partiel DISPONIBLES (ont d√©clar√© une disponibilit√©)
                tp_disponibles = []
                # Cat√©gorie 2: Temps partiel STAND-BY (rien d√©clar√©, ni dispo ni indispo)
                tp_standby = []
                # Cat√©gorie 3: Temps plein INCOMPLETS (< heures_max_semaine)
                tf_incomplets = []
                # Cat√©gorie 4: Temps plein COMPLETS (‚â• heures_max_semaine)
                tf_complets = []
                
                for u in available_users:
                    # Log sp√©cifique pour Guillaume Dubeau
                    if "guillaume" in u.get("prenom", "").lower() and "dubeau" in u.get("nom", "").lower():
                        logging.info(f"üîç [GUILLAUME] Traitement pour {type_garde['nom']} - {date_str}")
                        logging.info(f"    Type emploi: {u.get('type_emploi', 'temps_plein')}")
                        logging.info(f"    Statut: {u.get('statut', 'N/A')}")
                    
                    if u.get("type_emploi", "temps_plein") in ("temps_partiel", "temporaire"):
                        # CORRECTION CRITIQUE: V√©rifier si a d√©clar√© une disponibilit√© QUI COUVRE l'horaire de la garde
                        has_dispo_covering = False
                        
                        if u["id"] in dispos_lookup and date_str in dispos_lookup[u["id"]]:
                            # R√©cup√©rer les horaires de la garde
                            heure_debut_garde = type_garde.get("heure_debut")
                            heure_fin_garde = type_garde.get("heure_fin")
                            
                            # V√©rifier disponibilit√© sp√©cifique pour ce type de garde
                            if type_garde["id"] in dispos_lookup[u["id"]][date_str]:
                                dispos_list = dispos_lookup[u["id"]][date_str][type_garde["id"]]
                                if dispo_couvre_garde(dispos_list, heure_debut_garde, heure_fin_garde):
                                    has_dispo_covering = True
                                    logging.info(f"‚úÖ [DISPO_COUVRE] {u['prenom']} {u['nom']} a une dispo qui couvre {type_garde['nom']} ({heure_debut_garde}-{heure_fin_garde})")
                                else:
                                    logging.info(f"‚ö†Ô∏è [DISPO_PARTIELLE] {u['prenom']} {u['nom']} a une dispo pour {type_garde['nom']} mais ne couvre pas l'horaire complet")
                            
                            # OU disponibilit√© g√©n√©rale (type_garde_id = None)
                            if not has_dispo_covering and None in dispos_lookup[u["id"]][date_str]:
                                dispos_list = dispos_lookup[u["id"]][date_str][None]
                                if dispo_couvre_garde(dispos_list, heure_debut_garde, heure_fin_garde):
                                    has_dispo_covering = True
                                    logging.info(f"‚úÖ [DISPO_GENERALE_COUVRE] {u['prenom']} {u['nom']} a une dispo g√©n√©rale qui couvre {type_garde['nom']} ({heure_debut_garde}-{heure_fin_garde})")
                                else:
                                    logging.info(f"‚ö†Ô∏è [DISPO_GENERALE_PARTIELLE] {u['prenom']} {u['nom']} a une dispo g√©n√©rale mais ne couvre pas l'horaire complet")
                        
                        # V√©rifier si a d√©clar√© une indisponibilit√© (d√©j√† filtr√© normalement, mais double v√©rification)
                        has_indispo = (
                            u["id"] in indispos_lookup and
                            date_str in indispos_lookup[u["id"]]
                        )
                        
                        if has_dispo_covering:
                            tp_disponibles.append(u)
                            logging.info(f"‚úÖ [N2] {u['prenom']} {u['nom']} ajout√© √† T.Partiel DISPONIBLES pour {type_garde['nom']}")
                        elif not has_indispo:  # Ni dispo ni indispo = stand-by
                            tp_standby.append(u)
                            logging.info(f"‚ö†Ô∏è [N3] {u['prenom']} {u['nom']} ajout√© √† T.Partiel STAND-BY (pas de dispo couvrant l'horaire)")
                        # Si indispo, ne rien faire (exclu)
                    else:  # temps_plein
                        # Calculer les heures de LA SEMAINE CALENDAIRE de cette garde (lundi-dimanche)
                        # CORRECTION: Inclure TOUTES les assignations (existantes + nouvelles) avec d√©duplication
                        
                        # Calculer la semaine calendaire de cette garde (m√™me logique que plus haut)
                        garde_date = datetime.strptime(date_str, "%Y-%m-%d")
                        days_since_monday = garde_date.weekday()
                        semaine_start_tf = garde_date - timedelta(days=days_since_monday)
                        semaine_end_tf = semaine_start_tf + timedelta(days=6)
                        semaine_start_tf_str = semaine_start_tf.strftime("%Y-%m-%d")
                        semaine_end_tf_str = semaine_end_tf.strftime("%Y-%m-%d")
                        
                        heures_semaine_actuelle = 0
                        assignations_vues_tf = set()
                        toutes_assignations_tf = existing_assignations + nouvelles_assignations
                        
                        for assignation in toutes_assignations_tf:
                            # D√©duplication
                            assignation_key = f"{assignation['user_id']}_{assignation['type_garde_id']}_{assignation['date']}"
                            if assignation_key in assignations_vues_tf:
                                continue
                            assignations_vues_tf.add(assignation_key)
                            
                            if assignation["user_id"] == u["id"]:
                                # CORRECTION CRITIQUE: V√©rifier que c'est dans LA SEMAINE CALENDAIRE de cette garde
                                if semaine_start_tf_str <= assignation["date"] <= semaine_end_tf_str:
                                    type_g = next((t for t in types_garde if t["id"] == assignation["type_garde_id"]), None)
                                    if type_g and not type_g.get("est_garde_externe", False):
                                        heures_semaine_actuelle += type_g.get("duree_heures", 8)
                        
                        heures_max_user = u.get("heures_max_semaine", 40)
                        
                        if heures_semaine_actuelle < heures_max_user:
                            tf_incomplets.append(u)
                        else:
                            tf_complets.append(u)
                
                # Calculer l'√©quipe de garde du jour pour les temps partiels si activ√©
                equipe_garde_du_jour = None
                if equipes_garde_actif and privilegier_equipe_garde_tp and params_equipes_garde:
                    tp_config = params_equipes_garde.get("temps_partiel", {})
                    if tp_config.get("rotation_active", False):
                        type_rotation = tp_config.get("type_rotation", "personnalisee")
                        if type_rotation in ["montreal", "quebec", "longueuil"]:
                            equipe_garde_du_jour = get_equipe_garde_rotation_standard(type_rotation, "", date_str)
                        elif type_rotation == "personnalisee":
                            date_reference = tp_config.get("date_reference", "")
                            if date_reference:
                                equipe_garde_du_jour = get_equipe_garde_du_jour_sync(
                                    type_rotation=type_rotation,
                                    date_reference=date_reference,
                                    date_cible=date_str,
                                    nombre_equipes=tp_config.get("nombre_equipes", 4),
                                    pattern_mode=tp_config.get("pattern_mode", "hebdomadaire"),
                                    pattern_personnalise=tp_config.get("pattern_personnalise", []),
                                    duree_cycle=tp_config.get("duree_cycle", 28)
                                )
                        if equipe_garde_du_jour:
                            logging.info(f"üî• [√âQUIPE GARDE] {date_str}: √âquipe de garde du jour = {equipe_garde_du_jour}")
                
                # Trier chaque cat√©gorie par √©quit√© (heures du mois) puis anciennet√©
                # AVEC bonus pour l'√©quipe de garde des temps partiels
                def sort_by_equity_and_seniority(users_list, with_equipe_garde_bonus=False):
                    if type_garde.get("est_garde_externe", False):
                        users_list.sort(key=lambda u: (
                            # Bonus √©quipe de garde: -1000 si dans l'√©quipe du jour, 0 sinon (plus petit = prioritaire)
                            0 if not (with_equipe_garde_bonus and equipe_garde_du_jour and u.get("equipe_garde") == equipe_garde_du_jour) else -1000,
                            user_monthly_hours_externes.get(u["id"], 0),  # √âquit√© mensuelle
                            -parse_date_flexible(u.get("date_embauche", "1900-01-01")).timestamp()  # Anciennet√© (plus ancien = priorit√©)
                        ))
                    else:
                        users_list.sort(key=lambda u: (
                            # Bonus √©quipe de garde: -1000 si dans l'√©quipe du jour, 0 sinon
                            0 if not (with_equipe_garde_bonus and equipe_garde_du_jour and u.get("equipe_garde") == equipe_garde_du_jour) else -1000,
                            user_monthly_hours_internes.get(u["id"], 0),  # √âquit√© mensuelle
                            -parse_date_flexible(u.get("date_embauche", "1900-01-01")).timestamp()  # Anciennet√©
                        ))
                    
                    # Log si bonus appliqu√©
                    if with_equipe_garde_bonus and equipe_garde_du_jour:
                        users_equipe = [u for u in users_list if u.get("equipe_garde") == equipe_garde_du_jour]
                        if users_equipe:
                            logging.info(f"üî• [BONUS √âQUIPE] {len(users_equipe)} temps partiel(s) de l'√©quipe {equipe_garde_du_jour} prioris√©(s)")
                
                # Fonction helper pour parse_date_flexible
                def parse_date_flexible(date_str):
                    try:
                        return datetime.strptime(date_str, "%Y-%m-%d")
                    except:
                        try:
                            return datetime.strptime(date_str, "%d/%m/%Y")
                        except:
                            return datetime(1900, 1, 1)
                
                # Appliquer le tri avec bonus √©quipe de garde pour les temps partiels
                sort_by_equity_and_seniority(tp_disponibles, with_equipe_garde_bonus=True)
                sort_by_equity_and_seniority(tp_standby, with_equipe_garde_bonus=True)
                
                # Pour temps plein incomplets : trier par heures manquantes (plus loin de limite = priorit√©)
                def calculer_heures_user_semaine(user_id):
                    """Calcule les heures internes d'un user pour LA SEMAINE CALENDAIRE de cette garde"""
                    # Utiliser la m√™me semaine calendaire que calcul√©e plus haut
                    heures = 0
                    assignations_vues_sort = set()
                    toutes_assign = existing_assignations + nouvelles_assignations
                    for a in toutes_assign:
                        key = f"{a['user_id']}_{a['type_garde_id']}_{a['date']}"
                        if key in assignations_vues_sort:
                            continue
                        assignations_vues_sort.add(key)
                        
                        # CORRECTION CRITIQUE: V√©rifier la semaine calendaire de cette garde
                        if a["user_id"] == user_id and semaine_start_tf_str <= a["date"] <= semaine_end_tf_str:
                            type_g = next((t for t in types_garde if t["id"] == a["type_garde_id"]), None)
                            if type_g and not type_g.get("est_garde_externe", False):
                                heures += type_g.get("duree_heures", 8)
                    return heures
                
                tf_incomplets.sort(key=lambda u: (
                    # Heures manquantes (plus c'est √©lev√©, plus prioritaire)
                    -(u.get("heures_max_semaine", 40) - calculer_heures_user_semaine(u["id"])),
                    user_monthly_hours_externes.get(u["id"], 0) if type_garde.get("est_garde_externe", False) else user_monthly_hours_internes.get(u["id"], 0),
                    -parse_date_flexible(u.get("date_embauche", "1900-01-01")).timestamp()
                ))
                
                sort_by_equity_and_seniority(tf_complets)
                
                # CORRECTION CRITIQUE: Filtrer selon les niveaux d'attribution actifs
                liste_niveaux = []
                if niveaux_actifs["niveau_2"]:
                    liste_niveaux.extend(tp_disponibles)
                else:
                    logging.info(f"‚ö†Ô∏è [NIVEAU 2 D√âSACTIV√â] {len(tp_disponibles)} T.Partiel disponibles exclus")
                
                if niveaux_actifs["niveau_3"]:
                    liste_niveaux.extend(tp_standby)
                else:
                    logging.info(f"‚ö†Ô∏è [NIVEAU 3 D√âSACTIV√â] {len(tp_standby)} T.Partiel stand-by exclus")
                
                if niveaux_actifs["niveau_4"]:
                    liste_niveaux.extend(tf_incomplets)
                else:
                    logging.info(f"‚ö†Ô∏è [NIVEAU 4 D√âSACTIV√â] {len(tf_incomplets)} T.Plein incomplets exclus")
                
                if niveaux_actifs["niveau_5"]:
                    if activer_heures_sup:
                        liste_niveaux.extend(tf_complets)
                    else:
                        logging.info(f"‚ö†Ô∏è [NIVEAU 5] Heures sup d√©sactiv√©es - {len(tf_complets)} T.Plein complets exclus")
                else:
                    logging.info(f"‚ö†Ô∏è [NIVEAU 5 D√âSACTIV√â] {len(tf_complets)} T.Plein complets exclus")
                
                # Reconstruire available_users avec SEULEMENT les niveaux actifs
                available_users = liste_niveaux
                
                logging.info(f"üìä [PRIORIT√â FILTR√âE] {type_garde['nom']} - {date_str}:")
                logging.info(f"    T.Partiel Disponibles: {len(tp_disponibles)} {'‚úÖ' if niveaux_actifs['niveau_2'] else '‚ùå EXCLUS'}")
                logging.info(f"    T.Partiel Stand-by: {len(tp_standby)} {'‚úÖ' if niveaux_actifs['niveau_3'] else '‚ùå EXCLUS'}")
                logging.info(f"    T.Plein Incomplets: {len(tf_incomplets)} {'‚úÖ' if niveaux_actifs['niveau_4'] else '‚ùå EXCLUS'}")
                logging.info(f"    T.Plein Complets: {len(tf_complets)} {'‚úÖ' if niveaux_actifs['niveau_5'] and activer_heures_sup else '‚ùå EXCLUS'}")
                logging.info(f"    Total candidats apr√®s filtrage: {len(available_users)}")
                
                # √âTAPE 4b: S√âLECTION D'OFFICIER APR√àS FILTRAGE N2-N5
                # Si officier obligatoire ET pas encore assign√©, chercher parmi les candidats FILTR√âS
                officier_a_mettre_en_premier = None
                if besoin_officier and not officier_deja_assigne:
                    logging.info(f"üéñÔ∏è [OFFICIER APR√àS N2-N5] {type_garde['nom']} - {date_str}: Recherche d'officier parmi {len(available_users)} candidats filtr√©s")
                    
                    # Priorit√© 1: Chercher un officier (grade avec est_officier=true) parmi les candidats filtr√©s
                    officier_trouve = None
                    for u in available_users:
                        grade_obj = grades_map.get(u.get("grade"))
                        if grade_obj and grade_obj.get("est_officier", False):
                            officier_trouve = u
                            logging.info(f"‚úÖ [OFFICIER TROUV√â] {u.get('prenom')} {u.get('nom')} ({u.get('grade')}) - grade officier")
                            break
                    
                    # Priorit√© 2: Sinon, chercher un pompier avec fonction_superieur parmi les candidats filtr√©s
                    if not officier_trouve:
                        for u in available_users:
                            if u.get("fonction_superieur", False):
                                officier_trouve = u
                                logging.info(f"‚úÖ [OFFICIER FALLBACK] {u.get('prenom')} {u.get('nom')} - fonction_superieur=True")
                                break
                    
                    if officier_trouve:
                        # Mettre l'officier en PREMIER dans la liste pour qu'il soit assign√© en premier
                        officier_a_mettre_en_premier = officier_trouve
                        available_users = [u for u in available_users if u["id"] != officier_trouve["id"]]
                        available_users.insert(0, officier_trouve)
                        logging.info(f"üéñÔ∏è [OFFICIER EN PREMIER] {officier_trouve.get('prenom')} {officier_trouve.get('nom')} sera assign√© en premier")
                    else:
                        # Aucun officier disponible apr√®s filtrage N2-N5
                        logging.warning(f"‚ö†Ô∏è [OFFICIER MANQUANT] Aucun officier/fonction_superieur trouv√© apr√®s filtrage N2-N5 - place laiss√©e vacante")
                        # R√©duire places_restantes car pas d'officier
                        places_restantes = max(0, places_restantes - 1)
                        logging.info(f"üìã [OFFICIER VACANT] {places_restantes} postes pompiers restants √† assigner")
                
                # √âTAPE 5: Les candidats sont d√©j√† tri√©s par priorit√©, √©quit√© et anciennet√©
                # Utiliser directement available_users
                users_with_min_hours = available_users  # D√©j√† tri√©s correctement
                
                # Assigner autant de pompiers que n√©cessaire pour remplir la garde
                pompiers_assignes_cette_iteration = 0
                
                # üîç DEBUG LOGGING pour diagnostic auto-attribution
                logging.info(f"üîç [DEBUG] {type_garde['nom']} - {date_str}:")
                logging.info(f"    places_restantes={places_restantes}")
                logging.info(f"    available_users={len(available_users)} utilisateurs")
                if available_users:
                    logging.info(f"    premier available_user: {available_users[0].get('prenom')} {available_users[0].get('nom')} ({available_users[0].get('type_emploi')})")
                logging.info(f"    users_with_min_hours={len(users_with_min_hours)} utilisateurs")
                if users_with_min_hours:
                    logging.info(f"    premier min_hours_user: {users_with_min_hours[0].get('prenom')} {users_with_min_hours[0].get('nom')}")
                
                # Conserver la liste compl√®te de TOUS les candidats (incluant pompiers) pour r√©int√©grer apr√®s assignation d'un officier
                # CORRECTION: Utiliser tous_candidats_avant_filtrage (sauvegard√© AVANT le filtrage officier)
                # au lieu de liste_niveaux (qui ne contient que les officiers si filtrage appliqu√©)
                all_candidates_backup = tous_candidats_avant_filtrage.copy() if type_garde.get("officier_obligatoire", False) else []
                
                for iteration_idx in range(places_restantes):
                    if not users_with_min_hours:
                        # CORRECTION CRITIQUE: Si la liste est vide mais qu'on a un officier assign√©,
                        # r√©int√©grer TOUS les candidats (pompiers inclus) pour les postes restants
                        if type_garde.get("officier_obligatoire", False) and all_candidates_backup:
                            # V√©rifier si un officier est maintenant assign√©
                            # CORRECTION: Inclure existing_assignations + nouvelles_assignations
                            toutes_assign_pour_check = existing_assignations + nouvelles_assignations
                            toutes_assign_garde = [a for a in toutes_assign_pour_check 
                                                   if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                            officier_maintenant_assigne = False
                            for a in toutes_assign_garde:
                                a_user = next((u for u in users if u["id"] == a["user_id"]), None)
                                if a_user:
                                    grade_obj = grades_map.get(a_user.get("grade"))
                                    if (grade_obj and grade_obj.get("est_officier", False)) or a_user.get("fonction_superieur", False):
                                        officier_maintenant_assigne = True
                                        break
                            
                            if officier_maintenant_assigne:
                                # R√©int√©grer tous les candidats sauf ceux d√©j√† assign√©s
                                # CORRECTION: Utiliser toutes_assign_garde qui inclut les nouvelles assignations
                                users_deja_assignes = [a["user_id"] for a in toutes_assign_garde]
                                candidats_filtres = [u for u in all_candidates_backup if u["id"] not in users_deja_assignes]
                                
                                # CORRECTION: Trier les candidats r√©int√©gr√©s par niveaux (N2, N3, N4, N5)
                                # comme dans l'√©tape 4 originale
                                tp_dispo_reint = []
                                tp_standby_reint = []
                                tf_incomp_reint = []
                                tf_comp_reint = []
                                
                                for u_reint in candidats_filtres:
                                    if u_reint.get("type_emploi", "temps_plein") in ("temps_partiel", "temporaire"):
                                        # V√©rifier dispo
                                        has_dispo = (u_reint["id"] in dispos_lookup and 
                                                    date_str in dispos_lookup[u_reint["id"]])
                                        has_indispo = (u_reint["id"] in indispos_lookup and 
                                                      date_str in indispos_lookup[u_reint["id"]])
                                        if has_dispo:
                                            tp_dispo_reint.append(u_reint)
                                        elif not has_indispo:
                                            tp_standby_reint.append(u_reint)
                                    else:
                                        # Temps plein - calculer heures
                                        heures_u = user_monthly_hours_internes.get(u_reint["id"], 0)
                                        heures_max_u = u_reint.get("heures_max_semaine", 40)
                                        if heures_u < heures_max_u:
                                            tf_incomp_reint.append(u_reint)
                                        else:
                                            tf_comp_reint.append(u_reint)
                                
                                # Reconstruire la liste tri√©e par niveaux
                                users_with_min_hours = []
                                if niveaux_actifs["niveau_2"]:
                                    users_with_min_hours.extend(tp_dispo_reint)
                                if niveaux_actifs["niveau_3"]:
                                    users_with_min_hours.extend(tp_standby_reint)
                                if niveaux_actifs["niveau_4"]:
                                    users_with_min_hours.extend(tf_incomp_reint)
                                if niveaux_actifs["niveau_5"] and activer_heures_sup:
                                    users_with_min_hours.extend(tf_comp_reint)
                                
                                logging.info(f"üîÑ [R√âINT√âGRATION] Officier assign√© - {len(users_with_min_hours)} candidats (pompiers inclus) r√©int√©gr√©s")
                                all_candidates_backup = []  # Vider pour ne pas reboucler
                        
                        if not users_with_min_hours:
                            break  # Plus de pompiers disponibles
                    
                    # Select the best candidate
                    selected_user = users_with_min_hours[0]
                    
                    # G√©n√©rer la justification d√©taill√©e
                    justification = await generer_justification_attribution(
                        selected_user=selected_user,
                        all_candidates=available_users,
                        type_garde=type_garde,
                        date_str=date_str,
                        user_monthly_hours_internes=user_monthly_hours_internes,
                        user_monthly_hours_externes=user_monthly_hours_externes,
                        activer_heures_sup=activer_heures_sup,
                        existing_assignations=existing_assignations,
                        disponibilites_evaluees=None,
                        dispos_lookup=dispos_lookup  # Passer le lookup pour v√©rifier les dispos
                    )
                    
                    # Cr√©er l'assignation avec justification
                    assignation_obj = Assignation(
                        user_id=selected_user["id"],
                        type_garde_id=type_garde["id"],
                        date=date_str,
                        assignation_type="auto",
                        tenant_id=tenant.id,
                        justification=justification,
                        notes_admin=None,
                        justification_historique=[]
                    )
                    
                    await db.assignations.insert_one(assignation_obj.dict())
                    nouvelles_assignations.append(assignation_obj.dict())
                    existing_assignations.append(assignation_obj.dict())
                    pompiers_assignes_cette_iteration += 1
                    
                    # Log de l'assignation pour debug
                    duree = type_garde.get("duree_heures", 8)
                    type_garde_str = "EXTERNE" if type_garde.get("est_garde_externe", False) else "INTERNE"
                    logging.info(f"‚úÖ [ASSIGNATION] {selected_user['prenom']} {selected_user['nom']} assign√© √† {type_garde['nom']} ({type_garde_str}, {duree}h) le {date_str}")
                    
                    # Update monthly hours for next iteration (compteur appropri√© selon type de garde)
                    if type_garde.get("est_garde_externe", False):
                        user_monthly_hours_externes[selected_user["id"]] += duree
                        logging.info(f"   Heures externes mois: {user_monthly_hours_externes[selected_user['id']]}h")
                    else:
                        user_monthly_hours_internes[selected_user["id"]] += duree
                        logging.info(f"   Heures internes mois: {user_monthly_hours_internes[selected_user['id']]}h")
                    
                    # Retirer ce pompier de la liste des disponibles pour cette garde
                    users_with_min_hours.pop(0)
                    
                    # CORRECTION CRITIQUE: Apr√®s assignation d'un officier, v√©rifier si on peut ouvrir aux pompiers
                    if type_garde.get("officier_obligatoire", False) and all_candidates_backup and not users_with_min_hours:
                        # V√©rifier si l'utilisateur assign√© est un officier
                        grade_obj_selected = grades_map.get(selected_user.get("grade"))
                        is_officer = (grade_obj_selected and grade_obj_selected.get("est_officier", False)) or selected_user.get("fonction_superieur", False)
                        
                        if is_officer:
                            # R√©int√©grer tous les candidats sauf TOUS ceux d√©j√† assign√©s √† cette garde
                            toutes_assign_actuelle = existing_assignations + nouvelles_assignations
                            users_deja_assignes = [a["user_id"] for a in toutes_assign_actuelle 
                                                   if a["date"] == date_str and a["type_garde_id"] == type_garde["id"]]
                            candidats_filtres_2 = [u for u in all_candidates_backup if u["id"] not in users_deja_assignes]
                            
                            # CORRECTION: Trier les candidats r√©int√©gr√©s par niveaux (N2, N3, N4, N5)
                            tp_dispo_2 = []
                            tp_standby_2 = []
                            tf_incomp_2 = []
                            tf_comp_2 = []
                            
                            for u_r2 in candidats_filtres_2:
                                if u_r2.get("type_emploi", "temps_plein") in ("temps_partiel", "temporaire"):
                                    has_dispo = (u_r2["id"] in dispos_lookup and date_str in dispos_lookup[u_r2["id"]])
                                    has_indispo = (u_r2["id"] in indispos_lookup and date_str in indispos_lookup[u_r2["id"]])
                                    if has_dispo:
                                        tp_dispo_2.append(u_r2)
                                    elif not has_indispo:
                                        tp_standby_2.append(u_r2)
                                else:
                                    heures_u2 = user_monthly_hours_internes.get(u_r2["id"], 0)
                                    heures_max_u2 = u_r2.get("heures_max_semaine", 40)
                                    if heures_u2 < heures_max_u2:
                                        tf_incomp_2.append(u_r2)
                                    else:
                                        tf_comp_2.append(u_r2)
                            
                            # Reconstruire la liste tri√©e par niveaux
                            users_with_min_hours = []
                            if niveaux_actifs["niveau_2"]:
                                users_with_min_hours.extend(tp_dispo_2)
                            if niveaux_actifs["niveau_3"]:
                                users_with_min_hours.extend(tp_standby_2)
                            if niveaux_actifs["niveau_4"]:
                                users_with_min_hours.extend(tf_incomp_2)
                            if niveaux_actifs["niveau_5"] and activer_heures_sup:
                                users_with_min_hours.extend(tf_comp_2)
                            
                            logging.info(f"üîÑ [OUVERTURE POMPIERS] {selected_user['prenom']} (officier) assign√© - {len(users_with_min_hours)} pompiers maintenant √©ligibles (exclus: {len(users_deja_assignes)})")
                            all_candidates_backup = []  # Vider pour ne pas reboucler
                
                logging.info(f"‚úÖ [FIN-JOUR] {type_garde['nom']} - {date_str}: Jour trait√© avec succ√®s")
        
        # Logs de performance
        perf_end = time.time()
        perf_elapsed = perf_end - perf_start
        logging.info(f"‚è±Ô∏è [PERF] Semaine {semaine_debut} trait√©e en {perf_elapsed:.2f}s - {len(nouvelles_assignations)} assignations cr√©√©es")
        
        return len(nouvelles_assignations)
        
    except Exception as e:
        logging.error(f"‚ùå [ERROR] Erreur traitement semaine {semaine_debut}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Erreur traitement semaine: {str(e)}")

# Endpoint pour mettre √† jour les notes admin d'une assignation
@api_router.put("/{tenant_slug}/assignations/{assignation_id}/notes")
async def update_assignation_notes(
    tenant_slug: str,
    assignation_id: str,
    notes: str = Body(..., embed=True),
    current_user: User = Depends(get_current_user)
):
    """Permet √† un admin de mettre √† jour les notes sur une assignation auto"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Trouver l'assignation
    assignation = await db.assignations.find_one({
        "id": assignation_id,
        "tenant_id": tenant.id
    })
    
    if not assignation:
        raise HTTPException(status_code=404, detail="Assignation non trouv√©e")
    
    # Mettre √† jour les notes
    await db.assignations.update_one(
        {"id": assignation_id},
        {"$set": {"notes_admin": notes}}
    )
    
    return {"message": "Notes mises √† jour avec succ√®s", "notes": notes}

# Endpoint pour g√©n√©rer le rapport d'audit des assignations automatiques
@api_router.get("/{tenant_slug}/planning/rapport-audit")
async def generer_rapport_audit_assignations(
    tenant_slug: str,
    mois: str,  # Format: YYYY-MM
    format: str = "pdf",  # pdf ou excel
    current_user: User = Depends(get_current_user)
):
    """G√©n√®re un rapport d'audit complet des assignations automatiques pour un mois donn√©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # Parser le mois
        annee, mois_num = map(int, mois.split('-'))
        date_debut = datetime(annee, mois_num, 1)
        
        # Calculer la date de fin du mois
        if mois_num == 12:
            date_fin = datetime(annee + 1, 1, 1) - timedelta(days=1)
        else:
            date_fin = datetime(annee, mois_num + 1, 1) - timedelta(days=1)
        
        date_debut_str = date_debut.strftime("%Y-%m-%d")
        date_fin_str = date_fin.strftime("%Y-%m-%d")
        
        # R√©cup√©rer toutes les assignations automatiques du mois
        assignations_auto = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": date_debut_str,
                "$lte": date_fin_str
            },
            "assignation_type": "auto",
            "justification": {"$exists": True, "$ne": None}
        }).to_list(1000)
        
        if not assignations_auto:
            raise HTTPException(status_code=404, detail="Aucune assignation automatique trouv√©e pour ce mois")
        
        # R√©cup√©rer les infos compl√©mentaires (users, types garde)
        users = await db.users.find({"tenant_id": tenant.id}).to_list(1000)
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        
        # Mapper users et types garde
        user_map = {u["id"]: u for u in users}
        type_garde_map = {t["id"]: t for t in types_garde}
        
        # G√©n√©rer le rapport selon le format
        if format == "pdf":
            return await generer_pdf_audit(assignations_auto, user_map, type_garde_map, tenant, mois)
        else:  # excel
            return await generer_excel_audit(assignations_auto, user_map, type_garde_map, tenant, mois)
            
    except ValueError:
        raise HTTPException(status_code=400, detail="Format de mois invalide. Utilisez YYYY-MM")
    except Exception as e:
        logging.error(f"Erreur g√©n√©ration rapport audit: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur g√©n√©ration rapport: {str(e)}")

async def generer_pdf_audit(assignations, user_map, type_garde_map, tenant, mois):
    """G√©n√®re un PDF du rapport d'audit"""
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.platypus import Table, TableStyle, Paragraph, Spacer, PageBreak
    from reportlab.lib.styles import ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    
    # Utiliser la fonction helper pour cr√©er un PDF brand√©
    buffer, doc, elements = create_branded_pdf(tenant, pagesize=A4)
    styles = getSampleStyleSheet()
    
    # Style titre
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    
    # Titre
    titre = Paragraph(f"<b>Rapport d'Audit des Affectations Automatiques</b><br/>{tenant.nom}<br/>P√©riode: {mois}", title_style)
    elements.append(titre)
    elements.append(Spacer(1, 0.3*inch))
    
    # Statistiques globales
    stats = Paragraph(f"<b>Total d'assignations automatiques: {len(assignations)}</b>", styles['Normal'])
    elements.append(stats)
    elements.append(Spacer(1, 0.2*inch))
    
    # Tableau pour chaque assignation
    for idx, assignation in enumerate(assignations[:50], 1):  # Limiter √† 50 pour PDF
        user = user_map.get(assignation["user_id"], {})
        type_garde = type_garde_map.get(assignation["type_garde_id"], {})
        justif = assignation.get("justification", {})
        
        # Info assignation
        info_title = Paragraph(f"<b>{idx}. {user.get('prenom', 'N/A')} {user.get('nom', 'N/A')} - {type_garde.get('nom', 'N/A')} - {assignation['date']}</b>", styles['Heading3'])
        elements.append(info_title)
        
        # Scores
        assigned_user = justif.get("assigned_user", {})
        scores = assigned_user.get("scores", {})
        details = assigned_user.get("details", {})
        
        data_scores = [
            ["Crit√®re", "Score", "D√©tail"],
            ["√âquit√©", f"{scores.get('equite', 0)}/100", f"{details.get('heures_ce_mois', 0)}h (moy: {details.get('moyenne_equipe', 0)}h)"],
            ["Anciennet√©", f"{scores.get('anciennete', 0)}/100", f"{details.get('annees_service', 0)} ans"],
            ["Disponibilit√©", f"{scores.get('disponibilite', 0)}/100", "D√©clar√©e" if details.get('disponibilite_declaree') else "Temps plein"],
            ["Comp√©tences", f"{scores.get('competences', 0)}/100", user.get('grade', 'N/A')],
            ["TOTAL", f"{scores.get('total', 0)}/400", ""]
        ]
        
        table_scores = Table(data_scores, colWidths=[2*inch, 1.5*inch, 2.5*inch])
        table_scores.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#e5e7eb')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.grey)
        ]))
        
        elements.append(table_scores)
        elements.append(Spacer(1, 0.1*inch))
        
        # Notes admin
        notes = assignation.get("notes_admin")
        if notes:
            notes_para = Paragraph(f"<b>Notes admin:</b> {notes}", styles['Normal'])
            elements.append(notes_para)
        
        # Autres candidats (top 3)
        other_candidates = justif.get("other_candidates", [])[:3]
        if other_candidates:
            autres_title = Paragraph("<b>Autres candidats √©valu√©s:</b>", styles['Normal'])
            elements.append(autres_title)
            
            for cand in other_candidates:
                cand_text = f"‚Ä¢ {cand.get('nom_complet', 'N/A')} - {cand.get('excluded_reason', 'N/A')}"
                cand_para = Paragraph(cand_text, styles['Normal'])
                elements.append(cand_para)
        
        elements.append(Spacer(1, 0.3*inch))
        
        # Page break tous les 5 pour √©viter surcharge
        if idx % 5 == 0 and idx < len(assignations):
            elements.append(PageBreak())
    
    doc.build(elements)
    buffer.seek(0)
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename=audit_affectations_{mois}.pdf"
        }
    )

async def generer_excel_audit(assignations, user_map, type_garde_map, tenant, mois):
    """G√©n√®re un fichier Excel du rapport d'audit"""
    from io import BytesIO
    import openpyxl
    from openpyxl.styles import Font, Alignment, PatternFill
    
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Audit Affectations"
    
    # En-t√™te
    ws['A1'] = f"Rapport d'Audit - {tenant.nom}"
    ws['A1'].font = Font(size=14, bold=True)
    ws['A2'] = f"P√©riode: {mois}"
    ws['A3'] = f"Total d'assignations: {len(assignations)}"
    
    # Colonnes
    headers = ["Date", "Garde", "Pompier", "Grade", "Heures mois", "Score √âquit√©", 
               "Score Anciennet√©", "Score Dispo", "Score Comp√©t", "Score Total", 
               "Candidats √©valu√©s", "Notes Admin"]
    
    for col_num, header in enumerate(headers, 1):
        cell = ws.cell(row=5, column=col_num)
        cell.value = header
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")
        cell.alignment = Alignment(horizontal='center')
    
    # Donn√©es
    row_num = 6
    for assignation in assignations:
        user = user_map.get(assignation["user_id"], {})
        type_garde = type_garde_map.get(assignation["type_garde_id"], {})
        justif = assignation.get("justification", {})
        assigned_user = justif.get("assigned_user", {})
        scores = assigned_user.get("scores", {})
        details = assigned_user.get("details", {})
        
        ws.cell(row=row_num, column=1).value = assignation["date"]
        ws.cell(row=row_num, column=2).value = type_garde.get("nom", "N/A")
        ws.cell(row=row_num, column=3).value = f"{user.get('prenom', '')} {user.get('nom', '')}"
        ws.cell(row=row_num, column=4).value = user.get("grade", "N/A")
        ws.cell(row=row_num, column=5).value = details.get("heures_ce_mois", 0)
        ws.cell(row=row_num, column=6).value = scores.get("equite", 0)
        ws.cell(row=row_num, column=7).value = scores.get("anciennete", 0)
        ws.cell(row=row_num, column=8).value = scores.get("disponibilite", 0)
        ws.cell(row=row_num, column=9).value = scores.get("competences", 0)
        ws.cell(row=row_num, column=10).value = scores.get("total", 0)
        ws.cell(row=row_num, column=11).value = justif.get("total_candidates_evaluated", 0)
        ws.cell(row=row_num, column=12).value = assignation.get("notes_admin", "")
        
        row_num += 1
    
    # Ajuster les largeurs avec des valeurs fixes pour √©viter les erreurs MergedCell
    column_widths = {
        'A': 12, 'B': 12, 'C': 15, 'D': 15, 'E': 12, 'F': 12,
        'G': 12, 'H': 12, 'I': 12, 'J': 10, 'K': 10, 'L': 25
    }
    for col_letter, width in column_widths.items():
        ws.column_dimensions[col_letter].width = width
    
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={
            "Content-Disposition": f"attachment; filename=audit_affectations_{mois}.xlsx"
        }
    )

# Endpoint pour obtenir les statistiques personnelles mensuelles
@api_router.get("/{tenant_slug}/users/{user_id}/stats-mensuelles")
async def get_user_monthly_stats(tenant_slug: str, user_id: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ["admin", "superviseur"] and current_user.id != user_id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Get current month assignations for this user
        today = datetime.now(timezone.utc)
        month_start = today.replace(day=1).strftime("%Y-%m-%d")
        month_end = (today.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        month_end = month_end.strftime("%Y-%m-%d")
        
        user_assignations = await db.assignations.find({
            "user_id": user_id,
            "tenant_id": tenant.id,
            "date": {
                "$gte": month_start,
                "$lte": month_end
            }
        }).to_list(1000)
        
        # Get types garde for calculating hours
        types_garde = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        types_dict = {t["id"]: t for t in types_garde}
        
        # Calculate stats
        gardes_ce_mois = len(user_assignations)
        heures_travaillees = 0
        
        for assignation in user_assignations:
            type_garde = types_dict.get(assignation["type_garde_id"])
            if type_garde:
                heures_travaillees += type_garde.get("duree_heures", 8)
        
        # Get user formations count
        user_data = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
        certifications = len(user_data.get("formations", [])) if user_data else 0
        
        return {
            "gardes_ce_mois": gardes_ce_mois,
            "heures_travaillees": heures_travaillees,
            "certifications": certifications,
            "mois": today.strftime("%B %Y")
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du calcul des statistiques: {str(e)}")

# Statistics routes
@api_router.get("/{tenant_slug}/statistiques", response_model=Statistiques)
async def get_statistiques(tenant_slug: str, current_user: User = Depends(get_current_user)):
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # 1. Personnel actif (100% dynamique)
        personnel_count = await db.users.count_documents({"statut": "Actif", "tenant_id": tenant.id})
        
        # 2. Gardes cette semaine (100% dynamique)
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        gardes_count = await db.assignations.count_documents({
            "tenant_id": tenant.id,
            "date": {
                "$gte": start_week.strftime("%Y-%m-%d"),
                "$lte": end_week.strftime("%Y-%m-%d")
            }
        })
        
        # 3. Formations planifi√©es (100% dynamique)
        formations_count = await db.sessions_formation.count_documents({"statut": "planifie", "tenant_id": tenant.id})
        
        # 4. Taux de couverture dynamique - CALCUL CORRECT
        # Calculer le total de personnel requis pour la semaine
        total_assignations_required = await db.types_garde.find({"tenant_id": tenant.id}).to_list(1000)
        total_personnel_requis = 0
        total_personnel_assigne = 0
        
        # Pour chaque jour de la semaine
        for day_offset in range(7):
            current_day = start_week + timedelta(days=day_offset)
            day_name = current_day.strftime("%A").lower()
            
            # Pour chaque type de garde
            for type_garde in total_assignations_required:
                jours_app = type_garde.get("jours_application", [])
                
                # Si ce type de garde s'applique √† ce jour
                if not jours_app or day_name in jours_app:
                    personnel_requis = type_garde.get("personnel_requis", 1)
                    total_personnel_requis += personnel_requis
                    
                    # Compter combien de personnes sont assign√©es pour cette garde ce jour
                    assignations_jour = await db.assignations.count_documents({
                        "tenant_id": tenant.id,
                        "date": current_day.strftime("%Y-%m-%d"),
                        "type_garde_id": type_garde["id"]
                    })
                    
                    total_personnel_assigne += min(assignations_jour, personnel_requis)
        
        # Calcul correct : (personnel assign√© / personnel requis) √ó 100
        taux_couverture = (total_personnel_assigne / total_personnel_requis * 100) if total_personnel_requis > 0 else 0
        
        # Cap √† 100% maximum
        taux_couverture = min(taux_couverture, 100.0)
        
        # 5. Heures travaill√©es ce mois (100% dynamique)
        start_month = today.replace(day=1)
        end_month = (start_month + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        
        assignations_mois = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {
                "$gte": start_month.strftime("%Y-%m-%d"),
                "$lte": end_month.strftime("%Y-%m-%d")
            }
        }).to_list(1000)
        
        # Calculer les heures bas√©es sur les types de garde
        heures_totales = 0
        types_garde_dict = {tg["id"]: tg for tg in total_assignations_required}
        
        for assignation in assignations_mois:
            type_garde = types_garde_dict.get(assignation["type_garde_id"])
            if type_garde:
                heures_totales += type_garde.get("duree_heures", 8)
        
        # 6. Remplacements effectu√©s (100% dynamique)
        remplacements_count = await db.demandes_remplacement.count_documents({"statut": "approuve", "tenant_id": tenant.id})
        
        return Statistiques(
            personnel_actif=personnel_count,
            gardes_cette_semaine=gardes_count,
            formations_planifiees=formations_count,
            taux_couverture=round(taux_couverture, 1),
            heures_travaillees=heures_totales,
            remplacements_effectues=remplacements_count
        )
        
    except Exception as e:
        # Fallback en cas d'erreur
        print(f"Erreur calcul statistiques: {str(e)}")
        return Statistiques(
            personnel_actif=0,
            gardes_cette_semaine=0,
            formations_planifiees=0,
            taux_couverture=0.0,
            heures_travaillees=0,
            remplacements_effectues=0
        )

# R√©initialiser tout le planning (vider toutes assignations)
@api_router.post("/planning/reinitialiser")
async def reinitialiser_planning(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Supprimer toutes les assignations
        result = await db.assignations.delete_many({})
        
        return {
            "message": "Planning r√©initialis√© avec succ√®s",
            "assignations_supprimees": result.deleted_count
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur r√©initialisation: {str(e)}")



# ==================== PARAM√àTRES DE VALIDATION DU PLANNING ====================

@api_router.get("/{tenant_slug}/parametres/validation-planning")
async def get_parametres_validation(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """
    R√©cup√©rer les param√®tres de validation du planning pour le tenant
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les param√®tres de validation ou retourner valeurs par d√©faut
        validation_params = tenant.parametres.get('validation_planning', {
            'frequence': 'mensuel',
            'jour_envoi': 25,  # 25 du mois
            'heure_envoi': '17:00',
            'periode_couverte': 'mois_suivant',
            'envoi_automatique': True,
            'derniere_notification': None
        })
        
        return validation_params
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur r√©cup√©ration param√®tres: {str(e)}")

@api_router.get("/{tenant_slug}/parametres/formations")
async def get_parametres_formations(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """
    R√©cup√©rer les param√®tres de formations pour le tenant
    """
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer les param√®tres de formations ou retourner valeurs par d√©faut
        formation_params = tenant.parametres.get('formations', {
            'heures_minimales_annuelles': 100,
            'pourcentage_presence_minimum': 80,
            'delai_notification_liste_attente': 7,
            'email_notifications_actif': True
        }) if tenant.parametres else {
            'heures_minimales_annuelles': 100,
            'pourcentage_presence_minimum': 80,
            'delai_notification_liste_attente': 7,
            'email_notifications_actif': True
        }
        
        return formation_params
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur r√©cup√©ration param√®tres formations: {str(e)}")

@api_router.put("/{tenant_slug}/parametres/formations")
async def update_parametres_formations(tenant_slug: str, parametres: dict, current_user: User = Depends(get_current_user)):
    """
    Mettre √† jour les param√®tres de formations
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        tenant_doc = await db.tenants.find_one({"id": tenant.id})
        
        if not tenant_doc:
            raise HTTPException(status_code=404, detail="Tenant non trouv√©")
        
        # Mettre √† jour les param√®tres
        current_parametres = tenant_doc.get('parametres', {})
        current_parametres['formations'] = parametres
        
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": {"parametres": current_parametres}}
        )
        
        return {"message": "Param√®tres mis √† jour", "parametres": parametres}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise √† jour param√®tres formations: {str(e)}")

@api_router.put("/{tenant_slug}/parametres/validation-planning")
async def update_parametres_validation(tenant_slug: str, parametres: dict, current_user: User = Depends(get_current_user)):
    """
    Mettre √† jour les param√®tres de validation du planning
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        tenant_doc = await db.tenants.find_one({"id": tenant.id})
        
        if not tenant_doc:
            raise HTTPException(status_code=404, detail="Tenant non trouv√©")
        
        # Mettre √† jour les param√®tres
        current_parametres = tenant_doc.get('parametres', {})
        current_parametres['validation_planning'] = parametres
        
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": {"parametres": current_parametres}}
        )
        
        return {"message": "Param√®tres mis √† jour avec succ√®s", "parametres": parametres}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise √† jour param√®tres: {str(e)}")

@api_router.post("/{tenant_slug}/planning/envoyer-notifications")
async def envoyer_notifications_planning(tenant_slug: str, periode_debut: str, periode_fin: str, current_user: User = Depends(get_current_user)):
    """
    Envoyer les notifications par email √† tous les pompiers avec leurs gardes assign√©es
    
    Args:
        tenant_slug: slug de la caserne
        periode_debut: Date d√©but (YYYY-MM-DD)
        periode_fin: Date fin (YYYY-MM-DD)
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        tenant = await get_tenant_from_slug(tenant_slug)
        
        # R√©cup√©rer toutes les assignations de la p√©riode
        assignations_list = await db.assignations.find({
            "tenant_id": tenant.id,
            "date": {"$gte": periode_debut, "$lte": periode_fin}
        }).to_list(length=None)
        
        # R√©cup√©rer tous les users et types de garde
        users_list = await db.users.find({"tenant_id": tenant.id}).to_list(length=None)
        types_garde_list = await db.types_garde.find({"tenant_id": tenant.id}).to_list(length=None)
        
        # Cr√©er des maps pour acc√®s rapide
        users_map = {u['id']: u for u in users_list}
        types_garde_map = {t['id']: t for t in types_garde_list}
        
        # Grouper les assignations par user
        gardes_par_user = {}
        for assignation in assignations_list:
            user_id = assignation['user_id']
            if user_id not in gardes_par_user:
                gardes_par_user[user_id] = []
            
            type_garde = types_garde_map.get(assignation['type_garde_id'], {})
            
            # Trouver les coll√®gues pour cette garde
            collegues = [
                f"{users_map[a['user_id']]['prenom']} {users_map[a['user_id']]['nom']}"
                for a in assignations_list
                if a['date'] == assignation['date'] and 
                   a['type_garde_id'] == assignation['type_garde_id'] and 
                   a['user_id'] != user_id and 
                   a['user_id'] in users_map
            ]
            
            # Formater la date
            from datetime import datetime as dt
            date_obj = dt.strptime(assignation['date'], '%Y-%m-%d')
            jour_fr = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'][date_obj.weekday()]
            
            gardes_par_user[user_id].append({
                'date': date_obj.strftime('%d %B %Y'),
                'jour': jour_fr,
                'type_garde': type_garde.get('nom', 'Garde'),
                'horaire': f"{type_garde.get('heure_debut', '08:00')} - {type_garde.get('heure_fin', '08:00')}",
                'collegues': collegues
            })
        
        # Envoyer les emails
        emails_envoyes = 0
        emails_echoues = 0
        
        periode_str = f"{dt.strptime(periode_debut, '%Y-%m-%d').strftime('%B %Y')}"
        
        for user_id, gardes in gardes_par_user.items():
            user = users_map.get(user_id)
            if not user or not user.get('email'):
                continue
            
            user_name = f"{user['prenom']} {user['nom']}"
            email_sent = send_gardes_notification_email(
                user['email'],
                user_name,
                gardes,
                tenant_slug,
                periode_str
            )
            
            if email_sent:
                emails_envoyes += 1
            else:
                emails_echoues += 1
        
        # Mettre √† jour la date de derni√®re notification
        tenant_doc = await db.tenants.find_one({"id": tenant.id})
        current_parametres = tenant_doc.get('parametres', {})
        if 'validation_planning' not in current_parametres:
            current_parametres['validation_planning'] = {}
        current_parametres['validation_planning']['derniere_notification'] = datetime.now(timezone.utc).isoformat()
        
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": {"parametres": current_parametres}}
        )
        
        return {
            "message": "Notifications envoy√©es",
            "emails_envoyes": emails_envoyes,
            "emails_echoues": emails_echoues,
            "total_pompiers": len(gardes_par_user)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur envoi notifications: {str(e)}")



 


# R√©parer tous les mots de passe d√©mo
@api_router.post("/repair-demo-passwords")
async def repair_demo_passwords():
    try:
        password_fixes = [
            ("admin@firemanager.ca", "admin123"),
            ("superviseur@firemanager.ca", "superviseur123"),
            ("employe@firemanager.ca", "employe123"),
            ("partiel@firemanager.ca", "partiel123")
        ]
        
        fixed_count = 0
        for email, password in password_fixes:
            user = await db.users.find_one({"email": email})
            if user:
                new_hash = get_password_hash(password)
                await db.users.update_one(
                    {"email": email},
                    {"$set": {"mot_de_passe_hash": new_hash}}
                )
                fixed_count += 1
                print(f"Fixed password for {email}")
        
        return {"message": f"{fixed_count} mots de passe d√©mo r√©par√©s"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Fix all demo passwords endpoint
@api_router.post("/fix-all-passwords")
async def fix_all_passwords():
    try:
        # Fix all demo account passwords
        password_fixes = [
            ("admin@firemanager.ca", "admin123"),
            ("superviseur@firemanager.ca", "superviseur123"),
            ("employe@firemanager.ca", "employe123"),
            ("partiel@firemanager.ca", "partiel123")
        ]
        
        fixed_count = 0
        for email, password in password_fixes:
            user = await db.users.find_one({"email": email})
            if user:
                new_hash = get_password_hash(password)
                await db.users.update_one(
                    {"email": email},
                    {"$set": {"mot_de_passe_hash": new_hash}}
                )
                fixed_count += 1
                print(f"Fixed password for {email}")
        
        return {"message": f"{fixed_count} mots de passe r√©par√©s"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Fix admin password endpoint
@api_router.post("/fix-admin-password")
async def fix_admin_password():
    try:
        # Find admin user
        admin_user = await db.users.find_one({"email": "admin@firemanager.ca"})
        if admin_user:
            # Update password hash
            new_password_hash = get_password_hash("admin123")
            await db.users.update_one(
                {"email": "admin@firemanager.ca"},
                {"$set": {"mot_de_passe_hash": new_password_hash}}
            )
            return {"message": "Mot de passe admin r√©par√©"}
        else:
            return {"message": "Compte admin non trouv√©"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Clean up endpoint
@api_router.post("/cleanup-duplicates")
async def cleanup_duplicates(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Clean formations duplicates - keep only unique ones by name
        formations = await db.formations.find().to_list(1000)
        unique_formations = {}
        
        for formation in formations:
            name = formation['nom']
            if name not in unique_formations:
                unique_formations[name] = formation
        
        # Delete all formations and re-insert unique ones
        await db.formations.delete_many({})
        
        if unique_formations:
            formations_to_insert = []
            for formation in unique_formations.values():
                formation.pop('_id', None)  # Remove MongoDB _id
                formations_to_insert.append(formation)
            
            await db.formations.insert_many(formations_to_insert)
        
        # Clean types garde duplicates
        types_garde = await db.types_garde.find().to_list(1000)
        unique_types = {}
        
        for type_garde in types_garde:
            key = f"{type_garde['nom']}_{type_garde['heure_debut']}_{type_garde['heure_fin']}"
            if key not in unique_types:
                unique_types[key] = type_garde
        
        # Delete all types garde and re-insert unique ones
        await db.types_garde.delete_many({})
        
        if unique_types:
            types_to_insert = []
            for type_garde in unique_types.values():
                type_garde.pop('_id', None)  # Remove MongoDB _id
                types_to_insert.append(type_garde)
            
            await db.types_garde.insert_many(types_to_insert)
        
        formations_count = len(unique_formations)
        types_count = len(unique_types)
        
        return {
            "message": f"Nettoyage termin√©: {formations_count} formations uniques, {types_count} types de garde uniques"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du nettoyage: {str(e)}")

# Cr√©er donn√©es de d√©monstration r√©alistes avec historique
@api_router.post("/init-demo-data-realiste")
async def init_demo_data_realiste():
    try:
        # Clear existing data
        await db.users.delete_many({})
        await db.types_garde.delete_many({})
        await db.assignations.delete_many({})
        await db.planning.delete_many({})
        await db.demandes_remplacement.delete_many({})
        await db.formations.delete_many({})
        await db.sessions_formation.delete_many({})
        await db.disponibilites.delete_many({})
        
        # Cr√©er plus d'utilisateurs r√©alistes
        demo_users = [
            {
                "nom": "Dupont", "prenom": "Jean", "email": "admin@firemanager.ca",
                "telephone": "514-111-2233", "contact_urgence": "514-999-1111",
                "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "admin", "numero_employe": "ADM001",
                "date_embauche": "14/01/2020", "formations": [], "mot_de_passe": "admin123"
            },
            {
                "nom": "Dubois", "prenom": "Sophie", "email": "superviseur@firemanager.ca",
                "telephone": "514-444-5566", "contact_urgence": "514-888-2222",
                "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "POM001",
                "date_embauche": "07/01/2022", "formations": [], "mot_de_passe": "superviseur123"
            },
            {
                "nom": "Bernard", "prenom": "Pierre", "email": "employe@firemanager.ca",
                "telephone": "418-555-9999", "contact_urgence": "418-777-3333",
                "grade": "Capitaine", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM002",
                "date_embauche": "21/09/2019", "formations": [], "mot_de_passe": "employe123"
            },
            {
                "nom": "Garcia", "prenom": "Claire", "email": "partiel@firemanager.ca",
                "telephone": "514-888-9900", "contact_urgence": "514-666-4444",
                "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel",
                "heures_max_semaine": 25, "role": "employe", "numero_employe": "POM005",
                "date_embauche": "02/11/2020", "formations": [], "mot_de_passe": "partiel123"
            },
            # Nouveaux utilisateurs pour d√©mo r√©aliste
            {
                "nom": "Tremblay", "prenom": "Marc", "email": "marc.tremblay@firemanager.ca",
                "telephone": "418-222-3333", "contact_urgence": "418-999-4444",
                "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein",
                "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM003",
                "date_embauche": "15/03/2021", "formations": [], "mot_de_passe": "TempPass123!"
            },
            {
                "nom": "Martin", "prenom": "Sarah", "email": "sarah.martin@firemanager.ca",
                "telephone": "514-333-4444", "contact_urgence": "514-777-8888",
                "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel",
                "heures_max_semaine": 20, "role": "employe", "numero_employe": "POM006",
                "date_embauche": "10/08/2023", "formations": [], "mot_de_passe": "TempPass123!"
            }
        ]
        
        # Cr√©er formations avec plus de d√©tails
        demo_formations = [
            {"nom": "Classe 4A", "description": "Formation de conduite v√©hicules lourds", "duree_heures": 40, "validite_mois": 60, "obligatoire": False},
            {"nom": "D√©sincarc√©ration", "description": "Techniques de d√©sincarc√©ration", "duree_heures": 24, "validite_mois": 36, "obligatoire": True},
            {"nom": "Pompier 1", "description": "Formation de base pompier niveau 1", "duree_heures": 200, "validite_mois": 24, "obligatoire": True},
            {"nom": "Officier 2", "description": "Formation officier niveau 2", "duree_heures": 120, "validite_mois": 36, "obligatoire": False},
            {"nom": "Premiers R√©pondants", "description": "Formation premiers secours", "duree_heures": 16, "validite_mois": 12, "obligatoire": True},
            {"nom": "Sauvetage Aquatique", "description": "Techniques de sauvetage en milieu aquatique", "duree_heures": 32, "validite_mois": 24, "obligatoire": False}
        ]
        
        formation_ids = {}
        for formation_data in demo_formations:
            formation_obj = Formation(**formation_data)
            await db.formations.insert_one(formation_obj.dict())
            formation_ids[formation_data["nom"]] = formation_obj.id
        
        # Assigner formations aux utilisateurs
        demo_users[0]["formations"] = [formation_ids["Officier 2"], formation_ids["Pompier 1"]]
        demo_users[1]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"]]
        demo_users[2]["formations"] = [formation_ids["Classe 4A"], formation_ids["D√©sincarc√©ration"], formation_ids["Premiers R√©pondants"]]
        demo_users[3]["formations"] = [formation_ids["Pompier 1"]]
        demo_users[4]["formations"] = [formation_ids["D√©sincarc√©ration"], formation_ids["Premiers R√©pondants"], formation_ids["Sauvetage Aquatique"]]
        demo_users[5]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"]]
        
        # Cr√©er utilisateurs
        user_ids = {}
        for user_data in demo_users:
            user_dict = user_data.copy()
            user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
            user_dict["statut"] = "Actif"
            user_obj = User(**user_dict)
            await db.users.insert_one(user_obj.dict())
            user_ids[user_data["email"]] = user_obj.id
        
        # Cr√©er assignations historiques (3 mois)
        assignations_created = 0
        for week_offset in range(-12, 1):  # 12 semaines pass√©es + semaine courante
            week_start = datetime.now(timezone.utc).date() + timedelta(weeks=week_offset)
            week_start = week_start - timedelta(days=week_start.weekday())
            
            for day_offset in range(7):
                date_assignation = week_start + timedelta(days=day_offset)
                date_str = date_assignation.strftime("%Y-%m-%d")
                
                # Assigner quelques gardes al√©atoirement
                if assignations_created % 3 == 0:  # Environ 1/3 des jours
                    # Garde Interne AM
                    assignation_obj = Assignation(
                        user_id=user_ids["employe@firemanager.ca"],
                        type_garde_id="garde-interne-am",  # Sera cr√©√© apr√®s
                        date=date_str,
                        assignation_type="auto"
                    )
                    await db.assignations.insert_one(assignation_obj.dict())
                    assignations_created += 1
        
        return {"message": f"Donn√©es de d√©monstration r√©alistes cr√©√©es : {len(demo_users)} utilisateurs, {len(demo_formations)} formations, {assignations_created} assignations historiques"}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Affecter disponibilit√©s √† TOUS les employ√©s temps partiel existants (auto-d√©tection)
@api_router.post("/auto-affecter-disponibilites-temps-partiel")
async def auto_affecter_disponibilites_temps_partiel(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # D√âTECTION AUTOMATIQUE de tous les employ√©s temps partiel
        tous_temps_partiel = await db.users.find({
            "type_emploi": "temps_partiel",
            "statut": "Actif"
        }).to_list(1000)
        
        print(f"Trouv√© {len(tous_temps_partiel)} employ√©s temps partiel")
        
        # Supprimer les anciennes disponibilit√©s de la semaine courante
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        await db.disponibilites.delete_many({
            "date": {
                "$gte": start_week.strftime("%Y-%m-%d"),
                "$lte": end_week.strftime("%Y-%m-%d")
            }
        })
        
        # R√©cup√©rer types de garde
        types_garde = await db.types_garde.find().to_list(100)
        
        disponibilites_created = 0
        
        # AFFECTER DISPONIBILIT√âS √Ä TOUS LES TEMPS PARTIEL D√âTECT√âS
        for index, user in enumerate(tous_temps_partiel):
            print(f"Affectation pour {user['prenom']} {user['nom']} ({user['grade']})")
            
            # Pattern de disponibilit√© selon l'index pour vari√©t√©
            if index % 4 == 0:  # Pattern 1: Lun-Mer-Ven
                jours_disponibles = [0, 2, 4]
            elif index % 4 == 1:  # Pattern 2: Mar-Jeu-Sam  
                jours_disponibles = [1, 3, 5]
            elif index % 4 == 2:  # Pattern 3: Mer-Ven-Dim
                jours_disponibles = [2, 4, 6]
            else:  # Pattern 4: Lun-Jeu-Dim
                jours_disponibles = [0, 3, 6]
            
            for day_offset in jours_disponibles:
                date_dispo = start_week + timedelta(days=day_offset)
                date_str = date_dispo.strftime("%Y-%m-%d")
                day_name = date_dispo.strftime("%A").lower()
                
                # Cr√©er disponibilit√©s pour TOUS les types de garde applicables
                for type_garde in types_garde:
                    jours_app = type_garde.get("jours_application", [])
                    if jours_app and day_name not in jours_app:
                        continue
                    
                    # Cr√©er disponibilit√© (strat√©gie intensive pour d√©mo)
                    dispo_obj = Disponibilite(
                        user_id=user["id"],
                        date=date_str,
                        type_garde_id=type_garde["id"],
                        heure_debut=type_garde["heure_debut"],
                        heure_fin=type_garde["heure_fin"],
                        statut="disponible"
                    )
                    await db.disponibilites.insert_one(dispo_obj.dict())
                    disponibilites_created += 1
        
        return {
            "message": "Disponibilit√©s affect√©es automatiquement",
            "employes_temps_partiel_detectes": len(tous_temps_partiel),
            "disponibilites_creees": disponibilites_created,
            "semaine": f"{start_week.strftime('%Y-%m-%d')} - {end_week.strftime('%Y-%m-%d')}",
            "patterns": "4 patterns diff√©rents pour vari√©t√© d√©mo",
            "employ√©s_d√©tect√©s": [f"{u['prenom']} {u['nom']} ({u['grade']})" for u in tous_temps_partiel]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur auto-affectation: {str(e)}")

# Cr√©er disponibilit√©s MAXIMALES pour d√©mo parfaite
@api_router.post("/init-disponibilites-demo-complete")
async def init_disponibilites_demo_complete(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Supprimer toutes les disponibilit√©s existantes
        await db.disponibilites.delete_many({})
        
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        # R√©cup√©rer TOUS les utilisateurs (temps plein ET temps partiel pour d√©mo)
        all_users = await db.users.find({"statut": "Actif"}).to_list(100)
        types_garde = await db.types_garde.find().to_list(100)
        
        disponibilites_created = 0
        
        # STRAT√âGIE D√âMO : TOUS LES EMPLOY√âS DISPONIBLES POUR TOUS LES TYPES
        for user in all_users:
            for day_offset in range(7):  # Chaque jour
                date_dispo = start_week + timedelta(days=day_offset)
                date_str = date_dispo.strftime("%Y-%m-%d")
                day_name = date_dispo.strftime("%A").lower()
                
                for type_garde in types_garde:
                    # V√©rifier jours d'application
                    jours_app = type_garde.get("jours_application", [])
                    if jours_app and day_name not in jours_app:
                        continue
                    
                    # CR√âER DISPONIBILIT√â POUR TOUS (temps plein et temps partiel)
                    # Exception : respecter les heures max pour temps partiel
                    if user.get("type_emploi", "temps_plein") in ("temps_partiel", "temporaire"):
                        # Temps partiel : disponible seulement 3 jours par semaine
                        user_number = int(user["numero_employe"][-1]) if user["numero_employe"][-1].isdigit() else 0
                        
                        # Pattern par employ√© pour √©viter √©puisement
                        if user_number % 3 == 0 and day_offset in [0, 2, 4]:  # Lun-Mer-Ven
                            pass
                        elif user_number % 3 == 1 and day_offset in [1, 3, 5]:  # Mar-Jeu-Sam
                            pass  
                        elif user_number % 3 == 2 and day_offset in [2, 4, 6]:  # Mer-Ven-Dim
                            pass
                        else:
                            continue  # Skip ce jour pour cet employ√©
                    
                    # CR√âER DISPONIBILIT√â
                    dispo_obj = Disponibilite(
                        user_id=user["id"],
                        date=date_str,
                        type_garde_id=type_garde["id"],
                        heure_debut=type_garde["heure_debut"],
                        heure_fin=type_garde["heure_fin"],
                        statut="disponible"
                    )
                    await db.disponibilites.insert_one(dispo_obj.dict())
                    disponibilites_created += 1
        
        return {
            "message": "Disponibilit√©s D√âMO COMPL√àTES cr√©√©es",
            "semaine": f"{start_week.strftime('%Y-%m-%d')} - {end_week.strftime('%Y-%m-%d')}",
            "disponibilites_creees": disponibilites_created,
            "all_users_included": len(all_users),
            "strategy": "TOUS employ√©s (TP+TPa) avec patterns optimis√©s"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Cr√©er disponibilit√©s pour semaine courante (d√©mo assignation auto)
@api_router.post("/init-disponibilites-semaine-courante")
async def init_disponibilites_semaine_courante(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    try:
        # Supprimer les disponibilit√©s existantes pour la semaine courante
        today = datetime.now(timezone.utc).date()
        start_week = today - timedelta(days=today.weekday())
        end_week = start_week + timedelta(days=6)
        
        await db.disponibilites.delete_many({
            "date": {
                "$gte": start_week.strftime("%Y-%m-%d"),
                "$lte": end_week.strftime("%Y-%m-%d")
            }
        })
        
        # R√©cup√©rer tous les types de garde
        types_garde = await db.types_garde.find().to_list(100)
        # D√âTECTION AUTOMATIQUE de TOUS les employ√©s temps partiel (peu importe le nombre)
        tous_temps_partiel = await db.users.find({
            "type_emploi": "temps_partiel",
            "statut": "Actif"
        }).to_list(1000)
        
        print(f"AUTO-D√âTECTION: {len(tous_temps_partiel)} employ√©s temps partiel trouv√©s")
        
        disponibilites_created = 0
        
        # ALGORITHME OPTIMIS√â POUR TOUS VOS EMPLOY√âS TEMPS PARTIEL
        for user_index, user in enumerate(tous_temps_partiel):
            for day_offset in range(7):  # Chaque jour de la semaine courante
                date_dispo = start_week + timedelta(days=day_offset)
                date_str = date_dispo.strftime("%Y-%m-%d")
                day_name = date_dispo.strftime("%A").lower()
                
                # Pattern de disponibilit√© vari√© selon l'employ√©
                if user_index % 3 == 0:  # 1/3 des employ√©s : Lun-Mer-Ven
                    jours_pattern = ['monday', 'wednesday', 'friday']
                elif user_index % 3 == 1:  # 1/3 des employ√©s : Mar-Jeu-Sam
                    jours_pattern = ['tuesday', 'thursday', 'saturday']
                else:  # 1/3 des employ√©s : Mer-Ven-Dim
                    jours_pattern = ['wednesday', 'friday', 'sunday']
                
                if day_name in jours_pattern:
                    # Cr√©er disponibilit√©s pour TOUS les types de garde applicables
                    for type_garde in types_garde:
                        jours_app = type_garde.get("jours_application", [])
                        if jours_app and day_name not in jours_app:
                            continue
                        
                        # CR√âER DISPONIBILIT√â pour vos employ√©s (pompiers ET lieutenants)
                        dispo_obj = Disponibilite(
                            user_id=user["id"],
                            date=date_str,
                            type_garde_id=type_garde["id"],
                            heure_debut=type_garde["heure_debut"],
                            heure_fin=type_garde["heure_fin"],
                            statut="disponible"
                        )
                        await db.disponibilites.insert_one(dispo_obj.dict())
                        disponibilites_created += 1
        
        return {
            "message": "Disponibilit√©s cr√©√©es pour TOUS vos employ√©s temps partiel",
            "employes_temps_partiel": len(tous_temps_partiel),
            "disponibilites_creees": disponibilites_created,
            "all_users_included": len(tous_temps_partiel),
            "strategy": f"AUTO-D√âTECTION: {len(tous_temps_partiel)} employ√©s temps partiel avec patterns optimis√©s"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Cr√©er donn√©es de d√©monstration OPTIMALES pour d√©mo client
@api_router.post("/init-demo-client-data")
async def init_demo_client_data():
    try:
        # Clear existing data
        await db.users.delete_many({})
        await db.types_garde.delete_many({})
        await db.assignations.delete_many({})
        await db.formations.delete_many({})
        await db.sessions_formation.delete_many({})
        await db.disponibilites.delete_many({})
        await db.demandes_remplacement.delete_many({})
        
        # 1. √âQUIPE R√âALISTE CASERNE (15 pompiers)
        demo_users = [
            # DIRECTION ET ADMINISTRATION
            {"nom": "Dupont", "prenom": "Jean", "email": "admin@firemanager.ca", "telephone": "514-111-2233", "contact_urgence": "514-999-1111", "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "admin", "numero_employe": "DIR001", "date_embauche": "14/01/2015", "formations": [], "mot_de_passe": "admin123"},
            {"nom": "Tremblay", "prenom": "Marie", "email": "directrice@firemanager.ca", "telephone": "514-222-3344", "contact_urgence": "514-888-1111", "grade": "Directeur", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "DIR002", "date_embauche": "03/06/2018", "formations": [], "mot_de_passe": "superviseur123"},
            
            # SUPERVISEURS / CAPITAINES
            {"nom": "Dubois", "prenom": "Sophie", "email": "superviseur@firemanager.ca", "telephone": "514-444-5566", "contact_urgence": "514-888-2222", "grade": "Capitaine", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "CAP001", "date_embauche": "07/01/2019", "formations": [], "mot_de_passe": "superviseur123"},
            {"nom": "Leblanc", "prenom": "Michel", "email": "michel.leblanc@firemanager.ca", "telephone": "418-333-4455", "contact_urgence": "418-777-5555", "grade": "Capitaine", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "superviseur", "numero_employe": "CAP002", "date_embauche": "15/08/2020", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # LIEUTENANTS
            {"nom": "Bernard", "prenom": "Pierre", "email": "employe@firemanager.ca", "telephone": "418-555-9999", "contact_urgence": "418-777-3333", "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "LT001", "date_embauche": "21/09/2019", "formations": [], "mot_de_passe": "employe123"},
            {"nom": "Gagnon", "prenom": "Julie", "email": "julie.gagnon@firemanager.ca", "telephone": "514-666-7788", "contact_urgence": "514-999-3333", "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "LT002", "date_embauche": "10/03/2021", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Roy", "prenom": "Alexandre", "email": "alex.roy@firemanager.ca", "telephone": "450-111-2222", "contact_urgence": "450-888-4444", "grade": "Lieutenant", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "LT003", "date_embauche": "05/11/2022", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # POMPIERS TEMPS PLEIN
            {"nom": "Lavoie", "prenom": "Marc", "email": "marc.lavoie@firemanager.ca", "telephone": "514-777-8899", "contact_urgence": "514-666-5555", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM001", "date_embauche": "12/04/2021", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "C√¥t√©", "prenom": "David", "email": "david.cote@firemanager.ca", "telephone": "418-888-9900", "contact_urgence": "418-555-6666", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM002", "date_embauche": "28/09/2022", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Bouchard", "prenom": "Simon", "email": "simon.bouchard@firemanager.ca", "telephone": "514-999-1234", "contact_urgence": "514-777-7777", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM003", "date_embauche": "16/01/2023", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # POMPIERS TEMPS PARTIEL POUR D√âMO ASSIGNATION AUTO (12 employ√©s)
            {"nom": "Garcia", "prenom": "Claire", "email": "partiel@firemanager.ca", "telephone": "514-888-9900", "contact_urgence": "514-666-4444", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 25, "role": "employe", "numero_employe": "PTP001", "date_embauche": "02/11/2023", "formations": [], "mot_de_passe": "partiel123"},
            {"nom": "Martin", "prenom": "Sarah", "email": "sarah.martin@firemanager.ca", "telephone": "450-555-6666", "contact_urgence": "450-999-8888", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 30, "role": "employe", "numero_employe": "PTP002", "date_embauche": "15/06/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Pelletier", "prenom": "√âmilie", "email": "emilie.pelletier@firemanager.ca", "telephone": "418-333-7777", "contact_urgence": "418-666-9999", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 20, "role": "employe", "numero_employe": "PTP003", "date_embauche": "08/02/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Bergeron", "prenom": "Thomas", "email": "thomas.bergeron@firemanager.ca", "telephone": "514-444-8888", "contact_urgence": "514-333-9999", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 28, "role": "employe", "numero_employe": "PTP004", "date_embauche": "22/08/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Rousseau", "prenom": "Jessica", "email": "jessica.rousseau@firemanager.ca", "telephone": "514-777-1111", "contact_urgence": "514-888-2222", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 24, "role": "employe", "numero_employe": "PTP005", "date_embauche": "12/03/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Fournier", "prenom": "Antoine", "email": "antoine.fournier@firemanager.ca", "telephone": "418-555-2222", "contact_urgence": "418-777-3333", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 32, "role": "employe", "numero_employe": "PTP006", "date_embauche": "05/01/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Leclerc", "prenom": "Mathieu", "email": "mathieu.leclerc@firemanager.ca", "telephone": "450-666-3333", "contact_urgence": "450-888-4444", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 26, "role": "employe", "numero_employe": "PTP007", "date_embauche": "18/07/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Gauthier", "prenom": "Isabelle", "email": "isabelle.gauthier@firemanager.ca", "telephone": "514-999-4444", "contact_urgence": "514-666-5555", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 22, "role": "employe", "numero_employe": "PTP008", "date_embauche": "30/04/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Beaulieu", "prenom": "Nicolas", "email": "nicolas.beaulieu@firemanager.ca", "telephone": "418-444-5555", "contact_urgence": "418-777-6666", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 35, "role": "employe", "numero_employe": "PTP009", "date_embauche": "14/09/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Caron", "prenom": "Melissa", "email": "melissa.caron@firemanager.ca", "telephone": "514-333-6666", "contact_urgence": "514-999-7777", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 29, "role": "employe", "numero_employe": "PTP010", "date_embauche": "25/05/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Simard", "prenom": "Gabriel", "email": "gabriel.simard@firemanager.ca", "telephone": "450-777-7777", "contact_urgence": "450-333-8888", "grade": "Pompier", "fonction_superieur": True, "type_emploi": "temps_partiel", "heures_max_semaine": 27, "role": "employe", "numero_employe": "PTP011", "date_embauche": "03/11/2024", "formations": [], "mot_de_passe": "TempPass123!"},
            {"nom": "Mercier", "prenom": "Val√©rie", "email": "valerie.mercier@firemanager.ca", "telephone": "418-888-8888", "contact_urgence": "418-555-9999", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_partiel", "heures_max_semaine": 31, "role": "employe", "numero_employe": "PTP012", "date_embauche": "17/12/2023", "formations": [], "mot_de_passe": "TempPass123!"},
            
            # NOUVELLES RECRUES
            {"nom": "Morin", "prenom": "Kevin", "email": "kevin.morin@firemanager.ca", "telephone": "514-111-9999", "contact_urgence": "514-222-8888", "grade": "Pompier", "fonction_superieur": False, "type_emploi": "temps_plein", "heures_max_semaine": 40, "role": "employe", "numero_employe": "POM004", "date_embauche": "01/09/2024", "formations": [], "mot_de_passe": "TempPass123!"}
        ]
        
        # 2. FORMATIONS COMPL√àTES POUR CASERNE
        demo_formations = [
            {"nom": "Pompier 1", "description": "Formation de base pompier niveau 1 - Obligatoire pour tous", "duree_heures": 200, "validite_mois": 24, "obligatoire": True},
            {"nom": "Premiers R√©pondants", "description": "Formation premiers secours et r√©animation", "duree_heures": 16, "validite_mois": 12, "obligatoire": True},
            {"nom": "D√©sincarc√©ration", "description": "Techniques de d√©sincarc√©ration et sauvetage routier", "duree_heures": 24, "validite_mois": 36, "obligatoire": True},
            {"nom": "Classe 4A", "description": "Permis de conduire v√©hicules lourds et √©chelles", "duree_heures": 40, "validite_mois": 60, "obligatoire": False},
            {"nom": "Officier 2", "description": "Formation commandement et leadership", "duree_heures": 120, "validite_mois": 36, "obligatoire": False},
            {"nom": "Sauvetage Aquatique", "description": "Techniques de sauvetage en milieu aquatique", "duree_heures": 32, "validite_mois": 24, "obligatoire": False},
            {"nom": "Mati√®res Dangereuses", "description": "Intervention mati√®res dangereuses HAZMAT", "duree_heures": 48, "validite_mois": 36, "obligatoire": False},
            {"nom": "Sauvetage Technique", "description": "Sauvetage en espace clos et hauteur", "duree_heures": 56, "validite_mois": 24, "obligatoire": False}
        ]
        
        formation_ids = {}
        for formation_data in demo_formations:
            formation_obj = Formation(**formation_data)
            await db.formations.insert_one(formation_obj.dict())
            formation_ids[formation_data["nom"]] = formation_obj.id
        
        # 3. ASSIGNER FORMATIONS R√âALISTES PAR GRADE
        # Directeur - Toutes formations + Officier
        demo_users[0]["formations"] = [formation_ids["Pompier 1"], formation_ids["Officier 2"], formation_ids["Premiers R√©pondants"], formation_ids["Classe 4A"]]
        demo_users[1]["formations"] = [formation_ids["Pompier 1"], formation_ids["Officier 2"], formation_ids["Premiers R√©pondants"], formation_ids["Sauvetage Aquatique"]]
        
        # Capitaines - Formations supervision
        demo_users[2]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["D√©sincarc√©ration"], formation_ids["Classe 4A"]]
        demo_users[3]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["Mati√®res Dangereuses"]]
        
        # Lieutenants - Formations techniques
        demo_users[4]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["D√©sincarc√©ration"]]
        demo_users[5]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["Sauvetage Aquatique"]]
        demo_users[6]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["Sauvetage Technique"]]
        
        # Pompiers temps plein - Formations de base + sp√©cialisations
        demo_users[7]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["D√©sincarc√©ration"]]
        demo_users[8]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"]]
        demo_users[9]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"], formation_ids["Classe 4A"]]
        
        # Pompiers temps partiel - Formations variables
        demo_users[10]["formations"] = [formation_ids["Pompier 1"]]
        demo_users[11]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"]]
        demo_users[12]["formations"] = [formation_ids["Pompier 1"]]
        demo_users[13]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"]]
        
        # Nouvelles recrues - Formations de base seulement
        demo_users[14]["formations"] = [formation_ids["Pompier 1"]]
        
        # Cr√©er utilisateurs
        user_ids = {}
        for user_data in demo_users:
            user_dict = user_data.copy()
            user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
            user_dict["statut"] = "Actif"
            user_obj = User(**user_dict)
            await db.users.insert_one(user_obj.dict())
            user_ids[user_data["email"]] = user_obj.id
        
        # 4. CR√âER TYPES DE GARDE R√âALISTES
        demo_types_garde = [
            {"nom": "Garde Interne AM - Semaine", "heure_debut": "06:00", "heure_fin": "18:00", "personnel_requis": 4, "duree_heures": 12, "couleur": "#10B981", "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"], "officier_obligatoire": True},
            {"nom": "Garde Interne PM - Semaine", "heure_debut": "18:00", "heure_fin": "06:00", "personnel_requis": 3, "duree_heures": 12, "couleur": "#3B82F6", "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"], "officier_obligatoire": True},
            {"nom": "Garde Weekend Jour", "heure_debut": "08:00", "heure_fin": "20:00", "personnel_requis": 3, "duree_heures": 12, "couleur": "#F59E0B", "jours_application": ["saturday", "sunday"], "officier_obligatoire": True},
            {"nom": "Garde Weekend Nuit", "heure_debut": "20:00", "heure_fin": "08:00", "personnel_requis": 2, "duree_heures": 12, "couleur": "#8B5CF6", "jours_application": ["saturday", "sunday"], "officier_obligatoire": False},
            {"nom": "Garde Externe Citerne", "heure_debut": "00:00", "heure_fin": "23:59", "personnel_requis": 1, "duree_heures": 24, "couleur": "#EF4444", "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"], "officier_obligatoire": False}
        ]
        
        type_garde_ids = {}
        for type_garde_data in demo_types_garde:
            type_garde_obj = TypeGarde(**type_garde_data)
            await db.types_garde.insert_one(type_garde_obj.dict())
            type_garde_ids[type_garde_data["nom"]] = type_garde_obj.id
        
        # 5. CR√âER HISTORIQUE ASSIGNATIONS (6 semaines)
        assignations_created = 0
        users_list = list(user_ids.values())
        
        for week_offset in range(-6, 1):  # 6 semaines pass√©es + courante
            week_start = datetime.now(timezone.utc).date() + timedelta(weeks=week_offset)
            week_start = week_start - timedelta(days=week_start.weekday())
            
            for day_offset in range(7):
                date_assignation = week_start + timedelta(days=day_offset)
                date_str = date_assignation.strftime("%Y-%m-%d")
                day_name = date_assignation.strftime("%A").lower()
                
                # Assigner gardes selon jours d'application
                for type_nom, type_id in type_garde_ids.items():
                    type_garde = next(t for t in demo_types_garde if t["nom"] == type_nom)
                    
                    if day_name in type_garde["jours_application"]:
                        # Assigner al√©atoirement 70% des gardes
                        if assignations_created % 3 != 2:  # 2/3 des gardes assign√©es
                            import random
                            user_id = random.choice(users_list)
                            
                            assignation_obj = Assignation(
                                user_id=user_id,
                                type_garde_id=type_id,
                                date=date_str,
                                assignation_type="auto"
                            )
                            await db.assignations.insert_one(assignation_obj.dict())
                            assignations_created += 1
        
        # 6. CR√âER DISPONIBILIT√âS MASSIVES POUR TEMPS PARTIEL (pour d√©mo assignation auto)
        temps_partiel_users = [
            user_ids["partiel@firemanager.ca"],
            user_ids["sarah.martin@firemanager.ca"],
            user_ids["emilie.pelletier@firemanager.ca"],
            user_ids["thomas.bergeron@firemanager.ca"],
            user_ids["jessica.rousseau@firemanager.ca"],
            user_ids["antoine.fournier@firemanager.ca"],
            user_ids["mathieu.leclerc@firemanager.ca"],
            user_ids["isabelle.gauthier@firemanager.ca"],
            user_ids["nicolas.beaulieu@firemanager.ca"],
            user_ids["melissa.caron@firemanager.ca"],
            user_ids["gabriel.simard@firemanager.ca"],
            user_ids["valerie.mercier@firemanager.ca"]
        ]
        
        disponibilites_created = 0
        
        # Pour chaque employ√© temps partiel, cr√©er des disponibilit√©s vari√©es
        for i, user_id in enumerate(temps_partiel_users):
            # Patterns de disponibilit√© diff√©rents pour vari√©t√©
            if i % 4 == 0:  # Pattern 1: Lun-Mer-Ven
                jours_pattern = [0, 2, 4]  # Lundi, Mercredi, Vendredi
            elif i % 4 == 1:  # Pattern 2: Mar-Jeu-Sam
                jours_pattern = [1, 3, 5]  # Mardi, Jeudi, Samedi
            elif i % 4 == 2:  # Pattern 3: Mer-Ven-Dim
                jours_pattern = [2, 4, 6]  # Mercredi, Vendredi, Dimanche
            else:  # Pattern 4: Lun-Jeu-Sam
                jours_pattern = [0, 3, 5]  # Lundi, Jeudi, Samedi
            
            # Cr√©er disponibilit√©s pour 8 semaines (2 mois futurs)
            for week_offset in range(0, 8):
                week_start = datetime.now(timezone.utc).date() + timedelta(weeks=week_offset)
                week_start = week_start - timedelta(days=week_start.weekday())
                
                for day_offset in jours_pattern:
                    date_dispo = week_start + timedelta(days=day_offset)
                    
                    # Cr√©er disponibilit√©s pour diff√©rents types de garde
                    # 80% pour Garde Interne (semaine)
                    if day_offset < 5:  # Lundi-Vendredi
                        # Disponible pour garde AM ou PM (alternativement)
                        type_garde_am = type_garde_ids["Garde Interne AM - Semaine"]
                        type_garde_pm = type_garde_ids["Garde Interne PM - Semaine"]
                        
                        # Disponible pour garde AM
                        if disponibilites_created % 3 != 2:  # 66% de chance
                            dispo_obj = Disponibilite(
                                user_id=user_id,
                                date=date_dispo.strftime("%Y-%m-%d"),
                                type_garde_id=type_garde_am,
                                heure_debut="06:00",
                                heure_fin="18:00",
                                statut="disponible"
                            )
                            await db.disponibilites.insert_one(dispo_obj.dict())
                            disponibilites_created += 1
                        
                        # Disponible pour garde PM
                        if disponibilites_created % 4 != 3:  # 75% de chance
                            dispo_obj = Disponibilite(
                                user_id=user_id,
                                date=date_dispo.strftime("%Y-%m-%d"),
                                type_garde_id=type_garde_pm,
                                heure_debut="18:00",
                                heure_fin="06:00",
                                statut="disponible"
                            )
                            await db.disponibilites.insert_one(dispo_obj.dict())
                            disponibilites_created += 1
                    else:  # Weekend
                        # Disponible pour garde weekend
                        if disponibilites_created % 2 == 0:  # 50% de chance
                            type_garde_weekend = type_garde_ids["Garde Weekend Jour"]
                            dispo_obj = Disponibilite(
                                user_id=user_id,
                                date=date_dispo.strftime("%Y-%m-%d"),
                                type_garde_id=type_garde_weekend,
                                heure_debut="08:00",
                                heure_fin="20:00",
                                statut="disponible"
                            )
                            await db.disponibilites.insert_one(dispo_obj.dict())
                            disponibilites_created += 1
        
        # 7. CR√âER SESSIONS DE FORMATION
        demo_sessions = [
            {"titre": "Formation Sauvetage Aquatique - Niveau 1", "competence_id": formation_ids["Sauvetage Aquatique"], "duree_heures": 32, "date_debut": "2025-01-15", "heure_debut": "09:00", "lieu": "Piscine municipale", "formateur": "Capitaine Sarah Tremblay", "descriptif": "Formation compl√®te aux techniques de sauvetage aquatique", "plan_cours": "", "places_max": 12, "participants": [], "statut": "planifie"},
            {"titre": "Perfectionnement D√©sincarc√©ration", "competence_id": formation_ids["D√©sincarc√©ration"], "duree_heures": 16, "date_debut": "2025-01-22", "heure_debut": "13:00", "lieu": "Centre formation s√©curit√©", "formateur": "Lieutenant Pierre Bernard", "descriptif": "Perfectionnement techniques de d√©sincarc√©ration moderne", "plan_cours": "", "places_max": 8, "participants": [], "statut": "planifie"},
            {"titre": "Mati√®res Dangereuses HAZMAT", "competence_id": formation_ids["Mati√®res Dangereuses"], "duree_heures": 48, "date_debut": "2025-02-05", "heure_debut": "08:00", "lieu": "Centre HAZMAT Montr√©al", "formateur": "Expert externe - Dr. Martin Dubois", "descriptif": "Formation compl√®te intervention mati√®res dangereuses", "plan_cours": "", "places_max": 15, "participants": [], "statut": "planifie"}
        ]
        
        for session_data in demo_sessions:
            session_obj = SessionFormation(**session_data)
            await db.sessions_formation.insert_one(session_obj.dict())
        
        return {
            "message": "Donn√©es d√©mo CLIENT cr√©√©es avec succ√®s",
            "details": {
                "utilisateurs": len(demo_users),
                "formations": len(demo_formations),
                "types_garde": len(demo_types_garde),
                "assignations_historiques": assignations_created,
                "disponibilites": disponibilites_created,
                "sessions_formation": len(demo_sessions),
                "breakdown": {
                    "admins": 1,
                    "superviseurs": 3,
                    "employes_temps_plein": 7,
                    "employes_temps_partiel": 12,
                    "total_personnel": 23
                }
            }
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur: {str(e)}")

# Initialize demo data
@api_router.post("/init-demo-data")
async def init_demo_data():
    # Clear existing data
    await db.users.delete_many({})
    await db.types_garde.delete_many({})
    await db.assignations.delete_many({})
    await db.planning.delete_many({})
    await db.demandes_remplacement.delete_many({})
    
    # Create demo users
    demo_users = [
        {
            "nom": "Dupont",
            "prenom": "Jean",
            "email": "admin@firemanager.ca",
            "telephone": "514-111-2233",
            "contact_urgence": "514-999-1111",
            "grade": "Directeur",
            "type_emploi": "temps_plein",
            "heures_max_semaine": 40,  # Temps plein standard
            "role": "admin",
            "numero_employe": "ADM001",
            "date_embauche": "14/01/2020",
            "formations": [],
            "mot_de_passe": "admin123"
        },
        {
            "nom": "Dubois",
            "prenom": "Sophie",
            "email": "superviseur@firemanager.ca",
            "telephone": "514-444-5566",
            "contact_urgence": "514-888-2222",
            "grade": "Directeur",
            "type_emploi": "temps_plein",
            "heures_max_semaine": 40,  # Temps plein standard
            "role": "superviseur",
            "numero_employe": "POM001",
            "date_embauche": "07/01/2022",
            "formations": [],
            "mot_de_passe": "superviseur123"
        },
        {
            "nom": "Bernard",
            "prenom": "Pierre",
            "email": "employe@firemanager.ca",
            "telephone": "418-555-9999",
            "contact_urgence": "418-777-3333",
            "grade": "Capitaine",
            "type_emploi": "temps_plein",
            "heures_max_semaine": 40,  # Temps plein standard
            "role": "employe",
            "numero_employe": "POM002",
            "date_embauche": "21/09/2019",
            "formations": [],
            "mot_de_passe": "employe123"
        },
        {
            "nom": "Garcia",
            "prenom": "Claire",
            "email": "partiel@firemanager.ca",
            "telephone": "514-888-9900",
            "contact_urgence": "514-666-4444",
            "grade": "Pompier",
            "type_emploi": "temps_partiel",
            "heures_max_semaine": 25,  # 25h max par semaine
            "role": "employe",
            "numero_employe": "POM005",
            "date_embauche": "02/11/2020",
            "formations": [],
            "mot_de_passe": "partiel123"
        }
    ]
    
    # First create formations
    demo_formations = [
        {
            "nom": "Classe 4A",
            "description": "Formation de conduite v√©hicules lourds",
            "duree_heures": 40,
            "validite_mois": 60,
            "obligatoire": False
        },
        {
            "nom": "D√©sincarc√©ration",
            "description": "Techniques de d√©sincarc√©ration",
            "duree_heures": 24,
            "validite_mois": 36,
            "obligatoire": True
        },
        {
            "nom": "Pompier 1",
            "description": "Formation de base pompier niveau 1",
            "duree_heures": 200,
            "validite_mois": 24,
            "obligatoire": True
        },
        {
            "nom": "Officier 2",
            "description": "Formation officier niveau 2",
            "duree_heures": 120,
            "validite_mois": 36,
            "obligatoire": False
        },
        {
            "nom": "Premiers R√©pondants",
            "description": "Formation premiers secours",
            "duree_heures": 16,
            "validite_mois": 12,
            "obligatoire": True
        }
    ]
    
    formation_ids = {}
    for formation_data in demo_formations:
        formation_obj = Formation(**formation_data)
        await db.formations.insert_one(formation_obj.dict())
        formation_ids[formation_data["nom"]] = formation_obj.id
    
    # Update users with formation IDs
    demo_users[0]["formations"] = [formation_ids["Officier 2"], formation_ids["Pompier 1"]]  # Jean
    demo_users[1]["formations"] = [formation_ids["Pompier 1"], formation_ids["Premiers R√©pondants"]]  # Sophie  
    demo_users[2]["formations"] = [formation_ids["Classe 4A"], formation_ids["D√©sincarc√©ration"]]  # Pierre
    demo_users[3]["formations"] = []  # Claire - aucune formation
    
    for user_data in demo_users:
        user_dict = user_data.copy()
        user_dict["mot_de_passe_hash"] = get_password_hash(user_dict.pop("mot_de_passe"))
        user_dict["statut"] = "Actif"
        user_obj = User(**user_dict)
        await db.users.insert_one(user_obj.dict())
    
    # Create demo garde types
    demo_types_garde = [
        {
            "nom": "Garde Interne AM - Semaine",
            "heure_debut": "06:00",
            "heure_fin": "12:00",
            "personnel_requis": 4,
            "duree_heures": 6,
            "couleur": "#10B981",
            "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"],
            "officier_obligatoire": True
        },
        {
            "nom": "Garde Interne PM - Semaine",
            "heure_debut": "12:00",
            "heure_fin": "18:00",
            "personnel_requis": 4,
            "duree_heures": 6,
            "couleur": "#3B82F6",
            "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday"],
            "officier_obligatoire": True
        },
        {
            "nom": "Garde Externe Citerne",
            "heure_debut": "18:00",
            "heure_fin": "06:00",
            "personnel_requis": 1,
            "duree_heures": 12,
            "couleur": "#8B5CF6",
            "jours_application": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"],
            "officier_obligatoire": False
        }
    ]
    
    for type_garde_data in demo_types_garde:
        type_garde_obj = TypeGarde(**type_garde_data)
        await db.types_garde.insert_one(type_garde_obj.dict())
    
    # Create demo disponibilit√©s for part-time employee (Claire Garcia) with specific dates
    claire_user = await db.users.find_one({"email": "partiel@firemanager.ca"})
    if claire_user:
        # Create availabilities for next 2 weeks
        today = datetime.now(timezone.utc).date()
        demo_disponibilites = []
        
        # Generate availabilities for specific dates
        for week_offset in range(4):  # Next 4 weeks
            week_start = today + timedelta(weeks=week_offset)
            week_start = week_start - timedelta(days=week_start.weekday())  # Get Monday
            
            # Claire is available Monday, Wednesday, Friday
            for day_offset in [0, 2, 4]:  # Monday, Wednesday, Friday
                date_available = week_start + timedelta(days=day_offset)
                demo_disponibilites.append({
                    "user_id": claire_user["id"],
                    "date": date_available.strftime("%Y-%m-%d"),
                    "heure_debut": "08:00",
                    "heure_fin": "16:00",
                    "statut": "disponible"
                })
        
        for dispo_data in demo_disponibilites:
            dispo_obj = Disponibilite(**dispo_data)
            await db.disponibilites.insert_one(dispo_obj.dict())
    
    return {"message": "Donn√©es de d√©monstration cr√©√©es avec succ√®s"}

# ==================== NOTIFICATIONS ====================

# ==================== NOTIFICATIONS ROUTES MIGR√âES VERS routes/notifications.py ====================
# Routes migr√©es:
# - GET /{tenant_slug}/notifications                            - Liste des notifications
# - GET /{tenant_slug}/notifications/non-lues/count            - Compteur non lues
# - PUT /{tenant_slug}/notifications/{notification_id}/marquer-lu - Marquer une notification lue
# - PUT /{tenant_slug}/notifications/marquer-toutes-lues       - Marquer toutes lues
# Note: La fonction creer_notification a √©t√© d√©plac√©e vers routes/dependencies.py
# ============================================================================

# ==================== PARAM√àTRES REMPLACEMENTS ====================

@api_router.get("/{tenant_slug}/parametres/remplacements")
async def get_parametres_remplacements(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√®re les param√®tres de remplacements"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Chercher pour ce tenant sp√©cifique
    parametres = await db.parametres_remplacements.find_one({"tenant_id": tenant.id})
    
    if not parametres:
        # Cr√©er param√®tres par d√©faut pour ce tenant
        default_params = ParametresRemplacements(tenant_id=tenant.id)
        await db.parametres_remplacements.insert_one(default_params.dict())
        return default_params
    
    cleaned_params = clean_mongo_doc(parametres)
    return cleaned_params  # Retourner le dict directement pour plus de flexibilit√©

@api_router.put("/{tenant_slug}/parametres/remplacements")
async def update_parametres_remplacements(
    tenant_slug: str,
    parametres_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Met √† jour les param√®tres de remplacements"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier le tenant
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Chercher les param√®tres existants pour ce tenant
    existing = await db.parametres_remplacements.find_one({"tenant_id": tenant.id})
    
    # S'assurer que tenant_id est pr√©sent dans les donn√©es
    parametres_data["tenant_id"] = tenant.id
    
    if existing:
        # Mettre √† jour les param√®tres existants
        await db.parametres_remplacements.update_one(
            {"tenant_id": tenant.id},
            {"$set": parametres_data}
        )
    else:
        # Cr√©er de nouveaux param√®tres avec un ID
        if "id" not in parametres_data:
            parametres_data["id"] = str(uuid.uuid4())
        await db.parametres_remplacements.insert_one(parametres_data)
    
    return {"message": "Param√®tres mis √† jour avec succ√®s"}


# ==================== PARAM√àTRES NIVEAUX D'ATTRIBUTION ====================

@api_router.get("/{tenant_slug}/parametres/niveaux-attribution")
async def get_niveaux_attribution(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√®re les param√®tres des niveaux d'attribution automatique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Les niveaux sont stock√©s dans les param√®tres du tenant
    return {
        "niveau_2_actif": tenant.parametres.get("niveau_2_actif", True),
        "niveau_3_actif": tenant.parametres.get("niveau_3_actif", True),
        "niveau_4_actif": tenant.parametres.get("niveau_4_actif", True),
        "niveau_5_actif": tenant.parametres.get("niveau_5_actif", True)
    }

@api_router.put("/{tenant_slug}/parametres/niveaux-attribution")
async def update_niveaux_attribution(
    tenant_slug: str,
    niveaux_data: dict,
    current_user: User = Depends(get_current_user)
):
    """Met √† jour les param√®tres des niveaux d'attribution automatique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Mettre √† jour les niveaux dans les param√®tres du tenant
    update_fields = {}
    for key in ['niveau_2_actif', 'niveau_3_actif', 'niveau_4_actif', 'niveau_5_actif']:
        if key in niveaux_data:
            update_fields[f"parametres.{key}"] = niveaux_data[key]
    
    if update_fields:
        await db.tenants.update_one(
            {"id": tenant.id},
            {"$set": update_fields}
        )
        logging.info(f"‚úÖ Niveaux d'attribution mis √† jour pour {tenant.slug}: {update_fields}")
    
    return {"message": "Niveaux d'attribution mis √† jour avec succ√®s"}


# ==================== PARAM√àTRES VALIDATION PLANNING ====================

@api_router.get("/{tenant_slug}/parametres/validation-planning")
async def get_parametres_validation_planning(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√®re les param√®tres de validation/notification du planning"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_validation_planning.find_one({"tenant_id": tenant.id})
    
    if not params:
        # Cr√©er param√®tres par d√©faut
        default_params = ParametresValidationPlanning(
            tenant_id=tenant.id,
            frequence="mensuel",
            jour_envoi=25,
            heure_envoi="17:00",
            periode_couverte="mois_suivant",
            envoi_automatique=True,
            derniere_notification=None
        )
        await db.parametres_validation_planning.insert_one(default_params.dict())
        params = default_params.dict()
    
    return clean_mongo_doc(params)

@api_router.put("/{tenant_slug}/parametres/validation-planning")
async def update_parametres_validation_planning(
    tenant_slug: str,
    params: dict = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Met √† jour les param√®tres de validation/notification du planning"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Valider les donn√©es
    if params.get("jour_envoi") and (params["jour_envoi"] < 1 or params["jour_envoi"] > 28):
        raise HTTPException(status_code=400, detail="Le jour d'envoi doit √™tre entre 1 et 28")
    
    # V√©rifier si param√®tres existent
    existing = await db.parametres_validation_planning.find_one({"tenant_id": tenant.id})
    
    if existing:
        # Mettre √† jour
        await db.parametres_validation_planning.update_one(
            {"tenant_id": tenant.id},
            {"$set": {**params, "updated_at": datetime.now(timezone.utc).isoformat()}}
        )
    else:
        # Cr√©er
        new_params = ParametresValidationPlanning(
            tenant_id=tenant.id,
            **params
        )
        await db.parametres_validation_planning.insert_one(new_params.dict())
    
    # Si les notifications automatiques ont √©t√© activ√©es, red√©marrer le scheduler
    if params.get("envoi_automatique"):
        # Le scheduler sera automatiquement recharg√© au prochain tick
        logging.info(f"Notifications automatiques activ√©es pour {tenant.nom}")
    
    return {"message": "Param√®tres mis √† jour avec succ√®s"}


# ==================== PARAM√àTRES DISPONIBILIT√âS ====================

@api_router.get("/{tenant_slug}/parametres/disponibilites")
async def get_parametres_disponibilites(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√®re les param√®tres disponibilit√©s"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_disponibilites.find_one({"tenant_id": tenant.id})
    
    if not params:
        # Cr√©er param√®tres par d√©faut
        default_params = {
            "tenant_id": tenant.id,
            "blocage_dispos_active": False,
            "jour_blocage_dispos": 15,
            "exceptions_admin_superviseur": True,
            "admin_peut_modifier_temps_partiel": True,
            "notifications_dispos_actives": True,
            "jours_avance_notification": 3
        }
        await db.parametres_disponibilites.insert_one(default_params)
        return default_params
    
    return clean_mongo_doc(params)

@api_router.put("/{tenant_slug}/parametres/disponibilites")
async def update_parametres_disponibilites(
    tenant_slug: str,
    params: dict,
    current_user: User = Depends(get_current_user)
):
    """Met √† jour les param√®tres disponibilit√©s"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    result = await db.parametres_disponibilites.update_one(
        {"tenant_id": tenant.id},
        {"$set": params},
        upsert=True
    )
    
    return {"message": "Param√®tres disponibilit√©s mis √† jour"}


@api_router.post("/{tenant_slug}/disponibilites/envoyer-rappels")
async def trigger_rappels_disponibilites(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """
    Endpoint admin pour d√©clencher manuellement l'envoi des rappels de disponibilit√©s.
    Utile pour tester le syst√®me sans attendre le job planifi√©.
    """
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s r√©serv√© aux administrateurs")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer les param√®tres
    params = await db.parametres_disponibilites.find_one({"tenant_id": tenant.id})
    
    if not params:
        raise HTTPException(status_code=400, detail="Param√®tres de disponibilit√©s non configur√©s")
    
    if not params.get("blocage_dispos_active", False):
        raise HTTPException(status_code=400, detail="Le syst√®me de blocage n'est pas activ√©")
    
    if not params.get("notifications_dispos_actives", True):
        raise HTTPException(status_code=400, detail="Les notifications de disponibilit√©s ne sont pas activ√©es")
    
    # Calculer les dates
    today = datetime.now(timezone.utc).date()
    current_month = today.month
    current_year = today.year
    
    if current_month == 12:
        next_month = 1
        next_month_year = current_year + 1
    else:
        next_month = current_month + 1
        next_month_year = current_year
    
    periode_debut = f"{next_month_year}-{str(next_month).zfill(2)}-01"
    if next_month == 12:
        dernier_jour = date(next_month_year + 1, 1, 1) - timedelta(days=1)
    else:
        dernier_jour = date(next_month_year, next_month + 1, 1) - timedelta(days=1)
    periode_fin = dernier_jour.isoformat()
    
    # R√©cup√©rer les employ√©s temps partiel actifs
    users_temps_partiel = await db.users.find({
        "tenant_id": tenant.id,
        "type_emploi": "temps_partiel",
        "statut": "actif"
    }).to_list(None)
    
    if not users_temps_partiel:
        return {
            "message": "Aucun employ√© temps partiel √† notifier",
            "users_notifies": 0,
            "users_deja_complets": 0
        }
    
    # Identifier les employ√©s qui n'ont pas soumis de disponibilit√©s
    users_a_notifier = []
    users_complets = []
    
    for user in users_temps_partiel:
        user_id = user.get("id")
        disponibilites_count = await db.disponibilites.count_documents({
            "user_id": user_id,
            "tenant_id": tenant.id,
            "date": {"$gte": periode_debut, "$lte": periode_fin}
        })
        
        if disponibilites_count == 0:
            users_a_notifier.append(user)
        else:
            users_complets.append(user)
    
    if not users_a_notifier:
        return {
            "message": "Tous les employ√©s ont d√©j√† soumis leurs disponibilit√©s",
            "users_notifies": 0,
            "users_deja_complets": len(users_complets)
        }
    
    # Envoyer les notifications
    jour_blocage = params.get("jour_blocage_dispos", 15)
    date_blocage = date(current_year, current_month, jour_blocage)
    jours_restants = max(0, (date_blocage - today).days)
    
    mois_noms = ["janvier", "f√©vrier", "mars", "avril", "mai", "juin", 
                 "juillet", "ao√ªt", "septembre", "octobre", "novembre", "d√©cembre"]
    mois_suivant_texte = mois_noms[next_month - 1]
    
    titre_notification = "üìÖ Rappel: Saisissez vos disponibilit√©s"
    message_notification = f"Vous avez jusqu'au {jour_blocage} {mois_noms[current_month - 1]} pour saisir vos disponibilit√©s de {mois_suivant_texte}. Il vous reste {jours_restants} jour(s)."
    
    resend_api_key = os.environ.get("RESEND_API_KEY")
    sender_email = os.environ.get("RESEND_FROM_EMAIL", "noreply@resend.dev")
    app_url = os.environ.get("FRONTEND_URL", os.environ.get("REACT_APP_BACKEND_URL", ""))
    
    notifications_envoyees = 0
    emails_envoyes = 0
    
    for user in users_a_notifier:
        user_id = user.get("id")
        user_email = user.get("email")
        user_prenom = user.get("prenom", "")
        
        # Notification in-app
        await db.notifications.insert_one({
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "user_id": user_id,
            "type": "rappel_disponibilites",
            "titre": titre_notification,
            "message": message_notification,
            "lu": False,
            "urgent": jours_restants <= 1,
            "data": {
                "lien": "/disponibilites",
                "mois_cible": f"{next_month_year}-{str(next_month).zfill(2)}"
            },
            "created_at": datetime.now(timezone.utc).isoformat()
        })
        notifications_envoyees += 1
        
        # Push notification
        try:
            await send_push_notification_to_users(
                user_ids=[user_id],
                title=titre_notification,
                body=message_notification,
                data={"type": "rappel_disponibilites", "lien": "/disponibilites"}
            )
        except:
            pass
        
        # Email
        if resend_api_key and user_email:
            try:
                resend.api_key = resend_api_key
                
                html_content = f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                        .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                        .header {{ background-color: #1E40AF; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }}
                        .content {{ background-color: #f8f9fa; padding: 30px; border-radius: 0 0 8px 8px; }}
                        .alert {{ background-color: {'#FEF3C7' if jours_restants > 1 else '#FEE2E2'}; border-left: 4px solid {'#F59E0B' if jours_restants > 1 else '#EF4444'}; padding: 15px; margin: 20px 0; }}
                        .btn {{ display: inline-block; background-color: #1E40AF; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin-top: 20px; }}
                    </style>
                </head>
                <body>
                    <div class="container">
                        <div class="header">
                            <h1>üìÖ Rappel Disponibilit√©s</h1>
                        </div>
                        <div class="content">
                            <p>Bonjour {user_prenom},</p>
                            <div class="alert">
                                <strong>üì¢ Rappel</strong><br>
                                Vous n'avez pas encore saisi vos disponibilit√©s pour le mois de <strong>{mois_suivant_texte} {next_month_year}</strong>.
                            </div>
                            <p>La date limite est le <strong>{jour_blocage} {mois_noms[current_month - 1]}</strong>. Il vous reste <strong>{jours_restants} jour(s)</strong>.</p>
                            <center>
                                <a href="{app_url}/disponibilites" class="btn">Saisir mes disponibilit√©s</a>
                            </center>
                        </div>
                    </div>
                </body>
                </html>
                """
                
                resend.Emails.send({
                    "from": f"{tenant.nom} <{sender_email}>",
                    "to": [user_email],
                    "subject": f"Rappel - Saisissez vos disponibilit√©s pour {mois_suivant_texte}",
                    "html": html_content
                })
                emails_envoyes += 1
            except:
                pass
    
    return {
        "message": f"Rappels envoy√©s avec succ√®s",
        "users_notifies": notifications_envoyees,
        "emails_envoyes": emails_envoyes,
        "users_deja_complets": len(users_complets),
        "periode_cible": f"{mois_suivant_texte} {next_month_year}",
        "jours_restants": jours_restants
    }


# ==================== √âQUIPES DE GARDE - ENDPOINTS ====================

def get_equipe_garde_du_jour_sync(type_rotation: str, date_reference: str, date_cible: str, 
                                   nombre_equipes: int, pattern_mode: str, pattern_personnalise: List[int],
                                   duree_cycle: int) -> int:
    """
    Calcule quelle √©quipe est de garde pour une date donn√©e.
    Retourne le num√©ro de l'√©quipe (1, 2, 3, 4, 5).
    
    IMPORTANT: Cette fonction N'UTILISE PAS les patterns Montreal/Quebec/Longueuil existants.
    Elle calcule uniquement pour les rotations personnalis√©es ou les rotations standards appliqu√©es aux √©quipes de garde.
    """
    from datetime import datetime, timedelta
    
    date_ref = datetime.strptime(date_reference, "%Y-%m-%d").date()
    date_obj = datetime.strptime(date_cible, "%Y-%m-%d").date()
    
    # Calculer le jour dans le cycle
    jours_depuis_ref = (date_obj - date_ref).days
    
    # Pour les dates avant la r√©f√©rence
    if jours_depuis_ref < 0:
        jour_cycle = duree_cycle - ((-jours_depuis_ref - 1) % duree_cycle) - 1
    else:
        jour_cycle = jours_depuis_ref % duree_cycle
    
    # Si pattern personnalis√© d√©fini
    if pattern_personnalise and len(pattern_personnalise) >= duree_cycle:
        return pattern_personnalise[jour_cycle]
    
    # Sinon, utiliser le mode de pattern
    if pattern_mode == "hebdomadaire":
        # Alternance hebdomadaire: √©quipe change chaque semaine
        semaine = jour_cycle // 7
        return (semaine % nombre_equipes) + 1
    
    elif pattern_mode == "quotidien":
        # Alternance quotidienne: √©quipe change chaque jour
        return (jour_cycle % nombre_equipes) + 1
    
    elif pattern_mode == "deux_jours":
        # 2 jours chacun: 1,1,2,2,3,3,4,4...
        return ((jour_cycle // 2) % nombre_equipes) + 1
    
    else:
        # Par d√©faut: hebdomadaire
        semaine = jour_cycle // 7
        return (semaine % nombre_equipes) + 1


def get_equipe_garde_rotation_standard(type_rotation: str, date_reference: str, date_cible: str) -> int:
    """
    Calcule quelle √©quipe (1=Vert, 2=Bleu, 3=Jaune, 4=Rouge) est de garde pour une rotation standard.
    Utilise les m√™mes patterns que les fonctions de g√©n√©ration d'indisponibilit√©s.
    
    IMPORTANT: Cette fonction N'APPELLE PAS et NE MODIFIE PAS les fonctions existantes.
    Elle utilise simplement la m√™me logique de calcul de jour dans le cycle.
    """
    from datetime import datetime, timedelta
    
    date_obj = datetime.strptime(date_cible, "%Y-%m-%d").date()
    
    # D√©finir les dates de r√©f√©rence et les patterns pour chaque type de rotation
    # Ces valeurs sont copi√©es des fonctions existantes (lecture seule)
    if type_rotation == "montreal":
        # Date ref: 27 janvier 2025 (premier lundi rouge = jour 1)
        jour_1_cycle = datetime(2025, 1, 27).date()
        # Pattern: √©quipe qui travaille chaque jour du cycle
        # Rouge=4 travaille jours 1, 4, 12, 14, 17, 20, 23
        # Vert=1 travaille jours 2, 8, 11, 19, 21, 24, 27
        # Bleu=2 travaille jours 3, 6, 9, 15, 18, 26, 28
        # Jaune=3 travaille jours 5, 7, 10, 13, 16, 22, 25
        equipes_jours = {
            1: [2, 8, 11, 19, 21, 24, 27],   # Vert
            2: [3, 6, 9, 15, 18, 26, 28],    # Bleu
            3: [5, 7, 10, 13, 16, 22, 25],   # Jaune
            4: [1, 4, 12, 14, 17, 20, 23]    # Rouge
        }
    elif type_rotation == "quebec":
        jour_1_cycle = datetime(2026, 2, 1).date()
        equipes_jours = {
            1: [2, 3, 4, 5, 12, 13, 14, 20, 21, 22, 23, 24, 25],  # Vert
            2: [6, 7, 8, 9, 10, 11, 16, 17, 18, 19, 26, 27, 28],  # Bleu
            3: [1, 2, 3, 4, 9, 10, 11, 12, 19, 20, 21, 27, 28],   # Jaune
            4: [5, 6, 7, 13, 14, 15, 16, 17, 18, 23, 24, 25, 26]  # Rouge
        }
    elif type_rotation == "longueuil":
        # Date ref: 25 janvier 2026 (premier dimanche rouge = jour 1)
        jour_1_cycle = datetime(2026, 1, 25).date()
        equipes_jours = {
            1: [2, 6, 8, 12, 18, 21, 24],    # Vert
            2: [3, 9, 13, 15, 19, 25, 28],   # Bleu
            3: [4, 7, 10, 16, 20, 22, 26],   # Jaune
            4: [1, 5, 11, 14, 17, 23, 27]    # Rouge
        }
    else:
        return 1  # Par d√©faut √©quipe 1
    
    # Calculer le jour dans le cycle (1-28)
    jours_depuis_jour1 = (date_obj - jour_1_cycle).days
    jour_cycle = (jours_depuis_jour1 % 28) + 1
    
    if jours_depuis_jour1 < 0:
        jour_cycle = 28 - ((-jours_depuis_jour1 - 1) % 28)
    
    # Trouver quelle √©quipe travaille ce jour
    for equipe, jours in equipes_jours.items():
        if jour_cycle in jours:
            return equipe
    
    return 1  # Par d√©faut


@api_router.get("/{tenant_slug}/parametres/equipes-garde")
async def get_parametres_equipes_garde(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√®re les param√®tres des √©quipes de garde"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_equipes_garde.find_one({"tenant_id": tenant.id})
    
    if not params:
        # Cr√©er param√®tres par d√©faut
        default_params = {
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "actif": False,
            "temps_plein": {
                "rotation_active": False,
                "type_rotation": "aucun",
                "date_reference": None,
                "nombre_equipes": 4,
                "duree_cycle": 28,
                "pattern_mode": "hebdomadaire",
                "pattern_personnalise": [],
                "equipes_config": [
                    {"numero": 1, "nom": "Vert", "couleur": "#22C55E"},
                    {"numero": 2, "nom": "Bleu", "couleur": "#3B82F6"},
                    {"numero": 3, "nom": "Jaune", "couleur": "#EAB308"},
                    {"numero": 4, "nom": "Rouge", "couleur": "#EF4444"}
                ],
                "pre_remplissage_auto": False,
                "privilegier_equipe_garde": False
            },
            "temps_partiel": {
                "rotation_active": False,
                "type_rotation": "personnalisee",
                "date_reference": None,
                "nombre_equipes": 2,
                "duree_cycle": 14,
                "pattern_mode": "hebdomadaire",
                "pattern_personnalise": [],
                "equipes_config": [
                    {"numero": 1, "nom": "√âquipe A", "couleur": "#3B82F6"},
                    {"numero": 2, "nom": "√âquipe B", "couleur": "#EF4444"}
                ],
                "pre_remplissage_auto": False,
                "privilegier_equipe_garde": True
            },
            "created_at": datetime.now(timezone.utc).isoformat(),
            "updated_at": datetime.now(timezone.utc).isoformat()
        }
        await db.parametres_equipes_garde.insert_one(default_params)
        return clean_mongo_doc(default_params)
    
    return clean_mongo_doc(params)


@api_router.put("/{tenant_slug}/parametres/equipes-garde")
async def update_parametres_equipes_garde(
    tenant_slug: str,
    params: dict,
    current_user: User = Depends(get_current_user)
):
    """Met √† jour les param√®tres des √©quipes de garde"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params["updated_at"] = datetime.now(timezone.utc).isoformat()
    
    result = await db.parametres_equipes_garde.update_one(
        {"tenant_id": tenant.id},
        {"$set": params},
        upsert=True
    )
    
    return {"message": "Param√®tres √©quipes de garde mis √† jour"}


@api_router.get("/{tenant_slug}/equipes-garde/equipe-du-jour")
async def get_equipe_garde_du_jour(
    tenant_slug: str,
    date: str,  # Format YYYY-MM-DD
    type_emploi: str = "temps_plein",  # temps_plein ou temps_partiel
    current_user: User = Depends(get_current_user)
):
    """
    Retourne quelle √©quipe est de garde pour une date et un type d'emploi donn√©s.
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_equipes_garde.find_one({"tenant_id": tenant.id})
    
    if not params or not params.get("actif", False):
        return {"equipe": None, "message": "Syst√®me d'√©quipes de garde non activ√©"}
    
    config = params.get(type_emploi, {})
    
    if not config.get("rotation_active", False):
        return {"equipe": None, "message": f"Rotation non activ√©e pour {type_emploi}"}
    
    type_rotation = config.get("type_rotation", "aucun")
    
    if type_rotation == "aucun":
        return {"equipe": None, "message": "Aucune rotation configur√©e"}
    
    # Pour les rotations standards (Montreal, Quebec, Longueuil)
    if type_rotation in ["montreal", "quebec", "longueuil"]:
        equipe_num = get_equipe_garde_rotation_standard(type_rotation, "", date)
    else:
        # Rotation personnalis√©e
        date_reference = config.get("date_reference")
        if not date_reference:
            return {"equipe": None, "message": "Date de r√©f√©rence non configur√©e"}
        
        equipe_num = get_equipe_garde_du_jour_sync(
            type_rotation=type_rotation,
            date_reference=date_reference,
            date_cible=date,
            nombre_equipes=config.get("nombre_equipes", 4),
            pattern_mode=config.get("pattern_mode", "hebdomadaire"),
            pattern_personnalise=config.get("pattern_personnalise", []),
            duree_cycle=config.get("duree_cycle", 28)
        )
    
    # R√©cup√©rer la config de l'√©quipe
    equipes_config = config.get("equipes_config", [])
    equipe_info = next((e for e in equipes_config if e.get("numero") == equipe_num), None)
    
    if equipe_info:
        return {
            "equipe": equipe_num,
            "nom": equipe_info.get("nom", f"√âquipe {equipe_num}"),
            "couleur": equipe_info.get("couleur", "#3B82F6"),
            "date": date,
            "type_emploi": type_emploi
        }
    else:
        return {
            "equipe": equipe_num,
            "nom": f"√âquipe {equipe_num}",
            "couleur": "#3B82F6",
            "date": date,
            "type_emploi": type_emploi
        }


@api_router.get("/{tenant_slug}/equipes-garde/calendrier")
async def get_calendrier_equipes_garde(
    tenant_slug: str,
    date_debut: str,  # Format YYYY-MM-DD
    date_fin: str,    # Format YYYY-MM-DD
    type_emploi: str = "temps_plein",
    current_user: User = Depends(get_current_user)
):
    """
    Retourne le calendrier des √©quipes de garde pour une p√©riode.
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    params = await db.parametres_equipes_garde.find_one({"tenant_id": tenant.id})
    
    if not params or not params.get("actif", False):
        return {"calendrier": [], "message": "Syst√®me d'√©quipes de garde non activ√©"}
    
    config = params.get(type_emploi, {})
    
    if not config.get("rotation_active", False):
        return {"calendrier": [], "message": f"Rotation non activ√©e pour {type_emploi}"}
    
    type_rotation = config.get("type_rotation", "aucun")
    date_reference = config.get("date_reference")
    equipes_config = config.get("equipes_config", [])
    
    calendrier = []
    current = datetime.strptime(date_debut, "%Y-%m-%d").date()
    end = datetime.strptime(date_fin, "%Y-%m-%d").date()
    
    while current <= end:
        date_str = current.strftime("%Y-%m-%d")
        
        if type_rotation in ["montreal", "quebec", "longueuil"]:
            equipe_num = get_equipe_garde_rotation_standard(type_rotation, "", date_str)
        elif type_rotation != "aucun" and date_reference:
            equipe_num = get_equipe_garde_du_jour_sync(
                type_rotation=type_rotation,
                date_reference=date_reference,
                date_cible=date_str,
                nombre_equipes=config.get("nombre_equipes", 4),
                pattern_mode=config.get("pattern_mode", "hebdomadaire"),
                pattern_personnalise=config.get("pattern_personnalise", []),
                duree_cycle=config.get("duree_cycle", 28)
            )
        else:
            equipe_num = None
        
        if equipe_num:
            equipe_info = next((e for e in equipes_config if e.get("numero") == equipe_num), {})
            calendrier.append({
                "date": date_str,
                "equipe": equipe_num,
                "nom": equipe_info.get("nom", f"√âquipe {equipe_num}"),
                "couleur": equipe_info.get("couleur", "#3B82F6")
            })
        
        current += timedelta(days=1)
    
    return {"calendrier": calendrier, "type_emploi": type_emploi}


@api_router.get("/{tenant_slug}/equipes-garde/employes")
async def get_employes_par_equipe(
    tenant_slug: str,
    equipe: int,  # Num√©ro de l'√©quipe (1, 2, 3, 4, 5)
    type_emploi: Optional[str] = None,  # Filtrer par temps_plein ou temps_partiel
    current_user: User = Depends(get_current_user)
):
    """
    Retourne la liste des employ√©s d'une √©quipe de garde.
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    query = {
        "tenant_id": tenant.id,
        "statut": "Actif",
        "equipe_garde": equipe
    }
    
    if type_emploi:
        query["type_emploi"] = type_emploi
    
    users = await db.users.find(query).to_list(None)
    
    return [
        {
            "id": u.get("id"),
            "nom": u.get("nom"),
            "prenom": u.get("prenom"),
            "type_emploi": u.get("type_emploi"),
            "grade": u.get("grade"),
            "equipe_garde": u.get("equipe_garde")
        }
        for u in users
    ]


# ==================== MAT√âRIEL ROUTES MIGR√âES VERS routes/materiel.py ====================
# Routes migr√©es (~20 routes):
# - GET/POST/PUT/DELETE /{tenant_slug}/materiel/categories - Cat√©gories
# - GET/POST/PUT/DELETE /{tenant_slug}/materiel - Items de mat√©riel
# - POST/GET /{tenant_slug}/materiel/{id}/mouvement - Mouvements de stock
# - GET/POST/PUT /{tenant_slug}/materiel/maintenances - Maintenances
# - POST/GET /{tenant_slug}/materiel/{id}/inspection - Inspections
# - GET /{tenant_slug}/materiel/statistiques - Statistiques
# ============================================================================


# ==================== √âQUIPEMENTS (NFPA) - MODULE MAT√âRIEL & √âQUIPEMENTS ====================
# NOTE: Les routes CRUD de base ont √©t√© extraites vers /routes/equipements.py
# Seules les routes sp√©cialis√©es (export, import, APRIA) restent ici


# ===== PARAM√àTRES ET ALERTES √âQUIPEMENTS =====
# NOTE: Routes extraites vers /routes/equipements.py


# ===== √âQUIPEMENTS - EXPORTS =====

@api_router.get("/{tenant_slug}/equipements/export-csv")
async def export_equipements_csv(
    tenant_slug: str,
    categorie_id: str = None,
    etat: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export CSV de tous les √©quipements avec filtres optionnels"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Construire les filtres
    filters = {"tenant_id": tenant.id}
    if categorie_id:
        filters["categorie_id"] = categorie_id
    if etat:
        filters["etat"] = etat
    
    # R√©cup√©rer les √©quipements
    equipements = await db.equipements.find(filters, {"_id": 0}).to_list(10000)
    
    if not equipements:
        raise HTTPException(status_code=404, detail="Aucun √©quipement trouv√©")
    
    # G√©n√©rer le CSV
    import csv
    from io import StringIO
    
    output = StringIO()
    
    # En-t√™tes
    fieldnames = [
        "nom", "code_unique", "categorie_nom", "etat", "emplacement", 
        "quantite", "quantite_minimum", "vehicule_id", "employe_id",
        "date_acquisition", "date_fin_vie", "date_prochaine_maintenance",
        "valeur_achat", "notes", "champs_personnalises", "created_at"
    ]
    
    writer = csv.DictWriter(output, fieldnames=fieldnames)
    writer.writeheader()
    
    for eq in equipements:
        import json as json_lib
        row = {
            "nom": eq.get("nom", ""),
            "code_unique": eq.get("code_unique", ""),
            "categorie_nom": eq.get("categorie_nom", ""),
            "etat": eq.get("etat", ""),
            "emplacement": eq.get("emplacement", ""),
            "quantite": eq.get("quantite", 1),
            "quantite_minimum": eq.get("quantite_minimum", 0),
            "vehicule_id": eq.get("vehicule_id", ""),
            "employe_id": eq.get("employe_id", ""),
            "date_acquisition": eq.get("date_acquisition", ""),
            "date_fin_vie": eq.get("date_fin_vie", ""),
            "date_prochaine_maintenance": eq.get("date_prochaine_maintenance", ""),
            "valeur_achat": eq.get("valeur_achat", 0),
            "notes": eq.get("notes", ""),
            "champs_personnalises": json_lib.dumps(eq.get("champs_personnalises", {})),
            "created_at": eq.get("created_at", "")
        }
        writer.writerow(row)
    
    csv_content = output.getvalue()
    
    from fastapi.responses import Response
    return Response(
        content=csv_content,
        media_type="text/csv",
        headers={
            "Content-Disposition": f"attachment; filename=equipements_{tenant_slug}_{datetime.now().strftime('%Y%m%d')}.csv"
        }
    )


@api_router.get("/{tenant_slug}/equipements/export-pdf")
async def export_equipements_pdf(
    tenant_slug: str,
    categorie_id: str = None,
    etat: str = None,
    current_user: User = Depends(get_current_user)
):
    """Export PDF de tous les √©quipements avec filtres optionnels - Design unifi√© avec logo"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Construire les filtres
    filters = {"tenant_id": tenant.id}
    if categorie_id:
        filters["categorie_id"] = categorie_id
    if etat:
        filters["etat"] = etat
    
    # R√©cup√©rer les √©quipements
    equipements = await db.equipements.find(filters, {"_id": 0}).to_list(10000)
    
    if not equipements:
        raise HTTPException(status_code=404, detail="Aucun √©quipement trouv√©")
    
    # G√©n√©rer le PDF avec le design unifi√© (logo, header, styles modernes)
    buffer = io.BytesIO()
    doc = BrandedDocTemplate(buffer, tenant=tenant, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
    
    # D√©finir le page template avec frame
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='branded', frames=frame)
    doc.addPageTemplates([template])
    
    story = []
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    
    # Header personnalis√© (logo + nom service)
    header_elements = create_pdf_header_elements(tenant, styles)
    story.extend(header_elements)
    
    # Titre
    story.append(Paragraph("Inventaire des √âquipements", modern_styles['title']))
    
    # Sous-titre avec filtres
    subtitle_text = f"G√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')}"
    if categorie_id or etat:
        filters_text = []
        if categorie_id:
            # R√©cup√©rer le nom de la cat√©gorie
            cat = await db.equipement_categories.find_one({"id": categorie_id}, {"_id": 0})
            if cat:
                filters_text.append(f"Cat√©gorie: {cat.get('nom', 'Inconnue')}")
            else:
                filters_text.append("Cat√©gorie filtr√©e")
        if etat:
            etat_labels = {
                'neuf': 'Neuf', 'bon': 'Bon', 'a_reparer': '√Ä r√©parer',
                'en_reparation': 'En r√©paration', 'hors_service': 'Hors service'
            }
            filters_text.append(f"√âtat: {etat_labels.get(etat, etat)}")
        subtitle_text += f" | Filtres: {', '.join(filters_text)}"
    
    story.append(Paragraph(subtitle_text, modern_styles['subheading']))
    story.append(Spacer(1, 0.3*inch))
    
    # Statistiques par √©tat
    stats_by_etat = {}
    for eq in equipements:
        e = eq.get("etat", "inconnu")
        stats_by_etat[e] = stats_by_etat.get(e, 0) + 1
    
    etat_labels = {
        'neuf': 'Neuf', 'bon': 'Bon', 'a_reparer': '√Ä r√©parer',
        'en_reparation': 'En r√©paration', 'hors_service': 'Hors service'
    }
    
    stats_data = [["Statistiques", ""]]
    stats_data.append(["Total √©quipements", str(len(equipements))])
    for etat_key, count in stats_by_etat.items():
        stats_data.append([etat_labels.get(etat_key, etat_key), str(count)])
    
    stats_table = Table(stats_data, colWidths=[2.5*inch, 2*inch])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Tableau des √©quipements
    table_data = [['Code', 'Nom', 'Cat√©gorie', '√âtat', 'Emplacement', 'Qt√©']]
    
    for eq in equipements:
        etat_val = eq.get("etat", "")
        table_data.append([
            eq.get("code_unique", "")[:15],
            eq.get("nom", "")[:30],
            eq.get("categorie_nom", "")[:20],
            etat_labels.get(etat_val, etat_val.capitalize()),
            eq.get("emplacement", "")[:20],
            str(eq.get("quantite", 1))
        ])
    
    detail_table = Table(table_data, colWidths=[1.2*inch, 2.2*inch, 1.5*inch, 1*inch, 1.5*inch, 0.6*inch])
    detail_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('ALIGN', (-1, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
        ('FONTSIZE', (0, 1), (-1, -1), 8),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']])
    ]))
    
    story.append(detail_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Footer avec ProFireManager
    footer_text = create_pdf_footer_text(tenant)
    if footer_text:
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            alignment=TA_CENTER,
            spaceBefore=20
        )
        story.append(Paragraph(footer_text, footer_style))
    
    # Construire le PDF
    doc.build(story)
    
    pdf_content = buffer.getvalue()
    buffer.close()
    
    from fastapi.responses import Response
    return Response(
        content=pdf_content,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename=equipements_{tenant_slug}_{datetime.now().strftime('%Y%m%d')}.pdf"
        }
    )


# ===== √âQUIPEMENTS CRUD =====
# NOTE: Routes extraites vers /routes/equipements.py
# GET/POST/PUT/DELETE + maintenances + stats/resume


# ===== INITIALISATION CAT√âGORIES PAR D√âFAUT =====

@api_router.post("/{tenant_slug}/equipements/categories/initialiser")
async def initialiser_categories_equipement(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Initialiser les cat√©gories d'√©quipements par d√©faut (admin uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin requis")
    
    # Cat√©gories par d√©faut avec champs personnalis√©s
    categories_defaut = [
        {
            "nom": "Tuyaux",
            "description": "Tuyaux d'incendie - NFPA 1962",
            "norme_reference": "NFPA 1962",
            "frequence_inspection": "1 an",
            "couleur": "#EF4444",
            "icone": "üî¥",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Diam√®tre", "type": "select", "options": ["1.5\"", "1.75\"", "2.5\"", "3\"", "4\"", "5\""], "obligatoire": True},
                {"nom": "Longueur (pieds)", "type": "number", "obligatoire": True},
                {"nom": "Date dernier test pression", "type": "date", "obligatoire": False},
                {"nom": "R√©sultat test pression", "type": "select", "options": ["Conforme", "Non conforme", "√Ä retester"], "obligatoire": False},
                {"nom": "Pression test√©e (PSI)", "type": "number", "obligatoire": False}
            ]
        },
        {
            "nom": "Lances",
            "description": "Lances et embouts",
            "norme_reference": "",
            "frequence_inspection": "1 an",
            "couleur": "#F97316",
            "icone": "üíß",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Type", "type": "select", "options": ["Automatique", "Fixe", "Brouillard", "Mousse"], "obligatoire": True},
                {"nom": "D√©bit (GPM)", "type": "number", "obligatoire": False},
                {"nom": "Date inspection", "type": "date", "obligatoire": False}
            ]
        },
        {
            "nom": "√âquipement m√©dical",
            "description": "DEA, oxyg√®ne, trousses m√©dicales",
            "norme_reference": "",
            "frequence_inspection": "6 mois",
            "couleur": "#22C55E",
            "icone": "üè•",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Type √©quipement", "type": "select", "options": ["DEA", "Bouteille O2", "Trousse premiers soins", "Civi√®re", "Autre"], "obligatoire": True},
                {"nom": "Date expiration pads/batterie", "type": "date", "obligatoire": False},
                {"nom": "Date test hydrostatique (O2)", "type": "date", "obligatoire": False},
                {"nom": "Capacit√© (L)", "type": "number", "obligatoire": False}
            ]
        },
        {
            "nom": "√âchelles portatives",
            "description": "√âchelles - NFPA 1932",
            "norme_reference": "NFPA 1932",
            "frequence_inspection": "1 an",
            "couleur": "#A855F7",
            "icone": "ü™ú",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Type", "type": "select", "options": ["Coulissante", "√Ä crochets", "Combin√©e", "De toit"], "obligatoire": True},
                {"nom": "Longueur (pieds)", "type": "number", "obligatoire": True},
                {"nom": "Capacit√© (lbs)", "type": "number", "obligatoire": False},
                {"nom": "Date inspection", "type": "date", "obligatoire": False}
            ]
        },
        {
            "nom": "APRIA",
            "description": "Appareils de protection respiratoire - NFPA 1852",
            "norme_reference": "NFPA 1852",
            "frequence_inspection": "1 an",
            "couleur": "#3B82F6",
            "icone": "ü´Å",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Marque/Mod√®le", "type": "text", "obligatoire": True},
                {"nom": "Date test d√©bit", "type": "date", "obligatoire": False},
                {"nom": "R√©sultat test d√©bit", "type": "select", "options": ["Conforme", "Non conforme"], "obligatoire": False},
                {"nom": "Date remplacement batterie", "type": "date", "obligatoire": False}
            ]
        },
        {
            "nom": "Bouteilles APRIA",
            "description": "Bouteilles d'air comprim√© pour APRIA",
            "norme_reference": "DOT/TC",
            "frequence_inspection": "5 ans",
            "couleur": "#06B6D4",
            "icone": "üîµ",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Capacit√© (minutes)", "type": "select", "options": ["30 min", "45 min", "60 min"], "obligatoire": True},
                {"nom": "Date test hydrostatique", "type": "date", "obligatoire": True},
                {"nom": "Date prochain test", "type": "date", "obligatoire": False},
                {"nom": "Pression max (PSI)", "type": "number", "obligatoire": False}
            ]
        },
        {
            "nom": "Parties faciales",
            "description": "Masques APRIA assign√©s aux pompiers",
            "norme_reference": "NFPA 1852",
            "frequence_inspection": "1 an",
            "couleur": "#EC4899",
            "icone": "üò∑",
            "permet_assignation_employe": True,
            "champs_supplementaires": [
                {"nom": "Taille", "type": "select", "options": ["S", "M", "L", "XL"], "obligatoire": True},
                {"nom": "Marque/Mod√®le", "type": "text", "obligatoire": False},
                {"nom": "Date inspection", "type": "date", "obligatoire": False},
                {"nom": "R√©sultat test √©tanch√©it√©", "type": "select", "options": ["Conforme", "Non conforme"], "obligatoire": False}
            ]
        },
        {
            "nom": "D√©tecteurs 4 gaz",
            "description": "D√©tecteurs multigaz",
            "norme_reference": "",
            "frequence_inspection": "6 mois",
            "couleur": "#FBBF24",
            "icone": "‚ö†Ô∏è",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Marque/Mod√®le", "type": "text", "obligatoire": True},
                {"nom": "Date calibration", "type": "date", "obligatoire": True},
                {"nom": "Date prochain calibration", "type": "date", "obligatoire": False},
                {"nom": "Date expiration capteurs", "type": "date", "obligatoire": False},
                {"nom": "Gaz d√©tect√©s", "type": "text", "obligatoire": False}
            ]
        },
        {
            "nom": "D√©tecteurs CO",
            "description": "D√©tecteurs de monoxyde de carbone",
            "norme_reference": "",
            "frequence_inspection": "6 mois",
            "couleur": "#F59E0B",
            "icone": "üü°",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Marque/Mod√®le", "type": "text", "obligatoire": False},
                {"nom": "Date calibration", "type": "date", "obligatoire": True},
                {"nom": "Date prochain calibration", "type": "date", "obligatoire": False}
            ]
        },
        {
            "nom": "Extincteurs",
            "description": "Extincteurs portatifs - NFPA 10",
            "norme_reference": "NFPA 10",
            "frequence_inspection": "1 an",
            "couleur": "#DC2626",
            "icone": "üßØ",
            "permet_assignation_employe": False,
            "champs_supplementaires": [
                {"nom": "Type", "type": "select", "options": ["ABC", "BC", "CO2", "Eau", "Mousse", "Classe K"], "obligatoire": True},
                {"nom": "Capacit√© (lbs)", "type": "number", "obligatoire": True},
                {"nom": "Date inspection", "type": "date", "obligatoire": False},
                {"nom": "Date test hydrostatique", "type": "date", "obligatoire": False},
                {"nom": "Pression (PSI)", "type": "number", "obligatoire": False}
            ]
        },
        {
            "nom": "Radios portatives",
            "description": "Radios de communication",
            "norme_reference": "",
            "frequence_inspection": "1 an",
            "couleur": "#6366F1",
            "icone": "üìª",
            "permet_assignation_employe": True,
            "champs_supplementaires": [
                {"nom": "Marque/Mod√®le", "type": "text", "obligatoire": False},
                {"nom": "Canal/Fr√©quence", "type": "text", "obligatoire": False},
                {"nom": "Date inspection", "type": "date", "obligatoire": False},
                {"nom": "√âtat batterie", "type": "select", "options": ["Neuve", "Bonne", "√Ä remplacer"], "obligatoire": False}
            ]
        }
    ]
    
    created_count = 0
    skipped_count = 0
    
    for cat_data in categories_defaut:
        # V√©rifier si la cat√©gorie existe d√©j√†
        existing = await db.categories_equipement.find_one({
            "tenant_id": tenant.id,
            "nom": cat_data["nom"]
        })
        
        if existing:
            skipped_count += 1
            continue
        
        categorie_obj = CategorieEquipement(
            tenant_id=tenant.id,
            est_predefinit=True,
            **cat_data
        )
        
        await db.categories_equipement.insert_one(categorie_obj.dict())
        created_count += 1
    
    return {
        "message": f"{created_count} cat√©gories cr√©√©es, {skipped_count} d√©j√† existantes",
        "created": created_count,
        "skipped": skipped_count
    }


# ===== IMPORT/EXPORT √âQUIPEMENTS =====

@api_router.post("/{tenant_slug}/equipements/import-csv")
async def import_equipements_csv(
    tenant_slug: str,
    data: dict = Body(...),
    current_user: User = Depends(get_current_user)
):
    """
    Import en masse d'√©quipements depuis CSV/Excel
    Format attendu: nom, code_unique, categorie_nom, etat, emplacement, date_acquisition, vehicule, employe, champs_personnalises (JSON)
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin requis")
    
    equipements_data = data.get("equipements", [])
    
    if not equipements_data:
        raise HTTPException(status_code=400, detail="Aucun √©quipement fourni")
    
    results = {
        "created": 0,
        "updated": 0,
        "errors": [],
        "skipped": 0
    }
    
    # Charger toutes les cat√©gories du tenant
    categories = await db.categories_equipement.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    categories_by_nom = {normalize_string_for_matching(cat["nom"]): cat for cat in categories}
    
    # Charger tous les v√©hicules et utilisateurs pour les assignations
    vehicules = await db.vehicules.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    vehicules_by_nom = {normalize_string_for_matching(v["nom"]): v for v in vehicules}
    
    users = await db.users.find({"tenant_id": tenant.id}, {"_id": 0}).to_list(1000)
    users_by_name = create_user_matching_index(users)
    
    for index, eq_data in enumerate(equipements_data):
        try:
            # 1. Trouver la cat√©gorie
            categorie_nom = eq_data.get("categorie_nom", eq_data.get("categorie", "")).strip()
            if not categorie_nom:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": "Cat√©gorie manquante"
                })
                continue
            
            categorie_normalized = normalize_string_for_matching(categorie_nom)
            categorie = categories_by_nom.get(categorie_normalized)
            
            if not categorie:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": f"Cat√©gorie non trouv√©e: {categorie_nom}"
                })
                continue
            
            # 2. Donn√©es de base
            nom = eq_data.get("nom", "").strip()
            code_unique = eq_data.get("code_unique", "").strip()
            
            if not nom:
                results["errors"].append({
                    "ligne": index + 2,
                    "erreur": "Nom manquant"
                })
                continue
            
            # G√©n√©rer code unique si absent
            if not code_unique:
                code_unique = f"{categorie['nom'][:3].upper()}-{str(uuid.uuid4())[:8]}"
            
            # V√©rifier si l'√©quipement existe d√©j√† (par code unique)
            existing_equipement = await db.equipements.find_one({
                "tenant_id": tenant.id,
                "code_unique": code_unique
            })
            
            # 3. Assignations (optionnel)
            vehicule_id = None
            employe_id = None
            
            vehicule_str = eq_data.get("vehicule", "").strip()
            if vehicule_str:
                vehicule_normalized = normalize_string_for_matching(vehicule_str)
                vehicule = vehicules_by_nom.get(vehicule_normalized)
                if vehicule:
                    vehicule_id = vehicule["id"]
            
            employe_str = eq_data.get("employe", "").strip()
            if employe_str and categorie.get("permet_assignation_employe"):
                user_obj = find_user_intelligent(
                    search_string=employe_str,
                    users_by_name=users_by_name,
                    users_by_num={},
                    numero_field="numero_employe"
                )
                if user_obj:
                    employe_id = user_obj["id"]
            
            # 4. Champs personnalis√©s (JSON ou vide)
            champs_personnalises = {}
            champs_json_str = eq_data.get("champs_personnalises", "")
            if champs_json_str:
                try:
                    import json as json_lib
                    champs_personnalises = json_lib.loads(champs_json_str) if isinstance(champs_json_str, str) else champs_json_str
                except:
                    pass
            
            # 5. Cr√©er ou mettre √† jour l'√©quipement
            equipement_obj = {
                "id": existing_equipement["id"] if existing_equipement else str(uuid.uuid4()),
                "tenant_id": tenant.id,
                "nom": nom,
                "code_unique": code_unique,
                "categorie_id": categorie["id"],
                "categorie_nom": categorie["nom"],
                "etat": eq_data.get("etat", "bon").lower(),
                "emplacement": eq_data.get("emplacement", ""),
                "quantite": int(eq_data.get("quantite", 1)),
                "quantite_minimum": int(eq_data.get("quantite_minimum", 0)),
                "vehicule_id": vehicule_id or "",
                "employe_id": employe_id or "",
                "date_acquisition": eq_data.get("date_acquisition", datetime.now(timezone.utc).date().isoformat()),
                "date_fin_vie": eq_data.get("date_fin_vie", ""),
                "date_prochaine_maintenance": eq_data.get("date_prochaine_maintenance", ""),
                "valeur_achat": float(eq_data.get("valeur_achat", 0)) if eq_data.get("valeur_achat") else 0,
                "notes": eq_data.get("notes", ""),
                "champs_personnalises": champs_personnalises,
                "updated_at": datetime.now(timezone.utc).isoformat()
            }
            
            if existing_equipement:
                # Mise √† jour
                await db.equipements.update_one(
                    {"id": equipement_obj["id"], "tenant_id": tenant.id},
                    {"$set": equipement_obj}
                )
                results["updated"] += 1
            else:
                # Cr√©ation
                equipement_obj["created_at"] = datetime.now(timezone.utc).isoformat()
                await db.equipements.insert_one(equipement_obj)
                results["created"] += 1
        
        except Exception as e:
            results["errors"].append({
                "ligne": index + 2,
                "erreur": str(e)
            })
            logging.error(f"Erreur import √©quipement ligne {index + 2}: {str(e)}", exc_info=True)
    
    return results


# Export routes moved to before parameterized route to avoid conflicts



# ==================== INVENTAIRES V√âHICULES ENDPOINTS ====================

@api_router.get("/{tenant_slug}/parametres/modeles-inventaires-vehicules")
async def get_modeles_inventaires_vehicules(
    tenant_slug: str,
    type_vehicule: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les mod√®les d'inventaires v√©hicules"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    query = {"tenant_id": tenant.id}
    if type_vehicule:
        query["type_vehicule"] = type_vehicule
    
    modeles = await db.modeles_inventaires_vehicules.find(
        query,
        {"_id": 0}
    ).sort("created_at", -1).to_list(1000)
    
    return modeles

@api_router.post("/{tenant_slug}/parametres/modeles-inventaires-vehicules")
async def create_modele_inventaire_vehicule(
    tenant_slug: str,
    modele: ModeleInventaireVehiculeCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un mod√®le d'inventaire v√©hicule (admin/superviseur uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ['admin', 'superviseur']:
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin/Superviseur requis")
    
    # Convertir les sections dict en objets
    sections_obj = []
    for section in modele.sections:
        items_obj = []
        for item in section.get('items', []):
            items_obj.append(ItemInventaireVehicule(
                nom=item['nom'],
                photo_url=item.get('photo_url', ''),
                obligatoire=item.get('obligatoire', False),
                photo_requise=item.get('photo_requise', False),
                ordre=item.get('ordre', 0)
            ))
        
        sections_obj.append(SectionInventaireVehicule(
            titre=section['titre'],
            type_champ=section.get('type_champ', 'checkbox'),
            options=section.get('options', []),
            photo_url=section.get('photo_url', ''),
            items=items_obj,
            ordre=section.get('ordre', 0)
        ))
    
    modele_obj = ModeleInventaireVehicule(
        tenant_id=tenant.id,
        nom=modele.nom,
        type_vehicule=modele.type_vehicule,
        description=modele.description,
        sections=sections_obj,
        created_by=current_user.id
    )
    
    await db.modeles_inventaires_vehicules.insert_one(modele_obj.dict())
    
    return {"message": "Mod√®le d'inventaire cr√©√© avec succ√®s", "id": modele_obj.id}

@api_router.put("/{tenant_slug}/parametres/modeles-inventaires-vehicules/{modele_id}")
async def update_modele_inventaire_vehicule(
    tenant_slug: str,
    modele_id: str,
    modele: ModeleInventaireVehiculeUpdate,
    current_user: User = Depends(get_current_user)
):
    """Modifier un mod√®le d'inventaire v√©hicule (admin/superviseur uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ['admin', 'superviseur']:
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin/Superviseur requis")
    
    update_data = {k: v for k, v in modele.dict().items() if v is not None}
    if not update_data:
        return {"message": "Aucune modification"}
    
    # Convertir sections si pr√©sentes
    if 'sections' in update_data:
        sections_obj = []
        for section in update_data['sections']:
            items_obj = []
            for item in section.get('items', []):
                items_obj.append(ItemInventaireVehicule(
                    nom=item['nom'],
                    photo_url=item.get('photo_url', ''),
                    obligatoire=item.get('obligatoire', False),
                    photo_requise=item.get('photo_requise', False),
                    ordre=item.get('ordre', 0)
                ))
            
            sections_obj.append(SectionInventaireVehicule(
                titre=section['titre'],
                type_champ=section.get('type_champ', 'checkbox'),
                options=section.get('options', []),
                photo_url=section.get('photo_url', ''),
                items=items_obj,
                ordre=section.get('ordre', 0)
            ))
        
        update_data['sections'] = [s.dict() for s in sections_obj]
    
    update_data['updated_at'] = datetime.now(timezone.utc)
    
    result = await db.modeles_inventaires_vehicules.update_one(
        {"id": modele_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Mod√®le d'inventaire non trouv√©")
    
    return {"message": "Mod√®le d'inventaire mis √† jour avec succ√®s"}

@api_router.delete("/{tenant_slug}/parametres/modeles-inventaires-vehicules/{modele_id}")
async def delete_modele_inventaire_vehicule(
    tenant_slug: str,
    modele_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un mod√®le d'inventaire v√©hicule (admin/superviseur uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ['admin', 'superviseur']:
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin/Superviseur requis")
    
    result = await db.modeles_inventaires_vehicules.delete_one({
        "id": modele_id,
        "tenant_id": tenant.id
    })
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Mod√®le d'inventaire non trouv√©")
    
    return {"message": "Mod√®le d'inventaire supprim√© avec succ√®s"}

@api_router.get("/{tenant_slug}/vehicules/{vehicule_id}/modele-inventaire")
async def get_modele_inventaire_for_vehicule(
    tenant_slug: str,
    vehicule_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer le mod√®le d'inventaire pour un v√©hicule selon son type"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer le v√©hicule
    vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not vehicule:
        raise HTTPException(status_code=404, detail="V√©hicule non trouv√©")
    
    # Chercher le mod√®le correspondant au type du v√©hicule
    modele = await db.modeles_inventaires_vehicules.find_one(
        {
            "tenant_id": tenant.id,
            "type_vehicule": vehicule.get('type', 'autopompe')
        },
        {"_id": 0}
    )
    
    if not modele:
        raise HTTPException(
            status_code=404,
            detail=f"Aucun mod√®le d'inventaire configur√© pour ce type de v√©hicule ({vehicule.get('type', 'N/A')})"
        )
    
    return modele

@api_router.post("/{tenant_slug}/vehicules/{vehicule_id}/inventaire")
async def create_inventaire_vehicule(
    tenant_slug: str,
    vehicule_id: str,
    inventaire: InventaireVehiculeCreate,
    current_user: User = Depends(get_current_user)
):
    """Effectuer un inventaire v√©hicule (tous les utilisateurs)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # R√©cup√©rer le v√©hicule
    vehicule = await db.vehicules.find_one(
        {"id": vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not vehicule:
        raise HTTPException(status_code=404, detail="V√©hicule non trouv√©")
    
    # R√©cup√©rer le mod√®le
    modele = await db.modeles_inventaires_vehicules.find_one(
        {"id": inventaire.modele_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    
    if not modele:
        raise HTTPException(status_code=404, detail="Mod√®le d'inventaire non trouv√©")
    
    # Convertir items coch√©s en objets
    items_coches_obj = []
    
    for item in inventaire.items_coches:
        items_coches_obj.append(ItemInventaireVehiculeRempli(
            item_id=item['item_id'],
            section=item.get('section', ''),
            nom=item['nom'],
            type_champ=item.get('type_champ', 'text'),
            valeur=item.get('valeur', ''),
            notes=item.get('notes', ''),
            photo_prise=item.get('photo_prise', '')
        ))
    
    # D√©terminer statut global bas√© sur les alertes
    statut_global = "non_conforme" if (inventaire.alertes and len(inventaire.alertes) > 0) else "conforme"
    items_manquants = len([a for a in inventaire.alertes if 'absent' in str(a.get('valeur', '')).lower()]) if inventaire.alertes else 0
    items_defectueux = len([a for a in inventaire.alertes if 'd√©fectueux' in str(a.get('valeur', '')).lower() or 'defectueux' in str(a.get('valeur', '')).lower()]) if inventaire.alertes else 0
    
    # Cr√©er l'inventaire
    inventaire_obj = InventaireVehicule(
        tenant_id=tenant.id,
        vehicule_id=vehicule_id,
        vehicule_nom=vehicule.get('nom', 'N/A'),
        modele_id=inventaire.modele_id,
        modele_nom=modele['nom'],
        date_inventaire=inventaire.date_inventaire,
        effectue_par=f"{current_user.prenom} {current_user.nom}",
        effectue_par_id=current_user.id,
        items_coches=items_coches_obj,
        statut_global=statut_global,
        items_manquants=items_manquants,
        items_defectueux=items_defectueux,
        notes_generales=inventaire.notes_generales
    )
    
    await db.inventaires_vehicules.insert_one(inventaire_obj.dict())
    
    # Si des alertes existent, envoyer email de notification
    if inventaire.alertes and len(inventaire.alertes) > 0:
        # R√©cup√©rer les param√®tres d'email depuis parametres.actifs
        parametres = tenant.parametres if hasattr(tenant, 'parametres') and tenant.parametres else {}
        actifs_params = parametres.get('actifs', {})
        user_ids_ou_emails = actifs_params.get('emails_notifications_inventaires_vehicules', [])
        
        print(f"üîç DEBUG: Alertes d√©tect√©es ({len(inventaire.alertes)}), user_ids_ou_emails r√©cup√©r√©s: {user_ids_ou_emails}")
        
        if user_ids_ou_emails:
            # Convertir user IDs en emails
            emails_notifications = []
            for item in user_ids_ou_emails:
                if '@' in str(item):
                    emails_notifications.append(item)
                else:
                    try:
                        user = await db.users.find_one(
                            {"id": item, "tenant_id": tenant.id},
                            {"_id": 0, "email": 1}
                        )
                        if user and user.get('email'):
                            emails_notifications.append(user['email'])
                    except Exception as e:
                        print(f"‚ùå DEBUG: Erreur r√©cup√©ration user {item}: {e}")
            
            if emails_notifications:
                from utils.emails import send_inventaire_vehicule_alertes_email
                try:
                    await send_inventaire_vehicule_alertes_email(
                        tenant_slug=tenant_slug,
                        vehicule=vehicule,
                        inventaire=inventaire.dict(),
                        alertes=inventaire.alertes,
                        emails=emails_notifications
                    )
                    print(f"‚úÖ DEBUG: Email d'alertes inventaire envoy√© pour v√©hicule {vehicule_id} ({len(inventaire.alertes)} alertes)")
                except Exception as e:
                    print(f"‚ùå DEBUG: Erreur envoi email inventaire v√©hicule: {e}")
    
    return {
        "message": "Inventaire enregistr√© avec succ√®s",
        "id": inventaire_obj.id,
        "statut_global": statut_global,
        "items_manquants": items_manquants,
        "items_defectueux": items_defectueux
    }

@api_router.get("/{tenant_slug}/vehicules/{vehicule_id}/inventaires")
async def get_inventaires_vehicule(
    tenant_slug: str,
    vehicule_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer l'historique des inventaires d'un v√©hicule (admin/superviseur uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.role not in ['admin', 'superviseur']:
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin/Superviseur requis")
    
    inventaires = await db.inventaires_vehicules.find(
        {"vehicule_id": vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    ).sort("date_inventaire", -1).to_list(1000)
    
    return inventaires

@api_router.get("/{tenant_slug}/vehicules/{vehicule_id}/inventaires/{inventaire_id}")
async def get_inventaire_vehicule_details(
    tenant_slug: str,
    vehicule_id: str,
    inventaire_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les d√©tails d'un inventaire sp√©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    inventaire = await db.inventaires_vehicules.find_one(
        {
            "id": inventaire_id,
            "vehicule_id": vehicule_id,
            "tenant_id": tenant.id
        },
        {"_id": 0}
    )
    
    if not inventaire:
        raise HTTPException(status_code=404, detail="Inventaire non trouv√©")
    
    return inventaire


# ==================== PR√âVENTION ENDPOINTS ====================


@api_router.get("/{tenant_slug}/prevention/references")
async def get_prevention_references(tenant_slug: str):
    """R√©cup√®re les cat√©gories officielles (NR24-27) et risques (guide planification) pour le module pr√©vention"""
    
    categories_nr24_27 = {
        "A": {
            "nom": "√âtablissements de r√©union",
            "sous_groupes": {
                "A-1": "Destin√©s √† la production et √† la pr√©sentation d'arts du spectacle",
                "A-2": "Qui ne figurent dans aucune autre division du groupe A",
                "A-3": "De type ar√©na",
                "A-4": "O√π les occupants sont rassembl√©s en plein air"
            }
        },
        "B": {
            "nom": "√âtablissements de d√©tention, soins, traitement et habitations supervis√©es",
            "sous_groupes": {
                "B-1": "√âtablissements de d√©tention",
                "B-2": "√âtablissements de traitement",
                "B-3": "√âtablissements de soins",
                "B-4": "√âtablissements de soins de type r√©sidentiel"
            }
        },
        "C": {
            "nom": "Habitations",
            "sous_groupes": {}
        },
        "D": {
            "nom": "√âtablissements d'affaires",
            "sous_groupes": {}
        },
        "E": {
            "nom": "√âtablissements commerciaux",
            "sous_groupes": {}
        },
        "F": {
            "nom": "√âtablissements industriels",
            "sous_groupes": {
                "F-1": "√Ä risques tr√®s √©lev√©s",
                "F-2": "√Ä risques moyens",
                "F-3": "√Ä risques faibles"
            }
        },
        "G": {
            "nom": "√âtablissements agricoles",
            "sous_groupes": {
                "G-1": "√Ä risques tr√®s √©lev√©s",
                "G-2": "Qui ne figurent dans aucune autre division du groupe G",
                "G-3": "Abritant des serres",
                "G-4": "Sans occupation humaine"
            }
        }
    }
    
    risques_guide_planification = {
        "incendies": [
            "Incendie",
            "Conflagration"
        ],
        "matieres": [
            "Mati√®res dangereuses",
            "Mati√®res hautement inflammables",
            "Mati√®res tr√®s toxiques",
            "Mati√®res combustibles",
            "Produits chimiques"
        ],
        "infrastructure": [
            "Explosion",
            "D√©faillances des syst√®mes de s√©curit√© incendie",
            "Mat√©riaux de construction douteux"
        ],
        "occupants": [
            "Grand nombre d'occupants",
            "Capacit√© physique ou mentale insuffisante des occupants",
            "Personnes avec limitations compliquant l'√©vacuation",
            "Difficult√© d'√©vacuation",
            "Nombre √©lev√© d'enfants"
        ],
        "usages_specifiques": [
            "Usage r√©sidentiel",
            "Usage commercial",
            "Usage industriel",
            "Atelier/entrep√¥t",
            "Garage de r√©paration",
            "Imprimerie",
            "Station-service",
            "B√¢timent agricole",
            "H√¥pital/centre d'accueil",
            "√âtablissement de d√©tention",
            "Centre commercial",
            "H√¥tel/motel",
            "√âcole/garderie/√©glise",
            "Usine de peinture",
            "Usine de produits chimiques",
            "Meunerie",
            "Hangar"
        ],
        "environnement": [
            "Incendies de for√™t",
            "Inondations",
            "Glissements de terrain"
        ],
        "transport": [
            "R√©seaux routiers",
            "R√©seaux ferroviaires",
            "Transport maritime",
            "Trafic a√©rien",
            "Transport de mati√®res dangereuses",
            "Accidents routiers",
            "Accidents ferroviaires"
        ],
        "impact_societal": [
            "Impact majeur sur la soci√©t√©",
            "Importance pour la communaut√©",
            "Pertes d'emplois potentielles",
            "Effets psychologiques"
        ]
    }
    
    return {
        "categories_nr24_27": categories_nr24_27,
        "risques_guide_planification": risques_guide_planification
    }


@api_router.get("/{tenant_slug}/prevention/batiments")
async def get_batiments(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√©rer tous les b√¢timents du tenant"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # OPTIMISATION: Pour la liste, inclure photo_url mais le frontend pourra charger les d√©tails complets au besoin
    # Note: Si photos base64 trop lourdes, migration vers stockage externe recommand√©e
    batiments = await db.batiments.find(
        {"tenant_id": tenant.id},
        {"_id": 0}
    ).to_list(1000)
    return [clean_mongo_doc(batiment) for batiment in batiments]


@api_router.get("/{tenant_slug}/prevention/batiments/search")
async def search_batiments(
    tenant_slug: str, 
    q: str = "",
    adresse: str = "",
    current_user: User = Depends(get_current_user)
):
    """Rechercher des b√¢timents par adresse ou nom (pour les interventions)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Construire le filtre de recherche
    filters = {"tenant_id": tenant.id}
    
    search_term = q or adresse
    if search_term and len(search_term) >= 2:
        filters["$or"] = [
            {"adresse_civique": {"$regex": search_term, "$options": "i"}},
            {"nom_etablissement": {"$regex": search_term, "$options": "i"}},
            {"ville": {"$regex": search_term, "$options": "i"}}
        ]
    
    # Projection l√©g√®re pour la recherche
    projection = {
        "_id": 0,
        "id": 1,
        "nom_etablissement": 1,
        "adresse_civique": 1,
        "ville": 1,
        "code_postal": 1,
        "type_batiment": 1,
        "groupe_occupation": 1,
        "nombre_etages": 1,
        "annee_construction": 1,
        "niveau_risque": 1,
        "proprietaire_nom": 1,
        "proprietaire_telephone": 1,
        "superficie_totale_m2": 1,
        "risques_identifies": 1,
        "latitude": 1,
        "longitude": 1
    }
    
    batiments = await db.batiments.find(filters, projection).limit(20).to_list(20)
    return [clean_mongo_doc(b) for b in batiments]

@api_router.post("/{tenant_slug}/prevention/batiments")
async def create_batiment(
    tenant_slug: str, 
    batiment: BatimentCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un nouveau b√¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    try:
        batiment_dict = batiment.dict()
        print(f"üîç DEBUG - Donn√©es re√ßues du frontend: {batiment_dict}")
        batiment_dict["tenant_id"] = tenant.id
        batiment_dict["id"] = str(uuid.uuid4())  # G√©n√©rer un UUID pour le nouveau b√¢timent
        print(f"üîç DEBUG - Donn√©es avec tenant_id et id: {batiment_dict}")
        batiment_obj = Batiment(**batiment_dict)
        print(f"‚úÖ DEBUG - Objet Batiment cr√©√© avec succ√®s")
    except Exception as e:
        print(f"‚ùå DEBUG - Erreur cr√©ation Batiment: {e}")
        raise HTTPException(status_code=422, detail=f"Erreur validation: {str(e)}")
    
    await db.batiments.insert_one(batiment_obj.dict())
    return clean_mongo_doc(batiment_obj.dict())

@api_router.get("/{tenant_slug}/prevention/batiments/{batiment_id}")
async def get_batiment(
    tenant_slug: str, 
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer un b√¢timent sp√©cifique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    return clean_mongo_doc(batiment)

@api_router.put("/{tenant_slug}/prevention/batiments/{batiment_id}")
async def update_batiment(
    tenant_slug: str, 
    batiment_id: str,
    batiment_update: BatimentCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour un b√¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    update_data = batiment_update.dict()
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    return {"message": "B√¢timent mis √† jour avec succ√®s"}

@api_router.get("/{tenant_slug}/prevention/grilles-inspection")
async def get_grilles_inspection(tenant_slug: str, current_user: User = Depends(get_current_user)):
    """R√©cup√©rer toutes les grilles d'inspection du tenant"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer les grilles sp√©cifiques au tenant ET les grilles globales (templates)
    grilles = await db.grilles_inspection.find({
        "$or": [
            {"tenant_id": tenant.id},
            {"tenant_id": {"$exists": False}}  # Grilles globales/templates
        ]
    }).to_list(1000)
    return [clean_mongo_doc(grille) for grille in grilles]

@api_router.post("/{tenant_slug}/prevention/grilles-inspection")
async def create_grille_inspection(
    tenant_slug: str, 
    grille: GrilleInspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle grille d'inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    grille_dict = grille.dict()
    grille_dict["tenant_id"] = tenant.id
    grille_obj = GrilleInspection(**grille_dict)
    
    await db.grilles_inspection.insert_one(grille_obj.dict())
    return clean_mongo_doc(grille_obj.dict())

@api_router.get("/{tenant_slug}/prevention/grilles-inspection/{grille_id}")
async def get_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer une grille d'inspection sp√©cifique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    grille = await db.grilles_inspection.find_one({"id": grille_id, "tenant_id": tenant.id})
    if not grille:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouv√©e")
    
    return clean_mongo_doc(grille)

@api_router.put("/{tenant_slug}/prevention/grilles-inspection/{grille_id}")
async def update_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    grille_update: GrilleInspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour une grille d'inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    update_data = grille_update.dict()
    update_data["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.grilles_inspection.update_one(
        {"id": grille_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouv√©e")
    
    return {"message": "Grille d'inspection mise √† jour avec succ√®s"}

@api_router.delete("/{tenant_slug}/prevention/grilles-inspection/{grille_id}")
async def delete_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une grille d'inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.grilles_inspection.delete_one({"id": grille_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouv√©e")
    
    return {"message": "Grille d'inspection supprim√©e avec succ√®s"}

@api_router.post("/{tenant_slug}/prevention/grilles-inspection/{grille_id}/dupliquer")
async def dupliquer_grille_inspection(
    tenant_slug: str, 
    grille_id: str,
    nouveau_nom: str = None,
    current_user: User = Depends(get_current_user)
):
    """Dupliquer une grille d'inspection pour cr√©er une variante"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer la grille source
    grille_source = await db.grilles_inspection.find_one({"id": grille_id, "tenant_id": tenant.id}, {"_id": 0})
    
    if not grille_source:
        raise HTTPException(status_code=404, detail="Grille d'inspection non trouv√©e")
    
    # Cr√©er la copie avec un nouvel ID
    grille_copie = grille_source.copy()
    grille_copie["id"] = str(uuid.uuid4())
    grille_copie["nom"] = nouveau_nom if nouveau_nom else f"{grille_source['nom']} (Copie)"
    grille_copie["version"] = "1.0"
    
    await db.grilles_inspection.insert_one(grille_copie)
    
    return clean_mongo_doc(grille_copie)

@api_router.post("/{tenant_slug}/prevention/initialiser")
async def initialiser_module_prevention(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """Initialiser le module pr√©vention avec les 7 grilles d'inspection standards"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier si des grilles existent d√©j√†
    existing_count = await db.grilles_inspection.count_documents({"tenant_id": tenant.id})
    if existing_count > 0:
        raise HTTPException(status_code=400, detail=f"{existing_count} grille(s) existent d√©j√†. Supprimez-les d'abord si vous voulez r√©initialiser.")
    
    # Importer les grilles depuis insert_grilles.py
    import sys
    import os
    sys.path.insert(0, os.path.dirname(__file__))
    from insert_grilles import GRILLES
    
    # Cr√©er les 7 grilles pour ce tenant
    grilles_creees = []
    for grille_template in GRILLES:
        grille = grille_template.copy()
        grille["id"] = str(uuid.uuid4())
        grille["tenant_id"] = tenant.id
        grille["actif"] = True
        grille["version"] = "1.0"
        
        await db.grilles_inspection.insert_one(grille)
        grilles_creees.append({"id": grille["id"], "nom": grille["nom"]})
    
    return {
        "message": f"{len(grilles_creees)} grilles d'inspection cr√©√©es avec succ√®s",
        "grilles": grilles_creees
    }

@api_router.post("/{tenant_slug}/prevention/batiments/import-csv")
async def import_batiments_csv(
    tenant_slug: str,
    request: Dict[str, Any],  # Contient batiments: List[dict], required_fields: List[dict]
    current_user: User = Depends(get_current_user)
):
    """Import en masse de b√¢timents via CSV avec validation personnalis√©e"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    batiments_data = request.get('batiments', [])
    if not batiments_data:
        raise HTTPException(status_code=400, detail="Aucune donn√©e de b√¢timent fournie")
    
    # R√©cup√©rer les champs requis personnalis√©s (sinon utiliser les valeurs par d√©faut)
    required_fields = request.get('required_fields', [
        {'key': 'nom_etablissement', 'label': 'Nom √©tablissement'},
        {'key': 'adresse_civique', 'label': 'Adresse civique'}
    ])
    
    success_count = 0
    error_count = 0
    errors = []
    
    for idx, batiment_data in enumerate(batiments_data):
        try:
            # Validation dynamique selon les champs requis personnalis√©s
            for required_field in required_fields:
                field_key = required_field['key']
                field_label = required_field['label']
                
                if not batiment_data.get(field_key, '').strip():
                    errors.append({
                        "row": idx + 1,
                        "message": f"{field_label} requis"
                    })
                    error_count += 1
                    # Passer √† la ligne suivante si un champ requis est manquant
                    raise ValueError(f"{field_label} manquant")
            
            # Nettoyer et pr√©parer les donn√©es
            batiment_dict = {}
            for field_key, value in batiment_data.items():
                if value and str(value).strip():  # Ignorer les valeurs vides
                    batiment_dict[field_key] = str(value).strip()
                else:
                    batiment_dict[field_key] = ""
            
            # Ajouter les m√©tadonn√©es
            batiment_dict["tenant_id"] = tenant.id
            batiment_dict["statut"] = "actif"
            
            # Cr√©er l'objet Batiment et l'ins√©rer
            batiment_obj = Batiment(**batiment_dict)
            await db.batiments.insert_one(batiment_obj.dict())
            success_count += 1
            
        except ValueError:
            # Erreur d√©j√† ajout√©e dans la liste
            continue
        except Exception as e:
            errors.append({
                "row": idx + 1,
                "message": str(e)
            })
            error_count += 1
    
    # Cr√©er une activit√©
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="prevention_import_batiments",
        description=f"üìä {current_user.prenom} {current_user.nom} a import√© {success_count} b√¢timents ({error_count} erreurs)",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    return {
        "success_count": success_count,
        "error_count": error_count,
        "errors": errors[:10],  # Limiter √† 10 erreurs pour √©viter une r√©ponse trop lourde
        "total_processed": len(batiments_data)
    }

@api_router.delete("/{tenant_slug}/prevention/batiments/{batiment_id}")
async def delete_batiment(
    tenant_slug: str, 
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un b√¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.batiments.delete_one({"id": batiment_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    return {"message": "B√¢timent supprim√© avec succ√®s"}


class BatimentPhotoUpload(BaseModel):
    photo_base64: str

@api_router.post("/{tenant_slug}/prevention/batiments/{batiment_id}/photo")
async def upload_batiment_photo(
    tenant_slug: str,
    batiment_id: str,
    photo_data: BatimentPhotoUpload,
    current_user: User = Depends(get_current_user)
):
    """Uploader/Mettre √† jour la photo d'un b√¢timent (en base64)"""
    # Admins, superviseurs et pr√©ventionnistes peuvent uploader des photos
    if current_user.role not in ["admin", "superviseur"] and not current_user.est_preventionniste:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Permission insuffisante")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que le b√¢timent existe
    existing = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    # V√©rifier que la photo est au bon format base64
    if not photo_data.photo_base64.startswith('data:image/'):
        raise HTTPException(status_code=400, detail="Format de photo invalide (doit √™tre base64 data URL)")
    
    # Mettre √† jour la photo
    await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": {"photo_url": photo_data.photo_base64, "updated_at": datetime.now(timezone.utc)}}
    )
    
    return {"message": "Photo mise √† jour avec succ√®s", "photo_url": photo_data.photo_base64}

@api_router.delete("/{tenant_slug}/prevention/batiments/{batiment_id}/photo")
async def delete_batiment_photo(
    tenant_slug: str,
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer la photo d'un b√¢timent"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Mettre √† jour pour retirer la photo
    result = await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": {"photo_url": "", "updated_at": datetime.now(timezone.utc)}}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    return {"message": "Photo supprim√©e avec succ√®s"}

# ==================== SYMBOLES PERSONNALIS√âS ====================

@api_router.get("/{tenant_slug}/prevention/symboles-personnalises")
async def get_symboles_personnalises(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer tous les symboles personnalis√©s du tenant"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    symboles = await db.symboles_personnalises.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(symbole) for symbole in symboles]

@api_router.post("/{tenant_slug}/prevention/symboles-personnalises")
async def create_symbole_personnalise(
    tenant_slug: str,
    symbole: SymbolePersonnaliseCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un nouveau symbole personnalis√©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que l'image est au bon format base64
    if not symbole.image_base64.startswith('data:image/'):
        raise HTTPException(status_code=400, detail="Format d'image invalide (doit √™tre base64 data URL)")
    
    symbole_dict = symbole.dict()
    symbole_dict["tenant_id"] = tenant.id
    symbole_dict["id"] = str(uuid.uuid4())
    symbole_dict["created_at"] = datetime.now(timezone.utc)
    symbole_dict["created_by"] = current_user.id
    
    symbole_obj = SymbolePersonnalise(**symbole_dict)
    await db.symboles_personnalises.insert_one(symbole_obj.dict())
    
    return clean_mongo_doc(symbole_obj.dict())

@api_router.put("/{tenant_slug}/prevention/symboles-personnalises/{symbole_id}")
async def update_symbole_personnalise(
    tenant_slug: str,
    symbole_id: str,
    symbole: SymbolePersonnaliseCreate,
    current_user: User = Depends(get_current_user)
):
    """Modifier un symbole personnalis√©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que le symbole existe
    existing = await db.symboles_personnalises.find_one({"id": symbole_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Symbole non trouv√©")
    
    # V√©rifier que l'image est au bon format si elle est fournie
    if symbole.image_base64 and not symbole.image_base64.startswith('data:image/'):
        raise HTTPException(status_code=400, detail="Format d'image invalide (doit √™tre base64 data URL)")
    
    update_dict = symbole.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    await db.symboles_personnalises.update_one(
        {"id": symbole_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    updated = await db.symboles_personnalises.find_one({"id": symbole_id, "tenant_id": tenant.id})
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/symboles-personnalises/{symbole_id}")
async def delete_symbole_personnalise(
    tenant_slug: str,
    symbole_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un symbole personnalis√©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier si le symbole existe
    symbole = await db.symboles_personnalises.find_one({"id": symbole_id, "tenant_id": tenant.id})
    if not symbole:
        raise HTTPException(status_code=404, detail="Symbole non trouv√©")
    
    # V√©rifier si le symbole est utilis√© dans des plans d'intervention
    # Les plans peuvent stocker les symboles dans les layers (format GeoJSON)
    plans_utilisant = await db.plans_intervention.count_documents({
        "tenant_id": tenant.id,
        "$or": [
            {"layers.properties.symbolId": symbole_id},
            {"layers": {"$elemMatch": {"properties.symbolId": symbole_id}}}
        ]
    })
    
    if plans_utilisant > 0:
        raise HTTPException(
            status_code=409, 
            detail=f"Impossible de supprimer ce symbole. Il est utilis√© dans {plans_utilisant} plan(s) d'intervention."
        )
    
    result = await db.symboles_personnalises.delete_one({"id": symbole_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Symbole non trouv√©")
    
    return {"message": "Symbole supprim√© avec succ√®s"}



# ==================== SECTEURS G√âOGRAPHIQUES ====================

@api_router.get("/{tenant_slug}/prevention/secteurs")
async def get_secteurs(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer tous les secteurs g√©ographiques"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    secteurs = await db.secteurs_geographiques.find({"tenant_id": tenant.id}).to_list(1000)
    return [clean_mongo_doc(secteur) for secteur in secteurs]

@api_router.post("/{tenant_slug}/prevention/secteurs")
async def create_secteur(
    tenant_slug: str,
    secteur: SecteurGeographiqueCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un nouveau secteur g√©ographique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    secteur_dict = secteur.dict()
    secteur_dict["tenant_id"] = tenant.id
    secteur_dict["id"] = str(uuid.uuid4())
    secteur_dict["created_at"] = datetime.now(timezone.utc)
    secteur_dict["updated_at"] = datetime.now(timezone.utc)
    
    secteur_obj = SecteurGeographique(**secteur_dict)
    await db.secteurs_geographiques.insert_one(secteur_obj.dict())
    
    return clean_mongo_doc(secteur_obj.dict())

@api_router.get("/{tenant_slug}/prevention/secteurs/{secteur_id}")
async def get_secteur(
    tenant_slug: str,
    secteur_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer un secteur g√©ographique sp√©cifique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    secteur = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    if not secteur:
        raise HTTPException(status_code=404, detail="Secteur non trouv√©")
    
    return clean_mongo_doc(secteur)

@api_router.put("/{tenant_slug}/prevention/secteurs/{secteur_id}")
async def update_secteur(
    tenant_slug: str,
    secteur_id: str,
    secteur_update: SecteurGeographiqueCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour un secteur g√©ographique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    existing = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Secteur non trouv√©")
    
    update_dict = secteur_update.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    await db.secteurs_geographiques.update_one(
        {"id": secteur_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    updated = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/secteurs/{secteur_id}")
async def delete_secteur(
    tenant_slug: str,
    secteur_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un secteur g√©ographique"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.secteurs_geographiques.delete_one({"id": secteur_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Secteur non trouv√©")
    
    return {"message": "Secteur supprim√© avec succ√®s"}



@api_router.get("/{tenant_slug}/prevention/meta/niveaux-risque")
async def get_niveaux_risque(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les niveaux de risque standardis√©s selon les documents officiels du Qu√©bec"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Niveaux de risque standardis√©s selon les documents officiels du Qu√©bec
    # (Tableau A1: Classification des risques d'incendie)
    niveaux_risque = [
        {
            "valeur": "Faible",
            "description": "Tr√®s petits b√¢timents, tr√®s espac√©s. B√¢timents r√©sidentiels de 1 ou 2 logements, de 1 ou 2 √©tages, d√©tach√©s"
        },
        {
            "valeur": "Moyen",
            "description": "B√¢timents d'au plus 3 √©tages et dont l'aire au sol est d'au plus 600 m¬≤"
        },
        {
            "valeur": "√âlev√©",
            "description": "B√¢timents dont l'aire au sol est de plus de 600 m¬≤. B√¢timents de 4 √† 6 √©tages. Lieux o√π les occupants sont normalement aptes √† √©vacuer"
        },
        {
            "valeur": "Tr√®s √©lev√©",
            "description": "B√¢timents de plus de 6 √©tages ou pr√©sentant un risque √©lev√© de conflagration. Lieux o√π les occupants ne peuvent √©vacuer d'eux-m√™mes ou √©vacuation difficile"
        }
    ]
    
    return {
        "niveaux_risque": niveaux_risque,
        "source": "Documents officiels du Qu√©bec (Tableau A1: Classification des risques d'incendie)"
    }

@api_router.get("/{tenant_slug}/prevention/meta/categories-batiments")
async def get_categories_batiments(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les cat√©gories et sous-cat√©gories de b√¢timents selon le Code national de pr√©vention des incendies"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le module pr√©vention est activ√©
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Cat√©gories de b√¢timents selon le Code national de pr√©vention des incendies - Canada 2020
    categories = [
        {
            "groupe": "A",
            "nom": "Habitation",
            "divisions": [
                {"code": "A-1", "description": "Usage principal pour habitation"},
                {"code": "A-2", "description": "√âtablissements de soins ou de d√©tention supervis√©s"}
            ]
        },
        {
            "groupe": "B",
            "nom": "Soins et d√©tention",
            "divisions": [
                {"code": "B-1", "description": "√âtablissements de soins"},
                {"code": "B-2", "description": "√âtablissements de d√©tention"}
            ]
        },
        {
            "groupe": "C",
            "nom": "R√©sidentiel",
            "divisions": [
                {"code": "C-1", "description": "Habitations unifamiliales et bifamiliales"},
                {"code": "C-2", "description": "Habitations avec services communs"},
                {"code": "C-3", "description": "Ensembles r√©sidentiels"}
            ]
        },
        {
            "groupe": "D",
            "nom": "Affaires",
            "divisions": [
                {"code": "D-1", "description": "√âtablissements d'affaires"},
                {"code": "D-2", "description": "√âtablissements de services personnels"}
            ]
        },
        {
            "groupe": "E",
            "nom": "Commerce",
            "divisions": [
                {"code": "E-1", "description": "√âtablissements mercantiles"},
                {"code": "E-2", "description": "√âtablissements de vente au d√©tail"}
            ]
        },
        {
            "groupe": "F",
            "nom": "Industriel",
            "divisions": [
                {"code": "F-1", "description": "√âtablissements industriels √† risques tr√®s √©lev√©s (entrep√¥ts de mati√®res dangereuses, usines chimiques, meuneries)"},
                {"code": "F-2", "description": "√âtablissements industriels √† risques moyens (ateliers, garages de r√©paration, imprimeries, stations-service)"},
                {"code": "F-3", "description": "√âtablissements industriels √† risques faibles (ateliers, entrep√¥ts, salles de vente)"}
            ]
        },
        {
            "groupe": "G",
            "nom": "Agricole",
            "divisions": [
                {"code": "G-1", "description": "√âtablissements agricoles √† risques tr√®s √©lev√©s"},
                {"code": "G-2", "description": "√âtablissements agricoles √† risques moyens"},
                {"code": "G-3", "description": "√âtablissements agricoles √† risques faibles"}
            ]
        },
        {
            "groupe": "I",
            "nom": "Assembl√©e",
            "divisions": [
                {"code": "I-1", "description": "Lieux de rassemblement (auditoriums, √©glises, salles de spectacle)"},
                {"code": "I-2", "description": "√âtablissements de r√©union"}
            ]
        }
    ]
    
    return {
        "categories": categories,
        "source": "Code national de pr√©vention des incendies - Canada 2020 (Division A)"
    }


# ==================== G√âN√âRATION RAPPORT PDF ====================# ==================== G√âN√âRATION RAPPORT PDF ====================

async def generer_rapport_inspection_pdf(inspection_id: str, tenant_id: str) -> BytesIO:
    """G√©n√©rer un rapport PDF pour une inspection"""
    # R√©cup√©rer le tenant
    tenant = await db.tenants.find_one({"id": tenant_id}, {"_id": 0})
    
    # R√©cup√©rer l'inspection
    inspection = await db.inspections.find_one({"id": inspection_id, "tenant_id": tenant_id})
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    # R√©cup√©rer le b√¢timent
    batiment = await db.batiments.find_one({"id": inspection["batiment_id"], "tenant_id": tenant_id})
    
    # R√©cup√©rer la grille d'inspection
    grille = await db.grilles_inspection.find_one({"id": inspection["grille_inspection_id"], "tenant_id": tenant_id})
    
    # R√©cup√©rer le pr√©ventionniste
    preventionniste = await db.users.find_one({"id": inspection["preventionniste_id"]})
    
    # R√©cup√©rer les non-conformit√©s
    non_conformites = await db.non_conformites.find({
        "inspection_id": inspection_id,
        "tenant_id": tenant_id
    }).to_list(1000)
    
    # Cr√©er le PDF avec branding
    from types import SimpleNamespace
    tenant_obj = SimpleNamespace(**tenant) if tenant else None
    buffer, doc, story = create_branded_pdf(tenant_obj, pagesize=letter)
    styles = getSampleStyleSheet()
    
    # Style personnalis√©
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        textColor=colors.HexColor('#1f2937'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#374151'),
        spaceAfter=12,
        spaceBefore=20
    )
    
    # Titre
    story.append(Paragraph("RAPPORT D'INSPECTION INCENDIE", title_style))
    story.append(Spacer(1, 0.3*inch))
    
    # Informations g√©n√©rales
    story.append(Paragraph("INFORMATIONS G√âN√âRALES", heading_style))
    
    info_data = [
        ["Date d'inspection:", inspection.get("date_inspection", "N/A")],
        ["Type:", inspection.get("type_inspection", "r√©guli√®re").upper()],
        ["Pr√©ventionniste:", f"{preventionniste.get('prenom', '')} {preventionniste.get('nom', '')}" if preventionniste else "N/A"],
        ["Heure d√©but:", inspection.get("heure_debut", "N/A")],
        ["Heure fin:", inspection.get("heure_fin", "N/A")],
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb'))
    ]))
    story.append(info_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Informations b√¢timent
    if batiment:
        story.append(Paragraph("INFORMATIONS B√ÇTIMENT", heading_style))
        
        bat_data = [
            ["Nom √©tablissement:", batiment.get("nom_etablissement", "N/A")],
            ["Adresse:", batiment.get("adresse_civique", "N/A")],
            ["Ville:", batiment.get("ville", "N/A")],
            ["Code postal:", batiment.get("code_postal", "N/A")],
            ["Groupe occupation:", batiment.get("groupe_occupation", "N/A")],
        ]
        
        bat_table = Table(bat_data, colWidths=[2*inch, 4*inch])
        bat_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb'))
        ]))
        story.append(bat_table)
        story.append(Spacer(1, 0.3*inch))
    
    # R√©sultat global
    story.append(Paragraph("R√âSULTAT GLOBAL", heading_style))
    
    statut_color = colors.HexColor('#10b981') if inspection.get("statut_global") == "conforme" else colors.HexColor('#ef4444')
    statut_text = inspection.get("statut_global", "N/A").upper()
    score = inspection.get("score_conformite", 100)
    
    result_data = [
        ["Statut:", statut_text],
        ["Score de conformit√©:", f"{score}%"],
        ["Non-conformit√©s:", str(len(non_conformites))],
    ]
    
    result_table = Table(result_data, colWidths=[2*inch, 4*inch])
    result_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
        ('BACKGROUND', (1, 0), (1, 0), statut_color),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
        ('TEXTCOLOR', (1, 0), (1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTNAME', (1, 0), (1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb'))
    ]))
    story.append(result_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Non-conformit√©s
    if non_conformites:
        story.append(Paragraph("NON-CONFORMIT√âS IDENTIFI√âES", heading_style))
        
        for idx, nc in enumerate(non_conformites, 1):
            nc_data = [
                [f"#{idx}", ""],
                ["Titre:", nc.get("titre", "N/A")],
                ["Description:", nc.get("description", "N/A")],
                ["Gravit√©:", nc.get("gravite", "N/A").upper()],
                ["Statut:", nc.get("statut", "N/A")],
                ["D√©lai correction:", nc.get("delai_correction", "N/A")],
            ]
            
            nc_table = Table(nc_data, colWidths=[2*inch, 4*inch])
            nc_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#fef2f2')),
                ('BACKGROUND', (0, 1), (0, -1), colors.HexColor('#f3f4f6')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb')),
                ('SPAN', (0, 0), (-1, 0)),
            ]))
            story.append(nc_table)
            story.append(Spacer(1, 0.2*inch))
    
    # Notes et recommandations
    if inspection.get("notes_inspection") or inspection.get("recommandations"):
        story.append(Paragraph("NOTES ET RECOMMANDATIONS", heading_style))
        
        if inspection.get("notes_inspection"):
            story.append(Paragraph(f"<b>Notes:</b> {inspection.get('notes_inspection')}", styles['Normal']))
            story.append(Spacer(1, 0.1*inch))
        
        if inspection.get("recommandations"):
            story.append(Paragraph(f"<b>Recommandations:</b> {inspection.get('recommandations')}", styles['Normal']))
            story.append(Spacer(1, 0.3*inch))
    
    # Signature
    story.append(Spacer(1, 0.5*inch))
    story.append(Paragraph("SIGNATURES", heading_style))
    
    sig_data = [
        ["Pr√©ventionniste:", "_" * 40],
        ["Date:", "_" * 40],
        ["", ""],
        ["Repr√©sentant b√¢timent:", "_" * 40],
        ["Nom:", inspection.get("nom_representant", "_" * 40)],
        ["Date:", "_" * 40],
    ]
    
    sig_table = Table(sig_data, colWidths=[2*inch, 4*inch])
    sig_table.setStyle(TableStyle([
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#1f2937')),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
    ]))
    story.append(sig_table)
    
    # G√©n√©rer le PDF
    doc.build(story)
    buffer.seek(0)
    return buffer


@api_router.get("/{tenant_slug}/prevention/inspections/{inspection_id}/rapport-pdf")
async def get_inspection_rapport_pdf(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """G√©n√©rer et t√©l√©charger le rapport PDF d'une inspection"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que l'inspection existe
    inspection = await db.inspections.find_one({"id": inspection_id, "tenant_id": tenant.id})
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    # G√©n√©rer le PDF
    pdf_buffer = await generer_rapport_inspection_pdf(inspection_id, tenant.id)
    
    # Retourner le PDF
    return StreamingResponse(
        pdf_buffer,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename=rapport_inspection_{inspection_id}.pdf"
        }
    )


# ==================== INSPECTIONS ====================

@api_router.post("/{tenant_slug}/prevention/inspections")
async def create_inspection(
    tenant_slug: str,
    inspection: InspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle inspection"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    inspection_dict = inspection.dict()
    inspection_dict["tenant_id"] = tenant.id
    inspection_obj = Inspection(**inspection_dict)
    
    await db.inspections.insert_one(inspection_obj.dict())
    
    return clean_mongo_doc(inspection_obj.dict())

@api_router.get("/{tenant_slug}/prevention/inspections")
async def get_inspections(
    tenant_slug: str,
    batiment_id: Optional[str] = None,
    preventionniste_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer toutes les inspections avec filtres optionnels"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id}
    if batiment_id:
        query["batiment_id"] = batiment_id
    if preventionniste_id:
        query["preventionniste_id"] = preventionniste_id
    
    inspections = await db.inspections.find(query).sort("created_at", -1).to_list(1000)
    return [clean_mongo_doc(i) for i in inspections]

@api_router.get("/{tenant_slug}/prevention/inspections/{inspection_id}")
async def get_inspection(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer une inspection sp√©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    inspection = await db.inspections.find_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    return clean_mongo_doc(inspection)

@api_router.put("/{tenant_slug}/prevention/inspections/{inspection_id}")
async def update_inspection(
    tenant_slug: str,
    inspection_id: str,
    inspection_data: InspectionCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour une inspection"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    update_dict = inspection_data.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.inspections.update_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    updated_inspection = await db.inspections.find_one({"id": inspection_id})
    return clean_mongo_doc(updated_inspection)

@api_router.get("/{tenant_slug}/prevention/inspections-planifiees")
async def get_inspections_planifiees(
    tenant_slug: str,
    days: int = 7,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les inspections planifi√©es pour les X prochains jours (pour mode offline)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Calculer la plage de dates
    from datetime import datetime, timedelta, timezone
    today = datetime.now(timezone.utc).date()
    end_date = today + timedelta(days=days)
    
    # Convertir en format ISO string YYYY-MM-DD pour comparaison
    today_str = today.isoformat()
    end_date_str = end_date.isoformat()
    
    # R√©cup√©rer les inspections planifi√©es (date_inspection entre aujourd'hui et end_date)
    inspections = await db.inspections.find({
        "tenant_id": tenant.id,
        "date_inspection": {
            "$gte": today_str,
            "$lte": end_date_str
        },
        "statut": {"$in": ["planifiee", "en_cours", "a_faire", None]}  # Exclure les termin√©es
    }).sort("date_inspection", 1).to_list(100)
    
    # Enrichir avec les infos du b√¢timent
    enriched = []
    for insp in inspections:
        batiment = await db.batiments.find_one(
            {"id": insp.get("batiment_id"), "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        enriched.append({
            **clean_mongo_doc(insp),
            "batiment": batiment
        })
    
    return enriched

@api_router.delete("/{tenant_slug}/prevention/inspections/{inspection_id}")
async def delete_inspection(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une inspection"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.inspections.delete_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    # Supprimer aussi les non-conformit√©s associ√©es
    await db.non_conformites.delete_many({"inspection_id": inspection_id, "tenant_id": tenant.id})
    
    return {"message": "Inspection supprim√©e avec succ√®s"}


# ==================== NON-CONFORMIT√âS ====================

@api_router.post("/{tenant_slug}/prevention/non-conformites")
async def create_non_conformite(
    tenant_slug: str,
    non_conformite: NonConformiteCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle non-conformit√©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    nc_dict = non_conformite.dict()
    nc_dict["tenant_id"] = tenant.id
    nc_obj = NonConformite(**nc_dict)
    
    await db.non_conformites.insert_one(nc_obj.dict())
    
    return clean_mongo_doc(nc_obj.dict())

@api_router.get("/{tenant_slug}/prevention/non-conformites")
async def get_non_conformites(
    tenant_slug: str,
    inspection_id: Optional[str] = None,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer toutes les non-conformit√©s avec filtres optionnels"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id}
    if inspection_id:
        query["inspection_id"] = inspection_id
    if batiment_id:
        query["batiment_id"] = batiment_id
    if statut:
        query["statut"] = statut
    
    non_conformites = await db.non_conformites.find(query).sort("created_at", -1).to_list(1000)
    return [clean_mongo_doc(nc) for nc in non_conformites]

@api_router.get("/{tenant_slug}/prevention/non-conformites/{nc_id}")
async def get_non_conformite(
    tenant_slug: str,
    nc_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer une non-conformit√© sp√©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    nc = await db.non_conformites.find_one({"id": nc_id, "tenant_id": tenant.id})
    
    if not nc:
        raise HTTPException(status_code=404, detail="Non-conformit√© non trouv√©e")
    
    return clean_mongo_doc(nc)

@api_router.put("/{tenant_slug}/prevention/non-conformites/{nc_id}")
async def update_non_conformite(
    tenant_slug: str,
    nc_id: str,
    nc_data: NonConformiteCreate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour une non-conformit√©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    update_dict = nc_data.dict()
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    result = await db.non_conformites.update_one(
        {"id": nc_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformit√© non trouv√©e")
    
    updated_nc = await db.non_conformites.find_one({"id": nc_id})
    return clean_mongo_doc(updated_nc)

@api_router.patch("/{tenant_slug}/prevention/non-conformites/{nc_id}/statut")
async def update_non_conformite_statut(
    tenant_slug: str,
    nc_id: str,
    statut: str = Body(..., embed=True),
    notes_correction: str = Body("", embed=True),
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour le statut d'une non-conformit√©"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    update_data = {
        "statut": statut,
        "notes_correction": notes_correction,
        "updated_at": datetime.now(timezone.utc)
    }
    
    if statut == "corrigee" or statut == "fermee":
        update_data["date_correction"] = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    
    result = await db.non_conformites.update_one(
        {"id": nc_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformit√© non trouv√©e")
    
    updated_nc = await db.non_conformites.find_one({"id": nc_id})
    return clean_mongo_doc(updated_nc)

@api_router.delete("/{tenant_slug}/prevention/non-conformites/{nc_id}")
async def delete_non_conformite(
    tenant_slug: str,
    nc_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une non-conformit√©"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.non_conformites.delete_one({"id": nc_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformit√© non trouv√©e")
    
    return {"message": "Non-conformit√© supprim√©e avec succ√®s"}


# ==================== UPLOAD PHOTOS ====================

@api_router.post("/{tenant_slug}/prevention/upload-photo")
async def upload_photo(
    tenant_slug: str,
    photo_base64: str = Body(..., embed=True),
    filename: str = Body(..., embed=True),
    current_user: User = Depends(get_current_user)
):
    """Upload une photo en base64 et retourne l'URL"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    try:
        # G√©n√©rer un ID unique pour la photo
        photo_id = str(uuid.uuid4())
        
        # Stocker la photo dans la collection photos
        photo_doc = {
            "id": photo_id,
            "tenant_id": tenant.id,
            "filename": filename,
            "data": photo_base64,
            "uploaded_by": current_user.id,
            "uploaded_at": datetime.now(timezone.utc).isoformat()
        }
        
        await db.photos_prevention.insert_one(photo_doc)
        
        # Retourner l'ID de la photo (qui servira d'URL)
        return {
            "photo_id": photo_id,
            "url": f"/api/{tenant_slug}/prevention/photos/{photo_id}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur upload photo: {str(e)}")

@api_router.post("/{tenant_slug}/inventaires/upload-photo")
async def upload_inventaire_photo(
    tenant_slug: str,
    photo_base64: str = Body(..., embed=True),
    filename: str = Body(..., embed=True),
    current_user: User = Depends(get_current_user)
):
    """Upload une photo pour un inventaire v√©hicule et retourne l'URL"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    try:
        # G√©n√©rer un ID unique pour la photo
        photo_id = str(uuid.uuid4())
        
        # Stocker la photo dans la collection photos
        photo_doc = {
            "id": photo_id,
            "tenant_id": tenant.id,
            "filename": filename,
            "data": photo_base64,
            "uploaded_by": current_user.id,
            "uploaded_at": datetime.now(timezone.utc).isoformat(),
            "type": "inventaire_vehicule"
        }
        
        await db.photos_inventaires.insert_one(photo_doc)
        
        # Retourner l'URL de la photo
        return {
            "photo_id": photo_id,
            "url": f"/api/{tenant_slug}/inventaires/photos/{photo_id}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur upload photo: {str(e)}")

@api_router.get("/{tenant_slug}/inventaires/photos/{photo_id}")
async def get_inventaire_photo(
    tenant_slug: str,
    photo_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer une photo d'inventaire par son ID"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    photo = await db.photos_inventaires.find_one({
        "id": photo_id,
        "tenant_id": tenant.id
    }, {"_id": 0})
    
    if not photo:
        raise HTTPException(status_code=404, detail="Photo non trouv√©e")
    
    # Retourner la photo en base64
    from fastapi.responses import Response
    import base64
    
    # Extraire les donn√©es de l'image
    if photo['data'].startswith('data:'):
        # Format: data:image/png;base64,xxxx
        header, data = photo['data'].split(',', 1)
        mime_type = header.split(':')[1].split(';')[0]
    else:
        data = photo['data']
        mime_type = 'image/png'
    
    image_data = base64.b64decode(data)
    
    return Response(content=image_data, media_type=mime_type)

@api_router.get("/{tenant_slug}/prevention/photos/{photo_id}")
async def get_photo(
    tenant_slug: str,
    photo_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer une photo par son ID"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    photo = await db.photos_prevention.find_one({"id": photo_id, "tenant_id": tenant.id})
    
    if not photo:
        raise HTTPException(status_code=404, detail="Photo non trouv√©e")
    
    return {
        "id": photo["id"],
        "filename": photo.get("filename", "photo.jpg"),
        "data": photo["data"],
        "uploaded_at": photo.get("uploaded_at")
    }

@api_router.delete("/{tenant_slug}/prevention/photos/{photo_id}")
async def delete_photo(
    tenant_slug: str,
    photo_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une photo"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.photos_prevention.delete_one({"id": photo_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Photo non trouv√©e")
    
    return {"message": "Photo supprim√©e avec succ√®s"}


# ==================== IC√îNES PERSONNALIS√âES ====================

@api_router.post("/{tenant_slug}/prevention/icones-personnalisees")
async def create_icone_personnalisee(
    tenant_slug: str,
    icone: IconePersonnaliseeCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une ic√¥ne personnalis√©e"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    try:
        # Cr√©er l'ic√¥ne
        icone_dict = icone.dict()
        icone_dict["id"] = str(uuid.uuid4())
        icone_dict["tenant_id"] = tenant.id
        icone_dict["created_by_id"] = current_user.id
        icone_dict["created_at"] = datetime.now(timezone.utc).isoformat()
        
        await db.icones_personnalisees.insert_one(icone_dict)
        
        return clean_mongo_doc(icone_dict)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur cr√©ation ic√¥ne: {str(e)}")

@api_router.get("/{tenant_slug}/prevention/icones-personnalisees")
async def get_icones_personnalisees(
    tenant_slug: str,
    categorie: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer toutes les ic√¥nes personnalis√©es d'un tenant"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id}
    if categorie:
        query["categorie"] = categorie
    
    icones = await db.icones_personnalisees.find(query).to_list(length=None)
    
    return [clean_mongo_doc(icone) for icone in icones]

@api_router.delete("/{tenant_slug}/prevention/icones-personnalisees/{icone_id}")
async def delete_icone_personnalisee(
    tenant_slug: str,
    icone_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une ic√¥ne personnalis√©e"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.icones_personnalisees.delete_one({"id": icone_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Ic√¥ne non trouv√©e")
    
    return {"message": "Ic√¥ne supprim√©e avec succ√®s"}


# ==================== INSPECTIONS VISUELLES (NOUVEAU SYST√àME) ====================

@api_router.post("/{tenant_slug}/prevention/inspections-visuelles")
async def create_inspection_visuelle(
    tenant_slug: str,
    inspection: InspectionVisuelleCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle inspection visuelle (pompiers + pr√©ventionnistes)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que le b√¢timent existe
    batiment = await db.batiments.find_one({"id": inspection.batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    inspection_dict = inspection.dict()
    inspection_dict["tenant_id"] = tenant.id
    
    # Cr√©er l'objet InspectionVisuelle complet
    inspection_obj = InspectionVisuelle(**inspection_dict)
    
    await db.inspections_visuelles.insert_one(inspection_obj.dict())
    
    return clean_mongo_doc(inspection_obj.dict())

@api_router.get("/{tenant_slug}/prevention/inspections-visuelles")
async def get_inspections_visuelles(
    tenant_slug: str,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    date_debut: Optional[str] = None,
    date_fin: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer la liste des inspections visuelles avec filtres"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id}
    
    if batiment_id:
        query["batiment_id"] = batiment_id
    
    if statut:
        query["statut"] = statut
    
    if date_debut and date_fin:
        query["date_inspection"] = {"$gte": date_debut, "$lte": date_fin}
    
    inspections = await db.inspections_visuelles.find(query).sort("created_at", -1).to_list(length=None)
    
    return [clean_mongo_doc(insp) for insp in inspections]

@api_router.get("/{tenant_slug}/prevention/inspections-visuelles/{inspection_id}")
async def get_inspection_visuelle(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer une inspection visuelle sp√©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    inspection = await db.inspections_visuelles.find_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if not inspection:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    return clean_mongo_doc(inspection)

@api_router.put("/{tenant_slug}/prevention/inspections-visuelles/{inspection_id}")
async def update_inspection_visuelle(
    tenant_slug: str,
    inspection_id: str,
    inspection_update: InspectionVisuelleUpdate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour une inspection visuelle (toujours modifiable)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer l'inspection existante
    existing = await db.inspections_visuelles.find_one({"id": inspection_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    # Mettre √† jour uniquement les champs fournis
    update_dict = {k: v for k, v in inspection_update.dict(exclude_unset=True).items() if v is not None}
    update_dict["updated_at"] = datetime.now(timezone.utc)
    
    # Calculer la dur√©e si heure_fin est fournie
    if "heure_fin" in update_dict and existing.get("heure_debut"):
        try:
            debut = datetime.fromisoformat(f"{existing['date_inspection']}T{existing['heure_debut']}")
            fin = datetime.fromisoformat(f"{existing['date_inspection']}T{update_dict['heure_fin']}")
            update_dict["duree_minutes"] = int((fin - debut).total_seconds() / 60)
        except:
            pass
    
    result = await db.inspections_visuelles.update_one(
        {"id": inspection_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    updated = await db.inspections_visuelles.find_one({"id": inspection_id})
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/inspections-visuelles/{inspection_id}")
async def delete_inspection_visuelle(
    tenant_slug: str,
    inspection_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer une inspection visuelle (pr√©ventionnistes uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que l'utilisateur est pr√©ventionniste ou admin
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les pr√©ventionnistes peuvent supprimer des inspections")
    
    result = await db.inspections_visuelles.delete_one({"id": inspection_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Inspection non trouv√©e")
    
    # Supprimer aussi les non-conformit√©s associ√©es
    await db.non_conformites_visuelles.delete_many({"inspection_id": inspection_id, "tenant_id": tenant.id})
    
    return {"message": "Inspection supprim√©e avec succ√®s"}


# ==================== NON-CONFORMIT√âS VISUELLES ====================

@api_router.post("/{tenant_slug}/prevention/non-conformites-visuelles")
async def create_non_conformite_visuelle(
    tenant_slug: str,
    nc: NonConformiteVisuelleCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle non-conformit√© visuelle"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    nc_dict = nc.dict()
    nc_dict["tenant_id"] = tenant.id
    
    # Calculer la date limite si d√©lai fourni
    if nc_dict.get("delai_correction_jours"):
        from datetime import timedelta
        inspection = await db.inspections_visuelles.find_one({"id": nc.inspection_id})
        if inspection:
            date_insp = datetime.fromisoformat(inspection["date_inspection"])
            date_limite = date_insp + timedelta(days=nc_dict["delai_correction_jours"])
            nc_dict["date_limite"] = date_limite.strftime("%Y-%m-%d")
    
    nc_obj = NonConformiteVisuelle(**nc_dict)
    
    await db.non_conformites_visuelles.insert_one(nc_obj.dict())
    
    # Ajouter l'ID de la NC √† l'inspection
    await db.inspections_visuelles.update_one(
        {"id": nc.inspection_id, "tenant_id": tenant.id},
        {"$push": {"non_conformites_ids": nc_obj.id}}
    )
    
    return clean_mongo_doc(nc_obj.dict())

@api_router.get("/{tenant_slug}/prevention/non-conformites-visuelles")
async def get_non_conformites_visuelles(
    tenant_slug: str,
    inspection_id: Optional[str] = None,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    gravite: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les non-conformit√©s visuelles avec filtres"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id}
    
    if inspection_id:
        query["inspection_id"] = inspection_id
    if batiment_id:
        query["batiment_id"] = batiment_id
    if statut:
        query["statut"] = statut
    if gravite:
        query["gravite"] = gravite
    
    ncs = await db.non_conformites_visuelles.find(query).sort("created_at", -1).to_list(length=None)
    
    return [clean_mongo_doc(nc) for nc in ncs]

@api_router.put("/{tenant_slug}/prevention/non-conformites-visuelles/{nc_id}")
async def update_non_conformite_visuelle(
    tenant_slug: str,
    nc_id: str,
    statut: Optional[str] = Body(None),
    photos_resolution: Optional[List[PhotoInspection]] = Body(None),
    notes_resolution: Optional[str] = Body(None),
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour le statut d'une non-conformit√©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    update_dict = {"updated_at": datetime.now(timezone.utc)}
    
    if statut:
        update_dict["statut"] = statut
        if statut == "resolue":
            update_dict["date_resolution"] = datetime.now(timezone.utc)
    
    if photos_resolution:
        update_dict["photos_resolution"] = [p.dict() for p in photos_resolution]
    
    if notes_resolution:
        update_dict["notes_resolution"] = notes_resolution
    
    result = await db.non_conformites_visuelles.update_one(
        {"id": nc_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Non-conformit√© non trouv√©e")
    
    updated = await db.non_conformites_visuelles.find_one({"id": nc_id})
    return clean_mongo_doc(updated)


# ==================== CARTE INTERACTIVE & G√âOCODAGE ====================

@api_router.get("/{tenant_slug}/prevention/batiments/map")
async def get_batiments_for_map(
    tenant_slug: str,
    niveau_risque: Optional[str] = None,
    statut_inspection: Optional[str] = None,
    secteur: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les b√¢timents format√©s pour affichage sur carte"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer tous les b√¢timents
    query = {"tenant_id": tenant.id, "statut": "actif"}
    
    if niveau_risque:
        query["niveau_risque"] = niveau_risque
    
    batiments = await db.batiments.find(query).to_list(length=None)
    
    # Pour chaque b√¢timent, d√©terminer le statut d'inspection
    map_data = []
    for bat in batiments:
        # Chercher la derni√®re inspection
        derniere_inspection = await db.inspections_visuelles.find_one(
            {"batiment_id": bat["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        
        # D√©terminer le statut
        if not derniere_inspection:
            statut_insp = "a_faire"
        elif derniere_inspection["statut"] == "en_cours":
            statut_insp = "en_cours"
        elif derniere_inspection["statut_conformite"] == "non_conforme":
            statut_insp = "non_conforme"
        else:
            statut_insp = "fait_conforme"
        
        # Filtrer par statut si demand√©
        if statut_inspection and statut_insp != statut_inspection:
            continue
        
        # G√©ocoder l'adresse si pas d√©j√† fait (latitude/longitude manquants)
        latitude = bat.get("latitude")
        longitude = bat.get("longitude")
        
        map_item = BatimentMapView(
            id=bat["id"],
            nom_etablissement=bat.get("nom_etablissement", ""),
            adresse_civique=bat.get("adresse_civique", ""),
            ville=bat.get("ville", ""),
            latitude=latitude,
            longitude=longitude,
            niveau_risque=bat.get("niveau_risque", ""),
            statut_inspection=statut_insp,
            derniere_inspection=derniere_inspection["date_inspection"] if derniere_inspection else None,
            groupe_occupation=bat.get("groupe_occupation", ""),
            sous_groupe=bat.get("sous_groupe", "")
        )
        
        map_data.append(map_item.dict())
    
    return map_data

@api_router.post("/{tenant_slug}/prevention/geocode")
async def geocode_address(
    tenant_slug: str,
    request: GeocodeRequest,
    current_user: User = Depends(get_current_user)
):
    """G√©ocoder une adresse en latitude/longitude avec Google Maps API"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    try:
        import requests
        import os
        
        api_key = os.getenv("GOOGLE_MAPS_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="Cl√© API Google Maps non configur√©e")
        
        # Appeler l'API Google Geocoding
        url = "https://maps.googleapis.com/maps/api/geocode/json"
        params = {
            "address": request.adresse_complete,
            "key": api_key
        }
        
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        if data["status"] == "OK" and len(data["results"]) > 0:
            result = data["results"][0]
            location = result["geometry"]["location"]
            
            # D√©terminer la pr√©cision
            location_type = result["geometry"]["location_type"]
            if location_type == "ROOFTOP":
                precision = "building"
            elif location_type in ["RANGE_INTERPOLATED", "GEOMETRIC_CENTER"]:
                precision = "street"
            else:
                precision = "city"
            
            return GeocodeResponse(
                latitude=location["lat"],
                longitude=location["lng"],
                adresse_formatee=result["formatted_address"],
                precision=precision
            )
        else:
            raise HTTPException(status_code=404, detail="Adresse non trouv√©e")
    
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du g√©ocodage: {str(e)}")

@api_router.put("/{tenant_slug}/prevention/batiments/{batiment_id}/coordinates")
async def update_batiment_coordinates(
    tenant_slug: str,
    batiment_id: str,
    latitude: float = Body(...),
    longitude: float = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour les coordonn√©es GPS d'un b√¢timent"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {"$set": {
            "latitude": latitude,
            "longitude": longitude,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    return {"message": "Coordonn√©es mises √† jour avec succ√®s"}


# ==================== GESTION DES PR√âVENTIONNISTES ====================

@api_router.put("/{tenant_slug}/users/{user_id}/toggle-preventionniste")
async def toggle_preventionniste(
    tenant_slug: str,
    user_id: str,
    current_user: User = Depends(get_current_user)
):
    """Activer/d√©sactiver le statut de pr√©ventionniste pour un utilisateur (admin uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Seuls les admins et superviseurs peuvent modifier ce statut
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # R√©cup√©rer l'utilisateur
    user = await db.users.find_one({"id": user_id, "tenant_id": tenant.id})
    if not user:
        raise HTTPException(status_code=404, detail="Utilisateur non trouv√©")
    
    # Toggle le statut
    new_status = not user.get('est_preventionniste', False)
    
    await db.users.update_one(
        {"id": user_id, "tenant_id": tenant.id},
        {"$set": {"est_preventionniste": new_status}}
    )
    
    return {
        "message": "Statut de pr√©ventionniste mis √† jour",
        "user_id": user_id,
        "est_preventionniste": new_status
    }


@api_router.get("/{tenant_slug}/prevention/preventionnistes")
async def get_preventionnistes(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer la liste de tous les pr√©ventionnistes actifs"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer tous les utilisateurs avec est_preventionniste = true et statut actif
    preventionnistes_cursor = db.users.find({
        "tenant_id": tenant.id,
        "est_preventionniste": True,
        "statut": "Actif"
    })
    
    preventionnistes = await preventionnistes_cursor.to_list(length=None)
    
    # Pour chaque pr√©ventionniste, ajouter des statistiques
    result = []
    for prev in preventionnistes:
        # Compter les b√¢timents assign√©s
        nb_batiments = await db.batiments.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_assigne_id": prev["id"]
        })
        
        # Compter les secteurs assign√©s
        nb_secteurs = await db.secteurs_geographiques.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_assigne_id": prev["id"]
        })
        
        # Compter les inspections ce mois
        start_of_month = datetime.now(timezone.utc).replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        nb_inspections_mois = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_id": prev["id"],
            "date_inspection": {"$gte": start_of_month.isoformat()}
        })
        
        result.append({
            "id": prev["id"],
            "nom": prev["nom"],
            "prenom": prev["prenom"],
            "email": prev["email"],
            "telephone": prev.get("telephone", ""),
            "grade": prev.get("grade", ""),
            "nb_batiments": nb_batiments,
            "nb_secteurs": nb_secteurs,
            "nb_inspections_mois": nb_inspections_mois
        })
    
    return result


@api_router.get("/{tenant_slug}/prevention/preventionnistes/{preventionniste_id}/stats")
async def get_preventionniste_stats(
    tenant_slug: str,
    preventionniste_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les statistiques d√©taill√©es d'un pr√©ventionniste"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que le pr√©ventionniste existe
    preventionniste = await db.users.find_one({
        "id": preventionniste_id,
        "tenant_id": tenant.id,
        "est_preventionniste": True
    })
    
    if not preventionniste:
        raise HTTPException(status_code=404, detail="Pr√©ventionniste non trouv√©")
    
    # Statistiques globales
    nb_batiments = await db.batiments.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    nb_secteurs = await db.secteurs_geographiques.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    # Inspections par p√©riode
    start_of_month = datetime.now(timezone.utc).replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    start_of_year = datetime.now(timezone.utc).replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
    
    nb_inspections_mois = await db.inspections.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_id": preventionniste_id,
        "date_inspection": {"$gte": start_of_month.isoformat()}
    })
    
    nb_inspections_annee = await db.inspections.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_id": preventionniste_id,
        "date_inspection": {"$gte": start_of_year.isoformat()}
    })
    
    # Plans d'intervention cr√©√©s
    nb_plans = await db.plans_intervention.count_documents({
        "tenant_id": tenant.id,
        "created_by": preventionniste_id
    })
    
    return {
        "preventionniste": {
            "id": preventionniste["id"],
            "nom": preventionniste["nom"],
            "prenom": preventionniste["prenom"],
            "email": preventionniste["email"],
            "telephone": preventionniste.get("telephone", ""),
            "grade": preventionniste.get("grade", "")
        },
        "stats": {
            "nb_batiments": nb_batiments,
            "nb_secteurs": nb_secteurs,
            "nb_inspections_mois": nb_inspections_mois,
            "nb_inspections_annee": nb_inspections_annee,
            "nb_plans": nb_plans
        }
    }


@api_router.get("/{tenant_slug}/prevention/preventionnistes/{preventionniste_id}/batiments")
async def get_preventionniste_batiments(
    tenant_slug: str,
    preventionniste_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer tous les b√¢timents assign√©s √† un pr√©ventionniste"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    batiments_cursor = db.batiments.find({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    batiments = await batiments_cursor.to_list(length=None)
    
    # Nettoyer les ObjectIds pour s√©rialisation JSON
    for batiment in batiments:
        if "_id" in batiment:
            del batiment["_id"]
    
    return batiments


@api_router.get("/{tenant_slug}/prevention/preventionnistes/{preventionniste_id}/secteurs")
async def get_preventionniste_secteurs(
    tenant_slug: str,
    preventionniste_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer tous les secteurs assign√©s √† un pr√©ventionniste"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    secteurs_cursor = db.secteurs_geographiques.find({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": preventionniste_id
    })
    
    secteurs = await secteurs_cursor.to_list(length=None)
    
    # Nettoyer les ObjectIds pour s√©rialisation JSON
    for secteur in secteurs:
        if "_id" in secteur:
            del secteur["_id"]
    
    return secteurs


@api_router.put("/{tenant_slug}/prevention/batiments/{batiment_id}/assigner")
async def assigner_batiment_preventionniste(
    tenant_slug: str,
    batiment_id: str,
    preventionniste_id: Optional[str] = Body(None),
    raison: Optional[str] = Body(""),
    current_user: User = Depends(get_current_user)
):
    """Assigner un pr√©ventionniste √† un b√¢timent (avec historique)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier permissions
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # R√©cup√©rer le b√¢timent
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    # Si preventionniste_id fourni, v√©rifier qu'il existe et est actif
    if preventionniste_id:
        preventionniste = await db.users.find_one({
            "id": preventionniste_id,
            "tenant_id": tenant.id,
            "est_preventionniste": True,
            "statut": "Actif"
        })
        if not preventionniste:
            raise HTTPException(status_code=404, detail="Pr√©ventionniste non trouv√© ou inactif")
    
    # Cr√©er l'entr√©e d'historique
    ancien_preventionniste_id = batiment.get("preventionniste_assigne_id")
    historique_entry = {
        "date": datetime.now(timezone.utc).isoformat(),
        "ancien_preventionniste_id": ancien_preventionniste_id,
        "nouveau_preventionniste_id": preventionniste_id,
        "modifie_par": current_user.id,
        "modifie_par_nom": f"{current_user.prenom} {current_user.nom}",
        "raison": raison
    }
    
    # Mettre √† jour le b√¢timent
    await db.batiments.update_one(
        {"id": batiment_id, "tenant_id": tenant.id},
        {
            "$set": {
                "preventionniste_assigne_id": preventionniste_id,
                "updated_at": datetime.now(timezone.utc)
            },
            "$push": {"historique_assignations": historique_entry}
        }
    )
    
    # Cr√©er notification pour le pr√©ventionniste
    if preventionniste_id:
        notification = {
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "user_id": preventionniste_id,
            "type": "assignation_batiment",
            "titre": "Nouveau b√¢timent assign√©",
            "message": f"Le b√¢timent '{batiment.get('nom_etablissement') or batiment.get('adresse_civique')}' vous a √©t√© assign√©.",
            "lue": False,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "data": {
                "batiment_id": batiment_id,
                "batiment_nom": batiment.get('nom_etablissement') or batiment.get('adresse_civique')
            }
        }
        await db.notifications.insert_one(notification)
    
    return {
        "message": "B√¢timent assign√© avec succ√®s",
        "batiment_id": batiment_id,
        "preventionniste_id": preventionniste_id
    }


@api_router.put("/{tenant_slug}/prevention/secteurs/{secteur_id}/assigner")
async def assigner_secteur_preventionniste(
    tenant_slug: str,
    secteur_id: str,
    preventionniste_id: Optional[str] = Body(None),
    assigner_batiments: bool = Body(True),
    current_user: User = Depends(get_current_user)
):
    """Assigner un pr√©ventionniste √† un secteur (et optionnellement tous ses b√¢timents)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier permissions
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Permissions insuffisantes")
    
    # R√©cup√©rer le secteur
    secteur = await db.secteurs_geographiques.find_one({"id": secteur_id, "tenant_id": tenant.id})
    if not secteur:
        raise HTTPException(status_code=404, detail="Secteur non trouv√©")
    
    # Si preventionniste_id fourni, v√©rifier qu'il existe
    if preventionniste_id:
        preventionniste = await db.users.find_one({
            "id": preventionniste_id,
            "tenant_id": tenant.id,
            "est_preventionniste": True,
            "statut": "Actif"
        })
        if not preventionniste:
            raise HTTPException(status_code=404, detail="Pr√©ventionniste non trouv√© ou inactif")
    
    # Mettre √† jour le secteur
    await db.secteurs_geographiques.update_one(
        {"id": secteur_id, "tenant_id": tenant.id},
        {
            "$set": {
                "preventionniste_assigne_id": preventionniste_id,
                "updated_at": datetime.now(timezone.utc)
            }
        }
    )
    
    nb_batiments_assignes = 0
    
    # Si demand√©, assigner tous les b√¢timents du secteur
    if assigner_batiments:
        # Trouver tous les b√¢timents dans ce secteur (g√©om√©triquement)
        # Pour simplifier, on va assigner tous les b√¢timents sans preventionniste ou avec autre preventionniste
        batiments_cursor = db.batiments.find({
            "tenant_id": tenant.id,
            "latitude": {"$ne": None},
            "longitude": {"$ne": None}
        })
        
        batiments = await batiments_cursor.to_list(length=None)
        
        # Pour chaque b√¢timent, v√©rifier s'il est dans le polygone du secteur
        from shapely.geometry import Point, shape
        
        secteur_polygon = shape(secteur["geometry"])
        
        for batiment in batiments:
            if batiment.get("latitude") and batiment.get("longitude"):
                point = Point(batiment["longitude"], batiment["latitude"])
                
                if secteur_polygon.contains(point):
                    # Cr√©er l'entr√©e d'historique
                    ancien_preventionniste_id = batiment.get("preventionniste_assigne_id")
                    historique_entry = {
                        "date": datetime.now(timezone.utc).isoformat(),
                        "ancien_preventionniste_id": ancien_preventionniste_id,
                        "nouveau_preventionniste_id": preventionniste_id,
                        "modifie_par": current_user.id,
                        "modifie_par_nom": f"{current_user.prenom} {current_user.nom}",
                        "raison": f"Assignation automatique via secteur '{secteur['nom']}'"
                    }
                    
                    # Mettre √† jour le b√¢timent
                    await db.batiments.update_one(
                        {"id": batiment["id"]},
                        {
                            "$set": {
                                "preventionniste_assigne_id": preventionniste_id,
                                "updated_at": datetime.now(timezone.utc)
                            },
                            "$push": {"historique_assignations": historique_entry}
                        }
                    )
                    nb_batiments_assignes += 1
    
    # Cr√©er notification pour le pr√©ventionniste
    if preventionniste_id:
        notification = {
            "id": str(uuid.uuid4()),
            "tenant_id": tenant.id,
            "user_id": preventionniste_id,
            "type": "assignation_secteur",
            "titre": "Nouveau secteur assign√©",
            "message": f"Le secteur '{secteur['nom']}' vous a √©t√© assign√©" + (f" avec {nb_batiments_assignes} b√¢timents." if assigner_batiments else "."),
            "lue": False,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "data": {
                "secteur_id": secteur_id,
                "secteur_nom": secteur['nom'],
                "nb_batiments": nb_batiments_assignes
            }
        }
        await db.notifications.insert_one(notification)
    
    return {
        "message": "Secteur assign√© avec succ√®s",
        "secteur_id": secteur_id,
        "preventionniste_id": preventionniste_id,
        "nb_batiments_assignes": nb_batiments_assignes
    }


# ==================== PARAM√àTRES PR√âVENTION ====================

@api_router.put("/{tenant_slug}/prevention/parametres")
async def update_parametres_prevention(
    tenant_slug: str,
    recurrence_inspections: int = Body(...),
    nombre_visites_requises: int = Body(...),
    superviseur_prevention_id: Optional[str] = Body(None),
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour les param√®tres de pr√©vention (admin uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier permissions (admin seulement)
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Seuls les administrateurs peuvent modifier les param√®tres")
    
    # Valider les valeurs
    if recurrence_inspections not in [1, 2, 3, 4, 5]:
        raise HTTPException(status_code=400, detail="La r√©currence doit √™tre entre 1 et 5 ans")
    
    if nombre_visites_requises not in [1, 2, 3]:
        raise HTTPException(status_code=400, detail="Le nombre de visites doit √™tre entre 1 et 3")
    
    # Si superviseur fourni, v√©rifier qu'il existe
    if superviseur_prevention_id:
        superviseur = await db.users.find_one({
            "id": superviseur_prevention_id,
            "tenant_id": tenant.id
        })
        if not superviseur:
            raise HTTPException(status_code=404, detail="Superviseur non trouv√©")
    
    # Mettre √† jour les param√®tres du tenant
    parametres_update = {
        "parametres.recurrence_inspections": recurrence_inspections,
        "parametres.nombre_visites_requises": nombre_visites_requises,
        "parametres.superviseur_prevention_id": superviseur_prevention_id,
        "updated_at": datetime.now(timezone.utc)
    }
    
    await db.tenants.update_one(
        {"id": tenant.id},
        {"$set": parametres_update}
    )
    
    logging.info(f"Param√®tres pr√©vention mis √† jour pour {tenant_slug} par {current_user.prenom} {current_user.nom}")
    
    return {
        "message": "Param√®tres mis √† jour avec succ√®s",
        "parametres": {
            "recurrence_inspections": recurrence_inspections,
            "nombre_visites_requises": nombre_visites_requises,
            "superviseur_prevention_id": superviseur_prevention_id
        }
    }


# ==================== PLANS D'INTERVENTION ====================

@api_router.post("/{tenant_slug}/prevention/plans-intervention")
async def create_plan_intervention(
    tenant_slug: str,
    plan: PlanInterventionCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un nouveau plan d'intervention (pr√©ventionnistes uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier que l'utilisateur est pr√©ventionniste ou admin
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les pr√©ventionnistes peuvent cr√©er des plans")
    
    # V√©rifier que le b√¢timent existe
    batiment = await db.batiments.find_one({"id": plan.batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    # G√©n√©rer le num√©ro de plan unique
    current_year = datetime.now().year
    count = await db.plans_intervention.count_documents({"tenant_id": tenant.id})
    numero_plan = f"PI-{current_year}-{str(count + 1).zfill(3)}"
    
    plan_dict = plan.dict()
    
    # Debug logs
    import logging
    logger = logging.getLogger(__name__)
    logger.info(f"üì• Layers re√ßus dans plan_dict: {len(plan_dict.get('layers', []))} layers")
    logger.info(f"üì• D√©tails layers re√ßus: {plan_dict.get('layers', [])}")
    
    plan_dict["tenant_id"] = tenant.id
    plan_dict["numero_plan"] = numero_plan
    plan_dict["created_by_id"] = current_user.id
    plan_dict["statut"] = "brouillon"
    
    plan_obj = PlanIntervention(**plan_dict)
    
    logger.info(f"üì§ Layers dans plan_obj apr√®s conversion: {len(plan_obj.layers)} layers")
    
    plan_to_insert = plan_obj.dict()
    logger.info(f"üíæ Layers avant insertion MongoDB: {len(plan_to_insert.get('layers', []))} layers")
    
    await db.plans_intervention.insert_one(plan_to_insert)
    
    # Cr√©er une activit√©
    batiment_nom = batiment.get('nom') or batiment.get('nom_batiment') or batiment.get('adresse_civique') or 'B√¢timent'
    await creer_activite(
        tenant_id=tenant.id,
        type_activite="prevention_plan_creation",
        description=f"üè¢ {current_user.prenom} {current_user.nom} a cr√©√© le plan d'intervention #{numero_plan} pour '{batiment_nom}'",
        user_id=current_user.id,
        user_nom=f"{current_user.prenom} {current_user.nom}"
    )
    
    result = clean_mongo_doc(plan_to_insert)
    logger.info(f"‚úÖ Layers dans r√©sultat final: {len(result.get('layers', []))} layers")
    
    return result

@api_router.get("/{tenant_slug}/prevention/plans-intervention")
async def get_plans_intervention(
    tenant_slug: str,
    batiment_id: Optional[str] = None,
    statut: Optional[str] = None,
    created_by_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer la liste des plans d'intervention avec filtres"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id}
    
    if batiment_id:
        query["batiment_id"] = batiment_id
    if statut:
        query["statut"] = statut
    if created_by_id:
        query["created_by_id"] = created_by_id
    
    plans = await db.plans_intervention.find(query).sort("created_at", -1).to_list(length=None)
    
    return [clean_mongo_doc(plan) for plan in plans]

@api_router.get("/{tenant_slug}/prevention/plans-intervention/{plan_id}")
async def get_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer un plan d'intervention sp√©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    
    if not plan:
        raise HTTPException(status_code=404, detail="Plan d'intervention non trouv√©")
    
    return clean_mongo_doc(plan)

@api_router.put("/{tenant_slug}/prevention/plans-intervention/{plan_id}")
async def update_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    plan_update: PlanInterventionUpdate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour un plan d'intervention (seulement si brouillon ou en_attente)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer le plan existant
    existing = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not existing:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    # V√©rifier que le plan est modifiable
    if existing["statut"] not in ["brouillon", "en_attente_validation", "rejete"]:
        raise HTTPException(status_code=403, detail="Plan valid√© non modifiable - cr√©er une nouvelle version")
    
    # V√©rifier que l'utilisateur est le cr√©ateur ou admin
    if existing["created_by_id"] != current_user.id and current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Seul le cr√©ateur ou un admin peut modifier ce plan")
    
    # Mettre √† jour les champs fournis
    update_dict = {k: v for k, v in plan_update.dict(exclude_unset=True).items() if v is not None}
    
    # Debug logs
    import logging
    logger = logging.getLogger(__name__)
    if 'layers' in update_dict:
        logger.info(f"üì• UPDATE - Layers re√ßus: {len(update_dict.get('layers', []))} layers")
        logger.info(f"üì• UPDATE - D√©tails layers: {update_dict.get('layers', [])}")
    
    update_dict["updated_at"] = datetime.now(timezone.utc)
    update_dict["date_derniere_maj"] = datetime.now(timezone.utc)
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": update_dict}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    updated = await db.plans_intervention.find_one({"id": plan_id})
    
    if updated and 'layers' in updated:
        logger.info(f"‚úÖ UPDATE - Layers dans r√©sultat: {len(updated.get('layers', []))} layers")
    
    return clean_mongo_doc(updated)

@api_router.delete("/{tenant_slug}/prevention/plans-intervention/{plan_id}")
async def delete_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un plan d'intervention (admin uniquement)"""
    if current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Acc√®s refus√© - Admin uniquement")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    result = await db.plans_intervention.delete_one({"id": plan_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    return {"message": "Plan d'intervention supprim√© avec succ√®s"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/valider")
async def soumettre_plan_validation(
    tenant_slug: str,
    plan_id: str,
    request: ValidationRequest,
    current_user: User = Depends(get_current_user)
):
    """Soumettre un plan pour validation (pr√©ventionniste cr√©ateur)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    # V√©rifier que l'utilisateur est le cr√©ateur
    if plan["created_by_id"] != current_user.id and current_user.role not in ["admin"]:
        raise HTTPException(status_code=403, detail="Seul le cr√©ateur peut soumettre le plan")
    
    # V√©rifier que le plan est en brouillon
    if plan["statut"] != "brouillon":
        raise HTTPException(status_code=400, detail="Le plan n'est pas en brouillon")
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "en_attente_validation",
            "commentaires_validation": request.commentaires,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {"message": "Plan soumis pour validation"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/approuver")
async def approuver_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    request: ValidationRequest,
    current_user: User = Depends(get_current_user)
):
    """Approuver un plan d'intervention (admin/superviseur uniquement)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Seuls les admin/superviseurs peuvent approuver")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    if plan["statut"] != "en_attente_validation":
        raise HTTPException(status_code=400, detail="Le plan n'est pas en attente de validation")
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "valide",
            "validated_by_id": current_user.id,
            "date_validation": datetime.now(timezone.utc),
            "commentaires_validation": request.commentaires,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {"message": "Plan d'intervention approuv√©"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/rejeter")
async def rejeter_plan_intervention(
    tenant_slug: str,
    plan_id: str,
    request: RejectionRequest,
    current_user: User = Depends(get_current_user)
):
    """Rejeter un plan d'intervention (admin/superviseur uniquement)"""
    if current_user.role not in ["admin", "superviseur"]:
        raise HTTPException(status_code=403, detail="Seuls les admin/superviseurs peuvent rejeter")
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    if plan["statut"] != "en_attente_validation":
        raise HTTPException(status_code=400, detail="Le plan n'est pas en attente de validation")
    
    result = await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "statut": "rejete",
            "validated_by_id": current_user.id,
            "commentaires_rejet": request.commentaires_rejet,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {"message": "Plan d'intervention rejet√©"}

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/nouvelle-version")
async def creer_nouvelle_version_plan(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle version d'un plan valid√©"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les pr√©ventionnistes peuvent cr√©er des versions")
    
    # R√©cup√©rer le plan existant
    plan_actuel = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan_actuel:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    if plan_actuel["statut"] != "valide":
        raise HTTPException(status_code=400, detail="Seul un plan valid√© peut avoir une nouvelle version")
    
    # Archiver l'ancien plan
    await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {"statut": "archive"}}
    )
    
    # Cr√©er la nouvelle version
    nouveau_plan = plan_actuel.copy()
    nouveau_plan["id"] = str(uuid.uuid4())
    nouveau_plan["version_precedente_id"] = plan_id
    nouveau_plan["statut"] = "brouillon"
    nouveau_plan["created_by_id"] = current_user.id
    nouveau_plan["validated_by_id"] = None
    nouveau_plan["date_validation"] = None
    nouveau_plan["commentaires_validation"] = ""
    nouveau_plan["commentaires_rejet"] = ""
    nouveau_plan["created_at"] = datetime.now(timezone.utc)
    nouveau_plan["updated_at"] = datetime.now(timezone.utc)
    
    # Incr√©menter la version
    version_parts = nouveau_plan["version"].split(".")
    version_parts[-1] = str(int(version_parts[-1]) + 1)
    nouveau_plan["version"] = ".".join(version_parts)
    
    # Supprimer _id MongoDB du dict avant insertion
    if "_id" in nouveau_plan:
        del nouveau_plan["_id"]
    
    await db.plans_intervention.insert_one(nouveau_plan)
    
    return clean_mongo_doc(nouveau_plan)


@api_router.get("/{tenant_slug}/prevention/plans-intervention/{plan_id}/export-pdf")
async def export_plan_intervention_pdf(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """Exporter un plan d'intervention en PDF"""
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image as RLImage, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    from io import BytesIO
    import base64
    from PIL import Image as PILImage
    
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer le plan
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    # R√©cup√©rer le b√¢timent associ√©
    batiment = None
    if plan.get("batiment_id"):
        batiment = await db.batiments.find_one({"id": plan["batiment_id"], "tenant_id": tenant.id})
    
    # Cr√©er le buffer PDF avec branding
    buffer, doc, elements = create_branded_pdf(
        tenant, 
        pagesize=A4, 
        rightMargin=40, 
        leftMargin=40, 
        topMargin=60, 
        bottomMargin=40
    )
    
    # Styles
    styles = getSampleStyleSheet()
    modern_styles = get_modern_pdf_styles(styles)
    heading_style = modern_styles['heading']
    normal_style = styles['Normal']
    
    # En-t√™te avec titre du plan
    elements.append(Paragraph(f"üî• Plan d'Intervention", modern_styles['title']))
    plan_title = plan.get('titre') or plan.get('nom_plan') or f"Plan - {batiment.get('nom_etablissement', 'Sans titre') if batiment else 'Sans titre'}"
    elements.append(Paragraph(f"<b>{plan_title}</b>", heading_style))
    elements.append(Spacer(1, 0.2*inch))
    
    # Informations g√©n√©rales
    info_data = [
        ['Num√©ro de plan:', plan.get('numero_plan', 'N/A')],
        ['Statut:', plan.get('statut', 'brouillon').replace('_', ' ').capitalize()],
        ['Date de cr√©ation:', plan.get('created_at').strftime('%Y-%m-%d') if plan.get('created_at') and hasattr(plan.get('created_at'), 'strftime') else (str(plan.get('created_at', 'N/A'))[:10] if plan.get('created_at') else 'N/A')],
    ]
    
    if plan.get('date_validation'):
        date_val = plan['date_validation']
        if hasattr(date_val, 'strftime'):
            info_data.append(['Date de validation:', date_val.strftime('%Y-%m-%d')])
        elif isinstance(date_val, str):
            info_data.append(['Date de validation:', date_val[:10]])
        else:
            info_data.append(['Date de validation:', 'N/A'])
    
    if batiment:
        info_data.append(['B√¢timent:', f"{batiment.get('nom_etablissement', 'N/A')}"])
        info_data.append(['Adresse compl√®te:', f"{batiment.get('adresse_civique', '')} {batiment.get('ville', '')} {batiment.get('province', '')} {batiment.get('code_postal', '')}".strip() or 'N/A'])
        
        if batiment.get('type_batiment'):
            info_data.append(['Type de b√¢timent:', batiment['type_batiment']])
        if batiment.get('sous_type_batiment'):
            info_data.append(['Sous-type:', batiment['sous_type_batiment']])
        if batiment.get('groupe_occupation'):
            info_data.append(['Groupe d\'occupation:', batiment['groupe_occupation']])
        if batiment.get('sous_groupe'):
            info_data.append(['Sous-groupe:', batiment['sous_groupe']])
        if batiment.get('niveau_risque'):
            info_data.append(['Niveau de risque:', batiment['niveau_risque']])
        if batiment.get('annee_construction'):
            info_data.append(['Ann√©e construction:', batiment['annee_construction']])
        if batiment.get('nombre_etages'):
            info_data.append(['Nombre d\'√©tages:', batiment['nombre_etages']])
        if batiment.get('superficie_totale_m2'):
            info_data.append(['Superficie totale:', f"{batiment['superficie_totale_m2']} m¬≤"])
        if batiment.get('cadastre_matricule'):
            info_data.append(['Cadastre/Matricule:', batiment['cadastre_matricule']])
        if batiment.get('description_activite'):
            info_data.append(['Description activit√©:', batiment['description_activite']])
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F3F4F6')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
    ]))
    elements.append(info_table)
    elements.append(Spacer(1, 0.3*inch))
    
    # Section Contacts (si b√¢timent disponible)
    if batiment:
        has_contacts = False
        contact_data = []
        
        # Propri√©taire
        if batiment.get('proprietaire_nom') or batiment.get('proprietaire_prenom'):
            contact_data.append(['üë§ Propri√©taire:', f"{batiment.get('proprietaire_prenom', '')} {batiment.get('proprietaire_nom', '')}".strip()])
            if batiment.get('proprietaire_telephone'):
                contact_data.append(['T√©l√©phone:', batiment.get('proprietaire_telephone')])
            if batiment.get('proprietaire_courriel'):
                contact_data.append(['Courriel:', batiment.get('proprietaire_courriel')])
            has_contacts = True
        
        # Gestionnaire
        if batiment.get('gestionnaire_nom') or batiment.get('gestionnaire_prenom') or batiment.get('gerant_nom'):
            nom = batiment.get('gestionnaire_nom') or batiment.get('gerant_nom', '')
            prenom = batiment.get('gestionnaire_prenom', '')
            contact_data.append(['üë®‚Äçüíº Gestionnaire:', f"{prenom} {nom}".strip()])
            tel = batiment.get('gestionnaire_telephone') or batiment.get('gerant_telephone')
            if tel:
                contact_data.append(['T√©l√©phone:', tel])
            email = batiment.get('gestionnaire_courriel') or batiment.get('gerant_courriel')
            if email:
                contact_data.append(['Courriel:', email])
            has_contacts = True
        
        # Locataire
        if batiment.get('locataire_nom') or batiment.get('locataire_prenom') or batiment.get('localaire_nom'):
            nom = batiment.get('locataire_nom') or batiment.get('localaire_nom', '')
            prenom = batiment.get('locataire_prenom') or batiment.get('localaire_prenom', '')
            contact_data.append(['üè† Locataire:', f"{prenom} {nom}".strip()])
            tel = batiment.get('locataire_telephone') or batiment.get('localaire_telephone')
            if tel:
                contact_data.append(['T√©l√©phone:', tel])
            email = batiment.get('locataire_courriel') or batiment.get('localaire_courriel')
            if email:
                contact_data.append(['Courriel:', email])
            has_contacts = True
        
        # Responsable s√©curit√©
        if batiment.get('responsable_securite_nom'):
            contact_data.append(['üîí Responsable s√©curit√©:', batiment.get('responsable_securite_nom')])
            if batiment.get('responsable_securite_telephone'):
                contact_data.append(['T√©l√©phone:', batiment.get('responsable_securite_telephone')])
            if batiment.get('responsable_securite_courriel'):
                contact_data.append(['Courriel:', batiment.get('responsable_securite_courriel')])
            has_contacts = True
        
        if has_contacts:
            elements.append(Paragraph("<b>üìû Contacts</b>", heading_style))
            contact_table = Table(contact_data, colWidths=[2*inch, 4*inch])
            contact_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F3F4F6')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ]))
            elements.append(contact_table)
            elements.append(Spacer(1, 0.3*inch))
    
    # Description
    description = plan.get('description') or plan.get('notes_generales')
    if description:
        elements.append(Paragraph("<b>üìã Description</b>", heading_style))
        elements.append(Paragraph(description, normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Notes Tactiques
    notes_tactiques = plan.get('notes_tactiques') or plan.get('instructions_particulieres')
    if notes_tactiques:
        elements.append(Paragraph("<b>‚ö†Ô∏è Notes Tactiques</b>", heading_style))
        elements.append(Paragraph(notes_tactiques, normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Section Carte et L√©gendes (affichage visuel des symboles)
    layers = plan.get('layers', [])
    if layers and len(layers) > 0:
        elements.append(PageBreak())
        elements.append(Paragraph("<b>üó∫Ô∏è Carte et L√©gendes</b>", title_style))
        elements.append(Spacer(1, 0.2*inch))
        
        # Informations de la carte
        carte_info = f"""
        <b>Centre de la carte:</b><br/>
        Latitude: {plan.get('centre_lat', 'N/A')}<br/>
        Longitude: {plan.get('centre_lng', 'N/A')}<br/>
        <br/>
        <b>√âl√©ments plac√©s sur la carte:</b> {len(layers)} symbole(s)
        """
        elements.append(Paragraph(carte_info, normal_style))
        elements.append(Spacer(1, 0.2*inch))
        
        # Image de la carte (si disponible)
        carte_image = plan.get('carte_image')
        if carte_image:
            try:
                # D√©coder l'image base64
                if carte_image.startswith('data:image'):
                    image_data = carte_image.split(',')[1]
                    image_bytes = base64.b64decode(image_data)
                    
                    # Cr√©er une image PIL pour optimiser
                    img = PILImage.open(BytesIO(image_bytes))
                    if img.mode in ('RGBA', 'LA', 'P'):
                        img = img.convert('RGB')
                    
                    # Redimensionner pour le PDF (largeur max 6.5 inches)
                    max_width = 6.5 * inch
                    aspect_ratio = img.height / img.width
                    img_width = max_width
                    img_height = img_width * aspect_ratio
                    
                    # Limiter la hauteur maximale √† 4 inches
                    if img_height > 4 * inch:
                        img_height = 4 * inch
                        img_width = img_height / aspect_ratio
                    
                    # Compresser l'image
                    img_buffer = BytesIO()
                    img.save(img_buffer, format='JPEG', quality=80, optimize=True)
                    img_buffer.seek(0)
                    
                    # Cr√©er l'image ReportLab
                    carte_rl_image = RLImage(img_buffer, width=img_width, height=img_height)
                    
                    # Centrer l'image
                    elements.append(Paragraph("<b>üìç Vue de la Carte</b>", heading_style))
                    elements.append(Spacer(1, 0.1*inch))
                    elements.append(carte_rl_image)
                    elements.append(Spacer(1, 0.3*inch))
            except Exception as e:
                print(f"Erreur lors de l'ajout de l'image de la carte: {e}")
                elements.append(Paragraph("<i>Erreur lors du chargement de l'image de la carte</i>", normal_style))
                elements.append(Spacer(1, 0.2*inch))
        else:
            elements.append(Paragraph("<i>üí° Astuce: L'image de la carte sera captur√©e automatiquement √† la prochaine sauvegarde du plan.</i>", normal_style))
            elements.append(Spacer(1, 0.3*inch))
        
        # L√©gendes des symboles avec ic√¥nes
        elements.append(Paragraph("<b>üìå L√©gende des Symboles</b>", heading_style))
        elements.append(Spacer(1, 0.1*inch))
        
        # Grouper les symboles par type pour √©viter les r√©p√©titions
        symbol_types = {}
        for layer in layers:
            if layer.get('type') == 'symbol':
                props = layer.get('properties', {})
                label = props.get('label', 'Symbole')
                if label not in symbol_types:
                    symbol_types[label] = {
                        'symbol': props.get('symbol', 'üìç'),
                        'image': props.get('image'),
                        'color': props.get('color', '#6B7280'),
                        'count': 0
                    }
                symbol_types[label]['count'] += 1
        
        # Cr√©er un tableau de l√©gendes avec ic√¥nes
        legend_data = [['Ic√¥ne', 'Type', 'Quantit√©']]
        for label, info in symbol_types.items():
            # Si c'est une image, essayer de l'afficher
            if info['image']:
                try:
                    # D√©coder l'image base64
                    if info['image'].startswith('data:image'):
                        image_data = info['image'].split(',')[1]
                        image_bytes = base64.b64decode(image_data)
                        
                        # Cr√©er une image PIL
                        img = PILImage.open(BytesIO(image_bytes))
                        if img.mode in ('RGBA', 'LA', 'P'):
                            img = img.convert('RGB')
                        
                        # Redimensionner pour la l√©gende
                        img.thumbnail((24, 24))
                        img_buffer = BytesIO()
                        img.save(img_buffer, format='PNG')
                        img_buffer.seek(0)
                        
                        # Cr√©er une image ReportLab
                        icon_display = RLImage(img_buffer, width=24, height=24)
                        legend_data.append([icon_display, label, f"{info['count']}x"])
                    else:
                        legend_data.append([Paragraph(info['symbol'], normal_style), label, f"{info['count']}x"])
                except Exception as e:
                    print(f"Erreur affichage ic√¥ne: {e}")
                    legend_data.append([Paragraph(info['symbol'], normal_style), label, f"{info['count']}x"])
            else:
                # Afficher l'emoji
                legend_data.append([Paragraph(info['symbol'], normal_style), label, f"{info['count']}x"])
        
        legend_table = Table(legend_data, colWidths=[0.8*inch, 3*inch, 1*inch])
        legend_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3B82F6')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F3F4F6')])
        ]))
        elements.append(legend_table)
        elements.append(Spacer(1, 0.4*inch))
    
    # Points d'acc√®s
    points_acces = plan.get('points_acces', [])
    if points_acces and len(points_acces) > 0:
        elements.append(Paragraph(f"<b>üìç Points d'Acc√®s ({len(points_acces)})</b>", heading_style))
        for idx, point in enumerate(points_acces, 1):
            elements.append(Paragraph(f"{idx}. {point.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    else:
        elements.append(Paragraph("<b>üìç Points d'Acc√®s</b>", heading_style))
        elements.append(Paragraph("Aucun point d'acc√®s d√©fini", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Zones dangereuses
    zones_danger = plan.get('zones_dangereuses', []) or plan.get('zones_danger', [])
    if zones_danger and len(zones_danger) > 0:
        elements.append(Paragraph(f"<b>‚ö†Ô∏è Zones Dangereuses ({len(zones_danger)})</b>", heading_style))
        for idx, zone in enumerate(zones_danger, 1):
            elements.append(Paragraph(f"{idx}. {zone.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    else:
        elements.append(Paragraph("<b>‚ö†Ô∏è Zones Dangereuses</b>", heading_style))
        elements.append(Paragraph("Aucune zone dangereuse identifi√©e", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # √âquipements
    equipements = plan.get('equipements', [])
    if equipements and len(equipements) > 0:
        elements.append(Paragraph(f"<b>üîß √âquipements ({len(equipements)})</b>", heading_style))
        for idx, equip in enumerate(equipements, 1):
            elements.append(Paragraph(f"{idx}. {equip.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    else:
        elements.append(Paragraph("<b>üîß √âquipements</b>", heading_style))
        elements.append(Paragraph("Aucun √©quipement sp√©cifique", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Risques identifi√©s
    risques = plan.get('risques_identifies', [])
    if risques and len(risques) > 0:
        elements.append(Paragraph(f"<b>üî• Risques Identifi√©s ({len(risques)})</b>", heading_style))
        for idx, risque in enumerate(risques, 1):
            elements.append(Paragraph(f"{idx}. {risque.get('description', 'N/A')}", normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Commentaires de validation
    if plan.get('commentaires_validation'):
        elements.append(Paragraph("<b>‚úÖ Commentaires de Validation</b>", heading_style))
        elements.append(Paragraph(plan['commentaires_validation'], normal_style))
        elements.append(Spacer(1, 0.2*inch))
    
    # Galerie Photos (nouvelle section)
    photos = plan.get('photos', [])
    if photos and len(photos) > 0:
        try:
            elements.append(PageBreak())
            elements.append(Paragraph(f"<b>üì∑ Galerie Photos ({len(photos)})</b>", title_style))
            elements.append(Spacer(1, 0.3*inch))
        except Exception as e:
            print(f"Erreur lors de l'ajout du titre galerie photos: {e}")
        
        for idx, photo in enumerate(photos, 1):
            try:
                # En-t√™te de la photo
                photo_title = photo.get('titre', f'Photo {idx}')
                elements.append(Paragraph(f"<b>{idx}. {photo_title}</b>", heading_style))
                
                # Informations de la photo
                photo_info = []
                if photo.get('categorie'):
                    categorie_labels = {
                        'facade': 'üè¢ Fa√ßade',
                        'entree': 'üö™ Entr√©e',
                        'systeme_alarme': "üö® Syst√®me d'alarme",
                        'points_eau': "üíß Points d'eau",
                        'risques': '‚ö†Ô∏è Risques',
                        'autre': 'üì∑ Autre'
                    }
                    categorie = categorie_labels.get(photo.get('categorie'), photo.get('categorie'))
                    photo_info.append(f"<b>Cat√©gorie:</b> {categorie}")
                
                if photo.get('localisation'):
                    photo_info.append(f"<b>Localisation:</b> {photo.get('localisation')}")
                
                if photo.get('description'):
                    photo_info.append(f"<b>Description:</b> {photo.get('description')}")
                
                if photo_info:
                    info_text = ' | '.join(photo_info)
                    elements.append(Paragraph(info_text, normal_style))
                    elements.append(Spacer(1, 0.1*inch))
                
                # Image (si disponible)
                if photo.get('url'):
                    try:
                        # G√©rer les images base64
                        if photo['url'].startswith('data:image'):
                            # Extraire les donn√©es base64
                            image_data = photo['url'].split(',')[1]
                            image_bytes = base64.b64decode(image_data)
                            
                            # Ouvrir l'image avec PIL pour la compresser
                            img = PILImage.open(BytesIO(image_bytes))
                            
                            # Convertir en RGB si n√©cessaire
                            if img.mode in ('RGBA', 'LA', 'P'):
                                img = img.convert('RGB')
                            
                            # Compresser l'image (qualit√© optimis√©e 70-80%)
                            img_buffer = BytesIO()
                            img.save(img_buffer, format='JPEG', quality=75, optimize=True)
                            img_buffer.seek(0)
                            
                            # Cr√©er l'image ReportLab avec une largeur maximale de 5 inches
                            rl_image = RLImage(img_buffer, width=5*inch, height=3.5*inch, kind='proportional')
                            elements.append(rl_image)
                    except Exception as img_error:
                        print(f"Erreur chargement image {idx}: {img_error}")
                        elements.append(Paragraph(f"<i>Image non disponible</i>", normal_style))
                
                elements.append(Spacer(1, 0.4*inch))
                
                # Saut de page apr√®s 2 photos pour √©viter la surcharge
                if idx % 2 == 0 and idx < len(photos):
                    elements.append(PageBreak())
                    
            except Exception as e:
                print(f"Erreur traitement photo {idx}: {e}")
                elements.append(Paragraph(f"<i>Erreur lors du traitement de la photo {idx}</i>", normal_style))
                elements.append(Spacer(1, 0.2*inch))
    
    # Pied de page
    elements.append(Spacer(1, 0.5*inch))
    footer_style = ParagraphStyle(
        'Footer',
        parent=styles['Normal'],
        fontSize=8,
        textColor=colors.grey,
        alignment=TA_CENTER
    )
    elements.append(Paragraph(f"<i>Document g√©n√©r√© le {datetime.now(timezone.utc).strftime('%d/%m/%Y √† %H:%M')} - {tenant.nom}</i>", footer_style))
    
    # Construire le PDF
    doc.build(elements)
    
    # Retourner le PDF
    buffer.seek(0)
    
    # G√©n√©rer un nom de fichier avec le nom du b√¢timent ou l'adresse
    print(f"DEBUG - batiment: {batiment}")
    if batiment:
        print(f"DEBUG - batiment keys: {batiment.keys()}")
        batiment_info = batiment.get('nom') or batiment.get('nom_batiment') or batiment.get('adresse_civique') or batiment.get('adresse') or 'batiment'
    else:
        batiment_info = 'batiment'
    
    print(f"DEBUG - batiment_info: {batiment_info}")
    
    # Nettoyer le nom pour le rendre compatible avec les noms de fichiers
    batiment_safe = batiment_info.replace(' ', '_').replace('/', '-').replace('\\', '-').replace(',', '')
    numero_plan = plan.get('numero_plan', plan_id[:8])
    filename = f"plan_intervention_{numero_plan}_{batiment_safe}.pdf"
    
    print(f"DEBUG - filename g√©n√©r√©: {filename}")
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/pdf",
        headers={"Content-Disposition": f'attachment; filename="{filename}"'}
    )

@api_router.get("/{tenant_slug}/prevention/plans-intervention/{plan_id}/versions")
async def get_versions_plan(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer l'historique des versions d'un plan"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Trouver toutes les versions li√©es
    versions = []
    
    # Chercher la version actuelle
    plan_actuel = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan_actuel:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    versions.append(clean_mongo_doc(plan_actuel))
    
    # Chercher les versions pr√©c√©dentes
    version_precedente_id = plan_actuel.get("version_precedente_id")
    while version_precedente_id:
        plan_prec = await db.plans_intervention.find_one({"id": version_precedente_id, "tenant_id": tenant.id})
        if plan_prec:
            versions.append(clean_mongo_doc(plan_prec))
            version_precedente_id = plan_prec.get("version_precedente_id")
        else:
            break
    
    # Chercher les versions suivantes
    versions_suivantes = await db.plans_intervention.find({
        "version_precedente_id": plan_id,
        "tenant_id": tenant.id
    }).to_list(length=None)
    
    for v in versions_suivantes:
        versions.append(clean_mongo_doc(v))
    
    return sorted(versions, key=lambda x: x["version"], reverse=True)

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/calculer-distance")
async def calculer_distance_caserne(
    tenant_slug: str,
    plan_id: str,
    caserne_lat: float = Body(...),
    caserne_lng: float = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Calculer la distance entre la caserne et le b√¢timent"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    # Calculer la distance en utilisant l'API Google Distance Matrix
    try:
        import requests
        import os
        
        api_key = os.getenv("GOOGLE_MAPS_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="Cl√© API Google Maps non configur√©e")
        
        url = "https://maps.googleapis.com/maps/api/distancematrix/json"
        params = {
            "origins": f"{caserne_lat},{caserne_lng}",
            "destinations": f"{plan['centre_lat']},{plan['centre_lng']}",
            "key": api_key,
            "mode": "driving"
        }
        
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        if data["status"] == "OK" and len(data["rows"]) > 0:
            element = data["rows"][0]["elements"][0]
            if element["status"] == "OK":
                distance_m = element["distance"]["value"]
                duree_s = element["duration"]["value"]
                
                distance_km = distance_m / 1000.0
                temps_minutes = duree_s // 60
                
                # Mettre √† jour le plan
                await db.plans_intervention.update_one(
                    {"id": plan_id, "tenant_id": tenant.id},
                    {"$set": {
                        "distance_caserne_km": distance_km,
                        "distance_caserne_unite": "km",
                        "temps_acces_minutes": temps_minutes,
                        "updated_at": datetime.now(timezone.utc)
                    }}
                )
                
                return {
                    "distance_km": distance_km,
                    "distance_m": distance_m,
                    "temps_acces_minutes": temps_minutes,
                    "message": "Distance calcul√©e avec succ√®s"
                }
        
        raise HTTPException(status_code=404, detail="Impossible de calculer la distance")
    
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du calcul de distance: {str(e)}")

@api_router.post("/{tenant_slug}/prevention/plans-intervention/{plan_id}/generer-pdf")
async def generer_pdf_plan(
    tenant_slug: str,
    plan_id: str,
    current_user: User = Depends(get_current_user)
):
    """G√©n√©rer le PDF d'un plan d'intervention"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    plan = await db.plans_intervention.find_one({"id": plan_id, "tenant_id": tenant.id})
    if not plan:
        raise HTTPException(status_code=404, detail="Plan non trouv√©")
    
    # TODO: Impl√©menter la g√©n√©ration PDF compl√®te avec ReportLab/WeasyPrint
    # Pour l'instant, retourner un placeholder
    
    pdf_url = f"/api/{tenant_slug}/prevention/plans-intervention/{plan_id}/pdf"
    
    await db.plans_intervention.update_one(
        {"id": plan_id, "tenant_id": tenant.id},
        {"$set": {
            "pdf_url": pdf_url,
            "updated_at": datetime.now(timezone.utc)
        }}
    )
    
    return {
        "pdf_url": pdf_url,
        "message": "G√©n√©ration PDF programm√©e (fonctionnalit√© √† compl√©ter)"
    }


# ==================== TEMPLATES PLANS D'INTERVENTION ====================

@api_router.get("/{tenant_slug}/prevention/plans-intervention/templates")
async def get_templates_plans(
    tenant_slug: str,
    type_batiment: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les templates de plans d'intervention"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    query = {"tenant_id": tenant.id, "actif": True}
    
    if type_batiment:
        query["type_batiment"] = type_batiment
    
    templates = await db.templates_plans_intervention.find(query).to_list(length=None)
    
    return [clean_mongo_doc(t) for t in templates]

@api_router.post("/{tenant_slug}/prevention/plans-intervention/from-template/{template_id}")
async def creer_plan_depuis_template(
    tenant_slug: str,
    template_id: str,
    batiment_id: str = Body(...),
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un nouveau plan √† partir d'un template"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # V√©rifier permissions
    if current_user.role not in ["admin", "superviseur"] and current_user.type_emploi != "preventionniste":
        raise HTTPException(status_code=403, detail="Seuls les pr√©ventionnistes peuvent cr√©er des plans")
    
    # R√©cup√©rer le template
    template = await db.templates_plans_intervention.find_one({"id": template_id, "tenant_id": tenant.id})
    if not template:
        raise HTTPException(status_code=404, detail="Template non trouv√©")
    
    # V√©rifier que le b√¢timent existe
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    # Cr√©er le plan bas√© sur le template
    current_year = datetime.now().year
    count = await db.plans_intervention.count_documents({"tenant_id": tenant.id})
    numero_plan = f"PI-{current_year}-{str(count + 1).zfill(3)}"
    
    # Utiliser les coordonn√©es du b√¢timent si disponibles
    centre_lat = batiment.get("latitude", 45.5017)  # Default Montreal
    centre_lng = batiment.get("longitude", -73.5673)
    
    nouveau_plan = PlanIntervention(
        tenant_id=tenant.id,
        batiment_id=batiment_id,
        numero_plan=numero_plan,
        nom=f"Plan {batiment.get('nom_etablissement', '')}",
        created_by_id=current_user.id,
        centre_lat=centre_lat,
        centre_lng=centre_lng,
        notes_generales=template.get("instructions_utilisation", "")
    )
    
    # Appliquer les √©l√©ments par d√©faut du template
    # TODO: Adapter les positions relatives du template aux coordonn√©es du b√¢timent
    
    await db.plans_intervention.insert_one(nouveau_plan.dict())
    
    return clean_mongo_doc(nouveau_plan.dict())


# ==================== STATISTIQUES PR√âVENTION ====================

@api_router.get("/{tenant_slug}/prevention/statistiques")
async def get_prevention_statistics(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les statistiques du module pr√©vention"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Compter les b√¢timents
    total_batiments = await db.batiments.count_documents({"tenant_id": tenant.id})
    batiments_avec_preventionniste = await db.batiments.count_documents({
        "tenant_id": tenant.id,
        "preventionniste_assigne_id": {"$exists": True, "$ne": None}
    })
    
    # Compter les inspections
    total_inspections = await db.inspections.count_documents({"tenant_id": tenant.id})
    inspections_conformes = await db.inspections.count_documents({
        "tenant_id": tenant.id,
        "statut_global": "conforme"
    })
    
    # Compter les non-conformit√©s
    total_non_conformites = await db.non_conformites.count_documents({"tenant_id": tenant.id})
    nc_ouvertes = await db.non_conformites.count_documents({
        "tenant_id": tenant.id,
        "statut": {"$in": ["ouverte", "en_cours"]}
    })
    nc_corrigees = await db.non_conformites.count_documents({
        "tenant_id": tenant.id,
        "statut": {"$in": ["corrigee", "fermee"]}
    })
    
    # R√©cup√©rer les pr√©ventionnistes actifs
    preventionnistes = await db.users.find({
        "tenant_slug": tenant.slug,
        "role": {"$in": ["admin", "superviseur"]}
    }).to_list(100)
    
    preventionnistes_stats = []
    for prev in preventionnistes:
        batiments_assignes = await db.batiments.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_assigne_id": prev["id"]
        })
        inspections_realisees = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "preventionniste_id": prev["id"]
        })
        
        preventionnistes_stats.append({
            "id": prev["id"],
            "nom": f"{prev.get('prenom', '')} {prev.get('nom', '')}",
            "batiments_assignes": batiments_assignes,
            "inspections_realisees": inspections_realisees
        })
    
    return {
        "batiments": {
            "total": total_batiments,
            "avec_preventionniste": batiments_avec_preventionniste,
            "sans_preventionniste": total_batiments - batiments_avec_preventionniste
        },
        "inspections": {
            "total": total_inspections,
            "conformes": inspections_conformes,
            "non_conformes": total_inspections - inspections_conformes,
            "taux_conformite": round((inspections_conformes / total_inspections * 100) if total_inspections > 0 else 100, 1)
        },
        "non_conformites": {
            "total": total_non_conformites,
            "ouvertes": nc_ouvertes,
            "corrigees": nc_corrigees,
            "taux_resolution": round((nc_corrigees / total_non_conformites * 100) if total_non_conformites > 0 else 100, 1)
        },
        "preventionnistes": preventionnistes_stats
    }


# ==================== RAPPORT B√ÇTIMENT PDF ====================

@api_router.get("/{tenant_slug}/prevention/batiments/{batiment_id}/rapport-pdf")
async def export_rapport_batiment_pdf(
    tenant_slug: str,
    batiment_id: str,
    current_user: User = Depends(get_current_user)
):
    """G√©n√©rer un rapport complet PDF pour un b√¢timent"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # R√©cup√©rer le b√¢timent
    batiment = await db.batiments.find_one({"id": batiment_id, "tenant_id": tenant.id})
    if not batiment:
        raise HTTPException(status_code=404, detail="B√¢timent non trouv√©")
    
    # R√©cup√©rer les inspections du b√¢timent
    inspections_cursor = db.inspections.find({
        "tenant_id": tenant.id,
        "batiment_id": batiment_id
    }).sort("date_inspection", -1)
    inspections = await inspections_cursor.to_list(length=None)
    
    # R√©cup√©rer le plan d'intervention valid√©
    plan = await db.plans_intervention.find_one({
        "tenant_id": tenant.id,
        "batiment_id": batiment_id,
        "statut": "valide"
    })
    
    # R√©cup√©rer le pr√©ventionniste assign√©
    preventionniste = None
    if batiment.get("preventionniste_assigne_id"):
        preventionniste = await db.users.find_one({
            "id": batiment["preventionniste_assigne_id"],
            "tenant_id": tenant.id
        })
    
    # Cr√©er le PDF
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image as RLImage, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    import io
    from PIL import Image as PILImage
    import base64
    
    buffer, doc, story = create_branded_pdf(
        tenant, 
        pagesize=letter, 
        topMargin=0.5*inch, 
        bottomMargin=0.5*inch
    )
    styles = getSampleStyleSheet()
    
    # Style personnalis√©
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        textColor=colors.HexColor('#1a1a1a'),
        spaceAfter=12,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#2563eb'),
        spaceAfter=10,
        spaceBefore=15
    )
    
    # Titre principal
    story.append(Paragraph(f"RAPPORT DE PR√âVENTION", title_style))
    story.append(Paragraph(f"{batiment.get('nom_etablissement') or batiment.get('adresse_civique')}", styles['Heading2']))
    story.append(Spacer(1, 0.3*inch))
    
    # Section A : Informations du B√¢timent
    story.append(Paragraph("üìã INFORMATIONS DU B√ÇTIMENT", heading_style))
    
    info_data = [
        ["Adresse", f"{batiment.get('adresse_civique', '')}, {batiment.get('ville', '')}, {batiment.get('province', 'QC')}"],
        ["Type de b√¢timent", batiment.get('type_batiment', 'N/A')],
        ["Cat√©gorie", batiment.get('categorie', 'N/A')],
        ["Niveau de risque", batiment.get('niveau_risque', 'N/A')],
        ["Nombre d'occupants", str(batiment.get('nombre_occupants', 'N/A'))],
        ["Valeur fonci√®re", f"{batiment.get('valeur_fonciere', 0):,.2f} $" if batiment.get('valeur_fonciere') else 'N/A'],
        ["Pr√©ventionniste assign√©", f"{preventionniste['prenom']} {preventionniste['nom']}" if preventionniste else "Non assign√©"]
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4.5*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f3f4f6')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)
    ]))
    story.append(info_table)
    story.append(Spacer(1, 0.2*inch))
    
    # Photo du b√¢timent si disponible
    if batiment.get('photo_url'):
        try:
            photo_data = batiment['photo_url']
            if photo_data.startswith('data:image'):
                photo_data = photo_data.split(',')[1]
            
            img_data = base64.b64decode(photo_data)
            img = PILImage.open(io.BytesIO(img_data))
            
            # Redimensionner
            max_width = 4 * inch
            max_height = 3 * inch
            img.thumbnail((int(max_width * 2), int(max_height * 2)), PILImage.Resampling.LANCZOS)
            
            img_buffer = io.BytesIO()
            img.save(img_buffer, format='JPEG', quality=85)
            img_buffer.seek(0)
            
            rl_img = RLImage(img_buffer, width=max_width, height=max_height)
            story.append(rl_img)
            story.append(Spacer(1, 0.2*inch))
        except Exception as e:
            print(f"Erreur chargement photo: {e}")
    
    # Section B : Historique des Inspections
    story.append(Paragraph("üìú HISTORIQUE DES INSPECTIONS", heading_style))
    
    if inspections:
        insp_data = [["Date", "Statut", "Non-conformit√©s", "Inspecteur"]]
        
        for insp in inspections[:10]:  # Limiter √† 10 derni√®res
            date_str = insp.get('date_inspection', 'N/A')
            if isinstance(date_str, str):
                try:
                    date_obj = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    date_str = date_obj.strftime('%Y-%m-%d')
                except:
                    pass
            
            statut = insp.get('statut_conformite', 'N/A')
            nb_nc = len(insp.get('non_conformites', []))
            inspecteur = insp.get('inspecteur_nom', 'N/A')
            
            insp_data.append([date_str, statut, str(nb_nc), inspecteur])
        
        insp_table = Table(insp_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 2*inch])
        insp_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2563eb')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f9fafb')])
        ]))
        story.append(insp_table)
        
        # Statistiques
        story.append(Spacer(1, 0.15*inch))
        conformes = len([i for i in inspections if i.get('statut_conformite') == 'Conforme'])
        taux = (conformes / len(inspections) * 100) if inspections else 0
        
        stats_text = f"<b>Statistiques :</b> {len(inspections)} inspections | Taux de conformit√© : {taux:.1f}%"
        story.append(Paragraph(stats_text, styles['Normal']))
    else:
        story.append(Paragraph("Aucune inspection enregistr√©e pour ce b√¢timent.", styles['Normal']))
    
    story.append(Spacer(1, 0.2*inch))
    
    # Section C : Plan d'Intervention
    story.append(Paragraph("üó∫Ô∏è PLAN D'INTERVENTION", heading_style))
    
    if plan:
        plan_text = f"Plan valid√© : <b>{plan.get('numero_plan', 'N/A')}</b><br/>"
        plan_text += f"Points d'acc√®s : {len(plan.get('points_acces', []))}<br/>"
        plan_text += f"Zones dangereuses : {len(plan.get('zones_dangereuses', []))}<br/>"
        plan_text += f"√âquipements : {len(plan.get('equipements_disponibles', []))}"
        story.append(Paragraph(plan_text, styles['Normal']))
    else:
        story.append(Paragraph("Aucun plan d'intervention valid√©.", styles['Normal']))
    
    story.append(Spacer(1, 0.2*inch))
    
    # Section D : Recommandations
    story.append(Paragraph("üí° RECOMMANDATIONS", heading_style))
    
    recommandations = []
    
    # Analyse des derni√®res inspections
    if inspections:
        derniere_insp = inspections[0]
        date_derniere = derniere_insp.get('date_inspection')
        if date_derniere:
            try:
                date_obj = datetime.fromisoformat(date_derniere.replace('Z', '+00:00'))
                jours_depuis = (datetime.now(timezone.utc) - date_obj).days
                
                if jours_depuis > 365:
                    recommandations.append(f"‚ö†Ô∏è Derni√®re inspection il y a {jours_depuis} jours - Pr√©voir une nouvelle inspection")
            except:
                pass
        
        if derniere_insp.get('statut_conformite') == 'Non conforme':
            nb_nc = len(derniere_insp.get('non_conformites', []))
            recommandations.append(f"üî¥ {nb_nc} non-conformit√©(s) √† corriger en priorit√©")
    
    if not plan:
        recommandations.append("üìã Cr√©er un plan d'intervention pour ce b√¢timent")
    
    if batiment.get('niveau_risque') in ['√âlev√©', 'Tr√®s √©lev√©'] and not preventionniste:
        recommandations.append("üë§ Assigner un pr√©ventionniste pour le suivi r√©gulier")
    
    if not recommandations:
        recommandations.append("‚úÖ B√¢timent en bon √©tat, poursuivre le suivi r√©gulier")
    
    for reco in recommandations:
        story.append(Paragraph(f"‚Ä¢ {reco}", styles['Normal']))
    
    # Footer
    story.append(Spacer(1, 0.3*inch))
    footer_text = f"<i>Rapport g√©n√©r√© le {datetime.now().strftime('%Y-%m-%d %H:%M')} par {current_user.prenom} {current_user.nom}</i>"
    story.append(Paragraph(footer_text, styles['Normal']))
    
    # Construire le PDF
    doc.build(story)
    buffer.seek(0)
    
    # Nom du fichier
    filename = f"rapport_{batiment.get('nom_etablissement', 'batiment').replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.pdf"
    
    return Response(
        content=buffer.getvalue(),
        media_type="application/pdf",
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )


# ==================== EXPORT EXCEL ====================

@api_router.get("/{tenant_slug}/prevention/export-excel")
async def export_excel_prevention(
    tenant_slug: str,
    type_export: str = "inspections",  # inspections, batiments, non_conformites
    current_user: User = Depends(get_current_user)
):
    """Exporter les donn√©es en Excel"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    try:
        from io import BytesIO
        import openpyxl
        from openpyxl.styles import Font, PatternFill, Alignment
        
        wb = openpyxl.Workbook()
        ws = wb.active
        
        if type_export == "inspections":
            ws.title = "Inspections"
            
            # En-t√™tes
            headers = ["Date", "B√¢timent", "Pr√©ventionniste", "Type", "Statut", "Score (%)", "Non-conformit√©s"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True, color="FFFFFF")
                cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
                cell.alignment = Alignment(horizontal="center")
            
            # Donn√©es
            inspections = await db.inspections.find({"tenant_id": tenant.id}).to_list(10000)
            batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
            users = await db.users.find({"tenant_slug": tenant.slug}).to_list(10000)
            
            batiments_dict = {b["id"]: b for b in batiments}
            users_dict = {u["id"]: u for u in users}
            
            for idx, insp in enumerate(inspections, 2):
                batiment = batiments_dict.get(insp.get("batiment_id"), {})
                preventionniste = users_dict.get(insp.get("preventionniste_id"), {})
                
                nc_count = await db.non_conformites.count_documents({
                    "inspection_id": insp["id"],
                    "tenant_id": tenant.id
                })
                
                ws.cell(row=idx, column=1, value=insp.get("date_inspection", ""))
                ws.cell(row=idx, column=2, value=batiment.get("nom_etablissement", ""))
                ws.cell(row=idx, column=3, value=f"{preventionniste.get('prenom', '')} {preventionniste.get('nom', '')}")
                ws.cell(row=idx, column=4, value=insp.get("type_inspection", ""))
                ws.cell(row=idx, column=5, value=insp.get("statut_global", ""))
                ws.cell(row=idx, column=6, value=insp.get("score_conformite", 0))
                ws.cell(row=idx, column=7, value=nc_count)
        
        elif type_export == "batiments":
            ws.title = "B√¢timents"
            
            headers = ["Nom", "Adresse", "Ville", "Code Postal", "Groupe Occ.", "Pr√©ventionniste", "Nb Inspections"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True, color="FFFFFF")
                cell.fill = PatternFill(start_color="70AD47", end_color="70AD47", fill_type="solid")
                cell.alignment = Alignment(horizontal="center")
            
            batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
            users = await db.users.find({"tenant_slug": tenant.slug}).to_list(10000)
            users_dict = {u["id"]: u for u in users}
            
            for idx, bat in enumerate(batiments, 2):
                preventionniste = users_dict.get(bat.get("preventionniste_assigne_id"), {})
                insp_count = await db.inspections.count_documents({
                    "batiment_id": bat["id"],
                    "tenant_id": tenant.id
                })
                
                ws.cell(row=idx, column=1, value=bat.get("nom_etablissement", ""))
                ws.cell(row=idx, column=2, value=bat.get("adresse_civique", ""))
                ws.cell(row=idx, column=3, value=bat.get("ville", ""))
                ws.cell(row=idx, column=4, value=bat.get("code_postal", ""))
                ws.cell(row=idx, column=5, value=bat.get("groupe_occupation", ""))
                ws.cell(row=idx, column=6, value=f"{preventionniste.get('prenom', '')} {preventionniste.get('nom', '')}")
                ws.cell(row=idx, column=7, value=insp_count)
        
        elif type_export == "non_conformites":
            ws.title = "Non-Conformit√©s"
            
            headers = ["Date D√©tection", "B√¢timent", "Titre", "Description", "Gravit√©", "Statut", "D√©lai Correction"]
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True, color="FFFFFF")
                cell.fill = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")
                cell.alignment = Alignment(horizontal="center")
            
            non_conformites = await db.non_conformites.find({"tenant_id": tenant.id}).to_list(10000)
            batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
            batiments_dict = {b["id"]: b for b in batiments}
            
            for idx, nc in enumerate(non_conformites, 2):
                batiment = batiments_dict.get(nc.get("batiment_id"), {})
                
                ws.cell(row=idx, column=1, value=nc.get("created_at", "")[:10])
                ws.cell(row=idx, column=2, value=batiment.get("nom_etablissement", ""))
                ws.cell(row=idx, column=3, value=nc.get("titre", ""))
                ws.cell(row=idx, column=4, value=nc.get("description", ""))
                ws.cell(row=idx, column=5, value=nc.get("gravite", ""))
                ws.cell(row=idx, column=6, value=nc.get("statut", ""))
                ws.cell(row=idx, column=7, value=nc.get("delai_correction", ""))
        
        # Ajuster la largeur des colonnes
        for column in ws.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column_letter].width = adjusted_width
        
        # Sauvegarder dans un buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename=export_{type_export}_{datetime.now(timezone.utc).strftime('%Y%m%d')}.xlsx"
            }
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur export: {str(e)}")


# ==================== NOTIFICATIONS ====================

@api_router.get("/{tenant_slug}/prevention/notifications")
async def get_notifications(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les notifications pour l'utilisateur"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    notifications = []
    today = datetime.now(timezone.utc).date()
    
    # 1. Non-conformit√©s en retard
    non_conformites = await db.non_conformites.find({
        "tenant_id": tenant.id,
        "statut": {"$in": ["ouverte", "en_cours"]}
    }).to_list(1000)
    
    batiments = await db.batiments.find({"tenant_id": tenant.id}).to_list(10000)
    batiments_dict = {b["id"]: b for b in batiments}
    
    for nc in non_conformites:
        if nc.get("delai_correction"):
            try:
                delai_date = datetime.strptime(nc["delai_correction"], "%Y-%m-%d").date()
                days_remaining = (delai_date - today).days
                
                if days_remaining < 0:
                    notifications.append({
                        "id": f"nc_late_{nc['id']}",
                        "type": "nc_retard",
                        "priority": "urgent",
                        "titre": f"Non-conformit√© en retard",
                        "description": f"{nc.get('titre', 'NC')} au {batiments_dict.get(nc.get('batiment_id'), {}).get('nom_etablissement', 'b√¢timent')}",
                        "jours_retard": abs(days_remaining),
                        "link": f"/prevention/non-conformites/{nc['id']}",
                        "date": nc.get("created_at", "")
                    })
                elif days_remaining <= 7:
                    notifications.append({
                        "id": f"nc_soon_{nc['id']}",
                        "type": "nc_echeance_proche",
                        "priority": "high",
                        "titre": f"√âch√©ance proche ({days_remaining}j)",
                        "description": f"{nc.get('titre', 'NC')} au {batiments_dict.get(nc.get('batiment_id'), {}).get('nom_etablissement', 'b√¢timent')}",
                        "jours_restants": days_remaining,
                        "link": f"/prevention/non-conformites/{nc['id']}",
                        "date": nc.get("created_at", "")
                    })
            except:
                pass
    
    # 2. B√¢timents sans inspection depuis 6 mois
    six_months_ago = (datetime.now(timezone.utc) - timedelta(days=180)).date().isoformat()
    
    for batiment in batiments:
        last_inspection = await db.inspections.find_one(
            {"batiment_id": batiment["id"], "tenant_id": tenant.id},
            sort=[("date_inspection", -1)]
        )
        
        # G√©rer le cas o√π date_inspection peut √™tre datetime ou string
        last_inspection_date = None
        if last_inspection:
            date_insp = last_inspection.get("date_inspection")
            if isinstance(date_insp, datetime):
                last_inspection_date = date_insp.date().isoformat()
            elif isinstance(date_insp, str):
                last_inspection_date = date_insp
        
        if not last_inspection_date or last_inspection_date < six_months_ago:
            notifications.append({
                "id": f"bat_inspection_{batiment['id']}",
                "type": "inspection_requise",
                "priority": "medium",
                "titre": "Inspection requise",
                "description": f"{batiment.get('nom_etablissement', 'B√¢timent')} - Derni√®re inspection il y a >6 mois",
                "link": f"/prevention/batiments/{batiment['id']}",
                "date": last_inspection.get("date_inspection", "") if last_inspection else None
            })
    
    # 3. Inspections non-conformes r√©centes (< 30 jours)
    thirty_days_ago = (datetime.now(timezone.utc) - timedelta(days=30)).date().isoformat()
    
    recent_non_conformes = await db.inspections.find({
        "tenant_id": tenant.id,
        "statut_global": {"$ne": "conforme"},
        "date_inspection": {"$gte": thirty_days_ago}
    }).to_list(100)
    
    for inspection in recent_non_conformes:
        nc_count = await db.non_conformites.count_documents({
            "inspection_id": inspection["id"],
            "statut": {"$in": ["ouverte", "en_cours"]}
        })
        
        if nc_count > 0:
            notifications.append({
                "id": f"insp_nc_{inspection['id']}",
                "type": "inspection_nc",
                "priority": "medium",
                "titre": f"{nc_count} NC non r√©solues",
                "description": f"Inspection du {inspection.get('date_inspection', '')} au {batiments_dict.get(inspection.get('batiment_id'), {}).get('nom_etablissement', 'b√¢timent')}",
                "link": f"/prevention/inspections/{inspection['id']}",
                "date": inspection.get("date_inspection", "")
            })
    
    # Trier par priorit√©
    priority_order = {"urgent": 0, "high": 1, "medium": 2, "low": 3}
    notifications.sort(key=lambda x: priority_order.get(x["priority"], 999))
    
    return {
        "notifications": notifications,
        "count": len(notifications),
        "urgent_count": len([n for n in notifications if n["priority"] == "urgent"]),
        "high_count": len([n for n in notifications if n["priority"] == "high"])
    }


# ==================== RAPPORTS AVANC√âS ====================

@api_router.get("/{tenant_slug}/prevention/rapports/tendances")
async def get_tendances(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les tendances sur les 6 derniers mois"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if not tenant.parametres.get('module_prevention_active', False):
        raise HTTPException(status_code=403, detail="Module pr√©vention non activ√©")
    
    # Calculer les 6 derniers mois
    today = datetime.now(timezone.utc)
    months_data = []
    
    for i in range(6):
        month_date = today - timedelta(days=30 * i)
        month_start = month_date.replace(day=1).strftime("%Y-%m-%d")
        
        if month_date.month == 12:
            next_month = month_date.replace(year=month_date.year + 1, month=1, day=1)
        else:
            next_month = month_date.replace(month=month_date.month + 1, day=1)
        month_end = next_month.strftime("%Y-%m-%d")
        
        # Inspections du mois
        inspections_count = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "date_inspection": {"$gte": month_start, "$lt": month_end}
        })
        
        conformes_count = await db.inspections.count_documents({
            "tenant_id": tenant.id,
            "date_inspection": {"$gte": month_start, "$lt": month_end},
            "statut_global": "conforme"
        })
        
        # Non-conformit√©s du mois
        nc_ouvertes = await db.non_conformites.count_documents({
            "tenant_id": tenant.id,
            "created_at": {"$gte": month_start, "$lt": month_end}
        })
        
        months_data.append({
            "mois": month_date.strftime("%B %Y"),
            "inspections_total": inspections_count,
            "inspections_conformes": conformes_count,
            "taux_conformite": round((conformes_count / inspections_count * 100) if inspections_count > 0 else 0, 1),
            "non_conformites_nouvelles": nc_ouvertes
        })
    
    return {
        "tendances": list(reversed(months_data))
    }


# ==================== HEALTH CHECK ====================

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Test MongoDB connection
        await db.command('ping')
        db_status = "connected"
    except:
        db_status = "disconnected"
    
    return {
        "status": "healthy" if db_status == "connected" else "degraded",
        "service": "ProFireManager API",
        "version": "2.0",
        "database": db_status,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

# Endpoint d'initialisation (√† appeler une fois apr√®s d√©ploiement)
@app.post("/api/admin/initialize-production")
async def initialize_production_data():
    """
    Endpoint pour initialiser les donn√©es de production
    √Ä appeler UNE SEULE FOIS apr√®s le premier d√©ploiement
    """
    try:
        # V√©rifier si d√©j√† initialis√©
        existing_super_admin = await db.super_admins.find_one({"email": SUPER_ADMIN_EMAIL})
        existing_tenant = await db.tenants.find_one({"slug": "shefford"})
        
        if existing_super_admin and existing_tenant:
            return {
                "status": "already_initialized",
                "message": "Les donn√©es sont d√©j√† initialis√©es",
                "super_admin_email": SUPER_ADMIN_EMAIL,
                "tenants_count": await db.tenants.count_documents({})
            }
        
        # Initialiser via la fonction existante
        await initialize_multi_tenant()
        
        return {
            "status": "success",
            "message": "Donn√©es de production initialis√©es avec succ√®s",
            "super_admin_email": SUPER_ADMIN_EMAIL,
            "tenants_created": 1,
            "instructions": "Connectez-vous en super-admin pour cr√©er vos casernes"
        }
    except Exception as e:
        logging.error(f"Erreur initialisation production: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Erreur lors de l'initialisation: {str(e)}"
        )


# ==================== ROUTES ACTIFS MIGR√âES VERS routes/actifs.py ====================
# Les routes CRUD v√©hicules, bornes, inventaires, mat√©riels ont √©t√© extraites vers:
# /app/backend/routes/actifs.py
# Les mod√®les Pydantic ci-dessous restent ici car utilis√©s par d'autres fonctions


# ==================== GESTION DES ACTIFS - INSPECTIONS SAAQ MODELS ====================

class DefectDetail(BaseModel):
    """D√©tail d'une d√©fectuosit√© identifi√©e"""
    item: str  # Ex: "Freins avant", "Pneu avant gauche"
    severity: str  # "mineure" ou "majeure"
    description: str
    photo_url: Optional[str] = None
    reported_by: str
    reported_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    resolved_by: Optional[str] = None

class InspectionSAAQ(BaseModel):
    """Inspection de s√©curit√© SAAQ (Ronde pr√©-d√©part)"""
    id: str = Field(default_factory=lambda: f"insp_{str(uuid.uuid4())[:8]}")
    tenant_id: str
    vehicle_id: str
    
    # Inspecteur
    inspector_id: str
    inspector_name: str
    inspector_matricule: Optional[str] = None
    
    # Signature √©lectronique
    signature_certify: bool = False  # "Je certifie avoir effectu√© cette inspection"
    signature_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    signature_gps: Optional[List[float]] = None  # [longitude, latitude]
    
    # Date/Heure inspection
    inspection_date: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Checklist (Structure flexible pour diff√©rents types de v√©hicules)
    checklist: Dict[str, Any] = Field(default_factory=dict)
    
    # D√©fectuosit√©s
    defects: List[DefectDetail] = []
    has_major_defect: bool = False  # Flag pour hors service
    
    # Photos
    photo_urls: List[str] = []
    
    # R√©sultat
    passed: bool = True
    comments: Optional[str] = None
    
    # Offline sync (pour Atlas Device Sync)
    synced: bool = False
    created_offline: bool = False
    device_id: Optional[str] = None
    
    # M√©tadonn√©es
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class InspectionSAAQCreate(BaseModel):
    vehicle_id: str
    inspector_id: str
    inspector_name: str
    inspector_matricule: Optional[str] = None
    signature_certify: bool
    signature_gps: Optional[List[float]] = None
    checklist: Dict[str, Any]
    defects: List[DefectDetail] = []
    photo_urls: List[str] = []
    comments: Optional[str] = None
    device_id: Optional[str] = None

class AuditLogEntry(BaseModel):
    """Entr√©e dans la fiche de vie d'un actif"""
    date: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    user_id: str
    user_name: str
    action: str  # Ex: "created", "updated", "inspected", "repaired", "status_changed"
    details: Optional[str] = None
    gps: Optional[List[float]] = None  # Position GPS si applicable

# ==================== ROUTES SAAQ, QR CODES, IMPORT BORNES, PARAMETRES ACTIFS ====================
# Ces routes ont √©t√© migr√©es vers /app/backend/routes/actifs.py
# - POST /{tenant_slug}/actifs/vehicules/{vehicle_id}/inspection-saaq
# - GET  /{tenant_slug}/actifs/vehicules/{vehicle_id}/inspections
# - GET  /{tenant_slug}/actifs/vehicules/{vehicle_id}/fiche-vie
# - POST /{tenant_slug}/actifs/vehicules/{vehicle_id}/qr-code
# - POST /{tenant_slug}/actifs/bornes/{borne_id}/qr-code
# - POST /{tenant_slug}/actifs/bornes/import-inspections
# - GET/PUT /{tenant_slug}/actifs/parametres


# ==================== RONDES DE S√âCURIT√â ====================

class ContreSignature(BaseModel):
    """Contre-signature d'une ronde par un 2e conducteur"""
    nom_conducteur: str
    prenom_conducteur: str
    signature: str  # Base64 data URL
    date_contre_signature: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    user_id: Optional[str] = None

class RondeSecuriteCreate(BaseModel):
    vehicule_id: str
    date: str
    heure: str
    lieu: str
    position_gps: Optional[List[float]] = None  # [latitude, longitude]
    km: int
    personne_mandatee: str  # Nom complet de la personne qui effectue la ronde
    defectuosites: Optional[str] = ""
    points_verification: Dict[str, str]  # { "attelage": "conforme", "chassis_carrosserie": "defectueux", ... }
    signature_mandatee: str  # Base64 data URL

class RondeSecurite(BaseModel):
    id: str = Field(default_factory=lambda: f"ronde_{str(uuid.uuid4())[:12]}")
    tenant_id: str
    vehicule_id: str
    date: str
    heure: str
    lieu: str
    position_gps: Optional[List[float]] = None
    km: int
    personne_mandatee: str
    defectuosites: Optional[str] = ""
    points_verification: Dict[str, str]
    signature_mandatee: str
    contre_signatures: List[ContreSignature] = []  # Liste des contre-signatures
    created_by: str  # User ID
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ContreSignatureCreate(BaseModel):
    nom_conducteur: str
    prenom_conducteur: str
    signature: str
    raison_refus: Optional[str] = None  # Si la personne refuse la ronde

async def send_ronde_email_background(tenant, ronde_id: str, vehicle: dict, recipient_emails: list):
    """
    Fonction helper pour envoyer l'email de ronde en arri√®re-plan via Resend
    """
    try:
        import os
        import resend
        
        # R√©cup√©rer la ronde
        ronde = await db.rondes_securite.find_one(
            {"id": ronde_id, "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        if not ronde:
            logger.error(f"‚ùå Ronde {ronde_id} non trouv√©e pour envoi email")
            return
        
        # Configurer Resend
        resend_api_key = os.environ.get('RESEND_API_KEY')
        if not resend_api_key:
            logger.error("‚ùå RESEND_API_KEY non configur√©e")
            return
        
        resend.api_key = resend_api_key
        
        nom_service = tenant.nom_service if hasattr(tenant, 'nom_service') and tenant.nom_service else tenant.nom
        
        # Formater la date en heure locale (Canada EST = UTC-5)
        date_ronde_raw = ronde["date"]
        try:
            from datetime import datetime, timedelta
            # Parser la date ISO et convertir en heure locale Canada (UTC-5)
            dt = datetime.fromisoformat(date_ronde_raw.replace('Z', '+00:00'))
            # Convertir en heure locale du Canada (EST = UTC-5)
            dt_local = dt - timedelta(hours=5)
            date_ronde_str = dt_local.strftime('%Y-%m-%d')
        except Exception as e:
            # En cas d'erreur, utiliser la date brute
            date_ronde_str = date_ronde_raw[:10] if len(date_ronde_raw) >= 10 else date_ronde_raw
        
        # Si la ronde a une position GPS, r√©cup√©rer l'adresse via reverse geocoding
        lieu_display = ronde.get('lieu', 'N/A')
        if ronde.get('position_gps') and len(ronde.get('position_gps', [])) == 2:
            try:
                import httpx
                latitude, longitude = ronde['position_gps']
                async with httpx.AsyncClient() as client:
                    response = await client.get(
                        f"https://nominatim.openstreetmap.org/reverse?format=json&lat={latitude}&lon={longitude}&zoom=18&addressdetails=1",
                        headers={'User-Agent': 'ProFireManager-App'},
                        timeout=5.0
                    )
                    if response.status_code == 200:
                        data = response.json()
                        if data and 'address' in data:
                            addr = data['address']
                            parts = []
                            if addr.get('house_number'): parts.append(addr['house_number'])
                            if addr.get('road'): parts.append(addr['road'])
                            if addr.get('city') or addr.get('town') or addr.get('village'):
                                parts.append(addr.get('city') or addr.get('town') or addr.get('village'))
                            if addr.get('state'): parts.append(addr['state'])
                            if parts:
                                lieu_display = ', '.join(parts)
                            else:
                                lieu_display = data.get('display_name', lieu_display)
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur r√©cup√©ration adresse GPS: {e}")
                # En cas d'erreur, garder "Position GPS d√©tect√©e"
        
        sender_email = os.environ.get('SENDER_EMAIL', 'noreply@profiremanager.ca')
        
        subject = f"üîß Nouvelle Ronde de S√©curit√© - {vehicle.get('nom', 'V√©hicule')} - {date_ronde_str}"
        
        html_content = f"""
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #DC2626;">üîß Nouvelle Ronde de S√©curit√© SAAQ</h2>
            
            <p><strong>Service:</strong> {nom_service}</p>
            <p><strong>V√©hicule:</strong> {vehicle.get('type_vehicule', 'N/A')} - {vehicle.get('nom', 'N/A')}</p>
            <p><strong>Date:</strong> {date_ronde_str}</p>
            <p><strong>Heure:</strong> {ronde.get('heure', 'N/A')}</p>
            <p><strong>Lieu:</strong> {lieu_display}</p>
            <p><strong>Kilom√©trage:</strong> {ronde.get('km', 'N/A')} km</p>
            <p><strong>Personne mandat√©e:</strong> {ronde.get('personne_mandatee', 'N/A')}</p>
            
            <p style="margin-top: 20px;">
                Une nouvelle ronde de s√©curit√© a √©t√© compl√©t√©e. Vous pouvez consulter les d√©tails dans l'application.
            </p>
            
            <hr style="margin: 30px 0; border: none; border-top: 1px solid #E5E7EB;">
            
            <p style="color: #6B7280; font-size: 12px;">
                Cet email a √©t√© envoy√© automatiquement par ProFireManager.<br>
                Pour consulter et g√©rer vos rondes de s√©curit√©, connectez-vous √† l'application.
            </p>
        </div>
        """
        
        # Envoyer l'email √† tous les destinataires
        for email in recipient_emails:
            try:
                params = {
                    "from": sender_email,
                    "to": [email],
                    "subject": subject,
                    "html": html_content,
                }
                
                response = resend.Emails.send(params)
                logger.info(f"‚úÖ Email envoy√© √† {email} via Resend - ID: {response.get('id', 'N/A')}")
                
            except Exception as e:
                logger.error(f"‚ùå Erreur envoi email √† {email}: {e}")
        
    except Exception as e:
        logger.error(f"‚ùå Erreur globale envoi email ronde: {e}")

@api_router.post("/{tenant_slug}/actifs/rondes-securite", response_model=RondeSecurite)
async def create_ronde_securite(
    tenant_slug: str,
    ronde_data: RondeSecuriteCreate,
    current_user: User = Depends(get_current_user)
):
    """
    Cr√©er une nouvelle ronde de s√©curit√© SAAQ pour un v√©hicule
    """
    tenant = await get_tenant_from_slug(tenant_slug)
    
    if current_user.tenant_id != tenant.id:
        raise HTTPException(status_code=403, detail="Acc√®s refus√©")
    
    # V√©rifier que le v√©hicule existe
    vehicle = await db.vehicules.find_one(
        {"id": ronde_data.vehicule_id, "tenant_id": tenant.id},
        {"_id": 0}
    )
    if not vehicle:
        raise HTTPException(status_code=404, detail="V√©hicule non trouv√©")
    
    # Cr√©er la ronde
    ronde = RondeSecurite(
        tenant_id=tenant.id,
        vehicule_id=ronde_data.vehicule_id,
        date=ronde_data.date,
        heure=ronde_data.heure,
        lieu=ronde_data.lieu,
        position_gps=ronde_data.position_gps,
        km=ronde_data.km,
        personne_mandatee=ronde_data.personne_mandatee,
        defectuosites=ronde_data.defectuosites,
        points_verification=ronde_data.points_verification,
        signature_mandatee=ronde_data.signature_mandatee,
        contre_signatures=[],
        created_by=current_user.id
    )
    
    # Sauvegarder la ronde
    await db.rondes_securite.insert_one(ronde.dict())
    
    # Mettre √† jour la date de derni√®re inspection du v√©hicule
    await db.vehicules.update_one(
        {"id": ronde_data.vehicule_id},
        {"$set": {"derniere_inspection_date": ronde_data.date}}
    )
    
    # Envoyer automatiquement les emails configur√©s
    try:
        user_ids_config = tenant.parametres.get('user_ids_rondes_securite', [])
        if user_ids_config and len(user_ids_config) > 0:
            # R√©cup√©rer les emails des utilisateurs
            users = await db.users.find({
                "id": {"$in": user_ids_config},
                "tenant_id": tenant.id
            }, {"_id": 0, "email": 1, "nom": 1, "prenom": 1}).to_list(100)
            
            recipient_emails = [u['email'] for u in users]
            
            if recipient_emails:
                # Envoyer l'email en arri√®re-plan (fire and forget)
                import asyncio
                asyncio.create_task(
                    send_ronde_email_background(tenant, ronde.id, vehicle, recipient_emails)
                )
                logger.info(f"üìß Email de ronde programm√© pour {len(recipient_emails)} destinataire(s)")
    except Exception as e:
        logger.error(f"‚ùå Erreur programmation email ronde: {e}")
        # Ne pas bloquer la cr√©ation de la ronde si l'email √©choue
    
    return ronde

# Routes GET rondes-securite migr√©es vers actifs.py (POST reste ici pour l'envoi d'email)
# - GET /{tenant_slug}/actifs/rondes-securite - Liste des rondes
# - GET /{tenant_slug}/actifs/rondes-securite/{ronde_id} - D√©tail ronde

@api_router.get("/{tenant_slug}/actifs/rondes-securite/{ronde_id}/export-pdf")
async def export_ronde_securite_pdf(
    tenant_slug: str,
    ronde_id: str,
    token: str = None,
    current_user: User = Depends(get_current_user_optional)
):
    """Exporter une ronde de s√©curit√© en PDF (style rapport de temps)
    
    Sur mobile (iOS/Android), le token peut √™tre pass√© en param√®tre URL car
    l'ouverture dans un nouvel onglet ne supporte pas les headers d'authentification.
    """
    logger.info(f"üìÑ PDF Export - tenant: {tenant_slug}, ronde: {ronde_id}, token_present: {bool(token)}, user_from_header: {current_user is not None}")
    
    try:
        # Si pas d'utilisateur via header, essayer avec le token en param√®tre URL (pour mobile)
        if current_user is None and token:
            logger.info(f"üìÑ Tentative auth via token URL...")
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                user_id = payload.get("sub")  # sub contient l'ID utilisateur
                user_email = payload.get("email")  # email comme fallback
                tenant_id = payload.get("tenant_id")
                logger.info(f"üìÑ Token d√©cod√© - user_id: {user_id}, email: {user_email}, tenant_id: {tenant_id}")
                
                if tenant_id:
                    user_data = None
                    # Essayer d'abord par ID
                    if user_id:
                        user_data = await db.users.find_one(
                            {"id": user_id, "tenant_id": tenant_id},
                            {"_id": 0}
                        )
                    # Si pas trouv√©, essayer par email
                    if not user_data and user_email:
                        user_data = await db.users.find_one(
                            {"email": user_email, "tenant_id": tenant_id},
                            {"_id": 0}
                        )
                    
                    if user_data:
                        current_user = User(**user_data)
                        logger.info(f"üìÑ Utilisateur trouv√© via token URL: {current_user.email}")
                    else:
                        logger.error(f"üìÑ Utilisateur non trouv√© pour user_id: {user_id}, email: {user_email}, tenant_id: {tenant_id}")
            except jwt.ExpiredSignatureError:
                logger.error("üìÑ Token expir√©")
                raise HTTPException(status_code=401, detail="Token expir√©")
            except Exception as e:
                logger.error(f"üìÑ Erreur d√©codage token URL: {e}")
                raise HTTPException(status_code=401, detail="Token invalide")
        
        if current_user is None:
            raise HTTPException(status_code=401, detail="Non authentifi√©")
        
        logger.info(f"üìÑ Export PDF demand√© - tenant: {tenant_slug}, ronde_id: {ronde_id}, user: {current_user.email}")
        
        tenant = await get_tenant_from_slug(tenant_slug)
        logger.info(f"‚úÖ Tenant trouv√©: {tenant.nom} (id: {tenant.id})")
        
        if current_user.tenant_id != tenant.id:
            logger.error(f"‚ùå Tenant mismatch - user.tenant_id: {current_user.tenant_id}, tenant.id: {tenant.id}")
            raise HTTPException(status_code=403, detail="Acc√®s refus√©")
        
        # R√©cup√©rer la ronde
        ronde = await db.rondes_securite.find_one(
            {"id": ronde_id, "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        if not ronde:
            logger.error(f"‚ùå Ronde non trouv√©e - id: {ronde_id}, tenant_id: {tenant.id}")
            raise HTTPException(status_code=404, detail="Ronde de s√©curit√© non trouv√©e")
        
        logger.info(f"‚úÖ Ronde trouv√©e - v√©hicule_id: {ronde.get('vehicule_id')}")
        
        # R√©cup√©rer le v√©hicule
        vehicule = await db.vehicules.find_one(
            {"id": ronde["vehicule_id"], "tenant_id": tenant.id},
            {"_id": 0}
        )
        
        from io import BytesIO
        from reportlab.lib.pagesizes import A4
        from reportlab.lib import colors
        from reportlab.lib.units import inch
        from reportlab.platypus import Table, TableStyle, Paragraph, Spacer, PageBreak, Image as RLImage
        from reportlab.lib.styles import ParagraphStyle
        from reportlab.lib.enums import TA_CENTER, TA_LEFT
        import base64
        
        # Cr√©er le PDF manuellement avec header compact
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=0.5*inch, bottomMargin=0.5*inch)
        elements = []
        
        # Header compact avec logo (si pr√©sent)
        if hasattr(tenant, 'logo_url') and tenant.logo_url:
            try:
                if tenant.logo_url.startswith('data:image/'):
                    header_logo, encoded = tenant.logo_url.split(',', 1)
                    logo_data = base64.b64decode(encoded)
                    logo_buffer = BytesIO(logo_data)
                    
                    from PIL import Image as PILImage
                    pil_image = PILImage.open(logo_buffer)
                    img_width, img_height = pil_image.size
                    
                    # Logo plus petit pour le PDF compact
                    target_width = 1 * inch
                    aspect_ratio = img_height / img_width
                    target_height = target_width * aspect_ratio
                    
                    logo_buffer.seek(0)
                    logo = RLImage(logo_buffer, width=target_width, height=target_height)
                    logo.hAlign = 'CENTER'
                    elements.append(logo)
                    elements.append(Spacer(1, 0.05*inch))
            except Exception as e:
                logger.error(f"Erreur chargement logo: {e}")
        
        # Nom du service compact
        nom_service = tenant.nom_service if hasattr(tenant, 'nom_service') and tenant.nom_service else tenant.nom
        header_style_compact = ParagraphStyle(
            'ServiceHeaderCompact',
            fontSize=10,
            textColor=colors.HexColor('#1f2937'),
            spaceAfter=6,
            alignment=TA_CENTER
        )
        elements.append(Paragraph(nom_service, header_style_compact))
        elements.append(Spacer(1, 0.05*inch))
        from reportlab.lib.styles import getSampleStyleSheet
        styles = getSampleStyleSheet()
        modern_styles = get_modern_pdf_styles(styles)
        
        # Styles personnalis√©s - ultra-optimis√©s pour une page
        title_style = ParagraphStyle(
            'CustomTitle',
            fontSize=13,
            textColor=modern_styles['primary_color'],
            spaceAfter=4,
            alignment=TA_CENTER
        )
        
        subtitle_style = ParagraphStyle(
            'Subtitle',
            fontSize=8,
            textColor=modern_styles['secondary_color'],
            spaceAfter=6,
            alignment=TA_CENTER
        )
        
        section_style = ParagraphStyle(
            'Section',
            fontSize=9,
            textColor=modern_styles['primary_color'],
            spaceBefore=4,
            spaceAfter=3
        )
    
        # Titre
        elements.append(Paragraph("üîß Ronde de S√©curit√© SAAQ", title_style))
        
        # Date et lieu
        from datetime import datetime
        date_ronde = datetime.strptime(ronde["date"], "%Y-%m-%d")
        info_text = f"Date: {date_ronde.strftime('%d/%m/%Y')} ‚Ä¢ Heure: {ronde['heure']} ‚Ä¢ Lieu: {ronde['lieu']}"
        elements.append(Paragraph(info_text, subtitle_style))
        
        # Informations du v√©hicule
        elements.append(Paragraph("üìã Informations du v√©hicule", section_style))
        vehicule_data = [
            ['Type', 'N¬∞ Plaque', 'Marque', 'Ann√©e', 'KM'],
            [
                vehicule.get('type_vehicule', 'N/A'),
                vehicule.get('nom', 'N/A'),
                vehicule.get('marque', 'N/A'),
                str(vehicule.get('annee', 'N/A')),
                f"{ronde['km']} km"
            ]
        ]
        
        vehicule_table = Table(vehicule_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1*inch, 1*inch])
        vehicule_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 7),
        ]))
        elements.append(vehicule_table)
        elements.append(Spacer(1, 0.06*inch))
        
        # Personne mandat√©e
        elements.append(Paragraph("üë§ Personne mandat√©e", section_style))
        mandatee_text = f"<b>{ronde['personne_mandatee']}</b>"
        mandatee_para = ParagraphStyle('MandateeText', fontSize=7.5)
        elements.append(Paragraph(mandatee_text, mandatee_para))
        elements.append(Spacer(1, 0.05*inch))
        
        # Points de v√©rification
        elements.append(Paragraph("‚úÖ Points de v√©rification (19 points SAAQ)", section_style))
        
        points_labels = {
            'attelage': '1 - Attelage',
            'chassis_carrosserie': '2 - Ch√¢ssis et carrosserie',
            'chauffage_degivrage': '3 - Chauffage et d√©givrage',
            'commandes_conducteur_sirene': '4 - Commandes du conducteur et sir√®ne',
            'direction': '5 - Direction',
            'essuie_glaces_lave_glace': '6 - Essuie-glaces/lave-glace',
            'materiel_urgence': '7 - Mat√©riel d\'urgence',
            'phares_feux_gyrophares': '8 - Phares, feux et gyrophares',
            'pneus': '9 - Pneus',
            'portieres_autres_issues': '10 - Porti√®res et autres issues',
            'retroviseurs_vitrage': '11 - R√©troviseurs/Vitrage',
            'roues_moyeux_fixation': '12 - Roues, Moyeux et pi√®ces de fixation',
            'siege': '13 - Si√®ge',
            'suspension': '14 - Suspension',
            'systeme_alimentation_carburant': '15 - Syst√®me d\'alimentation en carburant',
            'systeme_echappement': '16 - Syst√®me d\'√©chappement',
            'systeme_freins_hydrauliques': '18 - Syst√®me de freins hydrauliques',
            'systeme_freins_pneumatiques': '19 - Syst√®me de freins pneumatiques'
        }
        
        points_data = [['Point de v√©rification', 'Statut']]
        
        nb_conformes = 0
        nb_defectueux = 0
        
        for key, label in points_labels.items():
            statut = ronde['points_verification'].get(key, 'conforme')
            statut_display = '‚úÖ Conforme' if statut == 'conforme' else '‚ùå D√©fectueux'
            if statut == 'conforme':
                nb_conformes += 1
            else:
                nb_defectueux += 1
            points_data.append([label, statut_display])
        
        points_table = Table(points_data, colWidths=[4.2*inch, 1.8*inch])
        points_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), modern_styles['primary_color']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('ALIGN', (1, 0), (1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 7),
            ('GRID', (0, 0), (-1, -1), 0.5, modern_styles['grid']),
            ('FONTSIZE', (0, 1), (-1, -1), 6.5),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, modern_styles['bg_light']]),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2)
        ]))
        elements.append(points_table)
        
        # R√©sum√©
        elements.append(Spacer(1, 0.05*inch))
        resume_text = f"<b>R√©sum√©:</b> {nb_conformes} point(s) conforme(s) ‚Ä¢ {nb_defectueux} point(s) d√©fectueux"
        resume_para = ParagraphStyle('ResumeText', fontSize=7.5)
        elements.append(Paragraph(resume_text, resume_para))
        
        # D√©fectuosit√©s
        if ronde.get('defectuosites'):
            elements.append(Spacer(1, 0.05*inch))
            elements.append(Paragraph("üìù D√©fectuosit√©s constat√©es", section_style))
            defects_text = ronde['defectuosites'].replace('\n', '<br/>')
            defects_para = ParagraphStyle('DefectsText', fontSize=6.5)
            elements.append(Paragraph(defects_text, defects_para))
        
        # Contre-signatures
        if ronde.get('contre_signatures') and len(ronde['contre_signatures']) > 0:
            elements.append(Spacer(1, 0.05*inch))
            elements.append(Paragraph("‚úçÔ∏è Contre-signatures", section_style))
            
            cs_para = ParagraphStyle('CSText', fontSize=6.5)
            for cs in ronde['contre_signatures']:
                cs_date = datetime.fromisoformat(cs['date_contre_signature'])
                cs_text = f"‚Ä¢ {cs['prenom_conducteur']} {cs['nom_conducteur']} - {cs_date.strftime('%d/%m/%Y √† %H:%M')}"
                elements.append(Paragraph(cs_text, cs_para))
        
        # Signature (image base64)
        elements.append(Spacer(1, 0.06*inch))
        elements.append(Paragraph("‚úçÔ∏è Signature de la personne mandat√©e", section_style))
        
        try:
            # Extraire les donn√©es de la signature (base64)
            sig_data = ronde['signature_mandatee']
            if sig_data and sig_data.startswith('data:image'):
                # Retirer le pr√©fixe data:image/png;base64,
                sig_base64 = sig_data.split(',')[1]
                sig_bytes = base64.b64decode(sig_base64)
                
                # Cr√©er une image temporaire - version compacte
                sig_buffer = BytesIO(sig_bytes)
                sig_image = RLImage(sig_buffer, width=2*inch, height=0.65*inch)
                elements.append(sig_image)
        except Exception as e:
            sig_error = ParagraphStyle('SigError', parent=styles['Normal'], fontSize=7)
            elements.append(Paragraph(f"<i>Signature non disponible</i>", sig_error))
        
        # Footer ultra-compact
        elements.append(Spacer(1, 0.05*inch))
        footer_style = ParagraphStyle(
            'Footer',
            fontSize=5,
            textColor=colors.grey,
            alignment=TA_CENTER,
            spaceAfter=0
        )
        footer_text = create_pdf_footer_text(tenant)
        if footer_text:
            elements.append(Paragraph(footer_text, footer_style))
        
            # G√©n√©rer le PDF
            logger.info("üìÑ G√©n√©ration du PDF...")
            doc.build(elements)
            buffer.seek(0)
            
            filename = f"ronde_securite_{vehicule.get('nom', 'vehicule')}_{ronde['date']}.pdf"
            logger.info(f"‚úÖ PDF g√©n√©r√© avec succ√®s - filename: {filename}")
            
            return StreamingResponse(
                buffer,
                media_type="application/pdf",
                headers={"Content-Disposition": f"attachment; filename={filename}"}
            )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Erreur g√©n√©ration PDF: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Erreur lors de la g√©n√©ration du PDF: {str(e)}")

# Routes configuration-emails-rondes et contre-signer migr√©es vers actifs.py
# - GET/PUT /{tenant_slug}/actifs/configuration-emails-rondes
# - POST /{tenant_slug}/actifs/rondes-securite/{ronde_id}/contre-signer


# Include the router in the main app

# Endpoint public pour lister les tenants (pour l'app mobile)
@app.get("/api/tenants")
async def get_all_tenants():
    """R√©cup√®re la liste de tous les tenants actifs (casernes) pour la s√©lection dans l'app mobile"""
    try:
        tenants = await db.tenants.find(
            {"actif": True},
            {"_id": 0, "id": 1, "slug": 1, "nom": 1}
        ).to_list(length=None)
        return tenants
    except Exception as e:
        return []



# ==================== MODULE BORNES S√àCHES - TEMPLATES & INSPECTIONS ====================

# Mod√®les Pydantic pour les templates de bornes s√®ches
class BorneSecheTemplateCreate(BaseModel):
    nom_borne: str
    municipalite: str = "Canton de Shefford"
    adresse_proximite: Optional[str] = None
    transversale: Optional[str] = None
    lien_itineraire: Optional[str] = None
    notes_importantes: Optional[str] = None
    # Caract√©ristiques techniques
    type_borne: Optional[str] = "PVC"
    angle: Optional[str] = "90¬∞"
    diametre_tuyau: Optional[str] = '6"'
    diametre_raccordement: Optional[str] = '6"'
    type_branchement: Optional[str] = "Filet√©"
    # Photos et sch√©mas (URLs ou Base64)
    photo_localisation: Optional[str] = None
    photo_borne: Optional[str] = None
    schema_1: Optional[str] = None  # Centre borne
    schema_2: Optional[str] = None  # Centre entr√©e pompe
    schema_3: Optional[str] = None  # Centre sortie borne
    schema_4: Optional[str] = None  # Distance borne √† berge
    schema_5: Optional[str] = None  # Centre sortie borne et entr√©e pompe

class BorneSecheTemplateUpdate(BaseModel):
    nom_borne: Optional[str] = None
    municipalite: Optional[str] = None
    adresse_proximite: Optional[str] = None
    transversale: Optional[str] = None
    lien_itineraire: Optional[str] = None
    notes_importantes: Optional[str] = None
    type_borne: Optional[str] = None
    angle: Optional[str] = None
    diametre_tuyau: Optional[str] = None
    diametre_raccordement: Optional[str] = None
    type_branchement: Optional[str] = None
    photo_localisation: Optional[str] = None
    photo_borne: Optional[str] = None
    schema_1: Optional[str] = None
    schema_2: Optional[str] = None
    schema_3: Optional[str] = None
    schema_4: Optional[str] = None
    schema_5: Optional[str] = None

# Mod√®le pour les inspections de bornes s√®ches
class InspectionBorneSecheCreate(BaseModel):
    borne_seche_id: str
    inspecteur_id: str
    date_inspection: str
    # Page 3 - Questions d'inspection
    accessibilite: List[str] = []  # ["S√©curitaire", "Facile", "Dangereuse", "Difficile"]
    conditions_atmospheriques: str  # "Nuageux", "D√©gag√©", "Froid", "Pluvieux", "Enneig√©"
    temperature_exterieure: Optional[str] = None
    # Inspection visuelle (8 items)
    joint_present: str = "N/A"  # Conforme, Non conforme, D√©fectuosit√©, N/A
    joint_bon_etat: str = "N/A"
    site_accessible: str = "N/A"
    site_bien_deneige: str = "N/A"
    vanne_sortie_storz_4: str = "N/A"
    vanne_sortie_6_filetee: str = "N/A"
    vanne_sortie_4_filetee: str = "N/A"
    niveau_plan_eau: str = "N/A"
    # Essai de pompage
    pompage_continu_5min: str = "Non conforme"  # Conforme, Non conforme
    temps_amorcage_secondes: Optional[int] = None  # Chronom√®tre
    # Commentaires et signature
    commentaire: Optional[str] = None
    matricule_pompier: Optional[str] = None
    photos_defauts: Optional[List[str]] = []  # URLs ou Base64 des photos prises

# ==================== BORNES S√àCHES ROUTES MIGR√âES VERS routes/bornes_seches.py ====================
# Routes migr√©es (~20 routes):
# - GET/POST/PUT/DELETE /{tenant_slug}/bornes-seches/templates - Templates
# - GET/POST /{tenant_slug}/bornes-seches/inspections - Inspections
# - GET/POST/PUT/DELETE /{tenant_slug}/bornes-seches/modeles-inspection - Mod√®les d'inspection
# - POST /{tenant_slug}/bornes-seches/modeles-inspection/{id}/activer - Activer mod√®le
# - POST /{tenant_slug}/bornes-seches/modeles-inspection/{id}/dupliquer - Dupliquer mod√®le
# - GET/POST /{tenant_slug}/bornes-seches/inspections-personnalisees - Inspections personnalis√©es
# ============================================================================


# ==================== MODULE APPROVISIONNEMENT EN EAU - POINTS D'EAU ====================

# Mod√®les Pydantic pour les points d'eau
class PointEauCreate(BaseModel):
    type: str  # "borne_fontaine", "borne_seche", "point_eau_statique"
    numero_identification: str
    latitude: float
    longitude: float
    adresse: Optional[str] = None
    ville: Optional[str] = None
    secteur_id: Optional[str] = None
    notes: Optional[str] = None
    # Champs sp√©cifiques aux bornes fontaines
    debit_gpm: Optional[str] = None
    pression_statique_psi: Optional[str] = None
    pression_dynamique_psi: Optional[str] = None
    diametre_raccordement: Optional[str] = None
    etat: Optional[str] = "fonctionnelle"  # fonctionnelle, hors_service, en_inspection
    date_dernier_test: Optional[str] = None
    # Champs sp√©cifiques aux points d'eau statiques
    capacite_litres: Optional[str] = None
    accessibilite: Optional[str] = "facile"  # facile, moyenne, difficile

class PointEauUpdate(BaseModel):
    type: Optional[str] = None
    nom: Optional[str] = None
    numero_identification: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    adresse: Optional[str] = None
    ville: Optional[str] = None
    secteur_id: Optional[str] = None
    notes: Optional[str] = None
    debit_gpm: Optional[str] = None
    pression_statique_psi: Optional[str] = None
    pression_dynamique_psi: Optional[str] = None
    diametre_raccordement: Optional[str] = None
    etat: Optional[str] = None
    date_dernier_test: Optional[str] = None
    capacite_litres: Optional[str] = None
    accessibilite: Optional[str] = None
    debit_max_statique_gpm: Optional[str] = None
    photos: Optional[List[str]] = None
    statut_couleur: Optional[str] = None
    statut_inspection: Optional[str] = None
    modele_inspection_assigne_id: Optional[str] = None  # ID du formulaire d'inspection assign√©

# ==================== POINTS D'EAU ROUTES MIGR√âES VERS routes/points_eau.py ====================
# Routes migr√©es:
# - GET    /{tenant_slug}/points-eau                        - Liste des points d'eau
# - GET    /{tenant_slug}/points-eau-statistiques           - Statistiques des points d'eau
# - GET    /{tenant_slug}/points-eau/{point_id}             - D√©tail d'un point d'eau
# - POST   /{tenant_slug}/points-eau                        - Cr√©er un point d'eau
# - PUT    /{tenant_slug}/points-eau/{point_id}             - Modifier un point d'eau
# - DELETE /{tenant_slug}/points-eau/{point_id}             - Supprimer un point d'eau
# - POST   /{tenant_slug}/points-eau/{point_id}/inspections - Cr√©er une inspection
# - GET    /{tenant_slug}/points-eau/{point_id}/inspections - Historique des inspections
# - GET    /{tenant_slug}/parametres/dates-tests-bornes-seches - Dates de tests configur√©es
# ============================================================================


# ==================== MODULE APPROVISIONNEMENT EN EAU ====================

# Mod√®les Pydantic pour les points d'eau
class PointEauBase(BaseModel):
    type: str  # "borne_fontaine", "borne_seche", "point_eau_statique"
    numero_identification: str
    latitude: float
    longitude: float
    adresse: Optional[str] = None
    ville: Optional[str] = None
    secteur_id: Optional[str] = None  # ID du secteur g√©ographique
    notes: Optional[str] = None

class BorneFontaine(PointEauBase):
    type: str = "borne_fontaine"
    debit_gpm: Optional[float] = None  # Gallons par minute
    marque: Optional[str] = None
    modele: Optional[str] = None
    etat: str = "fonctionnel"  # fonctionnel, defectueux, inaccessible
    date_derniere_inspection: Optional[str] = None
    frequence_inspection_mois: int = 12  # Inspection annuelle par d√©faut

class BorneSeche(PointEauBase):
    type: str = "borne_seche"
    debit_gpm: Optional[float] = None
    etat_raccords: str = "bon"  # bon, moyen, mauvais
    accessibilite: str = "facile"  # facile, difficile, inaccessible
    date_derniere_inspection: Optional[str] = None
    frequence_inspection_mois: int = 6  # Inspection bi-annuelle par d√©faut
    prochaine_date_test: Optional[str] = None  # Param√©tr√© par superviseur
    modele_inspection_assigne_id: Optional[str] = None  # ID du formulaire d'inspection assign√©

class PointEauStatique(PointEauBase):
    type: str = "point_eau_statique"
    accessibilite: str = "vehicule"  # vehicule, pied, difficile
    capacite_litres: Optional[float] = None
    profondeur_metres: Optional[float] = None
    etat_eau: str = "propre"  # propre, pollue, gele
    type_source: str = "etang"  # etang, bassin, riviere, lac, autre
    date_derniere_inspection: Optional[str] = None
    frequence_inspection_mois: int = 12

class PointEauCreate(BaseModel):
    type: str
    numero_identification: str
    latitude: float
    longitude: float
    adresse: Optional[str] = None
    ville: Optional[str] = None
    secteur_id: Optional[str] = None
    notes: Optional[str] = None
    # Champs sp√©cifiques selon le type
    debit_gpm: Optional[float] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    etat: Optional[str] = "fonctionnel"
    etat_raccords: Optional[str] = "bon"
    accessibilite: Optional[str] = None
    capacite_litres: Optional[float] = None
    profondeur_metres: Optional[float] = None
    etat_eau: Optional[str] = "propre"
    type_source: Optional[str] = "etang"
    frequence_inspection_mois: Optional[int] = None
    modele_inspection_assigne_id: Optional[str] = None  # ID du formulaire d'inspection assign√©

class PointEauUpdate(BaseModel):
    numero_identification: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    adresse: Optional[str] = None
    ville: Optional[str] = None
    secteur_id: Optional[str] = None
    notes: Optional[str] = None
    debit_gpm: Optional[float] = None
    marque: Optional[str] = None
    modele: Optional[str] = None
    etat: Optional[str] = None
    etat_raccords: Optional[str] = None
    accessibilite: Optional[str] = None
    capacite_litres: Optional[float] = None
    profondeur_metres: Optional[float] = None
    etat_eau: Optional[str] = None
    type_source: Optional[str] = None
    frequence_inspection_mois: Optional[int] = None
    modele_inspection_assigne_id: Optional[str] = None  # ID du formulaire d'inspection assign√©
    prochaine_date_test: Optional[str] = None

class InspectionPointEauCreate(BaseModel):
    point_eau_id: str
    inspecteur_id: str
    date_inspection: str
    etat_general: str  # conforme, non_conforme, defectueux
    debit_mesure_gpm: Optional[float] = None
    observations: Optional[str] = None
    photos: Optional[List[str]] = []  # URLs ou Base64
    defauts_constates: Optional[List[str]] = []
    actions_requises: Optional[str] = None
    # Champs sp√©cifiques bornes s√®ches
    etat_raccords: Optional[str] = None
    test_pression_ok: Optional[bool] = None
    # Champs sp√©cifiques points statiques
    niveau_eau: Optional[str] = None  # bas, moyen, haut
    accessibilite_verifiee: Optional[str] = None

# Endpoints API pour les points d'eau
@api_router.get("/{tenant_slug}/approvisionnement-eau/points-eau")
async def get_points_eau(
    tenant_slug: str,
    type: Optional[str] = None,
    secteur_id: Optional[str] = None,
    etat: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer tous les points d'eau avec filtres optionnels"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    query = {"tenant_id": tenant.id}
    if type:
        query["type"] = type
    if secteur_id:
        query["secteur_id"] = secteur_id
    if etat:
        query["etat"] = etat
    
    points = await db.points_eau.find(query, {"_id": 0}).to_list(length=None)
    
    # Calculer le statut de couleur pour chaque point (vert/orange/rouge/gris)
    from datetime import datetime, timedelta
    today = datetime.now()
    
    for point in points:
        date_derniere = point.get('date_derniere_inspection')
        freq_mois = point.get('frequence_inspection_mois', 12)
        
        if not date_derniere:
            point['statut_couleur'] = 'gris'  # Non inspect√©
        else:
            date_insp = datetime.fromisoformat(date_derniere.replace('Z', '+00:00'))
            jours_depuis = (today - date_insp).days
            jours_limite = freq_mois * 30
            
            if point.get('etat') in ['defectueux', 'inaccessible']:
                point['statut_couleur'] = 'rouge'
            elif jours_depuis > jours_limite:
                point['statut_couleur'] = 'rouge'  # Inspection en retard
            elif jours_depuis > (jours_limite - 30):
                point['statut_couleur'] = 'orange'  # Inspection √† venir (<30j)
            else:
                point['statut_couleur'] = 'vert'  # Conforme
        
        # Pour bornes s√®ches, v√©rifier aussi la date de test programm√©e
        if point.get('type') == 'borne_seche' and point.get('prochaine_date_test'):
            try:
                date_test = datetime.fromisoformat(point['prochaine_date_test'].replace('Z', '+00:00'))
                jours_avant_test = (date_test - today).days
                if jours_avant_test < 0:
                    point['statut_couleur'] = 'rouge'  # Test en retard
                elif jours_avant_test < 30:
                    point['statut_couleur'] = 'orange'  # Test √† venir
            except:
                pass
    
    return points

@api_router.post("/{tenant_slug}/approvisionnement-eau/points-eau")
async def create_point_eau(
    tenant_slug: str,
    point_data: PointEauCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er un nouveau point d'eau"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier permissions (admin ou preventionniste)
    if current_user.role not in ['admin', 'superviseur'] and not current_user.est_preventionniste:
        raise HTTPException(status_code=403, detail="Permission refus√©e")
    
    point_dict = point_data.dict()
    point_dict['id'] = str(uuid.uuid4())
    point_dict['tenant_id'] = tenant.id
    point_dict['created_by_id'] = current_user.id
    point_dict['created_at'] = datetime.now(timezone.utc).isoformat()
    point_dict['updated_at'] = datetime.now(timezone.utc).isoformat()
    
    # D√©finir fr√©quence par d√©faut selon le type
    if not point_dict.get('frequence_inspection_mois'):
        if point_dict['type'] == 'borne_seche':
            point_dict['frequence_inspection_mois'] = 6
        else:
            point_dict['frequence_inspection_mois'] = 12
    
    await db.points_eau.insert_one(point_dict)
    
    return {"message": "Point d'eau cr√©√© avec succ√®s", "id": point_dict['id']}

@api_router.get("/{tenant_slug}/approvisionnement-eau/points-eau/{point_id}")
async def get_point_eau(
    tenant_slug: str,
    point_id: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer un point d'eau sp√©cifique"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    point = await db.points_eau.find_one({"id": point_id, "tenant_id": tenant.id}, {"_id": 0})
    
    if not point:
        raise HTTPException(status_code=404, detail="Point d'eau non trouv√©")
    
    return point

@api_router.put("/{tenant_slug}/approvisionnement-eau/points-eau/{point_id}")
async def update_point_eau(
    tenant_slug: str,
    point_id: str,
    point_update: PointEauUpdate,
    current_user: User = Depends(get_current_user)
):
    """Mettre √† jour un point d'eau"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier permissions
    if current_user.role not in ['admin', 'superviseur'] and not current_user.est_preventionniste:
        raise HTTPException(status_code=403, detail="Permission refus√©e")
    
    update_data = {k: v for k, v in point_update.dict().items() if v is not None}
    if not update_data:
        return {"message": "Aucune modification"}
    
    update_data['updated_at'] = datetime.now(timezone.utc).isoformat()
    
    result = await db.points_eau.update_one(
        {"id": point_id, "tenant_id": tenant.id},
        {"$set": update_data}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Point d'eau non trouv√©")
    
    return {"message": "Point d'eau mis √† jour avec succ√®s"}

@api_router.delete("/{tenant_slug}/approvisionnement-eau/points-eau/{point_id}")
async def delete_point_eau(
    tenant_slug: str,
    point_id: str,
    current_user: User = Depends(get_current_user)
):
    """Supprimer un point d'eau"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier permissions (admin uniquement)
    if current_user.role not in ['admin', 'superviseur']:
        raise HTTPException(status_code=403, detail="Permission refus√©e - Admin requis")
    
    result = await db.points_eau.delete_one({"id": point_id, "tenant_id": tenant.id})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Point d'eau non trouv√©")
    
    # Supprimer aussi les inspections associ√©es
    await db.inspections_points_eau.delete_many({"point_eau_id": point_id, "tenant_id": tenant.id})
    
    return {"message": "Point d'eau supprim√© avec succ√®s"}

# Endpoints pour les inspections de points d'eau
@api_router.post("/{tenant_slug}/approvisionnement-eau/inspections")
async def create_inspection_point_eau(
    tenant_slug: str,
    inspection_data: InspectionPointEauCreate,
    current_user: User = Depends(get_current_user)
):
    """Cr√©er une nouvelle inspection de point d'eau"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier que le point d'eau existe
    point = await db.points_eau.find_one({"id": inspection_data.point_eau_id, "tenant_id": tenant.id})
    if not point:
        raise HTTPException(status_code=404, detail="Point d'eau non trouv√©")
    
    inspection_dict = inspection_data.dict()
    inspection_dict['id'] = str(uuid.uuid4())
    inspection_dict['tenant_id'] = tenant.id
    inspection_dict['created_at'] = datetime.now(timezone.utc).isoformat()
    
    await db.inspections_points_eau.insert_one(inspection_dict)
    
    # Mettre √† jour la date de derni√®re inspection du point d'eau
    await db.points_eau.update_one(
        {"id": inspection_data.point_eau_id, "tenant_id": tenant.id},
        {"$set": {
            "date_derniere_inspection": inspection_data.date_inspection,
            "etat": inspection_data.etat_general if inspection_data.etat_general == "defectueux" else point.get('etat', 'fonctionnel'),
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    return {"message": "Inspection cr√©√©e avec succ√®s", "id": inspection_dict['id']}

@api_router.get("/{tenant_slug}/approvisionnement-eau/inspections")
async def get_inspections_points_eau(
    tenant_slug: str,
    point_eau_id: Optional[str] = None,
    inspecteur_id: Optional[str] = None,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les inspections de points d'eau"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    query = {"tenant_id": tenant.id}
    if point_eau_id:
        query["point_eau_id"] = point_eau_id
    if inspecteur_id:
        query["inspecteur_id"] = inspecteur_id
    
    inspections = await db.inspections_points_eau.find(query, {"_id": 0}).sort("date_inspection", -1).to_list(length=None)
    
    return inspections

@api_router.get("/{tenant_slug}/approvisionnement-eau/statistiques")
async def get_statistiques_approvisionnement(
    tenant_slug: str,
    current_user: User = Depends(get_current_user)
):
    """R√©cup√©rer les statistiques du module approvisionnement en eau"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # Compter par type
    total_points = await db.points_eau.count_documents({"tenant_id": tenant.id})
    bornes_fontaines = await db.points_eau.count_documents({"tenant_id": tenant.id, "type": "borne_fontaine"})
    bornes_seches = await db.points_eau.count_documents({"tenant_id": tenant.id, "type": "borne_seche"})
    points_statiques = await db.points_eau.count_documents({"tenant_id": tenant.id, "type": "point_eau_statique"})
    
    # Compter par √©tat
    fonctionnels = await db.points_eau.count_documents({"tenant_id": tenant.id, "etat": "fonctionnel"})
    defectueux = await db.points_eau.count_documents({"tenant_id": tenant.id, "etat": "defectueux"})
    inaccessibles = await db.points_eau.count_documents({"tenant_id": tenant.id, "etat": "inaccessible"})
    
    # Inspections r√©centes (30 derniers jours)
    from datetime import datetime, timedelta
    date_limite = (datetime.now() - timedelta(days=30)).isoformat()
    inspections_recentes = await db.inspections_points_eau.count_documents({
        "tenant_id": tenant.id,
        "date_inspection": {"$gte": date_limite}
    })
    
    return {
        "total_points": total_points,
        "par_type": {
            "bornes_fontaines": bornes_fontaines,
            "bornes_seches": bornes_seches,
            "points_statiques": points_statiques
        },
        "par_etat": {
            "fonctionnels": fonctionnels,
            "defectueux": defectueux,
            "inaccessibles": inaccessibles
        },
        "inspections_30_jours": inspections_recentes
    }

@api_router.put("/{tenant_slug}/approvisionnement-eau/bornes-seches/{point_id}/programmer-test")
async def programmer_test_borne_seche(
    tenant_slug: str,
    point_id: str,
    date_test: str,
    current_user: User = Depends(get_current_user)
):
    """Programmer la prochaine date de test pour une borne s√®che (superviseur uniquement)"""
    tenant = await get_tenant_from_slug(tenant_slug)
    
    # V√©rifier permissions (admin ou superviseur)
    if current_user.role not in ['admin', 'superviseur']:
        raise HTTPException(status_code=403, detail="Permission refus√©e - Superviseur requis")
    
    result = await db.points_eau.update_one(
        {"id": point_id, "tenant_id": tenant.id, "type": "borne_seche"},
        {"$set": {
            "prochaine_date_test": date_test,
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Borne s√®che non trouv√©e")
    
    return {"message": "Date de test programm√©e avec succ√®s"}





# Include routers in the main app
# IMPORTANT: L'ordre d√©termine la priorit√© des routes
# Module personnel extrait et prioritaire
app.include_router(personnel_router, prefix="/api")  # Module Personnel (GET/PUT/DELETE users)
app.include_router(actifs_router, prefix="/api")  # Module Actifs (v√©hicules, bornes, inventaires, rondes)
app.include_router(formations_router, prefix="/api")  # Module Formations (CRUD + inscriptions)
app.include_router(equipements_router, prefix="/api")  # Module √âquipements (CRUD + maintenance + alertes)
app.include_router(prevention_router, prefix="/api")  # Module Pr√©vention (b√¢timents, inspections, grilles, secteurs)
app.include_router(planning_router, prefix="/api")  # Module Planning (assignations, rapports heures)
app.include_router(sftp_router, prefix="/api")  # Module SFTP (cartes d'appel 911, WebSocket)
app.include_router(billing_router, prefix="/api")  # Module Billing (Stripe, facturation)
app.include_router(admin_router, prefix="/api")  # Module Admin (centrales 911, audit logs)
app.include_router(debogage_router, prefix="/api")  # Module D√©bogage (bugs, features)
app.include_router(paie_complet_router, prefix="/api")  # Module Paie complet
app.include_router(interventions_router, prefix="/api")  # Module Interventions
app.include_router(apria_router, prefix="/api")  # Module APRIA - Inspections
app.include_router(epi_router, prefix="/api")  # Module EPI - √âquipements protection
app.include_router(competences_grades_router, prefix="/api")  # Module Comp√©tences & Grades
app.include_router(types_garde_router, prefix="/api")  # Module Types de Garde
app.include_router(dashboard_messages_router, prefix="/api")  # Module Messages Dashboard
app.include_router(conges_router, prefix="/api")  # Module Demandes de Cong√©
app.include_router(notifications_router, prefix="/api")  # Module Notifications (lecture)
app.include_router(personnalisation_router, prefix="/api")  # Module Personnalisation (logo, branding)
app.include_router(materiel_router, prefix="/api")  # Module Mat√©riel & Stock
app.include_router(bornes_seches_router, prefix="/api")  # Module Bornes S√®ches
app.include_router(points_eau_router, prefix="/api")  # Module Points d'Eau
# disponibilites_router d√©sactiv√© - routes server.py plus compl√®tes (export PDF, blocage avanc√©)
app.include_router(api_router)  # Routes principales (server.py)
app.include_router(pwa_router, prefix="/api")
app.include_router(dsi_router, prefix="/api")
app.include_router(dsi_transmissions_router, prefix="/api")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()