#!/usr/bin/env python3
"""
ProFireManager Backend API Testing Suite - FORMATION CREATION VALIDATION TESTING

CONTEXTE:
- Deux bugs ont √©t√© corrig√©s pour la cr√©ation de formation dans le tenant demo:
  1. Validation frontend ajout√©e pour v√©rifier que competence_id est renseign√©
  2. Validation backend ajout√©e pour v√©rifier que la comp√©tence existe avant de cr√©er la formation

TESTS √Ä EFFECTUER:
1. Login admin demo (gussdub@gmail.com / 230685Juin+)
2. V√©rifier que les comp√©tences existent: GET /api/demo/competences
3. Test cr√©ation formation SANS comp√©tence (doit √©chouer):
   POST /api/demo/formations avec competence_id=""
   - Devrait retourner 400 Bad Request avec message "La comp√©tence associ√©e est obligatoire"
4. Test cr√©ation formation AVEC comp√©tence invalide (doit √©chouer):
   POST /api/demo/formations avec competence_id="fake-id-123"
   - Devrait retourner 404 avec message mentionnant "Comp√©tence non trouv√©e"
5. Test cr√©ation formation AVEC comp√©tence valide (doit r√©ussir):
   POST /api/demo/formations avec competence_id=<id d'une comp√©tence existante>
   - Devrait retourner 200 OK avec la formation cr√©√©e
   - V√©rifier que la formation appara√Æt dans GET /api/demo/formations

OBJECTIF:
Confirmer que les validations fonctionnent correctement et qu'on ne peut plus cr√©er de formations sans comp√©tence valide.
"""

import requests
import json
import sys
from datetime import datetime
import uuid
import time

# Configuration - REAL PRODUCTION URLs
BASE_URL = "https://demo-dashboard-1.preview.emergentagent.com/api"

# Test Configuration for Demo tenant
TENANT_SLUG = "demo"

# Dashboard Testing Configuration
# Using existing users in MongoDB Atlas production database for tenant "demo"
# Authentication: admin@firemanager.ca or any valid credentials for demo tenant

class FormationValidationTesting:
    def __init__(self):
        self.base_url = BASE_URL
        self.session = requests.Session()
        self.auth_token = None
        self.test_results = []
        self.admin_token = None
        self.admin_user_id = None
        self.demo_tenant_id = None
        self.competences = []
        self.valid_competence_id = None
        self.created_formation_id = None
        
    def log_test(self, test_name, success, message, details=None):
        """Log test results"""
        result = {
            "test": test_name,
            "success": success,
            "message": message,
            "timestamp": datetime.now().isoformat(),
            "details": details or {}
        }
        self.test_results.append(result)
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        print(f"{status} - {test_name}: {message}")
        if details and not success:
            print(f"   Details: {details}")
    
    def test_admin_authentication(self):
        """Test admin authentication for Demo tenant - specifically gussdub@gmail.com / 230685Juin+"""
        try:
            # Use the specific credentials mentioned in the review request
            admin_credentials = {"email": "gussdub@gmail.com", "mot_de_passe": "230685Juin+"}
            
            print(f"üîë Authenticating as demo admin: {admin_credentials['email']}")
            
            # Try tenant-specific login first
            response = self.session.post(f"{self.base_url}/{TENANT_SLUG}/auth/login", json=admin_credentials)
            if response.status_code != 200:
                # Try legacy login
                response = self.session.post(f"{self.base_url}/auth/login", json=admin_credentials)
            
            if response.status_code == 200:
                data = response.json()
                if "access_token" in data:
                    self.admin_token = data["access_token"]
                    user_info = data.get("user", {})
                    self.admin_user_id = user_info.get("id")
                    
                    self.log_test("Admin Authentication", True, 
                                f"‚úÖ Demo admin login successful for {admin_credentials['email']}", 
                                {
                                    "admin_user_id": self.admin_user_id,
                                    "user_info": user_info,
                                    "tenant": user_info.get("tenant_slug", "unknown")
                                })
                    return True
                else:
                    self.log_test("Admin Authentication", False, 
                                f"‚ùå No access token in response for: {admin_credentials['email']}")
                    return False
            else:
                self.log_test("Admin Authentication", False, 
                            f"‚ùå Login failed for '{admin_credentials['email']}': {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Admin Authentication", False, f"Admin login error: {str(e)}")
            return False

    def get_competences_list(self):
        """Get competences list from GET /api/demo/competences - should return at least 1 competence"""
        try:
            if not self.admin_token:
                self.log_test("Get Competences List", False, "No admin token available")
                return False
            
            admin_session = requests.Session()
            admin_session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
            
            print(f"üìö Retrieving competences from GET /api/{TENANT_SLUG}/competences")
            
            response = admin_session.get(f"{self.base_url}/{TENANT_SLUG}/competences")
            
            if response.status_code == 200:
                try:
                    self.competences = response.json()
                    
                    if len(self.competences) > 0:
                        # Store the first competence ID for valid tests
                        self.valid_competence_id = self.competences[0].get("id")
                        
                        self.log_test("Get Competences List", True, 
                                    f"‚úÖ Retrieved {len(self.competences)} competences", 
                                    {
                                        "competences_count": len(self.competences),
                                        "valid_competence_id": self.valid_competence_id,
                                        "sample_competences": [{"id": c.get("id"), "nom": c.get("nom")} for c in self.competences[:3]]
                                    })
                        return True
                    else:
                        self.log_test("Get Competences List", False, 
                                    f"‚ùå No competences found in demo tenant")
                        return False
                    
                except json.JSONDecodeError as e:
                    self.log_test("Get Competences List", False, f"‚ùå Invalid JSON in competences response: {str(e)}")
                    return False
                    
            else:
                self.log_test("Get Competences List", False, 
                            f"‚ùå Competences endpoint failed with status {response.status_code}: {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Get Competences List", False, f"Competences retrieval error: {str(e)}")
            return False

    def test_formation_creation_without_competence(self):
        """Test formation creation WITHOUT competence - should fail with 400 Bad Request"""
        try:
            if not self.admin_token:
                self.log_test("Formation Creation Without Competence", False, "No admin token available")
                return False
            
            admin_session = requests.Session()
            admin_session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
            
            print(f"‚ùå Testing formation creation WITHOUT competence (should fail)")
            
            formation_data = {
                "nom": "Test Formation Sans Competence",
                "competence_id": "",  # Empty competence_id - should trigger validation error
                "date_debut": "2025-12-01",
                "date_fin": "2025-12-01",  
                "heure_debut": "09:00",
                "heure_fin": "17:00",
                "duree_heures": 8,
                "places_max": 20,
                "annee": 2025
            }
            
            response = admin_session.post(f"{self.base_url}/{TENANT_SLUG}/formations", json=formation_data)
            
            # Should return 400 Bad Request
            if response.status_code == 400:
                response_text = response.text
                if "comp√©tence" in response_text.lower() and "obligatoire" in response_text.lower():
                    self.log_test("Formation Creation Without Competence", True, 
                                f"‚úÖ Correctly rejected formation without competence: {response.status_code}", 
                                {
                                    "status_code": response.status_code,
                                    "response_message": response_text,
                                    "validation_working": True
                                })
                    return True
                else:
                    self.log_test("Formation Creation Without Competence", False, 
                                f"‚ùå Wrong error message for missing competence: {response_text}")
                    return False
            else:
                self.log_test("Formation Creation Without Competence", False, 
                            f"‚ùå Formation creation should have failed but got status {response.status_code}: {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Formation Creation Without Competence", False, f"Formation creation test error: {str(e)}")
            return False

    def test_formation_creation_with_invalid_competence(self):
        """Test formation creation WITH invalid competence - should fail with 404"""
        try:
            if not self.admin_token:
                self.log_test("Formation Creation With Invalid Competence", False, "No admin token available")
                return False
            
            admin_session = requests.Session()
            admin_session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
            
            print(f"‚ùå Testing formation creation WITH invalid competence (should fail)")
            
            formation_data = {
                "nom": "Test Formation Competence Invalide",
                "competence_id": "fake-id-123",  # Invalid competence_id - should trigger 404 error
                "date_debut": "2025-12-01",
                "date_fin": "2025-12-01",  
                "heure_debut": "09:00",
                "heure_fin": "17:00",
                "duree_heures": 8,
                "places_max": 20,
                "annee": 2025
            }
            
            response = admin_session.post(f"{self.base_url}/{TENANT_SLUG}/formations", json=formation_data)
            
            # Should return 404 Not Found
            if response.status_code == 404:
                response_text = response.text
                if "comp√©tence" in response_text.lower() and ("trouv√©e" in response_text.lower() or "found" in response_text.lower()):
                    self.log_test("Formation Creation With Invalid Competence", True, 
                                f"‚úÖ Correctly rejected formation with invalid competence: {response.status_code}", 
                                {
                                    "status_code": response.status_code,
                                    "response_message": response_text,
                                    "validation_working": True
                                })
                    return True
                else:
                    self.log_test("Formation Creation With Invalid Competence", False, 
                                f"‚ùå Wrong error message for invalid competence: {response_text}")
                    return False
            else:
                self.log_test("Formation Creation With Invalid Competence", False, 
                            f"‚ùå Formation creation should have failed but got status {response.status_code}: {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Formation Creation With Invalid Competence", False, f"Formation creation test error: {str(e)}")
            return False

    def test_formation_creation_with_valid_competence(self):
        """Test formation creation WITH valid competence - should succeed with 200 OK"""
        try:
            if not self.admin_token:
                self.log_test("Formation Creation With Valid Competence", False, "No admin token available")
                return False
            
            if not self.valid_competence_id:
                self.log_test("Formation Creation With Valid Competence", False, "No valid competence ID available")
                return False
            
            admin_session = requests.Session()
            admin_session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
            
            print(f"‚úÖ Testing formation creation WITH valid competence (should succeed)")
            
            formation_data = {
                "nom": "Test Formation Competence Valide",
                "competence_id": self.valid_competence_id,  # Valid competence_id - should succeed
                "date_debut": "2025-12-01",
                "date_fin": "2025-12-01",  
                "heure_debut": "09:00",
                "heure_fin": "17:00",
                "duree_heures": 8,
                "places_max": 20,
                "annee": 2025
            }
            
            response = admin_session.post(f"{self.base_url}/{TENANT_SLUG}/formations", json=formation_data)
            
            # Should return 200 OK or 201 Created
            if response.status_code in [200, 201]:
                try:
                    created_formation = response.json()
                    self.created_formation_id = created_formation.get("id")
                    
                    self.log_test("Formation Creation With Valid Competence", True, 
                                f"‚úÖ Successfully created formation with valid competence: {response.status_code}", 
                                {
                                    "status_code": response.status_code,
                                    "formation_id": self.created_formation_id,
                                    "formation_name": created_formation.get("nom"),
                                    "competence_id": created_formation.get("competence_id")
                                })
                    return True
                    
                except json.JSONDecodeError:
                    self.log_test("Formation Creation With Valid Competence", False, 
                                f"‚ùå Invalid JSON response from formation creation")
                    return False
            else:
                self.log_test("Formation Creation With Valid Competence", False, 
                            f"‚ùå Formation creation failed with status {response.status_code}: {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Formation Creation With Valid Competence", False, f"Formation creation test error: {str(e)}")
            return False

    def verify_formation_in_list(self):
        """Verify that the created formation appears in GET /api/demo/formations"""
        try:
            if not self.admin_token:
                self.log_test("Verify Formation In List", False, "No admin token available")
                return False
            
            if not self.created_formation_id:
                self.log_test("Verify Formation In List", False, "No created formation ID to verify")
                return False
            
            admin_session = requests.Session()
            admin_session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
            
            print(f"üîç Verifying created formation appears in formations list")
            
            response = admin_session.get(f"{self.base_url}/{TENANT_SLUG}/formations")
            
            if response.status_code == 200:
                try:
                    formations = response.json()
                    
                    # Look for our created formation
                    created_formation_found = False
                    for formation in formations:
                        if formation.get("id") == self.created_formation_id:
                            created_formation_found = True
                            break
                    
                    if created_formation_found:
                        self.log_test("Verify Formation In List", True, 
                                    f"‚úÖ Created formation found in formations list", 
                                    {
                                        "formation_id": self.created_formation_id,
                                        "total_formations": len(formations),
                                        "formation_found": True
                                    })
                        return True
                    else:
                        self.log_test("Verify Formation In List", False, 
                                    f"‚ùå Created formation not found in formations list")
                        return False
                    
                except json.JSONDecodeError:
                    self.log_test("Verify Formation In List", False, f"‚ùå Invalid JSON response from formations endpoint")
                    return False
                    
            else:
                self.log_test("Verify Formation In List", False, 
                            f"‚ùå Could not access formations endpoint: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Verify Formation In List", False, f"Formation verification error: {str(e)}")
            return False
    
    def cleanup_test_formation(self):
        """Clean up the test formation created during testing"""
        try:
            if not self.admin_token or not self.created_formation_id:
                self.log_test("Cleanup Test Formation", True, "No formation to clean up")
                return True
            
            admin_session = requests.Session()
            admin_session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
            
            print(f"üßπ Cleaning up test formation: {self.created_formation_id}")
            
            response = admin_session.delete(f"{self.base_url}/{TENANT_SLUG}/formations/{self.created_formation_id}")
            
            if response.status_code in [200, 204]:
                self.log_test("Cleanup Test Formation", True, 
                            f"‚úÖ Test formation cleaned up successfully", 
                            {
                                "formation_id": self.created_formation_id,
                                "status_code": response.status_code
                            })
                return True
            else:
                self.log_test("Cleanup Test Formation", False, 
                            f"‚ö†Ô∏è Could not clean up test formation: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            self.log_test("Cleanup Test Formation", False, f"Cleanup error: {str(e)}")
            return False

    def analyze_discrepancy_cause(self, metric, dashboard_value, real_value):
        """Analyze the probable cause of a discrepancy"""
        causes = {
            "total_personnel_actif": "Possible filtrage diff√©rent des utilisateurs actifs ou requ√™te incorrecte",
            "total_assignations": "Calcul des assignations du mois incorrect ou p√©riode diff√©rente",
            "formations_ce_mois": "Filtrage des formations par date incorrect ou format de date diff√©rent",
            "demandes_conges_en_attente": "Confusion entre demandes de cong√© et demandes de remplacement",
            "formations_a_venir": "Filtrage des formations futures incorrect ou crit√®res diff√©rents",
            "heures_travaillees_mois": "Calcul des heures bas√© sur assignations incorrect",
            "nombre_gardes_mois": "Comptage des gardes du mois incorrect",
            "couverture_planning": "Calcul du pourcentage de couverture incorrect"
        }
        
        base_cause = causes.get(metric, "Cause inconnue - n√©cessite investigation approfondie")
        
        if dashboard_value == 0 and real_value > 0:
            return f"{base_cause} - Dashboard retourne 0 alors que donn√©es r√©elles existent"
        elif dashboard_value > real_value:
            return f"{base_cause} - Dashboard surestime les donn√©es"
        elif dashboard_value < real_value:
            return f"{base_cause} - Dashboard sous-estime les donn√©es"
        else:
            return base_cause

    def run_corrections_verification(self):
        """Run the complete Dashboard Corrections Verification"""
        print("üöÄ Starting Dashboard Demo Corrections Verification")
        print("=" * 80)
        print(f"üè¢ Tenant: {TENANT_SLUG}")
        print(f"üë§ Admin: gussdub@gmail.com / 230685Juin+")
        print(f"üéØ Objectif: V√©rifier que les 2 bugs critiques sont corrig√©s")
        print(f"üêõ Bug #1: total_assignations affichait 0 au lieu de 82")
        print(f"üêõ Bug #2: formations_a_venir affichait 0 au lieu de 1")
        print(f"üìä Endpoint principal: GET /api/{TENANT_SLUG}/dashboard/donnees-completes")
        print("=" * 80)
        
        tests = [
            ("Admin Authentication", self.test_admin_authentication),
            ("Get Dashboard Data", self.get_dashboard_data),
            ("Verify Bug Corrections", self.verify_bug_corrections),
        ]
        
        passed = 0
        total = len(tests)
        
        for test_name, test_func in tests:
            print(f"\nüß™ Running: {test_name}")
            if test_func():
                passed += 1
            else:
                print(f"‚ùå Test failed: {test_name}")
                # Continue with other tests to get full picture
        
        print(f"\n" + "=" * 80)
        print(f"üìä Test Results: {passed}/{total} tests passed")
        
        # Generate detailed corrections report
        self.generate_corrections_report()
        
        return passed >= 2  # Consider success if authentication and dashboard work
    
    def generate_corrections_report(self):
        """Generate detailed corrections verification report"""
        print(f"\n" + "=" * 80)
        print(f"üìã RAPPORT DE V√âRIFICATION DES CORRECTIONS - DASHBOARD DEMO")
        print("=" * 80)
        
        # Check if we have all necessary data
        auth_success = any(r["success"] for r in self.test_results if "Admin Authentication" in r["test"])
        dashboard_success = any(r["success"] for r in self.test_results if "Get Dashboard Data" in r["test"])
        corrections_success = any(r["success"] for r in self.test_results if "Verify Bug Corrections" in r["test"])
        
        print(f"üîê Authentification admin demo: {'‚úÖ R√©ussie' if auth_success else '‚ùå √âchou√©e'}")
        print(f"üìä R√©cup√©ration donn√©es dashboard: {'‚úÖ R√©ussie' if dashboard_success else '‚ùå √âchou√©e'}")
        print(f"üîç V√©rification corrections bugs: {'‚úÖ R√©ussie' if corrections_success else '‚ùå √âchou√©e'}")
        
        if not auth_success:
            print(f"\n‚ùå IMPOSSIBLE DE CONTINUER LA V√âRIFICATION")
            print(f"   Cause: √âchec de l'authentification avec gussdub@gmail.com / 230685Juin+")
            print(f"   Action requise: V√©rifier les identifiants ou l'existence du tenant 'demo'")
            return
        
        if not dashboard_success:
            print(f"\n‚ùå IMPOSSIBLE DE R√âCUP√âRER LES DONN√âES DU DASHBOARD")
            print(f"   Cause: Endpoint GET /api/demo/dashboard/donnees-completes inaccessible")
            print(f"   Action requise: V√©rifier l'endpoint et les permissions")
            return
        
        print(f"\nüêõ V√âRIFICATION DES CORRECTIONS SP√âCIFIQUES:")
        print("-" * 60)
        
        if hasattr(self, 'corrections_results'):
            results = self.corrections_results
            
            # Bug #1 Status
            if results['bug1_fixed']:
                print(f"‚úÖ Bug #1 r√©solu: total_assignations = {results['total_assignations']} (attendu ~82)")
            else:
                print(f"‚ùå Bug #1 NON r√©solu: total_assignations = {results['total_assignations']} (toujours 0)")
            
            # Bug #2 Status
            if results['bug2_fixed']:
                print(f"‚úÖ Bug #2 r√©solu: formations_a_venir contient {results['formations_count']} formation(s)")
                if results['desincarceration_found']:
                    print(f"‚úÖ Formation sp√©cifique trouv√©e: 'D√©sincarc√©ration de 2 v√©hicules' le 2026-04-22")
                else:
                    print(f"‚ö†Ô∏è Formation sp√©cifique 'D√©sincarc√©ration de 2 v√©hicules' non trouv√©e")
            else:
                print(f"‚ùå Bug #2 NON r√©solu: formations_a_venir = {results['formations_count']} (toujours vide)")
            
            print(f"\nüìä R√âSUM√â DES CORRECTIONS:")
            print("-" * 60)
            for correction in results['corrections_verified']:
                print(f"   {correction}")
            
        else:
            print("‚ùå AUCUNE DONN√âE DE CORRECTION DISPONIBLE")
            print("   La v√©rification des corrections n'a pas pu √™tre effectu√©e")
        
        print(f"\nüéØ CONCLUSION DE LA V√âRIFICATION:")
        print("-" * 60)
        
        if hasattr(self, 'corrections_results'):
            results = self.corrections_results
            bugs_fixed = results['bug1_fixed'] + results['bug2_fixed']
            
            if bugs_fixed == 2:
                print("üéâ TOUTES LES CORRECTIONS SONT R√âUSSIES!")
                print("   ‚úÖ Bug #1 (total_assignations) corrig√©")
                print("   ‚úÖ Bug #2 (formations_a_venir) corrig√©")
                print("   Le dashboard affiche maintenant les donn√©es correctes.")
            elif bugs_fixed == 1:
                print("‚ö†Ô∏è CORRECTIONS PARTIELLES")
                if results['bug1_fixed']:
                    print("   ‚úÖ Bug #1 (total_assignations) corrig√©")
                    print("   ‚ùå Bug #2 (formations_a_venir) NON corrig√©")
                else:
                    print("   ‚ùå Bug #1 (total_assignations) NON corrig√©")
                    print("   ‚úÖ Bug #2 (formations_a_venir) corrig√©")
                print("   Action requise: Corriger le bug restant")
            else:
                print("‚ùå AUCUNE CORRECTION D√âTECT√âE")
                print("   ‚ùå Bug #1 (total_assignations) NON corrig√©")
                print("   ‚ùå Bug #2 (formations_a_venir) NON corrig√©")
                print("   Action requise: V√©rifier l'impl√©mentation des corrections")
        else:
            print("‚ùå IMPOSSIBLE DE D√âTERMINER L'√âTAT DES CORRECTIONS")
            print("   La v√©rification n'a pas pu √™tre compl√©t√©e")
        
        print("=" * 80)

if __name__ == "__main__":
    verification = DashboardCorrectionsVerification()
    success = verification.run_corrections_verification()
    
    sys.exit(0 if success else 1)
